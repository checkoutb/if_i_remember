


SpringBoot @ConfigurationProperties





































切面 = 通知 + 切点
切点就是 正常代码中的方法
通知就是 around，after，before会调用的方法

/**
 * 切面
 *
 */
@Aspect
public class MyInterceptor {
	@Pointcut("execution (* cn.itcast.service.impl.PersonServiceBean.*(..))")
	private void anyMethod() {}//声明一个切入点

	@Before("anyMethod() && args(name)")
	public void doAccessCheck(String name) {
		System.out.println("前置通知:"+ name);
	}
	@AfterReturning(pointcut="anyMethod()",returning="result")
	public void doAfterReturning(String result) {
		System.out.println("后置通知:"+ result);
	}
	@After("anyMethod()")
	public void doAfter() {
		System.out.println("最终通知");
	}
	@AfterThrowing(pointcut="anyMethod()",throwing="e")
	public void doAfterThrowing(Exception e) {
		System.out.println("例外通知:"+ e);
	}

	@Around("anyMethod()")
	public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
		//if(){//判断用户是否在权限
		System.out.println("进入方法");
		Object result = pjp.proceed();
		System.out.println("退出方法");
		//}
		return result;
	}

}

beans.xml
<aop:aspectj-autoproxy/>
<bean id="myInterceptor" class="cn.csdn.service.MyInterceptor"/>
<bean id="personService" class="cn.csdn.service.impl.PersonServiceBean"></bean>

@Test
ApplicationContext cxt = new ClassPathXmlApplicationContext("beans.xml");
PersonService personService = (PersonService)cxt.getBean("personService");
personService.save("xx");



Spring AOP支持的AspectJ切入点指示符如下：
execution：用于匹配方法执行的连接点；
within：用于匹配指定类型内的方法执行；
this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；
target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；
args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；
@within：用于匹配所以持有指定注解类型内的方法；
@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；
@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；
@annotation：用于匹配当前执行方法持有指定注解的方法；
bean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法；
reference pointcut：表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持。

AspectJ切入点支持的切入点指示符还有： call、get、set、preinitialization、staticinitialization、initialization、handler、adviceexecution、withincode、cflow、cflowbelow、if、@this、@withincode；但Spring AOP目前不支持这些指示符，使用这些指示符将抛出IllegalArgumentException异常。这些指示符Spring AOP可能会在以后进行扩展。


类型匹配语法
。。类匹配，匹配类
首先让我们来了解下AspectJ类型匹配的通配符：
*：匹配任何数量字符；
..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包；而在方法参数模式中匹配任何数量参数。
+：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。


java.lang.String    匹配String类型；
java.*.String       匹配java包下的任何“一级子包”下的String类型；  如匹配java.lang.String，但不匹配java.lang.ss.String

java..*            匹配java包及任何子包下的任何类型; 如匹配java.lang.String、java.lang.annotation.Annotation

java.lang.*ing      匹配任何java.lang包下的以ing结尾的类型；

java.lang.Number+  匹配java.lang包下的任何Number的自类型；
如匹配java.lang.Integer，也匹配java.math.BigInteger


匹配表达式类型

匹配类型：使用如下方式匹配
注解？ 类的全限定名字
注解：可选，类型上持有的注解，如@Deprecated；
类的全限定名：必填，可以是任何类全限定名。

匹配方法执行：使用如下方式匹配：
注解？ 修饰符? 返回值类型 类型声明?方法名(参数列表) 异常列表？
注解：可选，方法上持有的注解，如@Deprecated；
修饰符：可选，如public、protected；
返回值类型：必填，可以是任何类型模式；“*”表示所有类型；
类型声明：可选，可以是任何类型模式；
方法名：必填，可以使用“*”进行模式匹配；
参数列表：“()”表示方法没有任何参数；“(..)”表示匹配接受任意个参数的方法，“(..,java.lang.String)”表示匹配接受java.lang.String类型的参数结束，且其前边可以接受有任意个参数的方法；“(java.lang.String,..)” 表示匹配接受java.lang.String类型的参数开始，且其后边可以接受任意个参数的方法；“(*,java.lang.String)” 表示匹配接受java.lang.String类型的参数结束，且其前边接受有一个任意类型参数的方法；
异常列表：可选，以“throws 异常全限定名列表”声明，异常全限定名列表如有多个以“，”分割，如throws java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException。


匹配Bean名称：可以使用Bean的id或name进行匹配，并且可使用通配符“*”；


组合切入点表达式
AspectJ使用 且（&&）、或（||）、非（！）来组合切入点表达式。
在Schema风格下，由于在XML中使用“&&”需要使用转义字符“&amp;&amp;”来代替之，所以很不方便，因此Spring ASP 提供了and、or、not来代替&&、||、！。



切入点使用示例
一、execution：使用“execution(方法表达式)”匹配方法执行；
模式
描述
public * *(..)
任何公共方法的执行

* cn.javass..IPointcutService.*()
cn.javass包及所有子包下IPointcutService接口中的任何无参方法

* cn.javass..*.*(..)
cn.javass包及所有子包下任何类的任何方法

* cn.javass..IPointcutService.*(*)
cn.javass包及所有子包下IPointcutService接口的任何只有一个参数方法

* (!cn.javass..IPointcutService+).*(..)
非“cn.javass包及所有子包下IPointcutService接口及子类型”的任何方法

* cn.javass..IPointcutService+.*()
cn.javass包及所有子包下IPointcutService接口及子类型的的任何无参方法

* cn.javass..IPointcut*.test*(java.util.Date)
cn.javass包及所有子包下IPointcut前缀类型的的以test开头的只有一个参数类型为java.util.Date的方法，注意该匹配是根据方法签名的参数类型进行匹配的，而不是根据执行时传入的参数类型决定的
如定义方法：public void test(Object obj);即使执行时传入java.util.Date，也不会匹配的；

* cn.javass..IPointcut*.test*(..)  throws IllegalArgumentException, ArrayIndexOutOfBoundsException
cn.javass包及所有子包下IPointcut前缀类型的的任何方法，且抛出IllegalArgumentException和ArrayIndexOutOfBoundsException异常

* (cn.javass..IPointcutService+&& java.io.Serializable+).*(..)
任何实现了cn.javass包及所有子包下IPointcutService接口和java.io.Serializable接口的类型的任何方法

@java.lang.Deprecated * *(..)
任何持有@java.lang.Deprecated注解的方法

@java.lang.Deprecated @cn.javass..Secure  * *(..)
任何持有@java.lang.Deprecated和@cn.javass..Secure注解的方法

@(java.lang.Deprecated || cn.javass..Secure) * *(..)
任何持有@java.lang.Deprecated或@ cn.javass..Secure注解的方法

(@cn.javass..Secure  *)  *(..)
任何返回值类型持有@cn.javass..Secure的方法


*  (@cn.javass..Secure *).*(..)
任何定义方法的类型持有@cn.javass..Secure的方法
。。应该是指类被@cn.javas.. 注解了？，，。


* *(@cn.javass..Secure (*) , @cn.javass..Secure (*))
任何签名带有两个参数的方法，且这个两个参数都被@ Secure标记了，
如public void test(@Secure String str1, @Secure String str1);

* *((@ cn.javass..Secure *))或
* *(@ cn.javass..Secure *)
任何带有一个参数的方法，且该参数类型持有@ cn.javass..Secure；
如public void test(Model model);且Model类上持有@Secure注解

* *(
@cn.javass..Secure (@cn.javass..Secure *) ,
@ cn.javass..Secure (@cn.javass..Secure *))
任何带有两个参数的方法，且这两个参数都被@ cn.javass..Secure标记了；且这两个参数的类型上都持有@ cn.javass..Secure；

* *(
java.util.Map<cn.javass..Model, cn.javass..Model>
, ..)
任何带有一个java.util.Map参数的方法，且该参数类型是以< cn.javass..Model, cn.javass..Model >为泛型参数；注意只匹配第一个参数为java.util.Map,不包括子类型；
如public void test(HashMap<Model, Model> map, String str);将不匹配，必须使用“* *(
java.util.HashMap<cn.javass..Model,cn.javass..Model>
, ..)”进行匹配；
而public void test(Map map, int i);也将不匹配，因为泛型参数不匹配

* *(java.util.Collection<@cn.javass..Secure *>)
任何带有一个参数（类型为java.util.Collection）的方法，且该参数类型是有一个泛型参数，该泛型参数类型上持有@cn.javass..Secure注解；
如public void test(Collection<Model> collection);Model类型上持有@cn.javass..Secure

* *(java.util.Set<? extends HashMap>)
任何带有一个参数的方法，且传入的参数类型是有一个泛型参数，该泛型参数类型继承与HashMap；
Spring AOP目前测试不能正常工作

* *(java.util.List<? super HashMap>)
任何带有一个参数的方法，且传入的参数类型是有一个泛型参数，该泛型参数类型是HashMap的基类型；如public voi test(Map map)；
Spring AOP目前测试不能正常工作

* *(*<@cn.javass..Secure *>)
任何带有一个参数的方法，且该参数类型是有一个泛型参数，该泛型参数类型上持有@cn.javass..Secure注解；
Spring AOP目前测试不能正常工作


within：使用“within(类型表达式)”匹配指定类型内的方法执行；
模式
描述

within(cn.javass..*)
cn.javass包及子包下的任何方法执行

within(cn.javass..IPointcutService+)
cn.javass包或所有子包下IPointcutService类型及子类型的任何方法

within(@cn.javass..Secure *)
持有cn.javass..Secure注解的任何类型的任何方法,必须是在目标对象上声明这个注解，在接口上声明的对它不起作用



this：使用“this(类型全限定名)”匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口方法也可以匹配；注意this中使用的表达式必须是类型全限定名，不支持通配符；

模式
描述

this(cn.javass.spring.chapter6.service.IPointcutService)
当前AOP对象实现了 IPointcutService接口的任何方法

this(cn.javass.spring.chapter6.service.IIntroductionService)
当前AOP对象实现了 IIntroductionService接口的任何方法，也可能是引入接口


target：使用“target(类型全限定名)”匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；注意target中使用的表达式必须是类型全限定名，不支持通配符；

模式
描述

target(cn.javass.spring.chapter6.service.IPointcutService)
当前目标对象（非AOP对象）实现了 IPointcutService接口的任何方法

target(cn.javass.spring.chapter6.service.IIntroductionService)
当前目标对象（非AOP对象） 实现了IIntroductionService 接口的任何方法不可能是引入接口


args：使用“args(参数类型列表)”匹配当前执行的方法传入的参数为指定类型的执行方法；注意是匹配传入的参数类型，不是匹配方法签名的参数类型；参数类型列表中的参数必须是类型全限定名，通配符不支持；args属于动态切入点，这种切入点开销非常大，非特殊情况最好不要使用；

模式
描述

args (java.io.Serializable,..)
任何一个以接受“传入参数类型为 java.io.Serializable” 开头，且其后可跟任意个任意类型的参数的方法执行，args指定的参数类型是在运行时动态匹配的


@within：使用“@within(注解类型)”匹配所以持有指定注解类型内的方法；注解类型也必须是全限定类型名；

模式
描述

@within cn.javass.spring.chapter6.Secure)
任何目标对象对应的类型持有Secure注解的类方法；必须是在目标对象上声明这个注解，在接口上声明的对它不起作用


@target：使用“@target(注解类型)”匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；注解类型也必须是全限定类型名；

模式
描述

@target (cn.javass.spring.chapter6.Secure)
任何目标对象持有Secure注解的类方法；必须是在目标对象上声明这个注解，在接口上声明的对它不起作用


@args：使用“@args(注解列表)”匹配当前执行的方法传入的参数持有指定注解的执行；注解类型也必须是全限定类型名；

模式
描述

@args (cn.javass.spring.chapter6.Secure)
任何一个只接受一个参数的方法，且方法运行时传入的参数持有注解 cn.javass.spring.chapter6.Secure；动态切入点，类似于arg指示符；


@annotation：使用“@annotation(注解类型)”匹配当前执行方法持有指定注解的方法；注解类型也必须是全限定类型名；

模式
描述

@annotation(cn.javass.spring.chapter6.Secure )
当前执行方法上持有注解 cn.javass.spring.chapter6.Secure将被匹配




bean：使用“bean(Bean id或名字通配符)”匹配特定名称的Bean对象的执行方法；Spring ASP扩展的，在AspectJ中无相应概念；
模式
描述

bean(*Service)
匹配所有以Service命名（id或name）结尾的Bean


reference pointcut：表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持

比如我们定义如下切面：
package cn.javass.spring.chapter6.aop;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class ReferencePointcutAspect {
	@Pointcut(value="execution(* *())")
	public void pointcut() {}
}

可以通过如下方式引用：
@Before(value = "cn.javass.spring.chapter6.aop.ReferencePointcutAspect.pointcut()")
public void referencePointcutTest2(JoinPoint jp) {}
除了可以在@AspectJ风格的切面内引用外，也可以在Schema风格的切面定义内引用，引用方式与@AspectJ完全一样。



如果想获取被被通知方法参数并传递给通知方法，该如何实现呢？接下来我们将介绍两种获取通知参数的方式。
使用JoinPoint获取：Spring AOP提供使用org.aspectj.lang.JoinPoint类型获取连接点数据，任何通知方法的第一个参数都可以是JoinPoint(环绕通知是ProceedingJoinPoint，JoinPoint子类)，当然第一个参数位置也可以是JoinPoint.StaticPart类型，这个只返回连接点的静态部分。

JoinPoint：提供访问当前被通知方法的目标对象、代理对象、方法参数等数据：
package org.aspectj.lang;
import org.aspectj.lang.reflect.SourceLocation;
public interface JoinPoint {
	String toString();         //连接点所在位置的相关信息
	String toShortString();     //连接点所在位置的简短相关信息
	String toLongString();     //连接点所在位置的全部相关信息
	Object getThis();         //返回AOP代理对象
	Object getTarget();       //返回目标对象
	Object[] getArgs();       //返回被通知方法参数列表
	Signature getSignature();  //返回当前连接点签名
	SourceLocation getSourceLocation();//返回连接点方法所在类文件中的位置
	String getKind();        //连接点类型
	StaticPart getStaticPart(); //返回连接点静态部分
}


ProceedingJoinPoint：用于环绕通知，使用proceed()方法来执行目标方法：
public interface ProceedingJoinPoint extends JoinPoint {
	public Object proceed() throws Throwable;
	public Object proceed(Object[] args) throws Throwable;
}


JoinPoint.StaticPart：提供访问连接点的静态部分，如被通知方法签名、连接点类型等
public interface StaticPart {
	Signature getSignature();    //返回当前连接点签名
	String getKind();          //连接点类型
	int getId();               //唯一标识
	String toString();         //连接点所在位置的相关信息
	String toShortString();     //连接点所在位置的简短相关信息
	String toLongString();     //连接点所在位置的全部相关信息
}


使用如下方式在通知方法上声明，必须是在第一个参数，然后使用jp.getArgs()就能获取到被通知方法参数：
@Before(value="execution(* sayBefore(*))")
public void before(JoinPoint jp) {}

@Before(value="execution(* sayBefore(*))")
public void before(JoinPoint.StaticPart jp) {}



自动获取：通过切入点表达式可以将相应的参数自动传递给通知方法，例如前边章节讲过的返回值和异常是如何传递给通知方法的。
在Spring AOP中，除了execution和bean指示符不能传递参数给通知方法，其他指示符都可以将匹配的相应参数或对象自动传递给通知方法。
@Before(value="execution(* test(*)) && args(param)", argNames="param")
public void before1(String param) {
	System.out.println("===param:" + param);
}

切入点表达式execution(* test(*)) && args(param) ：
1）首先execution(* test(*))匹配任何方法名为test，且有一个任何类型的参数；
2）args(param)将首先查找通知方法上同名的参数，并在方法执行时（运行时）匹配传入的参数是使用该同名参数类型，即java.lang.String；如果匹配将把该被通知参数传递给通知方法上同名参数。
其他指示符（除了execution和bean指示符）都可以使用这种方式进行参数绑定。
在此有一个问题，即前边提到的类似于【3.1.2构造器注入】中的参数名注入限制：在class文件中没生成变量调试信息是获取不到方法参数名字的。
所以我们可以使用策略来确定参数名：

如果我们通过“argNames”属性指定了参数名，那么就是要我们指定的；
@Before(value=" args(param)", argNames="param") //明确指定了
public void before1(String param) {
	System.out.println("===param:" + param);
}

如果第一个参数类型是JoinPoint、ProceedingJoinPoint或JoinPoint.StaticPart类型，应该从“argNames”属性省略掉该参数名（可选，写上也对），这些类型对象会自动传入的，但必须作为第一个参数；
@Before(value=" args(param)", argNames="param") //明确指定了
public void before1(JoinPoint jp, String param) {
	System.out.println("===param:" + param);
}

如果“class文件中含有变量调试信息”将使用这些方法签名中的参数名来确定参数名；
@Before(value=" args(param)") //不需要argNames了
public void before1(JoinPoint jp, String param) {
	System.out.println("===param:" + param);
}
如果没有“class文件中含有变量调试信息”，将尝试自己的参数匹配算法，如果发现参数绑定有二义性将抛出AmbiguousBindingException异常；对于只有一个绑定变量的切入点表达式，而通知方法只接受一个参数，说明绑定参数是明确的，从而能配对成功。
@Before(value=" args(param)")
public void before1(JoinPoint jp, String param) {
	System.out.println("===param:" + param);
}
以上策略失败将抛出IllegalArgumentException。


除了上边介绍的普通方式，也可以对使用命名切入点自动获取参数：
@Pointcut(value="args(param)", argNames="param")
private void pointcut1(String param){}
@Pointcut(value="@annotation(secure)", argNames="secure")
private void pointcut2(Secure secure){}
@Before(value = "pointcut1(param) && pointcut2(secure)",
 argNames="param, secure")
public void before6(JoinPoint jp, String param, Secure secure) {
……
}



在Spring配置文件中，所以AOP相关定义必须放在<aop:config>标签下，该标签下可以有<aop:pointcut>、<aop:advisor>、<aop:aspect>标签，配置顺序不可变。
<aop:pointcut>：用来定义切入点，该切入点可以重用；
<aop:advisor>：用来定义只有一个通知和一个切入点的切面；
<aop:aspect>：用来定义切面，该切面可以包含多个切入点和通知，而且标签内部的通知和切入点定义是无序的；和advisor的区别就在此，advisor只包含一个通知和一个切入点。

<aop:config>
	<aop:pointcut />
	<aop:advisor />
	<aop:aspect>
		<aop:pointcut />
		<aop:before />
		<aop:after-returning />
		<aop:after-throwing />
		<aop:after />
		<aop:around />
		<aop:declare-aprents />
	</aop:aspect>
</aop:config>


bean作用域(scope)
在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。
Spring提供“singleton”和“prototype”两种基本作用域，另外提供“request”、“session”、“global session”三种web作用域；Spring还允许用户定制自己的作用域。

“singleton”作用域的Bean只会在每个Spring IoC容器中存在一个实例，而且其完整生命周期完全由Spring容器管理。对于所有获取该Bean的操作Spring容器将只返回同一个Bean。


GoF单例设计模式指“保证一个类仅有一个实例，并提供一个访问它的全局访问点”，介绍了两种实现：通过在类上定义静态属性保持该实例和通过注册表方式。
1）通过在类上定义静态属性保持该实例：一般指一个Java虚拟机 ClassLoader装载的类只有一个实例，一般通过类静态属性保持该实例，这样就造成需要单例的类都需要按照单例设计模式进行编码；Spring没采用这种方式，因为该方式属于侵入式设计；代码样例如下：
package cn.javass.spring.chapter3.bean;
public class Singleton {
	//1.私有化构造器
	private Singleton() {}
	//2.单例缓存者，惰性初始化，第一次使用时初始化
	private static class InstanceHolder {
		private static final Singleton INSTANCE = new Singleton();
	}
	//3.提供全局访问点
	public static Singleton getInstance() {
		return InstanceHolder.INSTANCE;
	}
	//4.提供一个计数器来验证一个ClassLoader一个实例
	private int counter=0;
}

通过注册表方式： 首先将需要单例的实例通过唯一键注册到注册表，然后通过键来获取单例，注意本注册表实现了Spring接口“SingletonBeanRegistry”，该接口定义了操作共享的单例对象，Spring容器实现将实现此接口；所以共享单例对象通过“registerSingleton”方法注册，通过“getSingleton”方法获取，消除了编程方式单例，注意在实现中不考虑并发：

public class SingletonBeanRegister implements SingletonBeanRegistry {
    //单例Bean缓存池，此处不考虑并发
    private final Map<String, Object> BEANS = new HashMap<String, Object>();
    public boolean containsSingleton(String beanName) {
        return BEANS.containsKey(beanName);
    }
    public Object getSingleton(String beanName) {
        return BEANS.get(beanName);
    }
    @Override
    public int getSingletonCount() {
        return BEANS.size();
    }
    @Override
    public String[] getSingletonNames() {
        return BEANS.keySet().toArray(new String[0]);
    }
    @Override
    public void registerSingleton(String beanName, Object bean) {
        if(BEANS.containsKey(beanName)) {
            throw new RuntimeException("[" + beanName + "] 已存在");
        }
        BEANS.put(beanName, bean);
	}
}
。。接口是有的，类是作者自己的。


在Spring容器中如果没指定作用域默认就是“singleton”
<bean  class="cn.javass.spring.chapter3.bean.Printer" scope="singleton"/>


prototype：即原型，指每次向Spring容器请求获取Bean都返回一个全新的Bean，相对于“singleton”来说就是不缓存Bean，每次都是一个根据Bean定义创建的全新Bean。

GoF原型设计模式，指用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
<bean class="cn.javass.spring.chapter3.bean.Printer" scope="prototype"/>

Spring中的原型和GoF中介绍的原型含义是不一样的：
GoF通过用原型实例指定创建对象的种类，而Spring容器用Bean定义指定创建对象的种类；
GoF通过拷贝这些原型创建新的对象，而Spring容器根据Bean定义创建新对象。
其相同地方都是根据某些东西创建新东西，而且GoF原型必须显示实现克隆操作，属于侵入式，而Spring容器只需配置即可，属于非侵入式。

org.springframework.beans.factory.config.BeanDefinition

。。单例还是原型是针对spring自己的，每次被ref的时候都会生成一个新的对象。。不过也只有这样啊，毕竟实际用的时候就是ref进去的。


在Web应用中，我们可能需要将数据存储到request、session、global session。因此Spring提供了三种Web作用域：request、session、globalSession。

一、request作用域：表示每个请求需要容器创建一个全新Bean。比如提交表单的数据必须是对每次请求新建一个Bean来保持这些表单数据，请求结束释放这些数据。

二、session作用域：表示每个会话需要容器创建一个全新Bean。比如对于每个用户一般会有一个会话，该用户的用户信息需要存储到会话中，此时可以将该Bean配置为web作用域。

三、globalSession：类似于session作用域，只是其用于portlet环境的web应用。如果在非portlet环境将视为session作用域。

org.springframework.web.context.request.SessionScope
org.springframework.web.context.request.RequestScope

1）Object get(String name, ObjectFactory<?> objectFactory)：用于从作用域中获取Bean，其中参数objectFactory是当在当前作用域没找到合适Bean时使用它创建一个新的Bean；

2）void registerDestructionCallback(String name, Runnable callback)：用于注册销毁回调，如果想要销毁相应的对象则由Spring容器注册相应的销毁回调，而由自定义作用域选择是不是要销毁相应的对象；

3）Object resolveContextualObject(String key)：用于解析相应的上下文数据，比如request作用域将返回request中的属性。

4）String getConversationId()：作用域的会话标识，比如session作用域将是sessionId。


让我们来实现个简单的thread作用域，该作用域内创建的对象将绑定到ThreadLocal内。

public class ThreadScope implements Scope {
	private final ThreadLocal<Map<String, Object>> THREAD_SCOPE = new ThreadLocal<Map<String, Object>>() {
		protected Map<String, Object> initialValue() {
			//用于存放线程相关Bean
			return new HashMap<String, Object>();
		}
	};
    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        //如果当前线程已经绑定了相应Bean，直接返回
        if(THREAD_SCOPE.get().containsKey(name)) {
           return THREAD_SCOPE.get().get(name);
        }
        //使用objectFactory创建Bean并绑定到当前线程上
        THREAD_SCOPE.get().put(name, objectFactory.getObject());
        return THREAD_SCOPE.get().get(name);
    }
    @Override
    public String getConversationId() {
        return null;
    }
    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
        //此处不实现就代表类似proytotype，容器返回给用户后就不管了
    }
    @Override
    public Object remove(String name) {
        return THREAD_SCOPE.get().remove(name);
    }
    @Override
    public Object resolveContextualObject(String key) {
        return null;
    }
}

Scope已经实现了，让我们将其注册到Spring容器，使其发挥作用：

<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
	<property name="scopes">
	   <map><entry>
			   <!-- 指定scope关键字 --><key><value>thread</value></key>
			   <!-- scope实现 -->      <bean class="cn.javass.spring.chapter3.ThreadScope"/>
	   </entry></map>
	</property>
</bean>


<bean id="helloApi"   class="cn.javass.spring.chapter2.helloworld.HelloImpl"   scope="thread"/>

首先在一个线程中测试，在同一线程中获取的Bean应该是一样的；再让我们开启两个线程，然后应该这两个线程创建的Bean是不一样：

自定义作用域实现其实是非常简单的，其实复杂的是如果需要销毁Bean，自定义作用域如何正确的销毁Bean。


延迟初始化Bean
配置方式很简单只需在<bean>标签上指定 “lazy-init” 属性值为“true”即可延迟初始化Bean。

Spring容器会在创建容器时提前初始化“singleton”作用域的Bean。
Spring容器预先初始化Bean通常能帮助我们提前发现配置错误，所以如果没有什么情况建议开启，除非有某个Bean可能需要加载很大资源，而且很可能在整个应用程序生命周期中很可能使用不到，可以设置为延迟初始化。

。。prototype默认懒加载？
。。yes...lazy-init 只对单例模式起作用,对 prototype 不起作用(因为 prototype 默认就不是程序初始化的时候实例化的)
..lazy-init接受 default，false，true。前2个功能一样的


depends-on是指指定Bean初始化及销毁时的顺序，使用depends-on属性指定的Bean要先初始化完毕后才初始化当前Bean，由于只有“singleton”Bean能被Spring管理销毁，所以当指定的Bean都是“singleton”时，使用depends-on属性指定的Bean要在指定的Bean之后销毁。


<bean id="helloApi" class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<bean id="decorator"   class="cn.javass.spring.chapter3.bean.HelloApiDecorator"   depends-on="helloApi">
	<property name="helloApi"><ref bean="helloApi"/></property>
</bean>

“decorator”指定了“depends-on”属性为“helloApi”，所以在“decorator”Bean初始化之前要先初始化“helloApi”，而在销毁“helloApi”之前先要销毁“decorator”，大家注意一下销毁顺序，与文档上的不符。

“depends-on”属性可以指定多个Bean，若指定多个Bean可以用“;”、“,”、空格分割。

那“depends-on”有什么好处呢？主要是给出明确的初始化及销毁顺序，比如要初始化“decorator”时要确保“helloApi”Bean的资源准备好了，否则使用“decorator”时会看不到准备的资源；而在销毁时要先在“decorator”Bean的把对“helloApi”资源的引用释放掉才能销毁“helloApi”，否则可能销毁 “helloApi”时而“decorator”还保持着资源访问，造成资源不能释放或释放错误。



<bean id="resourceBean"
	class="cn.javass.spring.chapter3.bean.ResourceBean"
	init-method="init" destroy-method="destroy">
	<property name="file" value="D:/test.txt"/>
</bean>
<bean id="dependentBean"
	class="cn.javass.spring.chapter3.bean.DependentBean"
	init-method="init" destroy-method="destroy" depends-on="resourceBean">
	<property name="resourceBean" ref="resourceBean"/>
</bean>
。。init-method,destory-method


<property name="file" value="D:/test.txt"/>配置：Spring容器能自动把字符串转换为java.io.File。

init-method="init" ：指定初始化方法，在构造器注入和setter注入完毕后执行。

destroy-method="destroy"：指定销毁方法，只有“singleton”作用域能销毁，“prototype”作用域的一定不能，其他作用域不一定能；后边再介绍。


目前Spring3.0支持“no”、“byName ”、“byType”、“constructor”四种自动装配，默认是“no”指不支持自动装配的，其中Spring3.0已不推荐使用之前版本的“autodetect”自动装配，推荐使用Java 5+支持的（@Autowired）注解方式代替；如果想支持“autodetect”自动装配，请将schema改为“spring-beans-2.5.xsd”或去掉。

自动装配的好处是减少构造器注入和setter注入配置，减少配置文件的长度。自动装配通过配置<bean>标签的“autowire”属性来改变自动装配方式。接下来让我们挨着看下配置的含义。

一、default：表示使用默认的自动装配，默认的自动装配需要在<beans>标签中使用default-autowire属性指定，其支持“no”、“byName ”、“byType”、“constructor”四种自动装配，如果需要覆盖默认自动装配，请继续往下看；

二、no：意思是不支持自动装配，必须明确指定依赖。

三、byName：通过设置Bean定义属性autowire="byName"，意思是根据名字进行自动装配，只能用于setter注入。比如我们有方法“setHelloApi”，则“byName”方式Spring容器将查找名字为helloApi的Bean并注入，如果找不到指定的Bean，将什么也不注入。
<bean id="helloApi" class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<bean id="bean" class="cn.javass.spring.chapter3.bean.HelloApiDecorator"   autowire="byName"/>

。。setOid.岂不是也要去搜下有没有oid这个bean。。。不不不，manager怎么会有oid呢。。还有这种配置会去注入父类的属性吗？

注意了，在根据名字注入时，将把当前Bean自己排除在外：比如“hello”Bean类定义了“setHello”方法，则hello是不能注入到“setHello”的。


“byType”：通过设置Bean定义属性autowire="byType"，意思是指根据类型注入，用于setter注入，比如如果指定自动装配方式为“byType”，而“setHelloApi”方法需要注入HelloApi类型数据，则Spring容器将查找HelloApi类型数据，如果找到一个则注入该Bean，如果找不到将什么也不注入，如果找到多个Bean将优先注入<bean>标签“primary”属性为true的Bean，否则抛出异常来表明有个多个Bean发现但不知道使用哪个。让我们用例子来讲解一下这几种情况吧。

1）根据类型只找到一个Bean，此处注意了，在根据类型注入时，将把当前Bean自己排除在外，即如下配置中helloApi和bean都是HelloApi接口的实现，而“bean”通过类型进行注入“HelloApi”类型数据时自己是排除在外的，配置如下（具体测试请参考AutowireBeanTest.testAutowireByType1方法）：
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<bean id="bean" class="cn.javass.spring.chapter3.bean.HelloApiDecorator"
	 autowire="byType"/>


2）根据类型找到多个Bean时，对于集合类型（如List、Set）将注入所有匹配的候选者，而对于其他类型遇到这种情况可能需要使用“autowire-candidate”属性为false来让指定的Bean放弃作为自动装配的候选者，或使用“primary”属性为true来指定某个Bean为首选Bean：

2.1）通过设置Bean定义的“autowire-candidate”属性为false来把指定Bean后自动装配候选者中移除：
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<!-- 从自动装配候选者中去除 -->
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl"
autowire-candidate="false"/>

<bean id="bean1" class="cn.javass.spring.chapter3.bean.HelloApiDecorator"
autowire="byType"/>


2.2）通过设置Bean定义的“primary”属性为true来把指定自动装配时候选者中首选Bean：
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<!-- 自动装配候选者中的首选Bean-->
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl" primary="true"/>
<bean id="bean" class="cn.javass.spring.chapter3.bean.HelloApiDecorator"
	 autowire="byType"/>


“constructor”：通过设置Bean定义属性autowire="constructor"，功能和“byType”功能一样，根据类型注入构造器参数，只是用于构造器注入方式.
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<!-- 自动装配候选者中的首选Bean-->
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl" primary="true"/>
<bean id="bean"  class="cn.javass.spring.chapter3.bean.HelloApiDecorator"
     autowire="constructor"/>


autodetect：自动检测是使用“constructor”还是“byType”自动装配方式，已不推荐使用。如果Bean有空构造器那么将采用“byType”自动装配方式，否则使用“constructor”自动装配方式。此处要把3.0的xsd替换为2.5的xsd，否则会报错。
xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-2.5.xsd">
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<!-- 自动装配候选者中的首选Bean-->
<bean class="cn.javass.spring.chapter2.helloworld.HelloImpl" primary="true"/>
<bean id="bean"  class="cn.javass.spring.chapter3.bean.HelloApiDecorator"  autowire="autodetect"/>


可以采用在“<beans>”标签中通过“default-autowire”属性指定全局的自动装配方式，即如果default-autowire=”byName”，将对所有Bean进行根据名字进行自动装配。

不是所有类型都能自动装配：

不能自动装配的数据类型：Object、基本数据类型（Date、CharSequence、Number、URI、URL、Class、int）等；
通过“<beans>”标签default-autowire-candidates属性指定的匹配模式，不匹配的将不能作为自动装配的候选者，例如指定“*Service，*Dao”，将只把匹配这些模式的Bean作为候选者，而不匹配的不会作为候选者；
通过将“<bean>”标签的autowire-candidate属性可被设为false，从而该Bean将不会作为依赖注入的候选者。

数组、集合、字典类型的根据类型自动装配和普通类型的自动装配是有区别的：

数组类型、集合（Set、Collection、List）接口类型：将根据泛型获取匹配的所有候选者并注入到数组或集合中，如“List<HelloApi> list”将选择所有的HelloApi类型Bean并注入到list中，而对于集合的具体类型将只选择一个候选者，“如 ArrayList<HelloApi> list”将选择一个类型为ArrayList的Bean注入，而不是选择所有的HelloApi类型Bean进行注入；
字典（Map）接口类型：同样根据泛型信息注入，键必须为String类型的Bean名字，值根据泛型信息获取，如“Map<String, HelloApi> map” 将选择所有的HelloApi类型Bean并注入到map中，而对于具体字典类型如“HashMap<String, HelloApi> map”将只选择类型为HashMap的Bean注入，而不是选择所有的HelloApi类型Bean进行注入。


首先，自动装配确实减少了配置文件的量；其次， “byType”自动装配能在相应的Bean更改了字段类型时自动更新，即修改Bean类不需要修改配置，确实简单了。

自动装配也是有缺点的，最重要的缺点就是没有了配置，在查找注入错误时非常麻烦，还有比如基本类型没法完成自动装配，所以可能经常发生一些莫名其妙的错误

配置注入的数据会覆盖自动装配注入的数据。



对于采用自动装配方式时如果没找到合适的的Bean时什么也不做，这样在程序中总会莫名其妙的发生一些空指针异常，而且是在程序运行期间才能发现，有没有办法能在提前发现这些错误呢？接下来就让我来看下依赖检查吧。

依赖检查：用于检查Bean定义的属性都注入数据了，不管是自动装配的还是配置方式注入的都能检查，如果没有注入数据将报错，从而提前发现注入错误，只检查具有setter方法的属性。

Spring3+也不推荐配置方式依赖检查了，建议采用Java5+ @Required注解方式，测试时请将XML schema降低为2.5版本的，和自动装配中“autodetect”配置方式的xsd一样。

依赖检查有none、simple、object、all四种方式
none：默认方式，表示不检查；

objects：检查除基本类型外的依赖对象，配置方式为：dependency-check="objects"，此处我们为HelloApiDecorator添加一个String类型属性“message”，来测试如果有简单数据类型的属性为null，也不报错；

<bean id="helloApi" class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<!-- 注意我们没有注入helloApi，所以测试时会报错 -->
<bean id="bean"  class="cn.javass.spring.chapter3.bean.HelloApiDecorator"  dependency-check="objects">
	<property name="message" value="Haha"/>
</bean>

注意由于我们没有注入bean需要的依赖“helloApi”，所以应该抛出异常UnsatisfiedDependencyException，表示没有发现满足的依赖：


simple：对基本类型进行依赖检查，包括数组类型，其他依赖不报错；配置方式为：dependency-check="simple"，以下配置中没有注入message属性，所以会抛出异常：
<bean id="helloApi" class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<!-- 注意我们没有注入message属性，所以测试时会报错 -->
<bean id="bean"  class="cn.javass.spring.chapter3.bean.HelloApiDecorator"  dependency-check="simple">
	<property name="helloApi" ref="helloApi"/>
</bean>


all：对所以类型进行依赖检查，配置方式为：dependency-check="all"，如下配置方式中如果两个属性其中一个没配置将报错。

<bean id="helloApi" class="cn.javass.spring.chapter2.helloworld.HelloImpl"/>
<bean id="bean"  class="cn.javass.spring.chapter3.bean.HelloApiDecorator"  dependency-check="all">
	<property name="helloApi" ref="helloApi"/>
	<property name="message" value="Haha"/>
</bean>


依赖检查也可以通过“<beans>”标签中default-dependency-check属性来指定全局依赖检查配置。



所谓方法注入其实就是通过配置方式覆盖或拦截指定的方法，通常通过代理模式实现。Spring提供两种方法注入：查找方法注入和方法替换注入。
因为Spring是通过CGLIB动态代理方式实现方法注入，也就是通过动态修改类的字节码来实现的，本质就是生成需方法注入的类的子类方式实现。

一、查找方法注入：又称为Lookup方法注入，用于注入方法返回结果，也就是说能通过配置方式替换方法返回结果。使用<lookup-method name="方法名" bean="bean名字"/>配置；其中name属性指定方法名，bean属性指定方法需返回的Bean。
方法定义格式：访问级别必须是public或protected，保证能被子类重载，可以是抽象方法，必须有返回值，必须是无参数方法，查找方法的类和被重载的方法必须为非final：
<public|protected> [abstract] <return-type> theMethodName(no-arguments);


因为“singleton”Bean在容器中只有一个实例，而“prototype”Bean是每次获取容器都返回一个全新的实例，所以如果“singleton”Bean在使用“prototype” Bean情况时，那么“prototype”Bean由于是“singleton”Bean的一个字段属性，所以获取的这个“prototype”Bean就和它所在的“singleton”Bean具有同样的生命周期，所以不是我们所期待的结果。因此查找方法注入就是用于解决这个问题。

https://jinnianshilongnian.iteye.com/blog/1415461

public class Printer {
    private int counter = 0;
    public void print(String type) {
        System.out.println(type + " printer: " + counter++);
    }
}

public abstract class HelloImpl5 implements HelloApi {
    private Printer printer;
    public void sayHello() {
        printer.print("setter");
        createPrototypePrinter().print("prototype");
        createSingletonPrinter().print("singleton");
    }
    public abstract Printer createPrototypePrinter();
    public Printer createSingletonPrinter() {
        System.out.println("该方法不会被执行，如果输出就错了");
        return new Printer();
    }
    public void setPrinter(Printer printer) {
        this.printer = printer;
    }
}

其中“prototypePrinter”是“prototype”Printer，“singletonPrinter”是“singleton”Printer，“helloApi1”是“singleton”Bean，而“helloApi2”注入了“prototype”Bean：
<bean id="prototypePrinter"
class="cn.javass.spring.chapter3.bean.Printer" scope="prototype"/>
<bean id="singletonPrinter"
class="cn.javass.spring.chapter3.bean.Printer" scope="singleton"/>
<bean id="helloApi1" class="cn.javass.spring.chapter3.HelloImpl5" scope="singleton">
<property name="printer" ref="prototypePrinter"/>
<lookup-method name="createPrototypePrinter" bean="prototypePrinter"/>
<lookup-method name="createSingletonPrinter" bean="singletonPrinter"/>
</bean>
<bean id="helloApi2" class="cn.javass.spring.chapter3.HelloImpl5" scope="prototype">
<property name="printer" ref="prototypePrinter"/>
<lookup-method name="createPrototypePrinter" bean="prototypePrinter"/>
<lookup-method name="createSingletonPrinter" bean="singletonPrinter"/>
</bean>

@Test
public void testLookup() {
ClassPathXmlApplicationContext context =
new ClassPathXmlApplicationContext("chapter3/lookupMethodInject.xml");
        System.out.println("=======singleton sayHello======");
        HelloApi helloApi1 = context.getBean("helloApi1", HelloApi.class);
        helloApi1.sayHello();
        helloApi1 = context.getBean("helloApi1", HelloApi.class);
        helloApi1.sayHello();
        System.out.println("=======prototype sayHello======");
        HelloApi helloApi2 = context.getBean("helloApi2", HelloApi.class);
        helloApi2.sayHello();
        helloApi2 = context.getBean("helloApi2", HelloApi.class);
        helloApi2.sayHello();
}}

首先“helloApi1”是“singleton”，通过setter注入的“printer”是“prototypePrinter”，所以它应该输出“setter printer:0”和“setter printer:1”；而“createPrototypePrinter”方法注入了“prototypePrinter”，所以应该输出两次“prototype printer:0”；而“createSingletonPrinter”注入了“singletonPrinter”，所以应该输出“singleton printer:0”和“singleton printer:1”。

首先“helloApi2”是“prototype”，通过setter注入的“printer”是“prototypePrinter”，所以它应该输出两次“setter printer:0”；而“createPrototypePrinter”方法注入了“prototypePrinter”，所以应该输出两次“prototype printer:0”；而“createSingletonPrinter”注入了“singletonPrinter”，所以应该输出“singleton printer:2”和“singleton printer:3”。

大家是否注意到“createSingletonPrinter”方法应该输出“该方法不会被执行，如果输出就错了”，而实际是没输出的，这说明Spring拦截了该方法并使用注入的Bean替换了返回结果。

方法注入主要用于处理“singleton”作用域的Bean需要其他作用域的Bean时，采用Spring查找方法注入方式无需修改任何代码即能获取需要的其他作用域的Bean。



二、替换方法注入：也叫“MethodReplacer”注入，和查找注入方法不一样的是，他主要用来替换方法体。通过首先定义一个MethodReplacer接口实现，然后如下配置来实现：
<replaced-method name="方法名" replacer="MethodReplacer实现">
	<arg-type>参数类型</arg-type>
</replaced-method>”

首先定义MethodReplacer实现，完全替换掉被替换方法的方法体及返回值，其中reimplement方法重定义方法 功能，参数obj为被替换方法的对象，method为被替换方法，args为方法参数；最需要注意的是不能再 通过“method.invoke(obj, new String[]{"hehe"});” 反射形式再去调用原来方法，这样会产生循环调用；如果返回值类型为Void，请在实现中返回null：

配置如下，首先定义MethodReplacer实现，使用< replaced-method >标签来指定要进行替换方法，属性name指定替换的方法名字，replacer指定该方法的重新实现者，子标签< arg-type >用来指定原来方法参数的类型，必须指定否则找不到原方法：

public class PrinterReplacer implements MethodReplacer {
    @Override
    public Object reimplement(Object obj, Method method, Object[] args)   throws Throwable {
        System.out.println("Print Replacer");
        //注意此处不能再通过反射调用了,否则会产生循环调用，知道内存溢出
        //method.invoke(obj, new String[]{"hehe"});
        return null;
    }
}

<bean id="replacer" class="cn.javass.spring.chapter3.bean.PrinterReplacer"/>
<bean id="printer" class="cn.javass.spring.chapter3.bean.Printer">
<replaced-method name="print" replacer="replacer">
        <arg-type>java.lang.String</arg-type>
    </replaced-method>
</bean>







<bean id="aspect" class="cn.javass.spring.chapter6.aop.HelloWorldAspect"/>
<aop:config>
<aop:pointcut id="pointcut" expression="execution(* cn.javass..*.*(..))"/>
	<aop:aspect ref="aspect">
		<aop:before pointcut-ref="pointcut" method="beforeAdvice"/>
		<aop:after pointcut="execution(* cn.javass..*.*(..))" method="afterFinallyAdvice"/>
	</aop:aspect>
</aop:config>





事务的隔离级别，传播


丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；
脏读：一个事务看到了另一个事务未提交的更新数据；
不可重复读：在同一事务中，多次读取同一数据却返回不同的结果；也就是有其他事务更改了这些数据；
幻读：一个事务在执行过程中读取到了另一个事务已提交的插入数据；即在第一个事务开始时读取到一批数据，但此后另一个事务又插入了新数据并提交，此时第一个事务又读取这批数据但发现多了一条，即好像发生幻觉一样。


在标准SQL规范中定义了四种隔离级别：
未提交读（Read Uncommitted）：最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；
提交读（Read Committed）：一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不可能可能出现丢失更新、脏读，但可能出现不可重复读、幻读；
可重复读（Repeatable Read）：保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，bu可能可能出现丢失更新、脏读、不可重复读，但可能出现幻读；
序列化（Serializable）：最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读。


数据库事务类型有本地事务和分布式事务：
本地事务：就是普通事务，能保证单台数据库上的操作的ACID，被限定在一台数据库上；
分布式事务：涉及两个或多个数据库源的事务，即跨越多台同类或异类数据库的事务（由每台数据库的本地事务组成的），分布式事务旨在保证这些本地事务的所有操作的ACID，使事务可以跨越多台数据库；

Java事务类型有JDBC事务和JTA事务：
JDBC事务：就是数据库事务类型中的本地事务，通过Connection对象的控制来管理事务；
JTA事务：JTA指Java事务API(Java Transaction API)，是Java EE数据库事务规范， JTA只提供了事务管理接口，由应用程序服务器厂商（如WebSphere Application Server）提供实现，JTA事务比JDBC更强大，支持分布式事务。

Java EE事务类型有本地事务和全局事务：
本地事务：使用JDBC编程实现事务；
全局事务：由应用程序服务器提供，使用JTA事务；


按是否通过编程实现事务有声明式事务和编程式事务；
声明式事务： 通过注解或XML配置文件指定事务信息；
编程式事务：通过编写代码实现事务。


Spring框架支持事务管理的核心是事务管理器抽象，对于不同的数据访问框架（如Hibernate）通过实现策略接口PlatformTransactionManager，
getTransaction()：返回一个已经激活的事务或创建一个新的事务（根据给定的TransactionDefinition类型参数定义的事务属性），返回的是TransactionStatus对象代表了当前事务的状态，其中该方法抛出TransactionException（未检查异常）表示事务由于某种原因失败。
commit()：用于提交TransactionStatus参数代表的事务，具体语义请参考Spring Javadoc；
rollback()：用于回滚TransactionStatus参数代表的事务，具体语义请参考Spring Javadoc。

TransactionDefinition接口
getPropagationBehavior()：返回定义的事务传播行为；
getIsolationLevel()：返回定义的事务隔离级别；
getTimeout()：返回定义的事务超时时间；
isReadOnly()：返回定义的事务是否是只读的；
getName()：返回定义的事务名字。

TransactionStatus接口定义
isNewTransaction()：返回当前事务状态是否是新事务；
hasSavepoint()：返回当前事务是否有保存点；
setRollbackOnly()：设置当前事务应该回滚；
isRollbackOnly(()：返回当前事务是否应该回滚；
flush()：用于刷新底层会话中的修改到数据库，一般用于刷新如Hibernate/JPA的会话，可能对如JDBC类型的事务无任何影响；
isCompleted():当前事务否已经完成。


DataSourceTransactionManager用于Spring JDBC抽象框架、iBATIS或MyBatis框架的事务管理

JdoTransactionManager用于集成JDO框架时的事务管理

JpaTransactionManager用于集成JPA实现框架时的事务管理

HibernateTransactionManager用于集成Hibernate框架时的事务管理；该事务管理器只支持Hibernate3+版本，且Spring3.0+版本只支持Hibernate 3.2+版本

JtaTransactionManager提供对分布式事务管理的支持，并将事务管理委托给Java EE应用服务器事务管理器

OC4JjtaTransactionManager，Spring提供的对OC4J10.1.3+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持；

WebSphereUowTransactionManager对WebSphere 6.0+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持；

WebLogicJtaTransactionManager对WebLogic 8.1+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持。


Spring不仅提供这些事务管理器，还提供对如JMS事务管理的管理器等


声明对本地事务的支持：
JDBC及iBATIS、MyBatis框架事务管理器
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"/>
</bean>

Jdo事务管理器
<bean id="txManager" class="org.springframework.orm.jdo.JdoTransactionManager">
	<property name="persistenceManagerFactory" ref="persistenceManagerFactory"/>
</bean>


<bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager">
	<property name="entityManagerFactory" ref="entityManagerFactory"/>
</bean>


<bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">
	<property name="sessionFactory" ref="sessionFactory"/>
</bean>



编程式事务
所谓编程式事务指的是通过编码方式实现事务，即类似于JDBC编程实现事务管理。
Spring框架提供一致的事务抽象，因此对于JDBC还是JTA事务都是采用相同的API进行编程。

Connection conn = null;
UserTransaction tx = null;
try {
	tx = getUserTransaction();              //1.获取事务
	tx.begin();           		     //2.开启JTA事务
	conn = getDataSource().getConnection();   //3.获取JDBC
	//4.声明SQL
	String sql = "select * from INFORMATION_SCHEMA.SYSTEM_TABLES";
	PreparedStatement pstmt = conn.prepareStatement(sql);//5.预编译SQL
	ResultSet rs = pstmt.executeQuery();  //6.执行SQL
	process(rs);                        //7.处理结果集
	closeResultSet(rs);                //8.释放结果集
	tx.commit();                   //7.提交事务
} catch (Exception e) {
	tx.rollback();               //8.回滚事务
	throw e;
} finally {
   conn.close();              //关闭连接
}

可以看到使用UserTransaction而不是Connection连接进行控制事务，从而对于JDBC事务和JTA事务是采用不同API进行编程控制的，并且JTA和JDBC事务管理的异常也是不一样的。


Spring中的事务分为物理事务和逻辑事务；

物理事务：就是底层数据库提供的事务支持，如JDBC或JTA提供的事务；
逻辑事务：是Spring管理的事务，不同于物理事务，逻辑事务提供更丰富的控制，而且如果想得到Spring事务管理的好处，必须使用逻辑事务，因此在Spring中如果没特别强调一般就是逻辑事务；

逻辑事务即支持非常低级别的控制，也有高级别解决方案：


低级别解决方案：
工具类：使用工具类获取连接（会话）和释放连接（会话），如使用org.springframework.jdbc.datasource包中的 DataSourceUtils 类来获取和释放具有逻辑事务功能的连接。当然对集成第三方ORM框架也提供了类似的工具类，如对Hibernate提供了SessionFactoryUtils工具类，JPA的EntityManagerFactoryUtils等，其他工具类都是使用类似***Utils命名；

//获取具有Spring事务（逻辑事务）管理功能的连接
DataSourceUtils. getConnection(DataSource dataSource)
//释放具有Spring事务（逻辑事务）管理功能的连接
DataSourceUtils. releaseConnection(Connection con, DataSource dataSource)


TransactionAwareDataSourceProxy：使用该数据源代理类包装需要Spring事务管理支持的数据源，该包装类必须位于最外层，主要用于遗留项目中可能直接使用数据源获取连接和释放连接支持或希望在Spring中进行混合使用各种持久化框架时使用，其内部实际使用 DataSourceUtils 工具类获取和释放真正连接；

<!--使用该方式包装数据源，必须在最外层，targetDataSource 知道目标数据源-->
<bean id="dataSourceProxy"
class="org.springframework.jdbc.datasource.
TransactionAwareDataSourceProxy">
	<property name="targetDataSource" ref="dataSource"/>
</bean>

通过如上方式包装数据源后，可以在项目中使用物理事务编码的方式来获得逻辑事务的支持，即支持直接从DataSource获取连接和释放连接，且这些连接自动支持Spring逻辑事务；


高级别解决方案：
模板类：使用Spring提供的模板类，如JdbcTemplate、HibernateTemplate和JpaTemplate模板类等，而这些模板类内部其实是使用了低级别解决方案中的工具类来管理连接或会话；

Spring提供两种编程式事务支持：直接使用PlatformTransactionManager实现和使用TransactionTemplate模板类，用于支持逻辑事务管理。

如果采用编程式事务推荐使用TransactionTemplate模板类和高级别解决方案。

TransactionTemplate
TransactionTemplate模板类用于简化事务管理，事务管理由模板类定义，而具体操作需要通过TransactionCallback回调接口或TransactionCallbackWithoutResult回调接口指定，通过调用模板类的参数类型为TransactionCallback或TransactionCallbackWithoutResult的execute方法来自动享受事务管理。

TransactionCallback：通过实现该接口的“T doInTransaction(TransactionStatus status) ”方法来定义需要事务管理的操作代码；
TransactionCallbackWithoutResult：继承TransactionCallback接口，提供“void doInTransactionWithoutResult(TransactionStatus status)”便利接口用于方便那些不需要返回值的事务操作代码。

@Test
public void testTransactionTemplate() {//位于TransactionTest类中
	jdbcTemplate.execute(CREATE_TABLE_SQL);
	TransactionTemplate transactionTemplate = new TransactionTemplate(txManager);
	transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
	transactionTemplate.execute(new TransactionCallbackWithoutResult() {
		@Override
		protected void doInTransactionWithoutResult(TransactionStatus status) {
		jdbcTemplate.update(INSERT_SQL, "test");
	}});
	jdbcTemplate.execute(DROP_TABLE_SQL);
}

。。cms
<bean id="baseCommissionRunTxTemplate" class="org.springframework.transaction.support.TransactionTemplate">
	<property name="transactionManager" ref="transactionManager"/>
	<property name="propagationBehaviorName" value="PROPAGATION_REQUIRES_NEW"/>
</bean>
。。cms..怎么配置隔离级别？app*baf中

TransactionTemplate ：通过new TransactionTemplate(txManager)创建事务模板类，其中构造器参数为PlatformTransactionManager实现，并通过其相应方法设置事务定义，如事务隔离级别、传播行为等，此处未指定传播行为，其默认为PROPAGATION_REQUIRED；
TransactionCallbackWithoutResult：此处使用不带返回的回调实现，其doInTransactionWithoutResult方法实现中定义了需要事务管理的操作；
transactionTemplate.execute()：通过该方法执行需要事务管理的回调。


对于抛出Exception类型的异常且需要回滚时，需要捕获异常并通过调用status对象的setRollbackOnly()方法告知事务管理器当前事务需要回滚，如下所示：
try {
	//业务操作
} catch (Exception e) { //可使用具体业务异常代替
	status.setRollbackOnly();
}

大家有没有注意到Spring事务全部在Service层定义，为什么会在Service层定义，而不是Dao层定义呢？这是因为在服务层可能牵扯到业务逻辑，而每个业务逻辑可能调用多个Dao层方法，为保证这些操作的原子性，必须在Service层定义事务。


事务属性
事务属性通过TransactionDefinition接口实现定义，主要有事务隔离级别、事务传播行为、事务超时时间、事务是否只读。
Spring提供TransactionDefinition接口默认实现DefaultTransactionDefinition，可以通过该实现类指定这些事务属性。

事务隔离级别：用来解决并发事务时出现的问题，其使用TransactionDefinition中的静态变量来指定：
ISOLATION_DEFAULT：默认隔离级别，即使用底层数据库默认的隔离级别
ISOLATION_READ_UNCOMMITTED：未提交读；
ISOLATION_READ_COMMITTED：提交读，一般情况下我们使用这个；
ISOLATION_REPEATABLE_READ：可重复读；
ISOLATION_SERIALIZABLE：序列化。
可以使用DefaultTransactionDefinition类的setIsolationLevel(TransactionDefinition. ISOLATION_READ_COMMITTED)来指定隔离级别，其中此处表示隔离级别为提交读，也可以使用或setIsolationLevelName(“ISOLATION_READ_COMMITTED”)方式指定，其中参数就是隔离级别静态变量的名字，但不推荐这种方式。

事务传播行为：Spring管理的事务是逻辑事务，而且物理事务和逻辑事务最大差别就在于事务传播行为，事务传播行为用于指定在多个事务方法间调用时，事务是如何在这些方法间传播的，Spring共支持7种传播行为：

Required：必须有逻辑事务，否则新建一个事务，使用PROPAGATION_REQUIRED指定，表示如果当前存在一个逻辑事务，则加入该逻辑事务，否则将新建一个逻辑事务

RequiresNew：创建新的逻辑事务，使用PROPAGATION_REQUIRES_NEW指定，表示每次都创建新的逻辑事务（物理事务也是不同的）

Supports：支持当前事务，使用PROPAGATION_SUPPORTS指定，指如果当前存在逻辑事务，就加入到该逻辑事务，如果当前没有逻辑事务，就以非事务方式执行

NotSupported：不支持事务，如果当前存在事务则暂停该事务，使用PROPAGATION_NOT_SUPPORTED指定，即以非事务方式执行，如果当前存在逻辑事务，就把当前事务暂停，以非事务方式执行，

Mandatory：必须有事务，否则抛出异常，使用PROPAGATION_MANDATORY指定，使用当前事务执行，如果当前没有事务，则抛出异常（IllegalTransactionStateException）

Never：不支持事务，如果当前存在是事务则抛出异常，使用PROPAGATION_NEVER指定，即以非事务方式执行，如果当前存在事务，则抛出异常（IllegalTransactionStateException）

Nested：嵌套事务支持，使用PROPAGATION_NESTED指定，如果当前存在事务，则在嵌套事务内执行，如果当前不存在事务，则创建一个新的事务，嵌套事务使用数据库中的保存点来实现，即嵌套事务回滚不影响外部事务，但外部事务回滚将导致嵌套事务回滚

Nested和RequiresNew的区别：
1、  RequiresNew每次都创建新的独立的物理事务，而Nested只有一个物理事务；
2、  Nested嵌套事务回滚或提交不会导致外部事务回滚或提交，但外部事务回滚将导致嵌套事务回滚，而 RequiresNew由于都是全新的事务，所以之间是无关联的；
3、  Nested使用JDBC 3的保存点实现，即如果使用低版本驱动将导致不支持嵌套事务。

使用嵌套事务，必须确保具体事务管理器实现的nestedTransactionAllowed属性为true，否则不支持嵌套事务，如DataSourceTransactionManager默认支持，而HibernateTransactionManager默认不支持，需要我们来开启。


事务超时：设置事务的超时时间，单位为秒，默认为-1表示使用底层事务的超时时间；
使用如setTimeout(100)来设置超时时间，如果事务超时将抛出org.springframework.transaction.TransactionTimedOutException异常并将当前事务标记为应该回滚，即超时后事务被自动回滚；
可以使用具体事务管理器实现的defaultTimeout属性设置默认的事务超时时间，如DataSourceTransactionManager. setDefaultTimeout(10)。


事务只读：将事务标识为只读，只读事务不修改任何数据；
对于JDBC只是简单的将连接设置为只读模式，对于更新将抛出异常；
而对于一些其他ORM框架有一些优化作用，如在Hibernate中，Spring事务管理器将执行“session.setFlushMode(FlushMode.MANUAL)”即指定Hibernate会话在只读事务模式下不用尝试检测和同步持久对象的状态的更新。
如果使用设置具体事务管理的validateExistingTransaction属性为true（默认false），将确保整个事务传播链都是只读或都不是只读

对于错误的事务只读设置将抛出IllegalTransactionStateException异常，并伴随“Participating transaction with definition [……] is not marked as read-only……”信息，表示参与的事务只读属性设置错误。


配置方式实现事务管理
在Spring2.x之前为了解决编程式事务管理的各种不好问题，Spring提出使用配置方式实现事务管理，配置方式利用代理机制实现，即使有TransactionProxyFactoryBean类来为目标类代理事务管理。

<bean id="transactionProxyParent" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"  abstract="true">
    <property name="transactionManager" ref="txManager"/>
    <property name="transactionAttributes">
		<props>
            <prop key="save*">
                      PROPAGATION_REQUIRED,
                      ISOLATION_READ_COMMITTED,
                      timeout_10,
                      -Exception,
                      +NoRollBackException
           </prop>
           <prop key="*">
                      PROPAGATION_REQUIRED,
                      ISOLATION_READ_COMMITTED,
                      readOnly
           </prop>
        </props>
	</property>
</bean>


TransactionProxyFactoryBean：用于为目标业务类创建代理的Bean；
abstract="true"：表示该Bean是抽象的，用于去除重复配置；
transactionManager：事务管理器定义；
transactionAttributes：表示事务属性定义：
PROPAGATION_REQUIRED,ISOLATION_READ_COMMITTED,timeout_10,-Exception,+NoRollBackException：事务属性定义，Required传播行为，提交读隔离级别，事务超时时间为10秒，将对所有Exception异常回滚，而对于抛出NoRollBackException异常将不发生回滚而是提交；
PROPAGATION_REQUIRED,ISOLATION_READ_COMMITTED,readOnly：事务属性定义，Required传播行为，提交读隔离级别，事务是只读的，且只对默认的RuntimeException异常回滚；
<prop key="save*">：表示将代理以save开头的方法，即当执行到该方法时会为该方法根据事务属性配置来开启/关闭事务；
<prop key="*">：表示将代理其他所有方法，但需要注意代理方式，默认是JDK代理，只有public方法能代理；

事务属性的传播行为和隔离级别使用TransactionDefinition静态变量名指定；事务超时使用“timeout_超时时间”指定，事务只读使用“readOnly”指定，需要回滚的异常使用“-异常”指定，不需要回滚的异常使用“+异常”指定，默认只对RuntimeException异常回滚。

需要特别注意“-异常”和“+异常”中“异常”只是真实异常的部分名，内部使用如下方式判断：
//真实抛出的异常.name.indexOf(配置中指定的需要回滚/不回滚的异常名)
exceptionClass.getName().indexOf(this.exceptionName)
因此异常定义时需要特别注意，配置中定义的异常只是真实异常的部分名。

<bean id="proxyUserService" parent="transactionProxyParent">
	<property name="target" ref="targetUserService"/>
</bean>
<bean id="proxyAddressService" parent="transactionProxyParent">
	<property name="target" ref="targetAddressService"/>
</bean>
代理Bean通过集成抽象Bean“transactionProxyParent”，并通过target属性设置目标Bean，在实际使用中应该使用该代理Bean。

在代理模式下，默认只有通过代理对象调用的方法才能应用相应的事务属性，而在目标方法内的“自我调用”是不会应用相应的事务属性的，即被调用方法不会应用相应的事务属性，而是使用调用方法的事务属性。

在目标对象targetUserService的save方法内调用事务方法“this.otherTransactionMethod()”将不会应用配置的传播行为RequriesNew，开启新事务，而是使用save方法的已开启事务，如果非要这样使用如下方式实现：
1、  修改TransactionProxyFactoryBean配置定义，添加exposeProxy属性为true；
2、  在业务方法内通过代理对象调用相应的事务方放，如 “((IUserService)AopContext.currentProxy()).otherTransactionMethod()”即可应用配置的事务属性。
3、  使用这种方式属于侵入式，不推荐使用，除非必要。


声明式事务

<bean id="userService" class="cn.javass.spring.chapter9.service.impl.ConfigUserServiceImpl">
	<property name="userDao" ref="userDao"/>
	<property name="addressService" ref="addressService"/>
</bean>
<bean id="addressService" class="cn.javass.spring.chapter9.service.impl.ConfigAddressServiceImpl">
	<property name="addressDao" ref="addressDao"/>
</bean>

<tx:advice id="txAdvice" transaction-manager="txManager">
	<tx:attributes>
		<tx:method name="save*" propagation="REQUIRED" isolation="READ_COMMITTED"/>
		<tx:method name="*" propagation="REQUIRED" isolation="READ_COMMITTED" read-only="true"/>
	</tx:attributes>
</tx:advice>

<aop:config>
	<aop:pointcut id="serviceMethod" expression="execution(* cn..chapter9.service..*.*(..))"/>
	<aop:advisor pointcut-ref="serviceMethod" advice-ref="txAdvice"/>
</aop:config>


<tx:advice>：事务通知定义，用于指定事务属性，其中“transaction-manager”属性指定事务管理器，并通过< tx:attributes >指定具体需要拦截的方法；
<tx:method name="save*">：表示将拦截以save开头的方法，被拦截的方法将应用配置的事务属性：propagation="REQUIRED"表示传播行为是Required，isolation="READ_COMMITTED"表示隔离级别是提交读；
<tx:method name="*">：表示将拦截其他所有方法，被拦截的方法将应用配置的事务属性：propagation="REQUIRED"表示传播行为是Required，isolation="READ_COMMITTED"表示隔离级别是提交读，read-only="true"表示事务只读；

<aop:config>：AOP相关配置：
<aop:pointcut/>：切入点定义，定义名为"serviceMethod"的aspectj切入点，切入点表达式为"execution(* cn..chapter9.service..*.*(..))"表示拦截cn包及子包下的chapter9. service包及子包下的任何类的任何方法；
<aop:advisor>：Advisor定义，其中切入点为serviceMethod，通知为txAdvice。

声明式事务是如何实现事务管理的呢？还记不记得TransactionProxyFactoryBean实现配置式事务管理，配置式事务管理是通过代理方式实现，而声明式事务管理同样是通过AOP代理方式实现。

声明式事务通过AOP代理方式实现事务管理，利用环绕通知TransactionInterceptor实现事务的开启及关闭，而TransactionProxyFactoryBean内部也是通过该环绕通知实现的，因此可以认为是<tx:tags/>帮你定义了TransactionProxyFactoryBean，从而简化事务管理。


<tx:advice/>配置详解
<tx:advice id="……" transaction-manager="……">
<tx:attributes>
		<tx:method name="……"
						   propagation=" REQUIRED"
						   isolation="READ_COMMITTED"
						   timeout="-1"
						   read-only="false"
						   no-rollback-for=""
						   rollback-for=""/>
		……
	</tx:attributes>
</tx:advice>

<tx:advice>：id用于指定此通知的名字， transaction-manager用于指定事务管理器，默认的事务管理器名字为“transactionManager”；

<tx:method>：用于定义事务属性即相关联的方法名；
name：定义与事务属性相关联的方法名，将对匹配的方法应用定义的事务属性，可以使用“*”通配符来匹配一组或所有方法，如“save*”将匹配以save开头的方法，而“*”将匹配所有方法；
propagation：事务传播行为定义，默认为“REQUIRED”，表示Required，其值可以通过TransactionDefinition的静态传播行为变量的“PROPAGATION_”后边部分指定，如“TransactionDefinition.PROPAGATION_REQUIRED”可以使用“REQUIRED”指定；
isolation：事务隔离级别定义；默认为“DEFAULT”，其值可以通过TransactionDefinition的静态隔离级别变量的“ISOLATION_”后边部分指定，如“TransactionDefinition. ISOLATION_DEFAULT”可以使用“DEFAULT”指定：
timeout：事务超时时间设置，单位为秒，默认-1，表示事务超时将依赖于底层事务系统；
read-only：事务只读设置，默认为false，表示不是只读；
rollback-for：需要触发回滚的异常定义，以“，”分割，默认任何RuntimeException 将导致事务回滚，而任何Checked Exception 将不导致事务回滚；异常名字定义和TransactionProxyFactoryBean中含义一样
no-rollback-for：不被触发进行回滚的 Exception(s)；以“，”分割；异常名字定义和TransactionProxyFactoryBean中含义一样；

记不记得在配置方式中为了解决“自我调用”而导致的不能设置正确的事务属性问题，使用“((IUserService)AopContext.currentProxy()).otherTransactionMethod()”方式解决，在声明式事务要得到支持需要使用<aop:config expose-proxy="true">来开启。


多事务语义配置及最佳实践

什么是多事务语义？说白了就是为不同的Bean配置不同的事务属性，因为我们项目中不可能就几个Bean，而可能很多，这可能需要为Bean分组，为不同组的Bean配置不同的事务语义。在Spring中，可以通过配置多切入点和多事务通知并通过不同方式组合使用即可。


<tx:advice id="txAdvice" transaction-manager="txManager">
	<tx:attributes>
	   <tx:method name="save*" propagation="REQUIRED" />
	   <tx:method name="add*" propagation="REQUIRED" />
	   <tx:method name="create*" propagation="REQUIRED" />
	   <tx:method name="insert*" propagation="REQUIRED" />
	   <tx:method name="update*" propagation="REQUIRED" />
	   <tx:method name="merge*" propagation="REQUIRED" />
	   <tx:method name="del*" propagation="REQUIRED" />
	   <tx:method name="remove*" propagation="REQUIRED" />
	   <tx:method name="put*" propagation="REQUIRED" />
	   <tx:method name="get*" propagation="SUPPORTS" read-only="true" />
	   <tx:method name="count*" propagation="SUPPORTS" read-only="true" />
	  <tx:method name="find*" propagation="SUPPORTS" read-only="true" />
	  <tx:method name="list*" propagation="SUPPORTS" read-only="true" />
	  <tx:method name="*" propagation="SUPPORTS" read-only="true" />
	</tx:attributes>
</tx:advice>
<aop:config>
	<aop:pointcut id="txPointcut" expression="execution(* cn.javass..service.*.*(..))" />
	<aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut" />
</aop:config>


<tx:advice id="noTxAdvice" transaction-manager="txManager">
	<tx:attributes>
		   <tx:method name="*" propagation="NEVER" />
	</tx:attributes>
</tx:advice>
<aop:config>
   <aop:pointcut id="noTxPointcut" expression="execution(* cn.javass..util.*.*())" />
   <aop:advisor advice-ref="noTxPointcut" pointcut-ref="noTxAdvice" />
</aop:config>


@Transactional
Spring默认情况下会对运行期例外(RunTimeException)进行事务回滚。
1 让checked异常也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class)
2 让unchecked异常不回滚： @Transactional(notRollbackFor=RunTimeException.class)
3 不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED)
。。不管理自然就不会回滚？

属性	类型		描述
value 	String 	可选的限定描述符，指定使用的事务管理器
propagation 	enum: Propagation 	可选的事务传播行为设置
isolation 	enum: Isolation 	可选的事务隔离级别设置
readOnly 	boolean 	读写或只读事务，默认读写
timeout 	int (in seconds granularity) 	事务超时时间设置
rollbackFor 	Class对象数组，必须继承自Throwable 	导致事务回滚的异常类数组
rollbackForClassName 	类名数组，必须继承自Throwable 	导致事务回滚的异常类名字数组
noRollbackFor 	Class对象数组，必须继承自Throwable 	不会导致事务回滚的异常类数组
noRollbackForClassName 	类名数组，必须继承自Throwable 	不会导致事务回滚的异常类名字数组

虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。

默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。
。。这个真的假的，调本类的方法不会触发aop？

方法上注解属性会覆盖类注解上的相同属性


对声明式事务管理，Spring提供基于@Transactional注解方式来实现，但需要Java 5+。

public class AnnotationUserServiceImpl implements IUserService {
    private IUserDao userDao;
    private IAddressService addressService;
    public void setUserDao(IUserDao userDao) {
        this.userDao = userDao;
    }
    public void setAddressService(IAddressService addressService) {
        this.addressService = addressService;
    }
    @Transactional(propagation=Propagation.REQUIRED, isolation=Isolation.READ_COMMITTED)
    @Override
    public void save(final UserModel user) {
        userDao.save(user);
        user.getAddress().setUserId(user.getId());
        addressService.save(user.getAddress());
    }
    @Transactional(propagation=Propagation.REQUIRED, isolation=Isolation.READ_COMMITTED, readOnly=true)
    @Override
    public int countAll() {
        return userDao.countAll();
    }
}

<tx:annotation-driven transaction-manager="txManager"/>

Spring提供的<tx:annotation-driven/>用于开启对注解事务管理的支持，从而能识别Bean类上的@Transactional注解元数据，其具有以下属性：
transaction-manager：指定事务管理器名字，默认为transactionManager，当使用其他名字时需要明确指定；
proxy-target-class：表示将使用的代码机制，默认false表示使用JDK代理，如果为true将使用CGLIB代理
order：定义事务通知顺序，默认Ordered.LOWEST_PRECEDENCE，表示将顺序决定权交给AOP来处理。

Spring使用@Transaction来指定事务属性，可以在接口、类或方法上指定，如果类和方法上都指定了@Transaction，则方法上的事务属性被优先使用，具体属性如下：

value：指定事务管理器名字，默认使用<tx:annotation-driven/>指定的事务管理器，用于支持多事务管理器环境；
propagation：指定事务传播行为，默认为Required，使用Propagation.REQUIRED指定；
isolation：指定事务隔离级别，默认为“DEFAULT”，使用Isolation.DEFAULT指定；
readOnly：指定事务是否只读，默认false表示事务非只读；
timeout：指定事务超时时间，以秒为单位，默认-1表示事务超时将依赖于底层事务系统；
rollbackFor：指定一组异常类，遇到该类异常将回滚事务；
rollbackForClassname：指定一组异常类名字，其含义与<tx:method>中的rollback-for属性语义完全一样；
noRollbackFor：指定一组异常类，即使遇到该类异常也将提交事务，即不回滚事务；
noRollbackForClassname：指定一组异常类名字，其含义与<tx:method>中的no-rollback-for属性语义完全一样；

Spring提供的@Transaction注解事务管理内部同样利用环绕通知TransactionInterceptor实现事务的开启及关闭。

使用@Transactional注解事务管理需要特别注意以下几点：
如果在接口、实现类或方法上都指定了@Transactional 注解，则优先级顺序为方法>实现类>接口；
建议只在实现类或实现类的方法上使用@Transactional，而不要在接口上使用，这是因为如果使用JDK代理机制是没问题，因为其使用基于接口的代理；而使用使用CGLIB代理机制时就会遇到问题，因为其使用基于类的代理而不是接口，这是因为接口上的@Transactional注解是“不能继承的”；
在Spring代理机制下(不管是JDK动态代理还是CGLIB代理)，“自我调用”同样不会应用相应的事务属性，其语义和<tx:tags>中一样；
默认只对RuntimeException异常回滚；
在使用Spring代理时，默认只有在public可见度的方法的@Transactional 注解才是有效的，其它可见度（protected、private、包可见）的方法上即使有@Transactional 注解也不会应用这些事务属性的，Spring也不会报错，如果你非要使用非公共方法注解事务管理的话，可考虑使用AspectJ。

Spring声明式事务实现其实就是Spring AOP+线程绑定实现，利用AOP实现开启和关闭事务，利用线程绑定（ThreadLocal）实现跨越多个方法实现事务传播。
由于我们不可能只使用一个事务通知，可能还有其他类型事务通知，而且如果这些通知中需要事务支持怎么办？这就牵扯到通知执行顺序的问题上了，因此如果可能与其他AOP通知协作的话，而且这些通知中需要使用声明式事务管理支持，事务通知应该具有最高优先级。

编程式事务时不推荐的，即使有很少事务操作，Spring发展到现在，没有理由使用编程式事务，只有在为了深入理解Spring事务管理才需要学习编程式事务使用。
推荐使用声明式事务，而且强烈推荐使用<tx:tags>方式的声明式事务，因为其是无侵入代码的，可以配置模板化的事务属性并运用到多个项目中。
而@Transaction注解事务，可以使用，不过作者更倾向于使用<tx:tags>声明式事务。

所谓混合事务管理就是混合多种数据访问技术使用，如混合使用Spring JDBC + Hibernate，接下来让我们学习一下常见混合事务管理：
1、  Hibernate + Spring JDBC/iBATIS：使用HibernateTransactionManager即可支持；
2、  JPA + Spring JDBC/iBATIS：使用JpaTransactionManager即可支持；
3、  JDO + Spring JDBC/iBATIS：使用JtaTransactionManager即可支持；
混合事务管理最大问题在于如果我们使用第三方ORM框架，如Hibernate，会遇到一级及二级缓存问题，尤其是二级缓存可能造成如使用Spring JDBC和Hibernate查询出来的数据不一致等。
因此不建议使用这种混合使用和混合事务管理。




<bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
	<property name="dataSource" ref="dataSource"/> <!-- 指定数据源 -->
	  <property name="mappingResources">     <!-- 指定映射定义 -->
		<list>
		  <value>chapter8/hbm/user.hbm.xml</value>
		</list>
	  </property>
	  <property name="hibernateProperties">   <!--指定Hibernate属性 -->
		<props>
		  <prop key="hibernate.dialect">
			  org.hibernate.dialect.HSQLDialect
		  </prop>
		</props>
	  </property>
</bean>


@Test
public void testFirst() {
	Session session = sessionFactory.openSession();
	Transaction transaction = null;
	try {
		transaction = beginTransaction(session);
		UserModel model = new UserModel();
		model.setMyName("myName");
		session.save(model);
	} catch (RuntimeException e) {
		rollbackTransaction(transaction);
		throw e;
	} finally {
		commitTransaction(session);
	}
}

private Transaction beginTransaction(Session session) {
    Transaction transaction = session.beginTransaction();
    transaction.begin();
    return transaction;
}
private void rollbackTransaction(Transaction transaction) {
   if(transaction != null) {
        transaction.rollback();
    }
}
private void commitTransaction(Session session) {
    session.close();
}

使用SessionFactory获取Session进行操作，必须自己控制事务，而且还要保证各个步骤不会出错，有没有更好的解决方案把我们从编程事务中解脱出来？Spring提供了HibernateTemplate模板类用来简化事务处理和常见操作。

HibernateTimplate模板类用于简化事务管理及常见操作，类似于JdbcTemplate模板类，对于复杂操作通过提供HibernateCallback回调接口来允许更复杂的操作。

@Test
public void testHibernateTemplate() {
	HibernateTemplate hibernateTemplate =
new HibernateTemplate(sessionFactory);
    final UserModel model = new UserModel();
    model.setMyName("myName");
    hibernateTemplate.save(model);
    //通过回调允许更复杂操作
    hibernateTemplate.execute(new HibernateCallback<Void>() {
        @Override
        public Void doInHibernate(Session session)
            throws HibernateException, SQLException {
            session.save(model);
            return null;
        }});
}


@Entity
@Table(name = "test")
public class UserModel2 {
    @Id @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    @Column(name = "name")
    private String myName;
    //省略getter和setter
}


<bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
	<property name="dataSource" ref="dataSource"/>  <!-- 1、指定数据源 -->
	<property name="annotatedClasses">           <!-- 2、指定注解类 -->
		<list><value>cn.javass.spring.chapter8.UserModel2</value></list>
	</property>
	<property name="hibernateProperties"><!-- 3、指定Hibernate属性 -->
		<props>
			<prop key="hibernate.dialect">
				org.hibernate.dialect.HSQLDialect
			</prop>
		</props>
	</property>
</bean>

<bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate">
	<property name="sessionFactory" ref="sessionFactory"/>
</bean>


Spring 2.5.5+版本支持iBATIS 2.3+版本，不支持低版本。
8.3.1  如何集成
Spring通过使用如下Bean进行集成iBATIS：
SqlMapClientFactoryBean：用于集成iBATIS。
configLocation和configLocations：用于指定SQL Map XML配置文件，用于指定如数据源等配置信息；
mappingLocations：用于指定SQL Map映射文件，即半自动概念中的SQL语句定义；
sqlMapClientProperties：定义iBATIS 配置文件配置信息；
dataSource：定义数据源。

。。后面有mybatis

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN"
    "http://ibatis.apache.org/dtd/sql-map-2.dtd">
<sqlMap namespace="UserSQL">
  <statement id="createTable">
    <!--id自增主键从0开始 -->
    <![CDATA[
        create memory table test(
          id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name varchar(100))
    ]]>
  </statement>
  <statement id="dropTable">
    <![CDATA[  drop table test  ]]>
  </statement>
  <insert id="insert" parameterClass="cn.javass.spring.chapter7.UserModel">
    <![CDATA[
      insert into test(name) values (#myName#)
    ]]>
    <selectKey resultClass="int" keyProperty="id" type="post">
      <!-- 获取hsqldb插入的主键 -->
      call identity();
      <!-- mysql使用select last_insert_id();获取插入的主键 -->
    </selectKey>
  </insert>
</sqlMap>


<sqlMapConfig>
    <settings enhancementEnabled="true" useStatementNamespaces="true"
        maxTransactions="20" maxRequests="32" maxSessions="10"/>
    <sqlMap resource="chapter8/sqlmaps/UserSQL.xml"/>
</sqlMapConfig>

<bean id="sqlMapClient"   class="org.springframework.orm.ibatis.SqlMapClientFactoryBean">
	<!-- 1、指定数据源 -->
	<property name="dataSource" ref="dataSource"/>
	<!-- 2、指定配置文件 -->
	<property name="configLocation" value="chapter8/sql-map-config.xml"/>
</bean>


SqlMapClientTemplate模板类同样用于简化事务管理及常见操作，类似于JdbcTemplate模板类，对于复杂操作通过提供SqlMapClientCallback回调接口来允许更复杂的操作。

public void testSqlMapClientTemplate() {
	SqlMapClientTemplate sqlMapClientTemplate =
new SqlMapClientTemplate(sqlMapClient);
    final UserModel model = new UserModel();
    model.setMyName("myName");
    sqlMapClientTemplate.insert("UserSQL.insert", model);
    //通过回调允许更复杂操作
    sqlMapClientTemplate.execute(new SqlMapClientCallback<Void>() {
        @Override
        public Void doInSqlMapClient(SqlMapExecutor session) throws SQLException {
            session.insert("UserSQL.insert", model);
            return null;
    }});
}


public class UserIbatisDaoImpl extends SqlMapClientDaoSupport
    implements IUserDao {
    @Override
    public void save(UserModel model) {
        getSqlMapClientTemplate().insert("UserSQL.insert", model);
    }
    @Override
    public int countAll() {
        return (Integer) getSqlMapClientTemplate().queryForObject("UserSQL.countAll");
    }
}
<select id="countAll" resultClass="java.lang.Integer">
	<![CDATA[ select count(*) from test ]]>
</select>

<bean id="abstractDao" abstract="true">
	<property name="sqlMapClient" ref="sqlMapClient"/>
</bean>
<bean id="userDao"   class="cn.javass.spring.chapter8.dao.ibatis.UserIbatisDaoImpl"  parent="abstractDao"/>



<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
     "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="UserSQL">
    <sql id="createTable">
    <!--id自增主键从0开始 -->
    <![CDATA[
      create memory table test(
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar(100))
    ]]>
    </sql>
    <sql id="dropTable">
    <![CDATA[ drop table test ]]>
    </sql>
    <insert id="insert" parameterType="cn.javass.spring.chapter7.UserModel">
    <![CDATA[ insert into test(name) values (#{myName}) ]]>
        <selectKey resultType="int" keyProperty="id" order="AFTER">
            <!-- 获取hsqldb插入的主键 -->
            call identity();
            <!-- mysql使用select last_insert_id();获取插入的主键 -->
        </selectKey>
    </insert>
    <select id="countAll" resultType="java.lang.Integer">
    <![CDATA[ select count(*) from test ]]>
    </select>
</mapper>

从映射定义中可以看出MyBatis与iBATIS2.3.4有如下不同：
http://ibatis.apache.org/dtd/sql-map-2.dtd 废弃，而使用http://mybatis.org/dtd/mybatis-3-mapper.dtd。
<sqlMap>废弃，而使用<mapper>标签；
<statement>废弃了，而使用<sql>标签；
parameterClass属性废弃，而使用parameterType属性；
resultClass属性废弃，而使用resultType属性；
#myName#方式指定命名参数废弃，而使用#{myName}方式。

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<settings>
		<setting name="cacheEnabled" value="false"/>
	</settings>
	<mappers>
		<mapper resource="chapter8/sqlmaps/UserSQL-mybatis.xml"/>
	</mappers>
</configuration>

从配置定义中可以看出MyBatis与iBATIS2.3.4有如下不同：
http://ibatis.apache.org/dtd/sql-map-config-2.dtd废弃，而使用http://mybatis.org/dtd/mybatis-3-config.dtd；
< sqlMapConfig >废弃，而使用<configuration>；
settings属性配置方式废弃，而改用子标签< setting name=".." value=".."/>方式指定属性，且一些属性被废弃，如maxTransactions；
< sqlMap>废弃，而采用<mappers>标签及其子标签<mapper>定义。


使用SqlSessionDaoSupport来支持一致性的DAO访问，该类位于org.mybatis.spring.support包中，非Spring提供；
使用getSqlSession方法获取SqlSessionTemplate，在较早版本中是getSqlSessionTemplate方法名，不知为什么改成getSqlSession方法名，因此这个地方在使用时需要注意。
SqlSessionTemplate是SqlSession接口的实现，并且自动享受Spring管理事务好处，因此从此处可以推断出为什么把获取模板类的方法名改为getSqlSession而不是getSqlSessionTemplate。

SqlMapClient类废弃，而使用SqlSessionFactory代替；
使用SqlSessionFactoryBean进行集成MyBatis。

JPA全称为Java持久性API（Java Persistence API），JPA是Java EE 5标准之一，是一个ORM规范，由厂商来实现该规范，目前有Hibernate、OpenJPA、TopLink、EclipseJPA等实现

Spring目前提供集成Hibernate、OpenJPA、TopLink、EclipseJPA四个JPA标准实现。

Spring通过使用如下Bean进行集成JPA（EntityManagerFactory）：

LocalEntityManagerFactoryBean：适用于那些仅使用JPA进行数据访问的项目，该FactoryBean将根据JPA PersistenceProvider自动检测配置文件进行工作，一般从“META-INF/persistence.xml”读取配置信息，这种方式最简单，但不能设置Spring中定义的DataSource，且不支持Spring管理的全局事务，而且JPA 实现商可能在JVM启动时依赖于VM agent从而允许它们进行持久化类字节码转换（不同的实现厂商要求不同，需要时阅读其文档），不建议使用这种方式；
persistenceUnitName：指定持久化单元的名称；
<bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
	<property name="persistenceUnitName" value="persistenceUnit"/>
</bean>

从JNDI中获取：用于从Java EE服务器获取指定的EntityManagerFactory，这种方式在进行Spring事务管理时一般要使用JTA事务管理；
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:jee="http://www.springframework.org/schema/jee"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/jee
		http://www.springframework.org/schema/jee/spring-jee-3.0.xsd">
	<jee:jndi-lookup id="entityManagerFactory"  jndi-name="persistence/persistenceUnit"/>
</beans>
此处需要使用“jee”命名标签，且使用<jee:jndi-lookup>标签进行JNDI查找，“jndi-name”属性用于指定JNDI名字。

LocalContainerEntityManagerFactoryBean：适用于所有环境的FactoryBean，能全面控制EntityManagerFactory配置,如指定Spring定义的DataSource等等。
persistenceUnitManager：用于获取JPA持久化单元，默认实现DefaultPersistenceUnitManager用于解决多配置文件情况
dataSource：用于指定Spring定义的数据源；
persistenceXmlLocation：用于指定JPA配置文件，对于对配置文件情况请选择设置persistenceUnitManager属性来解决；
persistenceUnitName：用于指定持久化单元名字；
persistenceProvider：用于指定持久化实现厂商类；如Hibernate为org.hibernate.ejb.HibernatePersistence类；
jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；目前Spring提供HibernateJpaVendorAdapter、OpenJpaVendorAdapter、EclipseLinkJpaVendorAdapter、TopLinkJpaVendorAdapter、OpenJpaVendorAdapter四个实现。其中最重要的属性是“database”，用来指定使用的数据库类型，从而能根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE）。
jpaDialect：用于指定一些高级特性，如事务管理，获取具有事务功能的连接对象等，目前Spring提供HibernateJpaDialect、OpenJpaDialect 、EclipseLinkJpaDialect、TopLinkJpaDialect、和DefaultJpaDialect实现，注意DefaultJpaDialect不提供任何功能，因此在使用特定实现厂商JPA实现时需要指定JpaDialect实现，如使用Hibernate就使用HibernateJpaDialect。当指定jpaVendorAdapter属性时可以不指定jpaDialect，会自动设置相应的JpaDialect实现；
jpaProperties和jpaPropertyMap：指定JPA属性；如Hibernate中指定是否显示SQL的“hibernate.show_sql”属性，对于jpaProperties设置的属性自动会放进jpaPropertyMap中；
loadTimeWeaver：用于指定LoadTimeWeaver实现，从而允许JPA 加载时修改相应的类文件。具体使用得参考相应的JPA规范实现厂商文档，如Hibernate就不需要指定loadTimeWeaver。


<?xml version="1.0" encoding="UTF-8"?>
<persistence version="1.0"
    xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence                      http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd">
    <persistence-unit name="persistenceUnit" transaction-type="RESOURCE_LOCAL"/>
</persistence>


<bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
	<property name="dataSource" ref="dataSource"/>
	<property name="persistenceXmlLocation" value="chapter8/persistence.xml"/>
	<property name="persistenceUnitName" value="persistenceUnit"/>
	<property name="persistenceProvider" ref="persistenceProvider"/>
	<property name="jpaVendorAdapter" ref="jpaVendorAdapter"/>
	<property name="jpaDialect" ref="jpaDialect"/>
	<property name="jpaProperties">
		<props>
		<prop key="hibernate.show_sql">true</prop>
		</props>
	</property>
</bean>
<bean id="persistenceProvider" class="org.hibernate.ejb.HibernatePersistence"/>


<bean id="jpaVendorAdapter" class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter">
	<property name="generateDdl" value="false" />
	<property name="database" value="HSQL"/>
</bean>
<bean id="jpaDialect" class="org.springframework.orm.jpa.vendor.HibernateJpaDialect"/>

LocalContainerEntityManagerFactoryBean:指定使用本地容器管理EntityManagerFactory，从而进行细粒度控制；
dataSource属性指定使用Spring定义的数据源；
persistenceXmlLocation指定JPA配置文件为chapter8/persistence.xml，且该配置文件非常简单，具体配置完全在Spring中进行；
persistenceUnitName指定持久化单元名字，即JPA配置文件中指定的;
persistenceProvider:指定JPA持久化提供商，此处使用Hibernate实现HibernatePersistence类；
jpaVendorAdapter：指定实现厂商专用特性，即generateDdl= false表示不自动生成DDL，database= HSQL表示使用hsqldb数据库；
jpaDialect：如果指定jpaVendorAdapter此属性可选，此处为HibernateJpaDialect；
jpaProperties：此处指定“hibernate.show_sql =true”表示在日志系统debug级别下将打印所有生成的SQL。


JpaTemplate模板类用于简化事务管理及常见操作，类似于JdbcTemplate模板类，对于复杂操作通过提供JpaCallback回调接口来允许更复杂的操作。
<bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager">
    <property name="entityManagerFactory" ref="entityManagerFactory"/>
</bean>


@Test
public void testJpaTemplate() {
	final JpaTemplate jpaTemplate = new JpaTemplate(entityManagerFactory);
	final UserModel2 model = new UserModel2();
	model.setMyName("test1");
	PlatformTransactionManager txManager = ctx.getBean(PlatformTransactionManager.class);
	new TransactionTemplate(txManager).execute(
		new TransactionCallback<Void>() {
			@Override
			public Void doInTransaction(TransactionStatus status) {
			jpaTemplate.persist(model);
			return null;
			}
		});
	String COUNT_ALL = "select count(*) from UserModel";
	Number count = (Number) jpaTemplate.find(COUNT_ALL).get(0);
	Assert.assertEquals(1, count.intValue());
}



jpaTemplate：可通过new JpaTemplate(entityManagerFactory)方式创建；
txManager：通过ctx.getBean(PlatformTransactionManager.class)获取事务管理器；
TransactionTemplate：通过new TransactionTemplate(txManager)创建事务模板对象，并通过execute方法执行TransactionCallback回调中的doInTransaction方法中定义需要执行的操作，从而将由模板类通过txManager事务管理器来进行事务管理，此处是调用jpaTemplate对象的persist方法进行持久化；
jpaTemplate.persist()：根据JPA规范，在JPA扩展的持久化上下文，该操作必须运行在事务环境，还有persist()、 merge()、remove()操作也必须运行在事务环境；
jpaTemplate.find()：根据JPA规范，该操作无需运行在事务环境，还有find()、getReference()、 refresh()、detach()和查询操作都无需运行在事务环境。


<tx:annotation-driven transaction-manager="txManager"/>
只为类添加@Transactional 注解是不能支持事务的，需要通过<tx:annotation-driven>标签来开启事务支持，其中txManager属性指定事务管理器。



Spring IoC容器注入依赖资源主要有以下两种基本实现方式：
构造器注入：就是容器实例化Bean时注入那些依赖，通过在在Bean定义中指定构造器参数进行注入依赖，包括实例工厂方法参数注入依赖，但静态工厂方法参数不允许注入依赖；
setter注入：通过setter方法进行注入依赖；
方法注入：能通过配置方式替换掉Bean方法，也就是通过配置改变Bean方法 功能。

根据参数索引注入，使用标签“<constructor-arg index="1" value="1"/>”来指定注入的依赖，其中“index”表示索引，从0开始，即第一个参数索引为0，“value”来指定注入的常量值

根据参数类型进行注入，使用标签“<constructor-arg type="java.lang.String" value="Hello World!"/>”来指定注入的依赖，其中“type”表示需要匹配的参数类型，可以是基本类型也可以是其他类型，如“int”、“java.lang.String”，“value”来指定注入的常量值

根据参数名进行注入，使用标签“<constructor-arg name="message" value="Hello World!"/>”来指定注入的依赖，其中“name”表示需要匹配的参数名字，“value”来指定注入的常量值

<!-- 通过构造器参数索引方式依赖注入 -->
<bean id="byIndex" class="cn.javass.spring.chapter3.HelloImpl3">
	<constructor-arg index="0" value="Hello World!"/>
	<constructor-arg index="1" value="1"/>
</bean>
<!-- 通过构造器参数类型方式依赖注入 -->
<bean id="byType" class="cn.javass.spring.chapter3.HelloImpl3">
	<constructor-arg type="java.lang.String" value="Hello World!"/>
	<constructor-arg type="int" value="2"/>
</bean>
<!-- 通过构造器参数名称方式依赖注入 -->
<bean id="byName" class="cn.javass.spring.chapter3.HelloImpl3">
	<constructor-arg name="message" value="Hello World!"/>
	<constructor-arg name="index" value="3"/>
</bean>



//静态工厂类
package cn.javass.spring.chapter3;
import cn.javass.spring.chapter2.helloworld.HelloApi;
public class DependencyInjectByStaticFactory {
	   public static HelloApi newInstance(String message, int index) {
			  return new HelloImpl3(message, index);
	   }
}
<bean id="byIndex" class="cn.javass.spring.chapter3.DependencyInjectByStaticFactory" factory-method="newInstance">
	<constructor-arg index="0" value="Hello World!"/>
	<constructor-arg index="1" value="1"/>
</bean>
<bean id="byType" class="cn.javass.spring.chapter3.DependencyInjectByStaticFactory" factory-method="newInstance">
	<constructor-arg type="java.lang.String" value="Hello World!"/>
	<constructor-arg type="int" value="2"/>
</bean>
<bean id="byName" class="cn.javass.spring.chapter3.DependencyInjectByStaticFactory" factory-method="newInstance">
	<constructor-arg name="message" value="Hello World!"/>
	<constructor-arg name="index" value="3"/>
</bean>


//实例工厂类
package cn.javass.spring.chapter3;
import cn.javass.spring.chapter2.helloworld.HelloApi;
public class DependencyInjectByInstanceFactory {
	public HelloApi newInstance(String message, int index) {
		return new HelloImpl3(message, index);
	}
}
<bean id="instanceFactory"
class="cn.javass.spring.chapter3.DependencyInjectByInstanceFactory"/>

<bean id="byIndex"  factory-bean="instanceFactory"  factory-method="newInstance">
	<constructor-arg index="0" value="Hello World!"/>
	<constructor-arg index="1" value="1"/>
</bean>
<bean id="byType"  factory-bean="instanceFactory" factory-method="newInstance">
	<constructor-arg type="java.lang.String" value="Hello World!"/>
	<constructor-arg type="int" value="2"/>
</bean>
<bean id="byName"  factory-bean="instanceFactory" factory-method="newInstance">
	<constructor-arg name="message" value="Hello World!"/>
	<constructor-arg name="index" value="3"/>
</bean>

还有一点需要大家注意就是静态工厂方式和实例工厂方式根据参数名字注入的方式只支持通过在class文件中添加“变量调试信息”方式才能运行，ConstructorProperties注解方式不能工作，它只对构造器方式起作用，不建议使用根据参数名进行构造器注入。
这个是windows-preference-java-compile-Classfile Generation-第一个Add variable attributes to generated class files

setter注入，是通过在通过构造器、静态工厂或实例工厂实例好Bean后，通过调用Bean类的setter方法进行注入依赖

setter注入方式只有一种根据setter名字进行注入：

<!-- 通过setter方式进行依赖注入 -->
<bean id="bean" class="cn.javass.spring.chapter3.HelloImpl4">
	<property name="message" value="Hello World!"/>
	<property name="index">
		<value>1</value>
	</property>
</bean>


JavaBean：是本质就是一个POJO类，但具有一下限制：
该类必须要有公共的无参构造器，如public HelloImpl4() {}；
属性为private访问级别，不建议public，如private String message;
属性必要时通过一组setter（修改器）和getter（访问器）方法来访问；
setter方法，以“set” 开头，后跟首字母大写的属性名，如“setMesssage”,简单属性一般只有一个方法参数，方法返回值通常为“void”;
getter方法，一般属性以“get”开头，对于boolean类型一般以“is”开头，后跟首字母大写的属性名，如“getMesssage”，“isOk”；
还有一些其他特殊情况，比如属性有连续两个大写字母开头，如“URL”,则setter/getter方法为：“setURL”和“getURL”，其他一些特殊情况请参看“Java Bean”命名规范。


注入常量
<property name="message" value="Hello World!"/>
或
<property name="index"><value>1</value></property>
以上两种方式都可以，从配置来看第一种更简洁。注意此处“value”中指定的全是字符串，由Spring容器将此字符串转换成属性所需要的类型，如果转换出错，将抛出相应的异常。

Spring容器目前能对各种基本类型把配置的String参数转换为需要的类型。
注：Spring类型转换系统对于boolean类型进行了容错处理，除了可以使用“true/false”标准的Java值进行注入，还能使用“yes/no”、“on/off”、“1/0”来代表“真/假”，所以大家在学习或工作中遇到这种类似问题不要觉得是人家配置错了，而是Spring容错做的非常好。


用于注入Bean的ID，ID是一个常量不是引用，且类似于注入常量，但提供错误验证功能，配置方式如下所示：
<property name="id"><idref bean="bean1"/></property>
<property name="id"><idref local="bean2"/></property>

第二种方式（<idref bean="bean1"/>）可以在容器初始化时校验被引用的Bean是否存在，如果不存在将抛出异常，而第一种方式（<idref local="bean2"/>）只有在Bean实际使用时才能发现传入的Bean的ID是否正确，可能发生不可预料的错误。因此如果想注入Bean的ID，推荐使用第二种方式。

Spring不仅能注入简单类型数据，还能注入集合（Collection、无序集合Set、有序集合List）类型、数组(Array)类型、字典(Map)类型数据、Properties类型数据，接下来就让我们一个个看看如何注入这些数据类型的数据。

List类型：需要使用<list>标签来配置注入，其具体配置如下：
1.可选的value-type属性，表示列表中数据的类型。value-type="java.lang.String"
2.也可以采用泛型，spring能根据泛型数据自动检测出List里数据的数据类型，比如java.util.List<String>，spring能自动识别需要的是string
3.如果既没有value-type，list也不是泛型，则默认String类型。

<list value-type="java.lang.String" merge="default"><value...
merge可选，用于父子bean时，是否合并list条目

<bean id="listBean" class="cn.javass.spring.chapter3.bean.ListTestBean">
	<property name="values">
		<list>
			<value>1</value>
			<value>2</value>
			<value>3</value>
		</list>
   </property>
</bean>

Set类型：需要使用<set>标签来配置注入，其配置参数及含义和<lsit>标签完全一样，在此就不阐述了

Collection类型：因为Collection类型是Set和List类型的基类型，所以使用<set>或<list>标签都可以进行注入，配置方式完全和以上配置方式一样，只是将测试类属性改成“Collection”类型

注入数组类型：需要使用<array>标签来配置注入，其中标签属性“value-type”和“merge”和<list>标签含义完全一样

注入字典（Map）类型：字典类型是包含键值对数据的数据结构，需要使用<map>标签来配置注入，其属性“key-type”和“value-type”分别指定“键”和“值”的数据类型，其含义和<list>标签的“value-type”含义一样，在此就不罗嗦了，并使用<key>子标签来指定键数据，<value>子标签来指定键对应的值数据


<property name="desc2LevelValue">
	<map>
		<entry value="2" key="优秀级"/>
		<entry value="3" key="良好级"/>
		<entry value="4" key="普通级"/>
		<entry value="5" key="关注级"/>
		<entry value="6" key="管控级"/>
	</map>
</property>

<property name="quantitativeSubitemCalculators">
	<set>
		<ref bean="DmtmTsrGradeQuantitativeDeadRateIn2Years"/>
		<ref bean="DmtmTsrGradeQuantitativePersistencyRateOf13M"/>
		<ref bean="DmtmTsrGradeQuantitativePersistencyRateOf3M"/>
		<ref bean="DmtmTsrGradeQuantitativePolicyWithdrawalRate"/>
		<ref bean="DmtmTsrGradeQuantitativeRefusePayRate"/>
		<ref bean="DmtmTsrGradeQuantitativeSuccessRateOfVisitInFreeLook"/>
	</set>
</property>

Properties注入：Spring能注入java.util.Properties类型数据，需要使用<props>标签来配置注入，键和值类型必须是String，不能变，子标签<prop key=”键”>值</prop>来指定键值对


引用其他bean

构造器注入方式
通过” <constructor-arg>”标签的ref属性来引用其他Bean
<constructor-arg index="0" ref="bean" />

通过” <constructor-arg>”标签的子<ref>标签来引用其他Bean，使用bean属性来指定引用的Bean
<constractor-arg index="0"><ref bean="bean" /></constructor-arg>

setter注入方式
通过” <property>”标签的ref属性来引用其他Bean
通过” <property>”标签的子<ref>标签来引用其他Bean，使用bean属性来指定引用的Bean


其他引用方式：除了最基本配置方式以外，Spring还提供了另外两种更高级的配置方式，<ref local=””/>和<ref parent=””/>

<ref local=””/>配置方式：用于引用通过<bean id=”beanName”>方式中通过id属性指定的Bean，它能利用XML解析器的验证功能在读取配置文件时来验证引用的Bean是否存在。因此如果在当前配置文件中有相互引用的Bean可以采用<ref local>方式从而如果配置错误能在开发调试时就发现错误。
。。看实例，要求所有的bean在同一个xml里？

<ref parent=””/>配置方式：用于引用父容器中的Bean，不会引用当前容器中的Bean，当然父容器中的Bean和当前容器的Bean是可以重名的，获取顺序是直接到父容器找
。。配置文件怎么有父容器，当前容器的区别。。

//初始化父容器
ApplicationContext parentBeanContext =  new ClassPathXmlApplicationContext("chapter3/parentBeanInject.xml");
//初始化当前容器
ApplicationContext beanContext = new ClassPathXmlApplicationContext(
new String[] {"chapter3/localBeanInject.xml"}, parentBeanContext);

。。。把父容器作为一个参数，来生成子容器。。擦。。。

内部bean
在<property>或<constructor-arg>内通过<bean>标签定义的Bean，该Bean不管是否指定id或name，该Bean都会有唯一的匿名标识符，而且不能指定别名，该内部Bean对其他外部Bean不可见

Spring通过<value>标签或value属性注入常量值，所有注入的数据都是字符串，那如何注入null值呢？通过“null”值吗？当然不是因为如果注入“null”则认为是字符串。Spring通过<null/>标签注入null值


对象图导航注入支持
所谓对象图导航是指类似a.b.c这种点缀访问形式的访问或修改值。Spring支持对象图导航方式依赖注入。对象图导航依赖注入有一个限制就是比如a.b.c对象导航图注入中a和b必须为非null值才能注入c，否则将抛出空指针异常。
Spring不仅支持对象的导航，还支持数组、列表、字典、Properties数据类型的导航，对Set数据类型无法支持，因为无法导航。
数组和列表数据类型可以用array[0]、list[1]导航，注意”[]”里的必须是数字，因为是按照索引进行导航，对于数组类型注意不要数组越界错误。
字典Map数据类型可以使用map[1]、map[str]进行导航，其中“[]”里的是基本类型，无法放置引用类型。

NavigationC类用于打印测试代码，从而观察配置是否正确
public class NavigationC {
    public void sayNavigation() {
        System.out.println("===navigation c");
    }
}

NavigationB类，包含对象和列表、Properties、数组字典数据类型导航，而且这些复合数据类型保存的条目都是对象，正好练习一下如何往复合数据类型中注入对象依赖。
public class NavigationB {
	private NavigationC navigationC;
	private List<NavigationC> list;
	private Properties properties;
	private NavigationC[] array = new NavigationC[1];
	private Map<String, NavigationC> map;
   //由于setter和getter方法占用太多空间，故省略，大家自己实现吧
}

NavigationA类是我们的前端类，通过对它的导航进行注入值
public class NavigationA {
    private NavigationB navigationB;
    public void setNavigationB(NavigationB navigationB) {
        this.navigationB = navigationB;
    }
    public NavigationB getNavigationB() {
        return navigationB;
    }
}

接下来该进行Bean定义配置（resources/chapter3/navigationBeanInject.xml）了，首先让我们配置一下需要被导航的数据，NavigationC和NavigationB类，其中配置NavigationB时注意要确保比如array字段不为空值，这就需要或者在代码中赋值如“NavigationC[] array = new NavigationC[1];”，或者通过配置文件注入如“<list></list>”注入一个不包含条目的列表。

<bean id="c" class="cn.javass.spring.chapter3.bean.NavigationC"/>
<bean id="b" class="cn.javass.spring.chapter3.bean.NavigationB">
	<property name="list"><list></list></property>
	<property name="map"><map></map></property>
	<property name="properties"><props></props></property>
</bean>

配置完需要被导航的Bean定义了，该来配置NavigationA导航Bean了，在此需要注意，由于“navigationB”属性为空值，在此需要首先注入“navigationB”值；还有对于数组导航不能越界否则报错；

<bean id="a" class="cn.javass.spring.chapter3.bean.NavigationA">
<!-- 首先注入navigatiionB 确保它非空 -->
<property name="navigationB" ref="b"/>
<!-- 对象图导航注入 -->
<property name="navigationB.navigationC" ref="c"/>
<!-- 注入列表数据类型数据 -->
<property name="navigationB.list[0]" ref="c"/>
<!-- 注入map类型数据 -->
<property name="navigationB.map[key]" ref="c"/>
<!-- 注入properties类型数据 -->
<property name="navigationB.properties[0]" ref="c"/>
<!-- 注入properties类型数据 -->
<property name="navigationB.properties[1]" ref="c"/>
<!-- 注入数组类型数据 ，注意不要越界-->
<property name="navigationB.array[0]" ref="c"/>
</bean>

//对象图导航
@Test
public void testNavigationBeanInject() {
ApplicationContext context =
new ClassPathXmlApplicationContext("chapter3/navigationBeanInject.xml");
NavigationA navigationA = context.getBean("a", NavigationA.class);
navigationA.getNavigationB().getNavigationC().sayNavigation();
navigationA.getNavigationB().getList().get(0).sayNavigation();
navigationA.getNavigationB().getMap().get("key").sayNavigation();
navigationA.getNavigationB().getArray()[0].sayNavigation();
((NavigationC)navigationA.getNavigationB().getProperties().get("1"))
.sayNavigation();
}

测试完毕，应该输出5个“===navigation c”，是不是很简单，注意这种方式是不推荐使用的，了解一下就够了，最好使用3.1.5一节使用的配置方式。


配置简写
让我们来总结一下依赖注入配置及简写形式，其实我们已经在以上部分穿插着进行简化配置了

一、构造器注入：
1）常量值
简写：<constructor-arg index="0" value="常量"/>
全写：<constructor-arg index="0"><value>常量</value></constructor-arg>

2）引用
简写：<constructor-arg index="0" ref="引用"/>
全写：<constructor-arg index="0"><ref bean="引用"/></constructor-arg>

二、setter注入：
1）常量值
简写：<property name="message" value="常量"/>
全写：<property name="message"><value>常量</value></ property>
2）引用
简写：<property name="message" ref="引用"/>
全写：<property name="message"><ref bean="引用"/></ property>
3）数组：<array>没有简写形式
4）列表：<list>没有简写形式
5）集合：<set>没有简写形式
6）字典
简写：
<map>
	<entry key="键常量" value="值常量"/>
	<entry key-ref="键引用" value-ref="值引用"/>
</map>
全写：
<map>
	<entry><key><value>键常量</value></key><value>值常量</value></entry>
	<entry><key><ref bean="键引用"/></key><ref bean="值引用"/></entry>
</map>
7）Properties：没有简写形式

三、使用p命名空间简化setter注入：
使用p命名空间来简化setter注入，具体使用如下：

<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="
		   http://www.springframework.org/schema/beans
		   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
	<bean id="bean1" class="java.lang.String">
		<constructor-arg index="0" value="test"/>
	</bean>
	<bean id="idrefBean1" class="cn.javass.spring.chapter3.bean.IdRefTestBean"  p:id="value"/>
	<bean id="idrefBean2" class="cn.javass.spring.chapter3.bean.IdRefTestBean"  p:id-ref="bean1"/>
</beans>


xmlns:p="http://www.springframework.org/schema/p" ：首先指定p命名空间；
<bean id="……" class="……" p:id="value"/> ：常量setter注入方式，其等价于<property name="id" value="value"/>；
<bean id="……" class="……" p:id-ref="bean1"/> ：引用setter注入方式，其等价于<property name="id" ref="bean1"/>。
。。应该是p:id="value",p:id-ref="bean1"等价于后面的。。。




<ref bean="someBean"/>
这里"someBean"  可以是指定bean的id值也可以是name值。
<ref local="someBean"/>
这里所引用的bean必须在同一个XML文件中,而且必须是目标bean的id属性值。


idref注入的只是目标bean的id，而不是目标bean的实例，同时使用idref容器在部署的时候还会验证这个名称是否存在，就相当于是一个验证功能。

同样在<constructor-arg/>或者<property/>元素内部也可以使用ref元素。用来将bean中指定属性的值设置为对容器中的另外一个bean的引用。ref元素有三个属性，区别如下：
1、local 只能指定与当前配置的Bean在同一个配置文件中的Bean定义的名称；
2、parent 只能指定位于当前容器的父容器中定义的对象引用；
3、bean 基本上都行，即以上两种情况都可以，所以，在这个情况下，直接使用bean来指定对象引用就可以了。





Spring中Bean的命名
1、每个Bean可以有一个id属性，并可以根据该id在IoC容器中查找该Bean，该id属性值必须在IoC容器中唯一；
2、可以不指定id属性，只指定全限定类名，如：
<bean class="com.zyh.spring3.hello.StaticBeanFactory"></bean>
此时需要通过接口getBean(Class<T> requiredType)来获取Bean；
3、如果不指定id，只指定name，那么name为Bean的标识符，并且需要在容器中唯一；
4、同时指定name和id，此时id为标识符，而name为Bean的别名，两者都可以找到目标Bean；
5、可以指定多个name，之间可以用分号（“；”）、空格（“ ”）或逗号（“，”）分隔开，如果没有指定id，那么第一个name为标识符，其余的为别名；若指定了id属性，则id为标识符，所有的name均为别名。如：
<bean name="alias1 alias2;alias3,alias4" id="hello1" class="com.zyh.spring3.hello.HelloWorld">
<constructor-arg index="0" value="Rod"></constructor-arg>
</bean>
此时，hello1为标识符，而alias1，alias2，alias3，alias4为别名，它们都可以作为Bean的键值；
6、可以使用<alias>标签指定别名，别名也必须在IoC容器中唯一，如：
<bean name="bean" class="com.zyh.spring3.hello.HelloWorld"/>
<alias alias="alias1" name="bean"/>
<alias alias="alias2" name="bean"/>


其实，idref注入的是目标bean的id而不是目标bean的实例，同时使用idref容器在部署的时候还会验证这个名称的bean是否真实存在。
其实idref就跟value一样，只是将某个字符串注入到属性或者构造函数中，只不过注入的是某个Bean定义的id属性值。
所以上面的代码中
<constructor-arg name="name"><idref bean="bea" /></constructor-arg>
其实等同于
<constructor-arg name="name"><value>bea</value></constructor-arg>

而ref则是完全地不同，ref元素是将目标Bean定义的实例注入到属性或构造函数中，ref元素有三个属性，区别如下：
1、local 只能指定与当前配置的Bean在同一个配置文件中的Bean定义的名称；
2、parent 只能指定位于当前容器的父容器中定义的对象引用；
3、bean 基本上通吃，即包括以上两种情况都可以，所以，通吃情况下，直接使用bean来指定对象引用就可以了。




@Configuration
@Bean
@Profile
@Inject ... ??? 我怎么没有这个。c+s+T，找不到。。不知道为什么
@Reource
@Autowired
@ImpoerResource





@Component
public @interface Repository {

@Component 功能和 @Bean 类似。都是声明一个bean。
@Component是类作为一个bean，@Bean是返回值作为一个bean。
@Bean可以让第三方类成为一个bean


@ComponentScan
// 默认范围是这个包中。可递归。


org.hibernate.HibernateException: Could not obtain transaction-synchronized Session for current thread
	at






https://docs.spring.io/spring/docs/5.1.7.BUILD-SNAPSHOT/spring-framework-reference/core.html#beans-factory-lazy-init



注意我在spring.schemas中标红的最后一行，说明我们在写命名空间值对应的xsd文件位置时，可以不用写版本号，它默认的是本地spring相关版本的对应xsd版本，我这里是4.1。




aop:advisor
aop:aspect
功能是一样的。。写法不同。。
advisor更适合事务，aspect更适合日志，缓存。

advisor的切面：
public class SleepHelper implements MethodBeforeAdvice,AfterReturningAdvice{


spring的aop还得下 aspectjweaver


噗，around是指真正的方法在around方法中执行，不是之前around一次，之后around一次。。


< aop:aspect>定义切面时，只需要定义一般的bean就行，而定义< aop:advisor>中引用的通知时，通知必须实现Advice接口。


<aop:aspectj-autoproxy expose-proxy="true"></aop:aspectj-autoproxy>


































==================================
==================================
==================================
==================================
spring boot in action

web.xml or WebApplicationInitializer


1.自动配置
在classpath中发现H2数据库的库，那么就自动配置一个H2数据库，如果在classpath中发现了jdbcTemplate，那么就配置一个JdbcTemplate的Bean。
。。jdbcTemplate是指发现这个jar库还是说发现它被使用？

2.起步依赖
刚开始构建时，需要导入多个框架，如：
spring-core,spring-web,spring-webmvc,jackson-databind,hibernate-validator,tomcat-embed-core,tomcat-embed-el,tomcat-embed-logging-juli

但是只要使用org.springframework.boot:spring-boot-starter-web,它会根据依赖(。。这个应该就是前面的那串英文代表依赖)传递把其他所需依赖引入项目里。
如果是web应用，加入web起步依赖
如果需要jpa持久化，加入jpa起步依赖
如果需要安全，加入security起步依赖

springBoot的起步依赖不需要人考虑：需要这些库的哪些版本。


3.命令行界面
spring boot cli
command line interface


4.Actuator



spring initializr用法
web界面
spring tool suite
IntelliJ IDEA
spring boot cli

http://start.spring.io
。。真的是initializr。。。这个网页的title。。


1.启动引导spring
ReadingListApplication在spring boot中有2个作用，配置和启动引导。首先，这是主要的spring配置类。虽然spring boot的自动配置免除了很多spring配置，但你还需要进行少量配置来启用自动配置。

ReadingListApplication.java不仅是启动引导类，还是配置类。

@SpringBootApplication			// 开启组件扫描和自动配置
public class ReadingListApplication {
	public static void main(String[] args) {
		SpringApplication.run(ReadingListApplication.class, args);
	}
}

SpringBootApplication将3个有用的注解组合在一起。
@Configuration
@ComponentScan
@EnableAutoConfiguration	这个开启springboot自动配置


2.测试
@SpringApplicationConfiguration 加载spring应用程序上下文。

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = ReadingListApplication.class)
@WebAppConfiguration

一个典型的spring集成测试会使用@ContextConfiguration注解来标识如何加载spring的应用程序上下文。
但是为了充分发挥spring boot，这里应该使用@SpringApplicationConfiguration。

3.配置应用程序属性
initializr为你生成的application.properties文件是一个空文件。实际上，这个文件完全是可选的，可以删除。
如果加入：server.port=8000。嵌入式tomcat的监听端口就变成了8000

只要存在application.properties，就会被自动加载。


<!-- 从spring-boot-starter-parent 继承版本号 -->
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>{springBootVersion}</version>
	<relativePath/>
</parent

<!-- 依赖 -->
<dependencies>
	<dependency>
		<groupId>org.springframeword.boot</
		<artifactId>spring-boot-starter-web</
	</
....
	spring-boot-starter-data-jpa
	spring-boot-starter-thymeleaf
	spring-boot-starter-test

groupid:com.h2database,artifactid:h2

</dependencies>

<!-- 运用springboot插件 -->
<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</
			<artifactId>spring-boot-maven-plugin</
</



覆盖起步依赖引入的传递依赖
gradle：
compile("org.springframework.boot:spring-boot-starter-web") {
	exculde group: 'com.fasterxml.jackson.core'
}

maven：
<dependency>
	<groupId>org.springframework.boot</
	<artifactId>spring-boot-starter-web</
	<exclusions>
		<esclusion>
			<groupId>com.fasterxml.jackson.core</
</


maven使用最近依赖，(继承路径上的最近)

gradle使用最新依赖，(版本最新)


使用自动配置
举几个例子，下面的情况都是springboot的自动配置需要考虑的
spring的JdbcTemplate是否在classpath中，如果是，并且有DataSource的bean，则自动配置一个JdbcTemplate的bean。
Thymeleaf是否在classpath中，如果是，配置Thymeleaf的模板解析器，视图解析器，模板引擎。
spring security是否在classpath中，如果是，则进行一个非常基本的web安全设置。

每当应用程序启动的时候，springboot的自动配置就要做近200个这样的决定，涵盖安全，集成，持久化，web开发等方面


@RequestMapping(value="/{reader}", method=RequestMethod.GET)
public String readersBooks (@PathVariable("reader") String reader, Model model) {
	List<Book> readingList = readingListRepository.findByReader(reader);
	if (readingList != null)
		model.addAttribute("books", readingList);
	return "readingList";
}

@RequestMapping(value="/{reader}", method=RequestMethod.POST)
public String addToReadingLisdt(@PathVariable("reader") String reader, Book book) {
	book.setReader(reader);
	readingListRepository.save(book);
	return "redirect:/{reader}";
}



在向应用程序加入springboot时，有个名为spring-boot-autoconfigure的jar文件，其中包含了很多配置类。每个配置类都在应用程序的classpath中，都有机会为应用程序的配置添砖加瓦。

这些配置是因为spring4引入的新特性-条件化配置。条件化配置运行在配置存在于应用程序中，但在满足某些条件之前都忽略这个配置。

你所要做的是实现Condition接口，覆盖matches方法。
下面这个条件类只有在classpath中存在jdbctemplate时才会生效：
public class JdbcTemplateConsition implements Condition {
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		try {
			context.getClassLoader().loadClass("org.springframework.jdbc.core.JdbcTemplate");
			return true;
		} catch (Exception e) {
			return false;
		}
	}
}

当你使用Java来声明Bean的时候，可以使用这个自定义条件类：
@Conditional(JdbcTemplateCondition.class)
public MyService myService() {...}

MyService,bean的创建条件是classpath中存在JdbcTemplate。

条件化注解
@ConditionalOnBean		配置了某个特定bean
@ConditionalOnMissingBean	没有配置某个bean
@ConditionalOnClass		classpath中有指定类
@ConditionalOnMissingClass
@ConditionalOnExpression	给定spring expression language(SpEL)表达式计算结果为true
@ConditionalOnJava		java的版本匹配特定值或者一个范围值
@ConditionalOnJndi		参数中给定的JNDI位置必须存在一个，如果没有给参数，则要有JNDI InitialContext
@ConditionalOnProperty		指定的配置属性要有一个明确的值
@ConditionalOnResource		classpath中有指定资源
@ConditionalOnWebApplication	这是一个web应用
@ConditionalOnNotWebApplication		这不是一个web应用


@Configuration
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSOurceProperties.class)
@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })
public class DataSourceAutoConfiguration {}

DataSourceAutoConfiguration里嵌入一个JdbcTemplateConfiguration类，自动配置一个JdbcTemplate bean
@Configuration
@Conditional(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)
protected static class JdbcTemplateConfiguration {
	@Autowired(required = false)
	private DataSource dataSource;

	@Bean
	@ConditionalOnMissingBean(JdbcOperations.class)
	public JdbcTemplate jdbcTemplate() {
		return new JdbcTemplate(this.dataSource);
	}
}



覆盖自动配置很简单，就当自动配置不存在，直接显式地写一段配置。显式配置的形式不限，spring支持的xml和groovy形式配置都可以。

在编写显示配置时，我们会专注于Java形式的配置。在spring security的场景下，这意味写一个扩展了WebSecurityConfigurerAdapter的配置类。

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	@Autowired
	private ReaderRepository rederRepository;

	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests().antMatchers("/").assess("hasRole('READER')").antMatchers("/**").permitAll()
		.and()
		.formLogin().loginPage("/login").failureUrl("/login?error=true");
	}

	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userADetailsService(new UserDetailsService() {
			public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
				return readerRepository.findone(username);
			}
		});
	}
}


springboot的设计是加载应用级配置，随后考虑自动配置类。


关于springsecurity，自动配置会考虑几个配置类，其中最重要的是SpringBootWebSecurityConfiguration。
@Configuration
@EnableConigurationProperties
@ConditionalOnClass({ EnableWebSecurity.class })
@ConditionalOnMissingBean(WebSecurityConfiguration.class)
@ConditionalOnWebApplication
public class SpringBootWebSecurityConfiguration {}

classpath中必须有@EnableWebSecurity注解。
。。但是只是类必须有，不一定用吧。。

通过在SecurityConfig上添加@EnableWebSecurity注解，我们实际上间接创建了一个WebSecurityConfiguration bean，所以在自动配置时，这个bean就已经存在了。这个自动配置就被跳过。
。。应该是那个 WebSecurityConfigurerAdapter 的作用。



通过属性文件外置配置

为了调整一些微小的细节，如，端口号，日志级别，便放弃自动配置，这得不偿失。

springboot提供了300个用于微调的属性。当你调整设置时，只要在环境变量，java系统属性，JNDI(java naming and directory interface),命令行参数或属性文件里指定就好了。

在命令行里运行readinglist应用程序时，spring boot有一个ascii-art banner..(。看翻译是 字符画，应该就是启动的时候的 使用|-+,这种符号画出的 SPRING BOOT这种。..banner是横幅，旗帜 或者 一流的 的意思，，不是禁止者。..).。如果想禁用这个，可以将spring.main.show-banner属性调整为false。有几种实现方式：

1.运行应用程序的命令行参数里指定：
$ java -jar readinglist-0.0.1-SNAPSHOT.jar --spring.main.show-banner=false

2.创建一个application.properties文件，包含如下内容
spring.main.show-banner=false

3.也可以创建application.yml的YAML文件，内容如下：
spring:
	main:
		show-banner: false

4.可以将属性设置为环境变量。如果用的是bash或zsh，可以使用export命令：
$ export spring_main_show_banner=false
。。..这里是下划线。不是点和横杠。这是对环境变量名称的要求。


事实上，springboot有多种设置途径，springboot能从多种属性源获得属性，包括：
1.命令行参数
2.java:comp/env 中的JNDI属性
3.jvm系统属性
4.操作系统环境变量
5.随机生成的带random.*前缀的属性(在设置其他属性时，可以引用它们，比如${random.long})
6.应用程序以外的application.properties或者application.yml
7.打包在应用程序里的application.properties或者application.yml
8.通过@PropertySource标记的属性源
9.默认属性

这是优先级排列。


application.properties和application.yml能放在以下4个位置
1.外置，在相对于应用程序运行目录的/config子目录中。
2.外置，在应用程序运行的目录里。
3.内置，在config包中
4.内置，在classpath根目录

按优先级排列

yml的属性会覆盖properties中的。



禁用模板缓存
如果readingList应用程序经过了几番修改，你一定已经注意到了，除非重启应用程序，否则对Thymeleaf模板的变更是不会生效的。这是因为模板默认缓存。这有助于改善性能，因为模板只需要编译一次。但在开发过程中就无法实时看到变更的效果了。
spring.thymeleaf.cache设置为false就能禁用Thymeleaf模板缓存。


Thymeleaf作为应用程序的视图，springboot支持的其他模板也能关闭模板缓存，设置这些属性就好了：
spring.freemarker.cache
spring.groovy.template.cache
spring.velocity.cache
默认情况下，这些都是true。


配置嵌入式服务器
server.port 属性

提供https服务，第一步是使用jdk的keytool工具来创建一个密钥存储：
% keytool -keystore mykeys.jks -genkey -alias tomcat -keyalg RSA
该工具会询问几个与名字和组织相关的问题，大部分都无关紧要，但在被问到密码时，一定要记住你的选择，在本例中，letmein作为密码。
现在只要设置几个属性就能开启嵌入式服务器的https服务了，可以把它们都配置在命令行中，但这样太不方便了。可以把它们放在application.properties或application.yml中。在application.yml中：
server:
	port: 8443
	ssl:
		key-store: file:///path/to/mykeys.jks
		key-store-password: letmein
		key-password: letmein

52
配置日志
默认情况下，使用Logback来记录日志，info级别输出到控制台。
如果需要Log4j，那么需要修改依赖，引入日志实现的起步依赖，同时排除掉Logback。

以Maven为例，应排除掉根起步依赖传递引入的默认日志起步依赖，这样就能排除
Logback了：
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter</artifactId>
	<exclusions>
		<exclusion>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-logging</artifactId>
		</exclusion>
	</exclusions>
</dependency>

在Gradle里，在configurations下排除该起步依赖是最简单的办法：
configurations {
	all*.exclude group:'org.springframework.boot',
				module:'spring-boot-starter-logging'
}

加入依赖
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-log4j</artifactId>
</dependency>

在Gradle里可以这样添加Log4j：
compile("org.springframework.boot:spring-boot-starter-log4j")

如果你想用Log4j2，可以把spring-boot-starter-log4j改成spring-boot-starter-log4j2。

要完全掌握日志配置，可以在Classpath根目录（src/main/resources）里创建logback.xml文
件。下面是一个logback.xml的简单例子：
<configuration>
	<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
		<encoder>
			<pattern>
			%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
			</pattern>
		</encoder>
	</appender>

	<logger name="root" level="INFO"/>

	<root level="INFO">
		<appender-ref ref="STDOUT" />
	</root>
</configuration>

要设置日志级别，你可以创建以logging.level开头的属性，后面是要日志名称。如果根日志级别要设置为WARN，但Spring Security的日志要用DEBUG级别，可以在application.yml里加入以下内容：
logging:
	level:
		root: WARN
		org:
			springframework:
				security: DEBUG

另外，你也可以把Spring Security的包名写成一行：
logging:
	level:
		root: WARN
		org.springframework.security: DEBUG


现在，假设你想把日志写到位于/var/logs/目录里的BookWorm.log文件里。使用logging.
path和loggin.file属性就行了：
logging:
	path: /var/logs/
	file: BookWorm.log
	level:
		root: WARN
		org:
			springframework:
				security: DEBUG

假设应用程序有/var/logs/的写权限，日志就能被写入/var/logs/BookWorm.log。默认情况下，日志文件的大小达到10MB时会切分一次。

与之类似，这些属性也能在application.properties里设置：
logging.path=/var/logs/
logging.file=BookWorm.log
logging.level.root=WARN
logging.level.root.org.springframework.security=DEBUG

如果你还是想要完全掌控日志配置，但是又不想用logback.xml作为Logback配置的名字，可以通过logging.config属性指定自定义的名字：
logging:
	config:
		classpath:logging-config.xml

配置数据源
虽然你可以显式配置自己的DataSource Bean，但通常并不用这么做，只需简单地通过属性配置数据库的URL和身份信息就可以了。举例来说，如果你用的是MySQL数据库，你的application.yml文件看起来可能是这样的：
	spring:
		datasource:
			url: jdbc:mysql://localhost/readinglist
			username: dbuser
			password: dbpass

通常你都无需指定JDBC驱动，Spring Boot会根据数据库URL识别出需要的驱动，但如果识别出问题了，你还可以设置spring.datasource.driver-class-name属性：
spring:
	datasource:
		url: jdbc:mysql://localhost/readinglist
		username: dbuser
		password: dbpass
		driver-class-name: com.mysql.jdbc.Driver

在自动配置DataSource Bean的时候，Spring Boot会使用这里的连接数据。DataSource Bean是一个连接池，如果Classpath里有Tomcat的连接池DataSource，那么就会使用这个连接池；否则，Spring Boot会在Classpath里查找以下连接池：
? HikariCP
? Commons DBCP
? Commons DBCP 2
这里列出的只是自动配置支持的连接池，你还可以自己配置DataSource Bean，使用你喜欢
的各种连接池。
。。Tomcat有连接池？

你也可以设置spring.datasource.jndi-name属性，从JNDI里查找DataSource：
spring:
datasource:
jndi-name: java:/comp/env/jdbc/readingListDS
一旦设置了spring.datasource.jndi-name属性，其他数据源连接属性都会被忽略，除非没有设置别的数据源连接属性。


。。。
@ConfigurationProperties
把配置文件的信息，读取并自动封装成实体类
用@ConfigurationProperties，它可以把同类的配置信息自动封装成实体类
首先在配置文件里面，这些信息是这样子滴
connection.username=admin
connection.password=kyjufskifas2jsfs
connection.remoteAddress=192.168.1.1

定义一个实体类在装载配置文件信息
@Component
@ConfigurationProperties(prefix="connection")
public class ConnectionSettings {

    private String username;
    private String remoteAddress;
    private String password ;

    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getRemoteAddress() {
        return remoteAddress;
    }
    public void setRemoteAddress(String remoteAddress) {
        this.remoteAddress = remoteAddress;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }

}

我们还可以把@ConfigurationProperties还可以直接定义在@bean的注解上，这是bean实体类就不用@Component和@ConfigurationProperties了
@SpringBootApplication
public class DemoApplication{

    //...

    @Bean
    @ConfigurationProperties(prefix = "connection")
    public ConnectionSettings connectionSettings(){
        return new ConnectionSettings();

    }

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

我们需要使用的时候就直接这样子注入
@RestController
@RequestMapping("/task")
public class TaskController {

@Autowired ConnectionSettings conn;

	@RequestMapping(value = {"/",""})
	public String hellTask(){
		String userName = conn.getUsername();
		return "hello task !!";
	}

}

如果发现@ConfigurationPropertie不生效，有可能是项目的目录结构问题，
你可以通过@EnableConfigurationProperties(ConnectionSettings.class)来明确指定需要用哪个实体类来装载配置信息
@Configuration
@EnableConfigurationProperties(ConnectionSettings.class)
 public class MailConfiguration {
    @Autowired private MailProperties mailProperties;

    @Bean public JavaMailSender javaMailSender() {
      // omitted for readability
    }
 }

。。。



。。通过ConfigurationProperties，直接将properties属性修改到页面上。
56

@Controller
@RequestMapping("/")
@ConfigurationProperties(prefix="amazon")
public class ReadingListController {
	private String associateId;
	private ReadingListRepository readingListRepository;
	@Autowired
	public ReadingListController(ReadingListRepository readingListRepository) {
		this.readingListRepository = readingListRepository;
	}
	public void setAssociateId(String associateId) {
		this.associateId = associateId;
	}
	@RequestMapping(method=RequestMethod.GET)
	public String readersBooks(Reader reader, Model model) {
	List<Book> readingList = readingListRepository.findByReader(reader);
	if (readingList != null) {
		model.addAttribute("books", readingList);
		model.addAttribute("reader", reader);
		model.addAttribute("amazonID", associateId);
	}
	return "readingList";
}
	@RequestMapping(method=RequestMethod.POST)
	public String addToReadingList(Reader reader, Book book) {
		book.setReader(reader);
		readingListRepository.save(book);
		return "redirect:/";
	}
}

如你所见，ReadingListController现在有了一个associateId属性，还有对应的setAssociateId()方法，用它可以设置该属性。readersBooks()现在能通过amazonID这个键把associateId的值放入模型。
棒极了！现在就剩一个问题了――从哪里能取到associateId的值。
请注意，ReadingListController上加了@ConfigurationProperties注解，这说明该Bean的属性应该是（通过setter方法）从配置属性值注入的。说得更具体一点，prefix属性说明ReadingListController应该注入带amazon前缀的属性。
综合起来，我们指定ReadingListController的属性应该从带amazon前缀的配置属性中进行注入。ReadingListController只有一个setter方法，就是设置associateId属性用的setter方法。因此，设置Amazon Associate ID唯一要做的就是添加amazon.associateId属性，把它加入支持的任一属性源位置里即可。

例如，我们可以在application.properties里设置该属性：
amazon.associateId=habuma-20
或者在application.yml里设置：
amazon:
	associateId: habuma-20
或者，我们可以将其设置为环境变量，把它作为命令行参数，或把它加到任何能够设置配置属性
的地方。


开启配置属性 从技术上来说，@ConfigurationProperties注解不会生效，除非先向Spring配置类添加@EnableConfigurationProperties注解。但通常无需这么做，因为Spring Boot自动配置后面的全部配置类都已经加上了@EnableConfigurationProperties注解。因此，除非你完全不使用自动配置（那怎么可能？），否则就无需显式地添加@EnableConfigurationProperties。

还有一点需要注意，Spring Boot的属性解析器非常智能，它会自动把驼峰规则的属性和使用连字符或下划线的同名属性关联起来。
换句话说，
amazon.associateId 这个属性和
amazon.associate_id以及
amazon.associate-id都是等价的。

虽然在ReadingListController上加上@ConfigurationProperties注解跑起来没问题，但这并不是一个理想的方案。ReadingListController和Amazon没什么关系，但属性的前缀却是amazon，这看起来难道不奇怪吗？再说，后续的各种功能可能需要在ReadingList-Controller里新增配置属性，而它们和Amazon无关。

@Component
@ConfigurationProperties("amazon")
public class AmazonProperties {
	private String associateId;
	public void setAssociateId(String associateId) {
		this.associateId = associateId;
	}
	public String getAssociateId() {
		return associateId;
	}
}


@Autowired
public ReadingListController(ReadingListRepository readingListRepository, AmazonProperties amazonProperties) {
	this.readingListRepository = readingListRepository;
	this.amazonProperties = amazonProperties;
}

@RequestMapping(method=RequestMethod.GET)public String readersBooks(Reader reader, Model model) {
	List<Book> readingList =
	readingListRepository.findByReader(reader);
	if (readingList != null) {
		model.addAttribute("books", readingList);
		model.addAttribute("reader", reader);
		model.addAttribute("amazonID", amazonProperties.getAssociateId());
	}
	return "readingList";
}


@Profile("production")
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
...
}
这里用的@Profile注解要求运行时激活production Profile，这样才能应用该配置。如果production Profile没有激活，就会忽略该配置，而此时缺少其他用于覆盖的安全配置，于是应用自动配置的安全配置。


设置spring.profiles.active属性就能激活Profile，任意设置配置属性的方式都能用于设置这个值。
例如，在命令行里运行应用程序时，可以这样激活production Profile：
$ java -jar readinglist-0.0.1-SNAPSHOT.jar --spring.profiles.active=production

也可以向application.yml里添加spring.profiles.active属性：
spring:
	profiles:
		active: production

还可以设置环境变量，将其放入application.properties，或者使用3.2节开头提到的各种方法。

但由于Spring Boot的自动配置替你做了太多的事情，要找到一个能放置@Profile的地方还真不怎么方便。幸运的是，Spring Boot支持为application.properties和application.yml里的属性配置Profile。


假设你希望针对生产环境和开发环境能有不同的日志配置

1. 使用特定于Profile的属性文件
如果你正在使用application.properties，可以创建额外的属性文件，遵循application-{profile}.properties这种命名格式，这样就能提供特定于Profile的属性了。

开发环境的配置可以放在名为application-development.properties的文件
里，配置包含日志级别和输出到控制台：
logging.level.root=DEBUG

对于生产环境，application-production.properties会将日志级别设置为WARN或更高级别，并将日志写入日志文件：
logging.path=/var/logs/
logging.file=BookWorm.log
logging.level.root=WARN

与此同时，那些并不特定于哪个Profile或者保持默认值（以防万一有哪个特定于Profile的配置不指定这个值）的属性，可以继续放在application.properties里：
amazon.associateId=habuma-20
logging.level.root=INFO


2. 使用多Profile YAML文件进行配置
如果使用YAML来配置属性，则可以遵循与配置文件相同的命名规范，即创建application-{profile}.yml这样的YAML文件，并将与Profile无关的属性继续放在application.yml里。

但既然用了YAML，你就可以把所有Profile的配置属性都放在一个application.yml文件里。举例来说，我们可以像下面这样声明日志配置：

logging:
	level:
		root: INFO
---
spring:
	profiles: development
logging:
	level:
		root: DEBUG
---
spring:
	profiles: production
logging:
	path: /tmp/
	file: BookWorm.log
	level:
		root: WARN

如你所见，这个application.yml文件分为三个部分，使用一组三个连字符（---）作为分隔符。
第二段和第三段分别为spring.profiles指定了一个值，这个值表示该部分配置应该应用在哪个Profile 里

第一段并未指定spring.profiles，因此这里的属性对全部Profile都生效，或者对那些未设置该属性的激活Profile生效。
。。设置profile的属性能覆盖默认的属性。


Spring Boot默认提供这个“白标”（whitelabel）错误页，这是自动配置的一部分。
Spring Boot自动配置的默认错误处理器会查找名为error的视图，如果找不到就用默认的白标错误视图
因此，最简单的方法就是创建一个自定义视图，让解析出的视图名为error

这一点归根到底取决于错误视图解析时的视图解析器。
? 实现了Spring的View接口的Bean，其ID为error（由Spring的BeanNameViewResolver所解析）。
? 如果配置了Thymeleaf，则有名为error.html的Thymeleaf模板。
? 如果配置了FreeMarker，则有名为error.ftl的FreeMarker模板。
? 如果配置了Velocity，则有名为error.vm的Velocity模板。
? 如果是用JSP视图，则有名为error.jsp的JSP模板。



<html>
	<head>
		<title>Oops!</title>
		<link rel="stylesheet" th:href="@{/style.css}"></link>
	</head>
	<html>
		<div class="errorPage">
			<span class="oops">Oops!</span><br/>
			<img th:src="@{/MissingPage.png}"></img>
			<p>There seems to be a problem with the page you requested
				(<span th:text="${path}"></span>).</p>
			<p th:text="${'Details: ' + message}"></p>
		</div>
	</html>
</html>

这个自定义的错误模板应该命名为error.html，放在模板目录里，这样Thymeleaf模板解析器才能找到它。在典型的Maven或Gradle项目里，这就意味着要把该文件放在src/main/resources/templates中，运行时它就在Classpath的根目录里。

这个简单的Thymeleaf模板就是显示一张图片和一些提示错误的文字。其中有两处特别的信息需要呈现：错误的请求路径和异常消息。但这还不是错误页上的全部细节。默认情况下，Spring Boot会为错误视图提供如下错误属性。
? timestamp：错误发生的时间。
? status：HTTP状态码。
? error：错误原因。
? exception：异常的类名。
? message：异常消息（如果这个错误是由异常引起的）。
? errors：BindingResult异常里的各种错误（如果这个错误是由异常引起的）。
? trace：异常跟踪信息（如果这个错误是由异常引起的）。
? path：错误发生时请求的URL路径。


模板里还引用了一张名为MissingPage.png的图片。图片的实际内容并不重要，所以尽情挑选适合你的图片就好了，但请一定将它放在src/main/resources/static或src/main/resources/public里，这样应用程序运行时才能找到它。


66
chapter 4 test

Spring2.5开始的SpringJUnit4ClassRunner(这是一个JUnit类运行器，会为JUnit测试加载Spring应用程序上下文，并为测试类自动织入所需的Bean。).可以在基于JUnit的应用程序测试里加载Spring应用程序上下文。在测试Spring Boot应用程序时，Spring Boot除了拥有Spring的集成测试支持，还开启了自动配置和Web服务器，并提供了不少实用的测试辅助工具。


@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=AddressBookConfiguration.class)
public class AddressServiceTests {
	@Autowired
	private AddressService addressService;
	@Test
	public void testService() {
		Address address = addressService.findByLastName("Sheman");
		assertEquals("P", address.getFirstName());
		assertEquals("Sherman", address.getLastName());
		assertEquals("42 Wallaby Way", address.getAddressLine1());
		assertEquals("Sydney", address.getCity());
		assertEquals("New South Wales", address.getState());
		assertEquals("2000", address.getPostCode());
	}
}

AddressServiceTests上加注了@RunWith和@ContextConfiguration注解。
@RunWith的参数是SpringJUnit4ClassRunner.class，开启了Spring集成测试支持。与此同时，@ContextConfiguration指定了如何加载应用程序上下文。此处我们让它加载AddressBookConfiguration里配置的Spring应用程序上下文。
除了加载应用程序上下文，SpringJUnit4ClassRunner还能通过自动织入从应用程序上下文里向测试本身注入Bean。

在Spring 4.2里，你可以选择基于规则的SpringClassRule和SpringMethodRule来代替SpringJUnit4ClassRunner。

虽然@ContextConfiguration在加载Spring应用程序上下文的过程中做了很多事情，但它没能加载完整的Spring Boot。Spring Boot应用程序最终是由SpringApplication加载的。它可以显式加载（如代码清单2-1所示），在这里也可以使用SpringBootServletInitializer（我们会在第8章里看到具体做法）。SpringApplication不仅加载应用程序上下文，还会开启日志、加载外部属性（application.properties或application.yml），以及其他Spring Boot特性。用@ContextConfiguration则得不到这些特性。

要在集成测试里获得这些特性，可以把@ContextConfiguration替换为Spring Boot的@SpringApplicationConfiguration：

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes=AddressBookConfiguration.class)
public class AddressServiceTests {
	...
}

..普通junit测试只能测试java方法内部是否正确，无法测试RequestMaaping之类的注解是否正确有效。controller的跳转。

要恰当地测试一个Web应用程序，你需要投入一些实际的HTTP请求，确认它能正确地处理那些请求。幸运的是，Spring Boot开发者有两个可选的方案能实现这类测试。

Spring Mock MVC：能在一个近似真实的模拟Servlet容器里测试控制器，而不用实际启动应用服务器。
 Web集成测试：在嵌入式Servlet容器（比如Tomcat或Jetty）里启动应用程序，在真正的应
用服务器里执行测试。

这两种方法各有利弊。很明显，启动一个应用服务器会比模拟Servlet容器要慢一些，但毫无疑问基于服务器的测试会更接近真实环境，更接近部署到生产环境运行的情况。


要在测试里设置Mock MVC，可以使用MockMvcBuilders，该类提供了两个静态方法。

? standaloneSetup()：构建一个Mock MVC，提供一个或多个手工创建并配置的控制器。

? webAppContextSetup()：使用Spring应用程序上下文来构建Mock MVC，该上下文里可以包含一个或多个配置好的控制器。

两者的主要区别在于，standaloneSetup()希望你手工初始化并注入你要测试的控制器，而webAppContextSetup()则基于一个WebApplicationContext的实例，通常由Spring加载。
前者同单元测试更加接近，你可能只想让它专注于单一控制器的测试，而后者让Spring加载控制器及其依赖，以便进行完整的集成测试。


webAppContextSetup()接受一个WebApplicationContext参数。因此，我们需要为测试类加上@WebAppConfiguration注解，使用@Autowired将WebApplicationContext作为实例变量注入测试类。

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = ReadingListApplication.class)
@WebAppConfiguration
public class MockMvcWebTests {
	@Autowired
	private WebApplicationContext webContext;
	private MockMvc mockMvc;
	@Before
	public void setupMockMvc() {
		mockMvc = MockMvcBuilders
		.webAppContextSetup(webContext)
		.build();
	}
}

@Test
public void homePage() throws Exception {
mockMvc.perform(MockMvcRequestBuilders.get("/readingList"))
.andExpect(MockMvcResultMatchers.status().isOk())
.andExpect(MockMvcResultMatchers.view().name("readingList"))
.andExpect(MockMvcResultMatchers.model().attributeExists("books"))
.andExpect(MockMvcResultMatchers.model().attribute("books",
Matchers.is(Matchers.empty())));
}


import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@Test
public void homePage() throws Exception {
	mockMvc.perform(get("/readingList"))
		.andExpect(status().isOk())
		.andExpect(view().name("readingList"))
		.andExpect(model().attributeExists("books"))
		.andExpect(model().attribute("books", is(empty())));
}


@Test
public void postBook() throws Exception {
	mockMvc.perform(post("/readingList")
		.contentType(MediaType.APPLICATION_FORM_URLENCODED)
		.param("title", "BOOK TITLE")
		.param("author", "BOOK AUTHOR")
		.param("isbn", "1234567890")
		.param("description", "DESCRIPTION"))
		.andExpect(status().is3xxRedirection())
		.andExpect(header().string("Location", "/readingList"));
	Book expectedBook = new Book();		// 期望的图书。
	expectedBook.setId(1L);
	expectedBook.setReader("craig");
	expectedBook.setTitle("BOOK TITLE");
	expectedBook.setAuthor("BOOK AUTHOR");
	expectedBook.setIsbn("1234567890");
	expectedBook.setDescription("DESCRIPTION");
	mockMvc.perform(get("/readingList"))
		.andExpect(status().isOk())
		.andExpect(view().name("readingList"))
		.andExpect(model().attributeExists("books"))
		.andExpect(model().attribute("books", hasSize(1)))
		.andExpect(model().attribute("books",
		contains(samePropertyValuesAs(expectedBook))));
}

Spring Security能让你非常方便地测试安全加固后的Web应用程序。为了利用这点优势，你必须在项目里添加Spring Security的测试模块。
要在Gradle里做到这一点，你需要的就是以下testCompile依赖：
testCompile("org.springframework.security:spring-security-test")

如果你用的是Maven，则添加以下<dependency>：
<dependency>
	<groupId>org.springframework.security</groupId>
	<artifactId>spring-security-test</artifactId>
	<scope>test</scope>
</dependency>

应用程序的Classpath里有了Spring Security的测试模块之后，只需在创建MockMvc实例时运用Spring Security的配置器。
@Before
public void setupMockMvc() {
	mockMvc = MockMvcBuilders
		.webAppContextSetup(webContext)
		.apply(springSecurity())
		.build();
}
springSecurity()方法 springSecurity()是SecurityMockMvcConfigurers的一个静态方法，考虑到可读性，我已经将其静态导入。

springSecurity()方法返回了一个Mock MVC配置器，为Mock MVC开启了Spring Security支持。只需像上面这样运用就行了，Spring Security会介入MockMvc上执行的每个请求。


开启了Spring Security之后，在请求主页的时候，我们便不能只期待HTTP 200响应。如果请求未经身份验证，我们应该期待重定向到登录页面：
@Test
public void homePage_unauthenticatedUser() throws Exception {
	mockMvc.perform(get("/"))
		.andExpect(status().is3xxRedirection())
		.andExpect(header().string("Location",
				"http://localhost/login"));
}

不过，经过身份验证的请求又该如何发起呢？Spring Security提供了两个注解。
@WithMockUser：加载安全上下文，其中包含一个UserDetails，使用了给定的用户名、密码和授权。
@WithUserDetails：根据给定的用户名查找UserDetails对象，加载安全上下文。

@Test
@WithMockUser(username="craig",password="password",roles="READER")
public void homePage_authenticatedUser() throws Exception {
	...
}

@WithMockUser绕过了对UserDetails对象的正常查询，用给定的值创建了一个UserDetails对象取而代之。在简单的测试里，这就够用了。但我们的测试需要Reader（实现了UserDetails ） 而非@WithMockUser 创建的通用UserDetails 。为此， 我们需要@WithUserDetails。
@WithUserDetails注解使用事先配置好的UserDetailsService来加载UserDetails对象，我们配置了一个UserDetailsService Bean，它会根据给定的用户名查找并返回一个Reader对象。

@Test
@WithUserDetails("craig")
public void homePage_authenticatedUser() throws Exception {
	Reader expectedReader = new Reader();
	expectedReader.setUsername("craig");
	expectedReader.setPassword("password");
	expectedReader.setFullname("Craig Walls");
	mockMvc.perform(get("/"))
		.andExpect(status().isOk())
		.andExpect(view().name("readingList"))
		.andExpect(model().attribute("reader",
					samePropertyValuesAs(expectedReader)))
		.andExpect(model().attribute("books", hasSize(0)))
}



Spring Boot支持将Tomcat或Jetty这样的嵌入式Servlet容器作为运行中的应用程序的一部分，可以运用相同的机制，在测试过程中用嵌入式Servlet容器来启动应用程序。

Spring Boot 的@WebIntegrationTest 注解就是这么做的。在测试类上添加@WebIntegrationTest注解，可以声明你不仅希望Spring Boot为测试创建应用程序上下文，还要启动一个嵌入式的Servlet容器。一旦应用程序运行在嵌入式容器里，你就可以发起真实的HTTP请求，断言结果了。

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes=ReadingListApplication.class)
@WebIntegrationTest
public class SimpleWebTest {
	@Test(expected=HttpClientErrorException.class)
	public void pageNotFound() {
		try {
			RestTemplate rest = new RestTemplate();
			rest.getForObject(
			"http://localhost:8080/bogusPage", String.class);
			fail("Should result in HTTP 404");
		} catch (HttpClientErrorException e) {
			assertEquals(HttpStatus.NOT_FOUND, e.getStatusCode());
			throw e;
		}
	}
}

虽然这个测试非常简单，但足以演示如何使用@WebIntegrationTest在服务器里启动应用程序。要判断实际启动的服务器究竟是哪个，可以遵循在命令行里运行应用程序时的逻辑。默认情况下，会有一个监听8080端口的Tomcat启动。但是，如果Classpath里有的话，Jetty或者Undertow也能启动这些服务器。


让Spring Boot 在随机选择的端口上启动服务器很方便。一种办法是将server.port属性设置为0，让Spring Boot选择一个随机的可用端口。@WebIntegrationTest的value属性接受一个String数组，数组中的每项都是键值对，形如name=value，用来设置测试中使用的属性。要设置server.port，你可以这样做：

@WebIntegrationTest(value={"server.port=0"})
另外，因为只要设置一个属性，所以还能有更简单的形式：
@WebIntegrationTest("server.port=0")

但@WebIntegrationTest还提供了一个randomPort属性，更明确地表示让服务器在随机端口上启动。
@WebIntegrationTest(randomPort=true)

首先，我们需要以实例变量的形式注入选中的端口。为了方便，Spring Boot将local.server.port的值设置为了选中的端口。我们只需使用Spring的@Value注解将其注入即可：
@Value("${local.server.port}")
private int port;

有了端口之后，只需对getForObject()稍作修改，使用这个port就好了：
rest.getForObject("http://localhost:{port}/bogusPage", String.class, port);



RestTemplate对于简单的请求而言使用方便，是测试REST端点的理想工具。但是，就算它能对返回HTML页面的URL发起请求，也不方便对页面内容或者页面上执行的操作进行断言。结果HTML里的内容最好能够精确判断（这种测试很脆弱）。不过你无法轻易判断页面上选中的内容，或者执行诸如点击链接或提交表单这样的操作。

对于HTML应用程序测试，有一个更好的选择――Selenium（www.seleniumhq.org），它的功能远不止提交请求和获取结果。它能实际打开一个Web浏览器，在浏览器的上下文中执行测试。
Selenium尽量接近手动执行测试，但与手工测试不同。Selenium的测试是自动的，而且可以重复运行。


首先需要把Selenium作为测试依赖添加到项目里：
testCompile("org.seleniumhq.selenium:selenium-java:2.45.0")

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes=ReadingListApplication.class)
@WebIntegrationTest(randomPort=true)
public class ServerWebTests {
	private static FirefoxDriver browser;
	@Value("${local.server.port}")
	private int port;
	@BeforeClass
	public static void openBrowser() {
		browser = new FirefoxDriver();
		browser.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
	}
	@AfterClass
	public static void closeBrowser() {
		browser.quit();
	}
}

静态方法openBrowser()会创建一个FirefoxDriver的实例，它将打开Firefox浏览器（需要在运行测试的服务器上安装该浏览器）。我们的测试方法将通过FirefoxDriver实例来执行浏览器操作。在页面上查找元素时，FirefoxDriver配置了10秒的等候时间（以防元素加载过慢）。


chapter 5
Groovy与spring boot cli
(命令行界面)

。。就是用groovy实现业务逻辑，而不是配置。
。。不清楚为什么我会认为groovy是配置。似乎前面有提到。但是不清楚了。

Spring Boot CLI在这里不仅仅是便捷地使用Groovy编写了Spring应用程序。Spring Boot CLI施展了很多技能。

CLI可以利用Spring Boot的自动配置和起步依赖。
CLI可以检测到正在使用的特定类，自动解析合适的依赖库来支持那些类。
CLI知道多数常用类都在哪些包里，如果用到了这些类，它会把那些包加入Groovy的默认包里。
应用自动依赖解析和自动配置后，CLI可以检测到当前运行的是一个Web应用程序，并自动引入嵌入式Web容器（默认是Tomcat）供应用程序使用。


CLI尝试用内嵌的Groovy编译器来编译Groovy代码。虽然你不知道，但实际上，未知类型（比如JdbcTemplate、Controller及RequestMapping，等等）最终会使代码编译失败。
。。就是 $spring run .

但CLI 不会放弃， 它知道只要把Spring Boot JDBC起步依赖加入Classpath 就能找到JdbcTemplate。它还知道把Spring Boot的Web起步依赖加入Classpath就能找到Spring MVC的相关类。因此，CLI会从Maven仓库（默认为Maven中心仓库）里获取那些依赖。

如果此时CLI重新编译，那还是会失败，因为缺少import语句。但CLI知道很多常用类的包。利用定制Groovy编译器默认包导入的功能之后，CLI把所有需要用到的包都加入了Groovy编译器的默认导入列表。

现在CLI可以尝试再一次编译了。假设没有其他CLI能力范围外的问题（比如，存在CLI不知道的语法或类型错误），代码就能完成编译。CLI将通过内置的启动方法（与基于Java的例子里的main()方法类似）运行应用程序。

此时，Spring Boot自动配置就能发挥作用了。它发现Classpath里存在Spring MVC（因为CLI解析了Web起步依赖），就自动配置了合适的Bean来支持Spring MVC，还有嵌入式Tomcat Bean供应用程序使用。它还发现Classpath里有JdbcTemplate，所以自动创建了JdbcTemplate Bean，注入了同样自动创建的DataSource Bean。


说起DataSource Bean，这只是Spring Boot自动配置创建的众多Bean中的一个。Spring Boot还自动配置了很多Bean来支持Spring MVC中的Thymeleaf模板。正是由于我们使用@Grab注解向Classpath里添加了H2和Thymeleaf，这才触发了针对嵌入式H2数据库和Thymeleaf的自动配置。

@Grab注解的作用是方便添加CLI无法自动解析的依赖。



该把@Grab注解放在哪里？ 并不需要像我们这样，严格将@Grab注解放在一个单独的类上。它们在ReadingListController或JdbcReadingListRepository同样有效。不过，为了便于组织管理，最好创建一个空类，把所有@Grab注解放在一起。这样方便在一个地方看到所有显式声明的依赖。


@Grab 注解源自Groovy Grape （ Groovy Adaptable Packaging Engine 或Groovy AdvancedPackaging Engine）工具。从本质上来说，Grape允许Groovy脚本在运行时下载依赖，无需Maven或Gradle这样的构建工具介入。除了支持@Grab注解，Spring Boot CLI还用Grape来获取代码中推断出的依赖。


使用@Grab就和描述依赖一样简单。举例来说，假设你想往项目里添加H2数据库，可以往项目的一个Groovy脚本添加如下@Grab注解：
@Grab(group="com.h2database", module="h2", version="1.4.190")

这样能明确地声明依赖的组、模块和版本号。或者，你也可以用更简洁的冒号分割表示依赖，这和Gradle构建说明里的表示方式类似。
@Grab("com.h2database:h2:1.4.185")

很多依赖不再要求指定版本号了。可以通过下面的方式，用@Grab添加H2数据库依赖：
@Grab("com.h2database:h2")
确切的版本号是由你所使用的CLI 的版本来决定的。如果用的是Spring Boot CLI 1.3.0.RELEASE，那么H2依赖的版本会解析为1.4.190。

很多常用依赖还可以省去Group ID，直接在@Grab里写上模块的ID。正是这个特性让上文的@Grab注解成功加载了H2。
@Grab("h2")


Spring Boot引入了新的@GrabMetadata注解，可以和@Grab搭配使用，用属性文件里的内容来覆盖默认的依赖版本。

要用@GrabMetadata，可以把它加到某个Groovy脚本文件里，提供相应的属性文件来覆盖依赖元数据：
@GrabMetadata("com.myorg:custom-versions:1.0.0")

这会从Maven仓库的com/myorg目录里加载一个名为custom-versions.properties的文件。文件里的每一行都应该有Group ID和Module ID。以这两个东西为键名，属性则是值。例如，要把H2的默认版本覆盖为1.4.186，可以把@GrabMetadata指向一个包含如下内容的属性文件：
com.h2database:h2=1.4.186

使用Spring IO平台
你可能希望让@GrabMetadata使用Spring IO平台（http://platform.spring.io/platform/）上定义的依赖版本。该平台提供了一套依赖和版本。明确哪个版本的Spring能和其他库的什么版本搭配使用。Spring IO平台提供的依赖和版本是Spring Boot已知依赖库的一个超集，包含了很多Spring应用程序经常用到的第三方库。
如果你想在Spring IO平台上构建Spring Boot CLI应用程序，只需要在Groovy脚本中添加如下@GrabMetadata即可。
@GrabMetadata('io.spring.platform:platform-versions:1.0.4.RELEASE')
这会覆盖CLI的默认依赖版本，使Spring IO平台定义的版本取而代之。



默认情况下，@Grab声明的依赖是从Maven中心仓库（http://repo1.maven.org/maven2/）拉取的。此外，Spring Boot还注册了Spring的里程碑及快照仓库，以便获取Spring项目的预发布版本依赖。

@GrabResolver注解可以让你指定额外的仓库，用来获取依赖。

假设你想使用最新的Hibernate，而最新的Hibernate版本只能从JBoss的仓库里获取到。那么你需要通过@GrabResolver来添加仓库：
@GrabResolver(name='jboss', root='https://repository.jboss.org/nexus/content/groups/public-jboss')
这里通过name属性将该解析器命名为jboss，通过root属性来指定仓库的URL。


在@Grab的支持下，CLI可以解析各种它无法自动解析的依赖。基于CLI的应用程序无需Maven或Gradle构建说明文件（传统方式开发的Java应用程序需要这个文件）。


89

因为基于CLI的应用程序并未涉及传统的构建系统，所以CLI提供了一个test命令来运行测试。
。。支持Junit，Spock说明 测试。


针对基于CLI的阅读列表应用程序，在命令行执行如下命令：
$ spring jar ReadingList.jar .

这会将整个项目打包成一个可执行的JAR文件，包含所有依赖、Groovy和一个嵌入式Tomcat。
打包完成后，就可以像下面这样在命令行里运行了（无需CLI）：
$ java -jar ReadingList.jar

除了可以在命令行里运行外，可执行的JAR文件也能部署到多个平台服务器（Platform as a Service，PaaS）云平台里，包括Pivotal Cloud Foundry和Heroku，


chapter 6

在Spring Boot刚发布时，经常有人问我在Spring Boot和Grails之间该如何选择。两者都构建于Spring Framework之上，都旨在简化应用程序的开发

Spring Boot和Grails两个都很好，完全可以结合到一起。

我们会先看到Spring Boot中Grails对象关系映射（Grails Object Relational Mapping，GORM）和Groovy服务器页面（Groovy Server Page，GSP）这样的Grails特性，还会看到Grails 3是如何基于Spring Boot重写的。

Grails里最让人着迷的恐怕就是GORM了。GORM将数据库相关工作简化到和声明要持久化的实体一样容易。

演示了阅读列表里的Book该如何用Groovy写成GORM实体。
package readinglist
import grails.persistence.*
@Entity
class Book {
	Reader reader
	String isbn
	String title
	String author
	String description
}

是Grails的@Entity注解让这个类变成了GORM实例

这个简单的实体可干了不少事，包括将对象映射到数据库，为Book添加持久化方法，通过这些方法可以存取图书。


在项目里添加GORM依赖。在Maven 中，<dependency>看起来是这样的：
<dependency>
	<groupId>org.grails</groupId>
	<artifactId>gorm-hibernate4-spring-boot</artifactId>
	<version>1.1.0.RELEASE</version>
</dependency>

一样的依赖，在Gradle里是这样的：
compile("org.grails:gorm-hibernate4-spring-boot:1.1.0.RELEASE")

这个库自带了一些Spring Boot自动配置，会自动配置所有支持GORM所需的Bean。


正如其名，gorm-hibernate4-spring-boot是通过Hibernate开启GORM数据持久化的。对很多项目而言，这很好。但如果你想用MongoDB，那你会对Spring Boot里的MongoDB GORM支持很感兴趣。
它的Maven依赖是这样的：
<dependency>
	<groupId>org.grails</groupId>
	<artifactId>gorm-mongodb-spring-boot</artifactId>
	<version>1.1.0.RELEASE</version>
</dependency>
下面是相同的Gradle依赖：
compile("org.grails:gorm-mongodb-spring-boot:1.1.0.RELEASE")

GORM的工作原理要求实体类必须用Groovy来编写


@Controller
@RequestMapping("/")
@ConfigurationProperties("amazon")
class ReadingListController {
	@Autowired
	AmazonProperties amazonProperties
	@ExceptionHandler(value=RuntimeException.class)
	@ResponseStatus(value=HttpStatus.BANDWIDTH_LIMIT_EXCEEDED)
	def error() {
		"error"
	}
	@RequestMapping(method=RequestMethod.GET)
	def readersBooks(Reader reader, Model model) {
		List<Book> readingList = Book.findAllByReader(reader)
		model.addAttribute("reader", reader)
		if (readingList) {
			model.addAttribute("books", readingList)
			model.addAttribute("amazonID", amazonProperties.getAssociateId())
		}
		"readingList"
	}
	@RequestMapping(method=RequestMethod.POST)
	def addToReadingList(Reader reader, Book book) {
		Book.withTransaction {
			book.setReader(reader)
			book.save()
		}
		"redirect:/"
	}
}

和java版本最重要的不同之处在于，无需再注入ReadingListRepository，它直接通过Book类型持久化。

在readersBooks()方法里，它调用了Book的findAllByReader()静态方法，传入了指定的读者信息。虽然代码清单6-1没有提供findAllByReader()方法，但这段代码仍然可以执行，因为GORM会为我们实现这个方法。

与之类似，addToReadingList()方法使用了静态方法withTransaction()和实例方法save()。这两个方法也是GORM提供的，用于将Book保存到数据库里。


除了GORM，Grails应用程序通常还会用Groovy Server Pages将模型数据以HTML的方式呈现给浏览器

到目前为止，我们都在用Thymeleaf模板定义阅读列表应用程序的视图。除了Thymeleaf，Spring Boot还支持Freemarker、Velocity和基于Groovy的模板。
无论选择哪种模板，你要做的就是添加合适的起步依赖，在Classpath根部的templates/目录里编写模板。自动配置会处理剩下的事情。

Grails项目也提供GSP的自动配置。如果你想在Spring Boot应用程序里使用GSP，必须向项目里添加Spring Boot的GSP库：
compile("org.grails:grails-gsp-spring-boot:1.0.0")

和Spring Boot提供的其他视图模板一样，库放在Classpath里就会触发自动配置，设置所需的视图解析器，以便在Spring MVC的视图层里使用GSP。

剩下的就是为应用程序编写GSP模板了。在阅读列表应用程序中，我们要把Thymeleaf的readingList.html 文件用GSP 的形式重写， 放在readingList.gsp 文件（ 位于src/main/resources/templates）里。

<!DOCTYPE html>
<html>
<head>
<title>Reading List</title>
<link rel="stylesheet" href="/style.css"></link>
</head>
<body>
<h2>Your Reading List</h2>
<g:if test="${books}">
<g:each in="${books}" var="book">
<dl>
<dt class="bookHeadline">
${book.title} by ${book.author}
(ISBN: ${book.isbn}")
</dt>
<dd class="bookDescription">
<g:if test="book.description">
${book.description}
</g:if>
<g:else>
No description available
</g:else>
</dd>
</dl>
</g:each>
</g:if>
<g:else>
<p>You have no books in your book list</p>
</g:else>
<hr/>
<h3>Add a book</h3>
<form method="POST">
<label for="title">Title:</label>
<input type="text" name="title"
value="${book?.title}"/><br/>
<label for="author">Author:</label>
<input type="text" name="author"
value="${book?.author}"/><br/>
<label for="isbn">ISBN:</label>
<input type="text" name="isbn"
value="${book?.isbn}"/><br/>
<label for="description">Description:</label><br/>
<textarea name="description" rows="5" cols="80">
${book?.description}
</textarea>
<input type="hidden" name="${_csrf.parameterName}"
value="${_csrf.token}" />
<input type="submit" value="Add Book" />
</form>
</body>
</html>

如你所见，GSP模板中使用了表达式语言引用（用${}包围的部分）以及GSP标签库（例如<g:if>和<g:each>）。这并不是Thymeleaf那样的纯HTML。但如果习惯用JSP，你会很熟悉这种方式，而且会觉得这是一个不错的选择。

代码里的绝大部分内容和第2章、第3章的Thymeleaf模板类似，映射GSP模板上的元素。但是有一点要注意，你必须要放一个隐藏域，其中包含CSRF（Cross-Site Request Forgery）令牌。SpringSecurity在提交POST请求时要求带有这个令牌，Thymeleaf在呈现HTML时会自动包含这个令牌，但在GSP里你必须在隐藏域显式地包含它。


Grails一直都是构建于Spring、Groovy、Hibernate和其他巨人肩膀之上的高阶框架。到了Grails3，Grails已经基于Spring Boot，带来了令人愉悦的开发体验。Grails开发者和Spring Boot开发者都能驾轻就熟。

创建项目
$ grails create-app readinglist

打开build.gradle文件，会发现一些更熟悉的东西。
首先，构建说明文件里使用了Spring Boot的Gradle插件：
apply plugin: "spring-boot"
这意味着你能像使用其他Spring Boot应用程序那样构建并运行这个Grails应用程序。

你还应该注意到，依赖里有不少有用的Spring Boot库：
dependencies {
compile 'org.springframework.boot:spring-boot-starter-logging'
compile("org.springframework.boot:spring-boot-starter-actuator")
compile "org.springframework.boot:spring-boot-autoconfigure"
compile "org.springframework.boot:spring-boot-starter-tomcat"
...
}
这些库为Grails应用程序提供了Spring Boot的自动配置、日志，还有Actuator及嵌入式Tomcat。把应用当作可执行JAR运行时，这个Tomcat可以提供服务。

实际上，这是一个Spring Boot项目，同时也是Grails项目，因为Grails 3就是构建在Spring Boot的基础上的。

运行Grails应用程序最直接的方式是在命令行里使用grails工具的run-app命令
$ grails run-app

Grails 3项目的Gradle说明里使用了Spring Boot的Gradle插件，你还可以用各种运行Spring Boot项目的方式来运行这个应用程序
此处通过Gradle引入了bootRun任务：
$ gradle bootRun

你还可以构建项目，运行生成的可执行JAR文件：
$ gradle build
...
$ java -jar build/lib/readingList-0.1.jar


阅读列表应用程序里的核心领域模型是Book类。虽然我们可以手工创建Book.groovy文件，但通常还是用grails工具来创建领域模型类比较好。因为它知道该把文件放到哪里，并且能在同一时间生成各种相关内容。

要创建Book类，我们会使用grails工具的create-domain-class命令：
$ grails create-domain-class Book
这条命令会生成两个源文件：一个Book.groovy文件和一个BookSpec.groovy文件。后者是一个Spock说明，用来测试Book类。一开始这个文件是空的，你可以填入各种测试内容来验证Book的各种功能。

Book.groovy文件里定义了Book类，你可以在grails-app/domain/readingList里找到这个文件。
它一开始基本没什么内容：
package readinglist
class Book {
	static constraints = {
	}
}

我们需要添加一些字段来定义一本书，比如书名、作者和ISBN。在添加了这些字段后，
Book.groovy看起来是这样的：
package readinglist
class Book {
	static constraints = {
	}

	String reader
	String isbn
	String title
	String author
	String description
}

静态的constraints变量里可以定义各种附加在Book实例上的验证约束


有了领域模型，通过grails工具创建出控制器就很容易了。关于控制器，有几个命令可供
选择。
create-controller：创建空控制器，让开发者来编写控制器的功能。
generate-controller：生成一个控制器，其中包含特定领域模型类的基本CRUD操作。
generate-all：生成针对特定领域模型类的基本CRUD控制器，及其视图。

我们用create-controller命令来创建原始的控制器，然后填入所需的方法。
$ grails create-controller ReadingList
这个命令会在grails-app/controllers/readingList里创建一个名为ReadingListController的控制器：
package readinglist
class ReadingListController {
	def index() { }
}

一行代码都不用改，这个控制器就能运行了，虽然它干不成什么事。此时，它能处理发往/readingList的请求，将请求转给grails-app/views/readingList/index.gsp里定义的视图（现在还没有，我们稍后会创建的）。

package readinglist
import static org.springframework.http.HttpStatus.*
import grails.transaction.Transactional
class ReadingListController {
	def index() {
		respond Book.list(params), model:[book: new Book()]
	}
	@Transactional
	def save(Book book) {
		book.reader = 'Craig'
		book.save flush:true
		redirect(action: "index")
	}
}

它可以处理发往/readingList的GET请求，获取并展示图书列表。在表单提交后，它还会处理POST请求，保存图书，随后重定向回index动作（由index()方法来处理）。

Grails应用程序通常都用GSP模板来做视图

<!DOCTYPE html>
<html>
<head>
<meta name="layout" content="main"/>
<title>Reading List</title>
<link rel="stylesheet"
href="/assets/main.css?compile=false" />
<link rel="stylesheet"
href="/assets/mobile.css?compile=false" />
<link rel="stylesheet"
href="/assets/application.css?compile=false" />
</head>
<body>
<h2>Your Reading List</h2>
<g:if test="${bookList && !bookList.isEmpty()}">
<g:each in="${bookList}" var="book">
<dl>
<dt class="bookHeadline">
${book.title}</span> by ${book.author}
(ISBN: ${book.isbn}")
</dt>
<dd class="bookDescription">
<g:if test="${book.description}">
${book.description}
</g:if>
<g:else>
No description available
</g:else>
</dd>
</dl>
</g:each>
</g:if>
<g:else>
<p>You have no books in your book list</p>
</g:else>
<hr/>
<h3>Add a book</h3>
<g:form action="save">
<fieldset class="form">
<label for="title">Title:</label>
<g:field type="text" name="title" value="${book?.title}"/><br/>
<label for="author">Author:</label>
<g:field type="text" name="author"
value="${book?.author}"/><br/>
<label for="isbn">ISBN:</label>
<g:field type="text" name="isbn" value="${book?.isbn}"/><br/>
<label for="description">Description:</label><br/>
<g:textArea name="description" value="${book?.description}"
rows="5" cols="80"/>
</fieldset>
<fieldset class="buttons">
<g:submitButton name="create" class="save"
value="${message(code: 'default.button.create.label',
default: 'Create')}" />
</fieldset>
</g:form>
</body>
</html>

在<head>元素里移除了引用样式表的<link>标签。这里放了一个<meta>标签，引入了Grails应用程序的main布局。这样一来，应用程序就能用上Grails的外观了，





108
chapter 7
actuator

我们将了解Spring Boot的Actuator。它提供了很多生产级的特性，比如监控和度量Spring Boot应用程序。Actuator的这些特性可以通过众多REST端点、远程shell和JMX获得。

Spring Boot Actuator的关键特性是在应用程序里提供众多Web端点，通过它们了解应用程序运行时的内部状况。有了Actuator，你可以知道Bean在Spring应用程序上下文里是如何组装在一起的，掌握应用程序可以获取的环境属性信息，获取运行时度量信息的快照

Actuator提供了13个端点

HTTP方法 	路径 	描述
GET 		/autoconfig 提供了一份自动配置报告，记录哪些自动配置条件通过了，哪些没通过
GET 		/configprops 描述配置属性（包含默认值）如何注入Bean
GET 		/beans 描述应用程序上下文里全部的Bean，以及它们的关系
GET 		/dump 获取线程活动的快照
GET 		/env 获取全部环境属性
GET 		/env/{name} 根据名称获取特定的环境属性值
GET 		/health 报告应用程序的健康指标，这些值由HealthIndicator的实现类提供
GET 		/info 获取应用程序的定制信息，这些信息由info打头的属性提供
GET 		/mappings 描述全部的URI路径，以及它们和控制器（包含Actuator端点）的映射关系
GET 		/metrics 报告各种应用程序度量信息，比如内存用量和HTTP请求计数
GET 		/metrics/{name} 报告指定名称的应用程序度量值
POST 		/shutdown 关闭应用程序，要求endpoints.shutdown.enabled设置为true
GET 		/trace 提供基本的HTTP请求跟踪信息（时间戳、HTTP头等）

端点可以分为三大类：配置端点、度量端点和其他端点。


要启用Actuator的端点，只需在项目中引入Actuator的起步依赖即可。在Gradle构建说明文件里，这个依赖是这样的：
compile 'org.springframework.boot:spring-boot-starter-actuator'

对于Maven项目，引入的依赖是这样的：
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

亦或你使用Spring Boot CLI，可以使用如下@Grab注解：
@Grab('spring-boot-starter-actuator')


关于Spring组件扫描和自动织入，最常遭人抱怨的问题之一就是很难看到应用程序中的组件是如何装配起来的。Spring Boot自动配置让这个问题变得更严重，因为Spring的配置更少了。

Actuator有一些端点不仅可以显示组件映射关系，还可以告诉你自动配置在配置Spring应用程序上下文时做了哪些决策。



要了解应用程序中Spring上下文的情况，最重要的端点就是/beans。它会返回一个JSON文档，描述上下文里每个Bean的情况，包括其Java类型以及注入的其他Bean。向/beans（在本地运行时是http://localhost:8080/beans）发起GET请求后，你会看到与代码清单7-1示例类似的信息。

[
{
"beans": [
{
"bean": "application",
"dependencies": [],
"resource": "null",
"scope": "singleton",
"type": "readinglist.Application$$EnhancerBySpringCGLIB$$f363c202"
},
{
"bean": "amazonProperties",
"dependencies": [],
"resource": "URL [jar:file:/../readinglist-0.0.1-SNAPSHOT.jar!
/readinglist/AmazonProperties.class]",
"scope": "singleton",
"type": "readinglist.AmazonProperties"
},
{
"bean": "readingListController",
"dependencies": [
"readingListRepository",
"amazonProperties"
],
"resource": "URL [jar:file:/../readinglist-0.0.1-SNAPSHOT.jar!
/readinglist/ReadingListController.class]",
"scope": "singleton",
"type": "readinglist.ReadingListController"
},
。。。。。。
"context": "application",
"parent": null
}
]

所有的Bean条目都有五类信息。
bean：Spring应用程序上下文中的Bean名称或ID。
resource：.class文件的物理位置，通常是一个URL，指向构建出的JAR文件。这会随着应用程序的构建和运行方式发生变化。
dependencies：当前Bean注入的Bean ID列表。
scope：Bean的作用域（通常是单例，这也是默认作用域）。
type：Bean的Java类型。


虽然Bean报告不用具体绘图告诉你Bean是如何装配的（例如，通过属性或构造方法），但它帮你直观地了解了应用程序上下文中Bean的关系。实际上，写出一个工具，把Bean报告处理一下，用图形化的方式来展现Bean关系，这并不难。请注意，完整的Bean报告会包含很多Bean，还有很多自动配置的Bean，画出来的图会非常复杂。



/beans端点产生的报告能告诉你Spring应用程序上下文里都有哪些Bean。/autoconfig端点能告诉你为什么会有这个Bean，或者为什么没有这个Bean。

Spring Boot自动配置构建于Spring的条件化配置之上。它提供了众多带有@Conditional注解的配置类，根据条件决定是否要自动配置这些Bean。/autoconfig端点提供了一个报告，列出了计算过的所有条件，根据条件是否通过进行分组。

{
"positiveMatches": {			// 成功条件
...
"DataSourceAutoConfiguration.JdbcTemplateConfiguration
#jdbcTemplate": [
{
"condition": "OnBeanCondition",
"message": "@ConditionalOnMissingBean (types:
org.springframework.jdbc.core.JdbcOperations;
SearchStrategy: all) found no beans"
}
],
...
},
"negativeMatches": {					// 失败条件
"ActiveMQAutoConfiguration": [
{
"condition": "OnClassCondition",
"message": "required @ConditionalOnClass classes not found:
javax.jms.ConnectionFactory,org.apache.activemq
.ActiveMQConnectionFactory"
}
],
...
}
}

在positiveMatches里，你会看到一个条件，决定Spring Boot是否自动配置JdbcTemplateBean。匹配到的名字是DataSourceAutoConfiguration.JdbcTemplateConfiguration#jdbcTemplate，这是运用了条件的具体配置类。条件类型是OnBeanCondition，意味着条件的输出是由某个Bean的存在与否来决定的。在本例中，message属性已经清晰地表明了该条件是检查是否有JdbcOperations类型（JbdcTemplate实现了该接口）的Bean存在。如果没有配置这种Bean，则条件成立，创建一个JdbcTemplate Bean。

与之类似，在negativeMatches里，有一个条件决定了是否要配置ActiveMQ。这是一个OnClassCondition ， 会检查Classpath 里是否存在ActiveMQConnectionFactory 。因为Classpath里没有这个类，条件不成立，所以不会自动配置ActiveMQ。


除了要知道应用程序的Bean是如何装配的，你可能还对能获取哪些环境属性，哪些配置属性注入了Bean里感兴趣。
/env端点会生成应用程序可用的所有环境属性的列表，无论这些属性是否用到。这其中包括环境变量、JVM属性、命令行参数，以及applicaition.properties或application.yml文件提供的属性。

的属性来源有很多，包括应用程序配置（application.yml）、Spring Profile、Servlet上下文初始化参数、系统环境变量和JVM系统属性。

所有名为password、secret、key（或者名字中最后一段是这些）的属性在/env里都会加上“*”。
举个例子，如果有一个属性名字是database.password，那么它在/env中的显示效果是这样的：
"database.password":"******"

/env端点还能用来获取单个属性的值，只需要在请求时在/env后加上属性名即可。举例来说，对阅读列表应用程序发起/env/amazon.associate_id请求，获得的结果是habuma-20（纯文本形式）。


回想第3章，这些环境属性可以通过@ConfigurationProperties注解很方便地使用。这些环境属性会注入带有@ConfigurationProperties注解的Bean的实例属性。/configprops端点会生成一个报告，说明如何进行设置（注入或其他方式）

{
"amazonProperties": {
"prefix": "amazon",
"properties": {
"associateId": "habuma-20"
}
},
...
"serverProperties": {
"prefix": "server",
"properties": {
"address": null,
"contextPath": null,
"port": null,
"servletPath": "/",
"sessionTimeout": null,
"ssl": null,
"tomcat": {
"accessLogEnabled": false,
"accessLogPattern": null,
"backgroundProcessorDelay": 30,
"basedir": null,
"compressableMimeTypes": "text/html,text/xml,text/plain",
"compression": "off",
"maxHttpHeaderSize": 0,
"maxThreads": 0,
"portHeader": null,
"protocolHeader": null,
"remoteIpHeader": null,
"uriEncoding": null
},
...
}
},
...
}

片段中的第一个内容是我们在第3章里创建的amazonProperties Bean。报告显示它添加了@ConfigurationProperties注解，前缀为amazon。associateId属性设置为habuma-20。这是因为在application.yml里，我们把amazon.associateId属性设置成了habuma-20。

除了展现运行中应用程序的配置属性如何设置，这个报告也能作为一个快速参考指南，告诉你有哪些属性可以设置。例如，如果你不清楚怎么设置嵌入式Tomcat服务器的最大线程数，可以看一下配置属性报告，里面会有一条server.tomcat.maxThreads，这就是你要找的属性。


在应用程序相对较小的时候，很容易搞清楚控制器都映射到了哪些端点上。如果Web界面的控制器和请求处理方法数量多，那最好能有一个列表，罗列出应用程序发布的全部端点。
/mappings端点就提供了这么一个列表

{
...
"{[/],methods=[GET],params=[],headers=[],consumes=[],produces=[],
custom=[]}": {
"bean": "requestMappingHandlerMapping",
"method": "public java.lang.String readinglist.ReadingListController.readersBooks(readinglist.Reader,org.springframework.ui.Model)"
},
"{[/],methods=[POST],params=[],headers=[],consumes=[],produces=[],
custom=[]}": {
"bean": "requestMappingHandlerMapping",
"method": "public java.lang.String readinglist.ReadingListController
.addToReadingList(readinglist.Reader,readinglist.
Book)"
},
"{[/autoconfig],methods=[GET],params=[],headers=[],consumes=[]
,produces=[],custom=[]}": {
"bean": "endpointHandlerMapping",
"method": "public java.lang.Object org.springframework.boot
.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()"
},
...
}

每个映射的键都是一个字符串，其内容就是Spring MVC的@RequestMapping注解上设置的属性。实际上，这个字符串能让你清晰地了解控制器是如何映射的，哪怕不看源代码。每个映射的值都有两个属性：bean和method。bean属性标识了SpringBean的名字，映射源自这个Bean。method属性是映射对应方法的全限定方法签名。



Actuator提供了一系列端点，让你能在运行时快速检查应用程序。

关于运行中的应用程序，有很多有趣而且有用的信息。举个例子，了解应用程序的内存情况（可用或空闲）有助于决定给JVM分配多少内存。对Web应用程序而言，不用查看Web服务器日志，如果请求失败或者是耗时太长，就可以大概知道内存的情况了。
运行中的应用程序有诸多计数器和度量器，/metrics端点提供了这些东西的快照。

{
mem: 198144,
mem.free: 144029,
processors: 8,
uptime: 1887794,
instance.uptime: 1871237,
systemload.average: 1.33251953125,
heap.committed: 198144,
heap.init: 131072,
heap.used: 54114,
heap: 1864192,
threads.peak: 21,
threads.daemon: 19,
threads: 21,
classes: 9749,
classes.loaded: 9749,
classes.unloaded: 0,
gc.ps_scavenge.count: 22,
gc.ps_scavenge.time: 122,
gc.ps_marksweep.count: 2,
gc.ps_marksweep.time: 156,
httpsessions.max: -1,
httpsessions.active: 1,
datasource.primary.active: 0,
datasource.primary.usage: 0,
counter.status.200.beans: 1,
counter.status.200.env: 1,
counter.status.200.login: 3,
counter.status.200.metrics: 2,
counter.status.200.root: 6,
counter.status.200.star-star: 9,
counter.status.302.login: 3,
counter.status.302.logout: 1,
counter.status.302.root: 5,
gauge.response.beans: 169,
gauge.response.env: 165,
gauge.response.login: 3,
gauge.response.logout: 0,
gauge.response.metrics: 2,
gauge.response.root: 11,
gauge.response.star-star: 2
}

/metrics端点提供了很多信息，逐行查看这些度量值太麻烦。表7-2根据所提供信息的类型对它们做了个分类。

分类	 前缀 	报告内容

垃圾收集器 		gc.* 已经发生过的垃圾收集次数，以及垃圾收集所耗费的时间，适用于标记-清理垃圾收集器和并行垃圾收集器（ 数据源自java.lang.management.
GarbageCollectorMXBean）

内存 		mem.* 分配给应用程序的内存数量和空闲的内存数量（数据源自java.lang.Runtime）

堆 		heap.* 当前内存用量（数据源自java.lang.management.MemoryUsage）

类加载器 	classes.* JVM类加载器加载与卸载的类的数量（数据源自java.lang.management.
ClassLoadingMXBean）

系统 	processors、uptime，instance.uptime、systemload.average	系统信息，例如处理器数量（数据源自java.lang.Runtime）、运行时间（数据源自java.lang.management.RuntimeMXBean）、平均负载（数据源自java.lang.management.OperatingSystemMXBean）

线程池		 threads.* 线程、守护线程的数量，以及JVM启动后的线程数量峰值（数据源自java.lang .management.ThreadMXBean）

数据源 		datasource.* 数据源连接的数量（源自数据源的元数据，仅当Spring应用程序上下文里存在DataSource Bean的时候才会有这个信息）

Tomcat会话		 httpsessions.* Tomcat的活跃会话数和最大会话数（数据源自嵌入式Tomcat的Bean，仅在使用嵌入式Tomcat服务器运行应用程序时才有这个信息）

HTTP counter.status.*、gauge.response.*	多种应用程序服务HTTP请求的度量值与计数器


你还可以注册自己的度量信息


root路径指向的是根路径或/。star-star代表了那些Spring
认为是静态资源的路径，包括图片、JavaScript和样式表，其中还包含了那些找不到的资源。这就是为什么你经常会看到counter.status.404.star-star，这是返回了HTTP 404 (NOT FOUND) 状态的请求数。

/metrics端点会返回所有的可用度量值，但你也可能只对某个值感兴趣。要获取单个值，请求时可以在URL后加上对应的键名。例如，要查看空闲内存大小，可以向/metrics/mem.free发一个GET请求：
$ curl localhost:8080/metrics/mem.free
144029


虽然响应里的Content-Type头设置为application/json;charset=UTF-8，但实际/metrics/{name}的结果是文本格式的。因此，如果需要的话，你也可以把它视为JSON来处理。



尽管/metrics端点提供了一些针对Web请求的基本计数器和计时器，但那些度量值缺少详细信息。知道所处理请求的更多信息是很有帮助的，尤其是在调试时，所以就有了/trace这个端点。
/trace端点能报告所有Web请求的详细信息，包括请求方法、路径、时间戳以及请求和响应的头信息。

[
...
{
"timestamp": 1426378239775,
"info": {
"method": "GET",
"path": "/metrics",
"headers": {
"request": {
"accept": "*/*",
"host": "localhost:8080",
"user-agent": "curl/7.37.1"
},
"response": {
"X-Content-Type-Options": "nosniff",
"X-XSS-Protection": "1; mode=block",
"Cache-Control":
"no-cache, no-store, max-age=0, must-revalidate",
"Pragma": "no-cache",
"Expires": "0",
"X-Frame-Options": "DENY",
"X-Application-Context": "application",
"Content-Type": "application/json;charset=UTF-8",
"Transfer-Encoding": "chunked",
"Date": "Sun, 15 Mar 2015 00:10:39 GMT",
"status": "200"
}
}
}
}
]

/trace端点实际能显示最近100个请求的信息，包含对/trace自己的请求。它在内存里维护了一个跟踪库。

稍后会看到创建一个自定义的跟踪库实现，以便将请求的跟踪持久化。


在确认应用程序运行情况时，除了跟踪请求，了解线程活动也会很有帮助。/dump端点会生成当前线程活动的快照。

完整的线程导出报告里会包含应用程序的每个线程。为了节省空间，代码清单7-8里只放了一个线程的内容片段。如你所见，其中包含很多线程的特定信息，还有线程相关的阻塞和锁状态。本例中，还有一个跟踪栈（stack trace），表明这是一个Tomcat容器线程。

[
{
"threadName": "container-0",
"threadId": 19,
"blockedTime": -1,
"blockedCount": 0,
"waitedTime": -1,
"waitedCount": 64,
"lockName": null,
"lockOwnerId": -1,
"lockOwnerName": null,
"inNative": false,
"suspended": false,
"threadState": "TIMED_WAITING",
"stackTrace": [
{
"className": "java.lang.Thread",
"fileName": "Thread.java",
"lineNumber": -2,
"methodName": "sleep",
"nativeMethod": true
},
{
"className": "org.springframework.boot.context.embedded.
tomcat.TomcatEmbeddedServletContainer$1",
"fileName": "TomcatEmbeddedServletContainer.java",
"lineNumber": 139,
"methodName": "run",
"nativeMethod": false
}
],
"lockedMonitors": [],
"lockedSynchronizers": [],
"lockInfo": null
},
...
]



如果你想知道自己的应用程序是否在运行，可以直接访问/health端点。在最简单的情况下，该端点会显示一个简单的JSON，内容如下：
{"status":"UP"}

status属性显示了应用程序在运行中。当然，它的确在运行，此处的响应无关紧要，任何输出都说明这个应用程序在运行。但/health端点可以输出的信息远远不止简单的UP状态。

/health端点输出的某些信息可能涉及内容，因此对未经授权的请求只能提供简单的健康状态。如果经过身份验证（比如你已经登录了），则可以提供更多信息
{
"status":"UP",
"diskSpace": {
"status":"UP",
"free":377423302656,
"threshold":10485760
},
"db":{
"status":"UP",
"database":"H2",
"hello":1
}
}
除了基本的健康状态，可用的磁盘空间以及应用程序正在使用的数据库状态也可以看到。

/health端点所提供的所有信息都是由一个或多个健康指示器提供的。表7-3列出了Spring Boot自带的健康指示器。

健康指示器 					键 		报告内容
ApplicationHealthIndicator 	none 	永远为UP
DataSourceHealthIndicator 	db 如果数据库能连上，则内容是UP和数据库类型；否则为DOWN
DiskSpaceHealthIndicator 	diskSpace 如果可用空间大于阈值，则内容为UP和可用磁盘空间；如果空间
不足则为DOWN
JmsHealthIndicator 		jms 如果能连上消息代理，则内容为UP和JMS提供方的名称；否则为
DOWN
MailHealthIndicator 	mail 如果能连上邮件服务器，则内容为UP和邮件服务器主机和端口；
否则为DOWN
MongoHealthIndicator 	mongo 如果能连上MongoDB服务器，则内容为UP和MongoDB服务器版
本；否则为DOWN
RabbitHealthIndicator 	rabbit 如果能连上RabbitMQ服务器，则内容为UP和版本号；否则为DOWN
RedisHealthIndicator 	redis 如果能连上服务器，则内容为UP和Redis服务器版本；否则为DOWN
SolrHealthIndicator 	solr 如果能连上Solr服务器，则内容为UP；否则为DOWN

这些健康指示器会按需自动配置。举例来说，如果Classpath里有javax.sql.DataSource，则会自动配置DataSourceHealthIndicator 。ApplicationHealthIndicator 和DiskSpaceHealthIndicator则会一直配置着。



假设你要关闭运行中的应用程序。比方说，在微服务架构中，你有多个微服务应用的实例运行在云上，其中某个实例有问题了，你决定关闭该实例并让云服务提供商为你重启这个有问题的应用程序。在这个场景中，Actuator的/shutdown端点就很有用了。

为了关闭应用程序，你要往/shutdown发送一个POST请求。例如，可以用命令行工具curl来关闭应用程序：
$ curl -X POST http://localhost:8080/shutdown

关闭运行中的应用程序是件危险的事情，因此这个端点默认是关闭的。如果没有显式地开启这个功能，那么POST请求的结果是这样的：
{"message":"This endpoint is disabled"}

要开启该端点，可以将endpoints.shutdown.enabled设置为true。举例来说，可以把如下内容加入application.yml，借此开启/shutdown端点：
endpoints:
	shutdown:
		enabled: true


/info端点能展示各种你希望发布的应用信息。针对该端点的GET请求的默认响应是这样的：
{}

可以通过配置带有info前缀的属性向/info端点的响应添加内容。例如，你希望在响应中添加联系邮箱。可以在application.yml里设置名为info.contactEmail的属性：
info:
	contactEmail: support@myreadinglist.com
现在再访问/info端点，就能得到如下响应：
{
"contactEmail":"support@myreadinglist.com"
}

info:
	contact:
		email: support@myreadinglist.com
		phone: 1-888-555-1971

/info端点返回的JSON会包含一个contact属性，其中有email和phone属性：
{
	"contact":{
		"email":"support@myreadinglist.com",
		"phone":"1-888-555-1971"
	}
}



Actuator通过REST端点提供了不少非常有用的信息。另一个深入运行中应用程序内部的方式是使用远程shell。Spring Boot集成了CRaSH，一种能嵌入任意Java应用程序的shell。Spring Boot还扩展了CRaSH，添加了不少Spring Boot特有的命令，提供了与Actuator端点类似的功能。
要使用远程shell，只需加入远程shell的起步依赖即可。你需要这样的Gradle依赖：
compile("org.springframework.boot:spring-boot-starter-remote-shell")
如果用Maven构建项目，你需要在pom.xml文件里添加如下依赖：
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-remote-shell</artifactId>
</dependency>
如果要用Spring Boot CLI来运行你所开发的应用程序，则需要如下@Grab注解：
@Grab("spring-boot-starter-remote-shell")

在启动的时候，可以看到要写进日志的一行密码。这行密码所在的行大概是这样的：
Using default security password: efe30c70-5bf0-43b1-9d50-c7a02dda7d79

与这个密码搭配使用的用户名是user。密码本身是随机生成的，每次运行应用程序时都会有所变化。

现在你可以通过SSH工具连接shell了，它监听的端口号是2000。如果你用的是Unix的ssh命
令，那么它看起来大概是这样的：
~% ssh user@localhost -p 2000
Password authentication
Password:
>

远程shell提供了24个可以在运行应用程序上下文中执行的命令，其中大部分都是CRaSH自带的。但Spring Boot也添加了一些。表7-4列出了这些Spring Boot特有的命令。

autoconfig	生成自动配置说明报告，和/autoconfig端点输出的内容类似，只是把JSON换成了纯文本
beans	 列出Spring应用程序上下文里的Bean，与/beans端点输出的内容类似
endpoint 	调用Actuator端点
metrics 	显示Spring Boot的度量信息，与/metrics端点类似，但显示的是实时更新的数据

autoconfig 命令生成了一个与Actuatord 的/autoconfig 端点类似的报告。
结果分为两组――匹配和不匹配，和/autoconfig端点的结果一样。

我不打算去讲CRaSH自己提供的shell命令，但你可能想把autoconfig命令的输出和CRaSH的less命令用管道串起来：
> autoconfig | less
less命令和Unix shell里的同名命令很相似，能让你穿梭于文件中。autoconfig的输出很长，但less命令会让它更容易读取和查阅。

beans命令的输出和/beans端点的输出一样
和/beans端点一样，beans命令会以JSON格式列出Spring应用程序上下文里所有的Bean，包括所依赖的Bean。


metrics，shell命令会输出与Actuator的/metrics端点一样的信息。/metrics端点以JSON格式输出当前度量信息的快照，而metrics命令则会接管shell，以实时仪表盘显示结果
一旦看完了metrics命令提供的度量信息，按Ctrl+C就能回到shell了。


并非所有的Actuator端点都有对应的shell命令。
虽然shell没能完全匹配上这些端点，但endpoint命令可以让你在shell里调用Actuator的端点。

首先，你要知道自己想调用哪个端点。在shell提示符中键入endpoint list就能获得端点的列表，列表中的端点用的是它们的Bean名称，而非URL路径。

如果想在shell里调用其中某个端点，你可以使用endpoint invoke命令，传入不带Endpoint后缀的Bean名称。举例来说，要调用健康检查端点，可以在shell提示符里键入endpoint invoke health
这些端点返回的信息都是原始格式的，即未格式化过的JSON文档。
你也可以创建一个自定义的CRaSH shell命令，通过管道接受未格式化的JSON，然后美化输出。你总是可以剪切黏贴endpoint命令的输出，将其放入你喜欢的工具进行阅读或格式化。


除了REST端点和远程shell，Actuator还把它的端点以MBean的方式发布了出来，可以通过JMX来查看和管理。使用JMX是管理Spring Boot应用程序的一个好方法

Actuator的端点都发布在org.springframework.boot域下。

JConsole工具


128
定制Actuator

Actuator有多种定制方式，包括以下五项。
? 重命名端点。
? 启用和禁用端点。
? 自定义度量信息。
? 创建自定义仓库来存储跟踪数据。
? 插入自定义的健康指示器。


重命名Actuator端点。
每个Actuator端点都有一个ID用来决定端点的路径，比方说，/beans端点的默认ID就是beans。如果端点的路径是由ID决定的，那么可以通过修改ID来改变端点的路径。你要做的就是设置一个属性，属性名是endpoints.endpoint-id.id。
。。这个属性怎么用。结合下面的关闭断点。可能是endpoints.shutdown.id=kill

我们用/shutdown端点来做个演示，它会响应发往/shutdown的POST请求。假设你想让它处理发往/kill的POST请求，可以通过如下YAML为/shutdown赋予一个新的ID，也就是新的路径：
endpoints:
	shutdown:
		id: kill

重命名端点并不能真的起到保护作用，顶多是让黑客慢点找到它们。


默认情况下，所有端点（除了/shutdown）都启用。我们已经看过如何设置endpoints.shutdown.enabled为true，以此开启/shutdown端点
用同样的方式，你可以禁用其他的端点，将endpoints.endpoint-id.enabled设置为false。

要禁用/metrics端点，你要做的就是将endpoints.metrics.enabled属性设置为false。在application.yml里做如下设置：
endpoints:
	metrics:
		enabled: false

endpoints:
	enabled: false
	metrics:
		enabled: true
正如以上片段所示，endpoints.enabled设置为false就能禁用Actuator的全部端点，然后将endpoints.metrics.enabled设置为true重新启用/metrics端点。


我们想要知道用户往阅读列表里保存了多少次图书，最简单的方法就是在每次调用ReadingListController的addToReadingList()方法时增加计数器值。计数器很容易实现，
但这个不断变化的总计值如何同/metrics端点发布的度量信息一起发布出来呢？
再假设我们想要获得最后保存图书的时间戳。时间戳可以通过调用System.currentTimeMillis()来获取，但如何在/metrics端点里报告该时间戳呢？
实际上，自动配置允许Actuator创建CounterService的实例，并将其注册为Spring的应用程序上下文中的Bean。CounterService这个接口里定义了三个方法，分别用来增加、减少或重置特定名称的度量值

package org.springframework.boot.actuate.metrics;
public interface CounterService {
	void increment(String metricName);
	void decrement(String metricName);
	void reset(String metricName);
}

Actuator的自动配置还会配置一个GaugeService类型的Bean。该接口与CounterService类似，能将某个值记录到特定名称的度量值里。GaugeService看起来是这样的：
package org.springframework.boot.actuate.metrics;
public interface GaugeService {
	void submit(String metricName, double value);
}

你无需实现这些接口。Spring Boot已经提供了两者的实现。我们所要做的就是把它们的实例注入所需的Bean，在适当的时候调用其中的方法，更新想要的度量值。

针对上文提到的需求，我们需要把CounterService和GaugeService Bean注入ReadingListController，然后在addToReadingList()方法里调用其中的方法。

@Controller
@RequestMapping("/")
@ConfigurationProperties("amazon")
public class ReadingListController {
	...
	private CounterService counterService;
	@Autowired			// constructor
	public ReadingListController(
	ReadingListRepository readingListRepository,
	AmazonProperties amazonProperties,
	CounterService counterService,
	GaugeService gaugeService) {
		this.readingListRepository = readingListRepository;
		this.amazonProperties = amazonProperties;
		this.counterService = counterService;
		this.gaugeService = gaugeService;
	}
	...
	@RequestMapping(method=RequestMethod.POST)
	public String addToReadingList(Reader reader, Book book) {
		book.setReader(reader);
		readingListRepository.save(book);
		counterService.increment("books.saved");	// 增加值
		gaugeService.submit("books.last.saved",		// 记录 System.currentTimeMillis());
		return "redirect:/";
	}
}
// 一个是简单的++，--，重置，，一个是设置值。


尽管CounterService和GaugeService用起来很简单，但还是有一些度量值很难通过增加计数器或记录指标值来捕获。对于那些情况，我们可以实现PublicMetrics接口，提供自己需要的度量信息。该接口定义了一个metrics()方法，返回一个Metric对象的集合：
package org.springframework.boot.actuate.endpoint;
public interface PublicMetrics {
	Collection<Metric<?>> metrics();
}


这里假设我们想报告一些源自Spring应用程序上下文的
度量值――应用程序上下文启动的时间、Bean及Bean定义的数量，这些都包含进来会很有意思。顺便再报告一下添加了@Controller 注解的Bean 的数量。

package readinglist;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.endpoint.PublicMetrics;
import org.springframework.boot.actuate.metrics.Metric;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
@Component
public class ApplicationContextMetrics implements PublicMetrics {
	private ApplicationContext context;

	@Autowired
	public ApplicationContextMetrics(ApplicationContext context) {
		this.context = context;
	}
	@Override
	public Collection<Metric<?>> metrics() {
		List<Metric<?>> metrics = new ArrayList<Metric<?>>();

		// 启动时间
		metrics.add(new Metric<Long>("spring.context.startup-date",
		context.getStartupDate()));

		// bean定义数量
		metrics.add(new Metric<Integer>("spring.beans.definitions",
		context.getBeanDefinitionCount()));

		// bean数量
		metrics.add(new Metric<Integer>("spring.beans",
		context.getBeanNamesForType(Object.class).length));

		// 控制器类型的bean数量
		metrics.add(new Metric<Integer>("spring.controllers",
		context.getBeanNamesForAnnotation(Controller.class).length));
		return metrics;
	}
}

Actuator会调用metrics()方法，收集ApplicationContextMetrics提供的度量信息。该方法调用了所注入的ApplicationContext上的方法，获取我们想要报告为度量的数量。每个度量值都会创建一个Metrics实例，指定度量的名称和值，将其加入要返回的列表。

创建ApplicationContextMetrics，并在ReadingListController里使用CounterService和GaugeService之后，我们可以在/metrics端点的响应中找到如下条目：
{
...
spring.context.startup-date: 1429398980443,
spring.beans.definitions: 261,
spring.beans: 272,
spring.controllers: 2,
books.count: 1,
gauge.books.save.time: 1429399793260,
...
}
为什么spring.controllers是2。因为这里算上了ReadingListController以及Spring Boot提供的BasicErrorController。

默认情况下，/trace端点报告的跟踪信息都存储在内存仓库里，100个条目封顶。一旦仓库满了，就开始移除老的条目，给新的条目腾出空间。

为了避免这个问题，你可以声明自己的InMemoryTraceRepository Bean，将它的容量调整至100以上。如下配置类可以将容量调整至1000个条目：
package readinglist;
import org.springframework.boot.actuate.trace.InMemoryTraceRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
@Configuration
public class ActuatorConfig {
	@Bean
	public InMemoryTraceRepository traceRepository() {
		InMemoryTraceRepository traceRepo = new InMemoryTraceRepository();
		traceRepo.setCapacity(1000);
		return traceRepo;
	}
}

这是一个内存存储的仓库，还要避免容量增长太多，影响应用程序的内存使用。

我们还可以将那些跟踪条目存储在其他地方――既不消耗内存，又能长久保存的地方。只需实现Spring Boot的TraceRepository接口即可：
package org.springframework.boot.actuate.trace;
import java.util.List;
import java.util.Map;
public interface TraceRepository {
	List<Trace> findAll();
	void add(Map<String, Object> traceInfo);
}

实现两个方法：一个方法查找所有存储的Trace对象，另一个保存了一个Trace，包含跟踪信息的Map对象

假设我们创建了一个使用MongoDB数据库存储跟踪信息的TraceRepository实例。

@Service
public class MongoTraceRepository implements TraceRepository {
	private MongoOperations mongoOps;
	@Autowired
	public MongoTraceRepository(MongoOperations mongoOps) {
		this.mongoOps = mongoOps;
	}
	@Override
	public List<Trace> findAll() {
		return mongoOps.findAll(Trace.class);
	}
	@Override
	public void add(Map<String, Object> traceInfo) {
		// new Trace
		mongoOps.save(new Trace(new Date(), traceInfo));
	}
}

需添加
MongoDB起步依赖即可。你需要如下Gradle依赖：
compile("org.springframework.boot:spring-boot-starter-data-mongodb")
如果你用的是Maven，则需要如下依赖：
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>


插入自定义健康指示器

查看amazon是否可以访问。
@Component
public class AmazonHealth implements HealthIndicator {
	@Override
	public Health health() {
		try {
			RestTemplate rest = new RestTemplate();
			rest.getForObject("http://www.amazon.com", String.class);
			return Health.up().build();
		} catch (Exception e) {
			return Health.down().build();
		}
	}
}

除了简单的状态之外，如果你还想向健康记录里添加其他附加信息，可以调用Health构造器的withDetail()方法。例如，要添加异常消息，将其作为健康记录的reason字段，可以让catch块返回这样一个Health对象：
return Health.down().withDetail("reason", e.getMessage()).build();

修改后，当Amazon无法访问时，健康记录看起来是这样的：
"amazonHealth": {
	"reason": "I/O error on GET request for
	\"http://www.amazon.com\":www.amazon.com;
	nested exception is java.net.UnknownHostException:
	www.amazon.com",
	"status": "DOWN"
},

如果有很多附加信息，可以多次调用withDetail()方法，每次设置一个要放入健康记录的附加字段。



Actuator的端点保护可以用和其他URL路径一样的方式――使用Spring Security。在Spring Boot应用程序中，这意味着将Security起步依赖作为构建依赖加入，然后让安全相关的自动配置来保护应用程序，其中当然也包括了Actuator端点。

保护/shutdown端点，仅允许拥有ADMIN权限的用户访问，
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	.authorizeRequests()
	.antMatchers("/").access("hasRole('READER')")
	.antMatchers("/shutdown").access("hasRole('ADMIN')")
	.antMatchers("/**").permitAll()
	.and()
	.formLogin()
	.loginPage("/login")
	.failureUrl("/login?error=true");
}

第3章里的自定义UserDetailsService只对通过ReaderRepository加载的用户赋予READER权限。因此，你需要创建一个更聪明的UserDetailsService实现，对某些用户赋予ADMIN权限。你可以配置一个额外的身份验证实现

添加一个内存里的admin用户
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth.userDetailsService(new UserDetailsService() {
		@Override
		public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {		// reader
			UserDetails user = readerRepository.findOne(username);
			if (user != null) {
				return user;
			}
			throw new UsernameNotFoundException("User '" + username + "' not found.");
		}
	})
	.and()
	.inMemoryAuthentication()
	.withUser("admin").password("s3cr3t")		// admin
	.roles("ADMIN", "READER");
}


要保护/metrics 、/confiprops 和/shutdown ， 可以像这样调用antMatchers()：
.antMatchers("/shutdown", "/metrics", "/configprops").access("hasRole('ADMIN')")

比起在调用antMatchers()方法时显式地列出所有的Actuator端点，用通配符在一个简单的Ant风格表达式里匹配全部的Actuator端点更容易。但是，这么做也小有点挑战，因为不同的端点路径之间没有什么共同点，我们也不能在/**上运用ADMIN权限。这样一来，除了根路径（/）之外，什么要有ADMIN权限。

为此，可以通过management.context-path属性设置端点的上下文路径。默认情况下，这个属性是空的，所以Actuator的端点路径都是相对于根路径的。在application.yaml里增加如下内容，可以让这些端点都带上/mgmt前缀。

management:
	context-path: /mgmt
你也可以在application.properties里做类似的事情：
management.context-path=/mgmt
将management.context-path设置为/mgmt后，所有的Actuator端点都会与/mgmt路径相关。例如，/metrics端点的URL会变为/mgmt/metrics。

有了这个新的路径，我们就有了公共的前缀，在为Actuator端点赋予ADMIN权限限制时就能借助这个公共前缀：
.antMatchers("/mgmt/**").access("hasRole('ADMIN')")


chapter8

大部分Java Web应用程序都以WAR文件的形式部署到应用服务器上。Spring Boot提供的部署方式则有所不同，后者在部署上提供了不少选择。

Spring Boot应用程序有多种构建和运行方式，其中一些你已经使用过了。

在IDE中运行应用程序（涉及Spring ToolSuite或IntelliJ IDEA）。
使用Maven的spring-boot:run或Gradle的bootRun，在命令行里运行。
使用Maven或Gradle生成可运行的JAR文件，随后在命令行中运行。
使用Spring Boot CLI在命令行中运行Groovy脚本。
使用Spring Boot CLI来生成可运行的JAR文件，随后在命令行中运行。

针对应用服务器的部署，你需要将应用程序打包成一个WAR文件。

Spring Boot应用程序可以用多种方式打包，
部署产物		 产生方式 			目标环境
Groovy源码 	 手写	 	Cloud Foundry及容器部署，比如Docker
可执行JAR 		Maven、Gradle或Spring Boot CLI 		云环境，包括Cloud Foundry和Heroku，还有容器部署，比如Docker
WAR			 Maven或Gradle			 Java应用服务器或云环境，比如Cloud Foundry


归功于Spring Boot的自动配置功能，我们不需要创建web.xml文件或者Servlet初始化类来声明Spring MVC的DispatcherServlet。但如果要将应用程序部署到Java应用服务器里，我们就需要构建WAR文件了

使用Gradle来构建应用程序，只需应用WAR插件即可：
apply plugin: 'war'
随后，在build.gradle里用以下war配置替换原来的jar配置：
war {
	baseName = 'readinglist'
	version = '0.0.1-SNAPSHOT'
}

如果使用Maven构建项目，获取WAR文件会更容易。只需把<packaging>元素的值从jar改为war。
<packaging>war</packaging>

这样就能生成WAR文件了。但如果WAR文件里没有启用Spring MVC DispatcherServlet的web.xml文件或者Servlet初始化类，这个WAR文件就一无是处。

Spring Boot它提供的SpringBootServletInitializer是一个支持Spring Boot的Spring WebApplicationInitializer实现。除了配置Spring的DispatcherServlet，SpringBootServletInitializer还会在Spring应用程序上下文里查找Filter、Servlet或ServletContextInitializer类型的Bean，把它们绑定到Servlet容器里。

要使用SpringBootServletInitializer，只需创建一个子类，覆盖configure()方法来指定Spring配置类

package readinglist;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.context.web.SpringBootServletInitializer;
public class ReadingListServletInitializer extends SpringBootServletInitializer {
@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
			// 指定spring配置
		return builder.sources(Application.class);
	}
}

configure()方法传入了一个SpringApplicationBuilder参数，并将其作为结果返回。期间它调用sources() 方法注册了一个Spring 配置类。本例只注册了一个Application类。回想一下，这个类既是启动类（带有main()方法），也是一个Spring配置类。

虽然阅读列表应用程序里还有其他Spring配置类，但没有必要在这里把它们全部注册进来。Application类上添加了@SpringBootApplication注解。这会隐性开启组件扫描，而组件扫描则会发现并应用其他配置类。

构建应用程序
$ gradle build
在build/libs中看到一个名为readinglist-0.0.1-SNAPSHOT.war的文件

$ mvn package
target目录里找到WAR文件。

对于Tomcat而言，可以把WAR文件复制到Tomcat的webapps目录里。如果Tomcat正在运行（要是没有运行，则在下次启动时检测），则会检测到WAR文件，解压并进行安装。

假设你没有在部署前重命名WAR文件， Servlet上下文路径会与WAR文件的主文件名相同，在本例中是/readinglist-0.0.1-SNAPSHOT。用你的浏览器打开http://server:port/readinglist-0.0.1-SNAPSHOT就能访问应用程序了。

还有一点值得注意：就算我们在构建的是WAR文件，这个文件仍旧可以脱离应用服务器直接运行。如果你没有删除Application里的main()方法，构建过程生成的WAR文件仍可直接运行，一如可执行的JAR文件：
$ java -jar readinglist-0.0.1-SNAPSHOT.war


假设我们想使用运行localhost上的PostgreSQL数据库，数据库名字是readingList。下面
的@Bean方法就能声明我们的DataSource Bean：
@Bean
@Profile("production")
public DataSource dataSource() {
	DataSource ds = new DataSource();
	ds.setDriverClassName("org.postgresql.Driver");
	ds.setUrl("jdbc:postgresql://localhost:5432/readinglist");
	ds.setUsername("habuma");
	ds.setPassword("password");
	return ds;
}

这里DataSource的类型是Tomcat的org.apache.tomcat.jdbc.pool.DataSource，不要和javax.sql.DataSource搞混了。前者是后者的实现。
连接数据库所需的细节（包括JDBC驱动类名、数据库URL、用户名和密码）提供给了DataSourse实例。声明了这个Bean之后，默认自动配置的DataSource Bean就会忽略。

这个@Bean方法最关键的一点是，它还添加了@Profile注解，说明只有在productionProfile被激活时才会创建该Bean。所以，在开发时我们还能继续使用嵌入式的H2数据库

虽然这么做能达到目的，但是配置数据库细节的时候，最好还是不要显式地声明自己的DataSource Bean 。在不替换自动配置的Datasource Bean 的情况下， 我们还能通过application.yml或application.properties来配置数据库的细节。

DataSource配置属性
属性（带有spring.datasource.前缀）		 描 述
name 								数据源的名称
initialize 					是否执行data.sql（默认：true）
schema 							Schema（DDL）脚本资源的名称
data 						数据（DML）脚本资源的名称
sql-script-encoding 				读入SQL脚本的字符集
platform 									读入Schema资源时所使用的平台（例如：schema-{platform}.sql）
continue-on-error 						如果初始化失败是否还要继续（默认：false）
separator 						SQL脚本的分隔符（默认：;）
driver-class-name 									JDBC驱动的全限定类名（通常能通过URL自动推断出来）
url								 数据库URL
username 								数据库的用户名
password 								数据库的密码
jndi-name 						通过JNDI查找数据源的JNDI名称
max-active						 最大的活跃连接数（默认：100）
max-idle					 最大的闲置连接数（默认：8）
min-idle 					最小的闲置连接数（默认：8）
initial-size 				连接池的初始大小（默认：10）
validation-query 				用来验证连接的查询语句
test-on-borrow 						从连接池借用连接时是否检查连接（默认：false）
test-on-return 						向连接池归还连接时是否检查连接（默认：false）
test-while-idle 								连接空闲时是否测试连接（默认：false）
time-between-eviction-runs-millis 									多久（单位为毫秒）清理一次连接（默认：5000）
min-evictable-idle-time-millis 								在被测试是否要清理前，连接最少可以空闲多久（单位为毫秒，默认：
60000）
max-wait 											当没有可用连接时，连接池在返回失败前最多等多久（单位为毫秒，默
认：30000）
jmx-enabled 						数据源是否可以通过JMX进行管理（默认：false）

我们现在要设置属性，让DataSource Bean指向PostgreSQL而非内嵌的H2数据库。具体来说，我们要设置的是spring.datasource.url、spring.datasource.username以及spring.datasource.password属性。

在设置这些内容时，我在本地运行了一个PostgreSQL数据库，监听5432端口。用户名和密码
分别是habuma和password。因此，application.yml的production Profile里需要如下内容：
---
spring:
	profiles: production
	datasource:
		url: jdbc:postgresql://localhost:5432/readinglist
		username: habuma
		password: password
	jpa:
		database-platform: org.hibernate.dialect.PostgreSQLDialect

请注意，这个代码片段以---开头，设置的第一个属性是spring.profiles。这说明随后的属性都只在productionProfile激活时才会生效。


要开启这个Profile，我们需要把spring.profiles.active属性设置为production。实现方式有很多，但最方便的还是在运行应用服务器的机器上设置一个系统环境变量。在启动Tomcat前开启productionProfile，我需要像这样设置SPRING_PROFILES_ACTIVE环境变量：
$ export SPRING_PROFILES_ACTIVE=production
你也许已经注意到了，SPRING_PROFILES_ACTIVE不同于spring.profiles.active。因为无法在环境变量名里使用句点，所以变量名需要稍作修改。站在Spring的角度看，这两个名字是等价的。

默认情况下，在使用内嵌的H2数据库时，Spring Boot会配置Hibernate来自动创建Schema。更确切地说，这是将Hibernate的hibernate.hbm2ddl.auto设置为create-drop，说明在Hibernate的SessionFactory创建时会创建Schema，SessionFactory关闭时删除Schema。
但如果没使用内嵌的H2数据库，那么它什么都不会做。也就是，说应用程序的数据表尚不存在，在查询那些不存在的表时会报错。

一种途径是通过Spring Boot的spring.jpa.hibernate.ddl-auto属性将hibernate.hbm2ddl.auto属性设置为create、create-drop或update。例如，要把hibernate.hbm2ddl.auto设置为create-drop，我们可以在application.yml里加入如下内容：
spring:
	jpa:
		hibernate:
			ddl-auto: create-drop

这对生产环境来说并不理想，因为应用程序每次重启数据库，Schema就会被清空。它可以设置为update，但就算这样，我们也不建议将其用于生产环境。
还有一个途径。我们可以在schema.sql里定义Schema。在第一次运行时，这么做没有问题，但随后每次启动应用程序时，这个初始化脚本都会失败，因为数据表已经存在了。这就要求在书写初始化脚本时格外注意，不要重复执行那些已经做过的工作。

一个比较好的选择是使用数据库迁移库（database migration library）。它使用一系列数据库脚本，而且会记录哪些已经用过了，不会多次运用同一个脚本。应用程序的每个部署包里都包含了这些脚本，数据库可以和应用程序保持一致。

Spring Boot为两款流行的数据库迁移库提供了自动配置支持。
? Flyway（http://flywaydb.org）
? Liquibase（http://www.liquibase.org）


146

Flyway是一个非常简单的开源数据库迁移库，使用SQL来定义迁移脚本。它的理念是，每个脚本都有一个版本号，Flyway会顺序执行这些脚本，让数据库达到期望的状态。它也会记录已执行的脚本状态，不会重复执行。

从空数据库到可用状态的Flyway脚本。
create table Reader (
id serial primary key,
username varchar(25) unique not null,
password varchar(25) not null,
fullname varchar(50) not null
);
create table Book (
id serial primary key,
author varchar(50) not null,
description varchar(1000) not null,
isbn varchar(10) not null,
title varchar(250) not null,
reader_username varchar(25) not null,
foreign key (reader_username) references Reader(username)
);
create sequence hibernate_sequence;
insert into Reader (username, password, fullname) values ('craig', 'password', 'Craig Walls');

Flyway脚本就是SQL。
让其发挥作用的是其在Classpath里的位置和文件名。Flyway脚本都遵循一个命名规范，含有版本号。
V2__initialize.sql
版本__描述
2个下划线。

所有Flyway脚本的名字都以大写字母V开头，随后是脚本的版本号。后面跟着两个下划线和对脚本的描述。

Flyway脚本需要放在相对于应用程序Classpath根路径的/db/migration路径下。因此，项目中，脚本需要放在src/main/resources/db/migration里。

需要将spring.jpa.hibernate.ddl-auto设置为none，由此告知Hibernate不要创建数据表。
spring:
	jpa:
		hibernate:
			ddl-auto: none

将Flyway添加为项目依赖。在Gradle里，此依赖是这样的：
compile("org.flywaydb:flyway-core")
在Maven项目里，<dependency>是这样的：
<dependency>
	<groupId>org.flywayfb</groupId>
	<artifactId>flyway-core</artifactId>
</dependency>

在应用程序部署并运行起来后，Spring Boot会检测到Classpath里的Flyway，自动配置所需的Bean。Flyway会依次查看/db/migration里的脚本，如果没有执行过就运行这些脚本。每个脚本都执行过后，向schema_version表里写一条记录。应用程序下次启动时，Flyway会先看schema_version里的记录，跳过那些脚本。


使用SQL来定义迁移脚本是一把双刃剑。SQL用起来便捷顺手，却要冒着只能在一个数据库平台上使用的风险。

Liquibase并不局限于特定平台的SQL，可以用多种格式书写迁移脚本，不用关心底层平台（其中包括XML、YAML和JSON）。如果你有这个期望的话，Liquibase当然也支持SQL脚本。

添加依赖。Gradle里的依赖是这样的：
compile("org.liquibase:liquibase-core")
对于Maven项目，你需要添加如下<dependency>：
<dependency>
	<groupId>org.liquibase</groupId>
	<artifactId>liquibase-core</artifactId>
</dependency>

有了这个依赖，Spring Boot自动配置就能接手，配置好用于支持Liquibase的Bean。默认情况下，那些Bean会在/db/changelog（相对于Classpath根目录）里查找db.changelog-master.yaml文件。

databaseChangeLog:
	- changeSet:
		id: 1
		author: habuma
		changes:
			- createTable:
				tableName: reader
				columns:
					- column:
						name: username
						type: varchar(25)
						constraints:
							unique: true
							nullable: false
					- column:
						name: password
						type: varchar(25)
						constraints:
							nullable: false
					- column:
						name: fullname
						type: varchar(50)
						constraints:
							nullable: false
			- createTable:
				tableName: book
。。。

- createSequence:
	sequenceName: hibernate_sequence
- insert:
	tableName: reader
	columns:
		- column:
			name: username
			value: craig
		- column:
			name: password
			value: password
		- column:
			name: fullname
			value: Craig Walls
。。

YAML格式略显繁琐，但看起来还是很清晰的，而且这个脚本不与任何特定的数据库平台绑定。

与Flyway不同，Flyway有多个脚本，每个脚本对应一个变更集。Liquibase变更集都集中在一个文件里。请注意，changeset命令后的那行有一个id属性，要对数据库进行后续变更。可以添加一个新的changeset，只要id不一样就行。此外，id属性也不一定是数字，可以包含任意内容。

应用程序启动时，Liquibase会读取db.changelog-master.yaml里的变更集指令集，与之前写入databaseChangeLog表里的内容做对比，随后执行未运行过的变更集

这里的例子使用的是YAML格式，但你也可以任意选择Liquibase所支持的其他格式，比如XML或JSON。只需简单地设置liquibase.change-log属性（在application.properties或application.yml里），标明希望Liquibase加载的文件即可。举个例子，要使用XML变更集，可以这样设置liquibase.change-log：
liquibase:
change-log: classpath:/db/changelog/db.changelog-master.xml


目前有多个云平台可供选择，而那些提供Platform as a Service（PaaS）能力的平台无疑是最有吸引力的。PaaS提供了现成的应用程序部署平台，带有附加服务（比如数据库和消息代理），可以绑定到应用程序上。除此之外，当你的应用程序要求提供更大的马力时，云平台能轻松实现应用程序在运行时向上（或向下）伸缩，只需添加或删除实例即可。

部署到Cloud Foundry
Cloud Foundry是Pivotal的PaaS平台

在注册了PWS后，可以从https://console.run.pivotal.io/tools下载并安装cf命令行工具。你可以通过这个工具将应用程序推上Cloud Foundry

$ cf login -a https://api.run.pivotal.io
API endpoint: https://api.run.pivotal.io
Email> {your email}
Password> {your password}
Authenticating...
OK

项目已经做好了部署到Cloud Foundry的准备，只需使用cf push命令把它推上去就好。
$ cf push sbia-readinglist -p build/libs/readinglist.war

cf push命令的第一个参数指定了应用程序在Cloud Foundry里的名称。这个名称将被用作托管应用程序的子域名。本例中，应用程序的完整域名将是http://sbia-readinglist.cfapps.io

名字必须独一无二，这样才不会和Cloud Foundry里部署的其他应用程序（包括其他用户部署的应用程序）发生冲突。

因为空想一个独一无二的名称有点困难，所以cf push命令提供了一个--random-route选项，可以为你随机产生一个子域名

$ cf push sbia-readinglist -p build/libs/readinglist.war --random-route

在使用了--random-route后，还是要设定应用程序名称。会有两个随机选择的单词添加到后面，组成子域名。（在我自己尝试的时候，生成的子域名是sbia-readinglist-gastroenterologicalstethoscope
。）

虽然我们部署的应用程序是一个WAR文件，但Cloud Foundry也可以部署其他格式的Spring Boot应用程序，包括可执行的JAR文件，甚至Spring BootCLI开发的未经编译的Groovy脚本。

elephantsql服务也有不少计划可选，小到开发用的小型数据库，大到工业级生产数据库。elephantsql的完整计划列表可以通过cf marketplace命令获得。

$ cf marketplace -s elephantsql
Getting service plan information for service elephantsql as craig@habuma.com...
OK
service plan 		description 		free or paid
turtle 				Tiny Turtle 		free
panda 				Pretty Panda 		paid
hippo 				Happy Hippo 		paid
elephant 			Enormous Elephant 	paid

创建数据库服务的实例，需要使用cf create-service命令，指定服务名、计划名和实
例名。
$ cf create-service elephantsql turtle readinglistdb
Creating service readinglistdb in org habuma /
	space development as craig@habuma.com...
OK
服务创建后，需要通过cf bind-service命令将它绑定到我们的应用程序上。
$ cf bind-service sbia-readinglist readinglistdb

将一个服务绑定到应用程序上不过就是为应用程序提供了连接服务的细节，这里用的是名为VCAP_SERVICES的环境变量。它不会通过修改应用程序来使用服务。
我们可以改写阅读列表应用程序，读取VCAP_SERVICES，使用其中提供的信息来连接数据库服务。但其实完全不用这么做。实际上，我们只需用cf restage命令重启应用程序就可以了：
$ cf restage sbia-readinglist

cf restage命令会让Cloud Foundry重新部署应用程序，并重新计算VCAP_SERVICES的值。如此一来，我们的应用程序会在Spring应用程序上下文里声明一个引用了绑定数据库服务的DataSource Bean，用它来替换原来的DataSource Bean。


Heroku在应用程序部署上有一套独特的方法，不用部署完整的部署产物。Heroku为你的应用程序安排了一个Git仓库。每当你向仓库里提交代码时，它都会自动为你构建并部署应用程序。

$ git init
这样Heroku的命令行工具就能自动把远程Heroku Git仓库添加到项目里。
现在可以通过Heroku的命令行工具在Heroku中设置应用程序了。这里使用apps:create命令。
$ heroku apps:create sbia-readinglist

这里我要求Heroku将应用程序命名为sbia-readinglist。这将成为Git仓库的名字，同时也是应用程序在herokuapps.com的子域名。你需要确定这个名字唯一，因为不能有同名应用程序。此外，也可以让Heroku替你生成一个独特的名字（比如fierce-river-8120或serene-anchorage-6223）。

apps:create命令会在https://git.heroku.com/sbia-readinglist.git创建一个远程Git仓库，并在本地项目的Git配置里添加一个名为heroku的远程仓库引用

Heroku需要你提供一个名为Procfile的文件，告诉Heroku应用程序构建后该如何运行。对于阅读列表应用程序而言，我们需要告诉Heroku，构建生成的WAR文件要当作可执行JAR文件来运行，这里使用java命令。假设应用程序是用Gradle来构建的，只需要如下一行内容的Procfile：
web: java -Dserver.port=$PORT -jar build/libs/readinglist.war

另一方面，如果你使用Maven来构建项目，JAR文件的路径就会有所不同。Heroku需要到target目录，而不是build/libs目录里寻找可执行WAR文件。具体如下：
web: java -Dserver.port=$PORT -jar target/readinglist.war

不管何种情况，你都需要像例子中那样设置server.port属性。这样内嵌的Tomcat服务器才能在Heroku分配的端口上（通过$PORT变量指定）启动。
但Gradle构建说明还要稍作调整。Heroku构建应用程序时，会执行一个名为stage的任务，因此需要在build.gradle里添加这个stage任务。
task stage(dependsOn: ['build']) {
}
这个stage任务什么也没做，但依赖了build任务。于是，在Heroku使用stage任务构建应用程序会触发build任务，生成的JAR文件会放在build/libs目录里。

还需要告诉Heroku用什么Java版本来构建并运行应用程序。
最简单的方法是在项目根目录里创一个名为system.properties的文件，在其中设置java.runtime.version属性：
java.runtime.version=1.7

只需将代码推到远程Git仓库，Heroku会帮我们搞定其他事情。
$ git commit -am "Initial commit"
$ git push heroku master

可以通过Heroku命令行工具的addons:add命令创建并绑定一个PostgreSQL服务。
$ heroku addons:add heroku-postgresql:hobby-dev
这里我们要使用名为heroku-postgresql的附加服务。这是Heroku提供的PostgreSQL服务。我们还要求使用该服务的hobby-dev计划，这是免费的。

在PostgreSQL服务创建并绑定到应用程序后，Heroku会自动重启应用程序以保证绑定生效。但即便如此，我们在访问/health端点时仍然会看到应用程序还在使用内嵌的H2数据库。那是因为H2的自动配置仍然有效，谁也没告诉Spring Boot要用PostgreSQL代替H2。

一个办法是设置spring.datasource.*属性，做法和我们将应用程序部署到应用服务器上时一样。我们所需要的信息能在数据库服务的仪表板上找到，可以用addons:open命令打开仪表板。
$ heroku addons:open waking-carefully-3728

在这个例子里，数据库实例的名字是waking-carefully-3728。该命令会在Web浏览器里打开仪表板页面，其中包含了你所需要的全部连接信息，包括主机名、数据库名和账户信息。总之，设置spring.datasource.*属性所需的一切信息都在这里了。

还有一个更简单的办法，与其自己查找那些信息，再设置到属性里，为什么不让Spring替我们查找信息呢？实际上，这就是Spring Cloud Connectors的用途。它可以用在Cloud Foundry和Heroku上，查找绑定到应用程序上的所有服务，并自动配置应用程序，以便使用那些服务。

只需在项目中加入Spring Cloud Connectors依赖即可。在Gradle项目里，在build.gradle中添加如下内容：
compile(
"org.springframework.boot:spring-boot-starter-cloud-connectors")
如果你用的是Maven，则添加如下Spring Cloud Connectors<dependency>：
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-cloud-connectors</artifactId>
</dependency>

只有激活cloud Profile，Spring Cloud Connectors才会工作。要在Heroku里激活cloud Profile，可以使用config:set命令：
$ heroku config:set SPRING_PROFILES_ACTIVE="cloud"

现在项目里有了Spring Cloud Connectors依赖，cloud Profile也激活了。我们可以再推一次应用程序。
$ git commit -am "Add cloud connector"
$ git push heroku master


157
附录A spring boot 开发者工具


























actuator
把spring的各种信息可视化。
autoconfig		提供一份自动配置报告，记录哪些自动配置条件通过了，哪些没有。
configprops		描述配置属性(包括默认值)如何注入bean
beans		描述上下文中所有的bean以及它们的关系
dump	获取线程活动的快照
env		全部环境属性
env/{name}		根据名称获取特定的环境属性值
health		报告应用程序的健康指标，这些值有HealthIndicator的实现类提供。
info	获取应用程序的定制信息，这些信息有info打头的属性提供
mappings	描述全部URI
metrics		报告各种应用程序度量信息，如内存用量和Http请求计数
metrics/{name}	报告指定名称的应用程序度量值
/shutdown	关闭应用程序，要求endpoints.shutdown.enabled设置为true
/trace	提供基本的HTTP请求跟踪信息(时间戳，http头等)






spring boot应用程序有多种构建和运行方式：
在ide中运行(涉及spring tool suite， InterlliJ IDEA)
使用maven的spring-boot:run或gradle的bootrun，在命令行中运行
使用maven或gradle生成可运行的jar文件，随后在命令行中运行
使用spring boot CLI在命令行中运行groovy脚步。
使用spring boot CLI来生成可运行kar文件，随后在命令行中运行。

package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库
install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库
deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库　　












=============================
spring cloud 微服务实战 - 翟永超， 不是in action系列
40%大小


微服务：Microservices，来自Martin Fowler


微服务是系统架构上一种设计风格，主旨是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于Http的RESTful-API进行通信协作。被拆分出的每一个小型服务都是围绕着系统中的某一项或一些耦合度较高的业务功能进行构建，并且每个服务维护着自身的数据存储，业务开发，自动化测试案例以及独立部署机制。由于有了轻量级的通信协作基础，所以这些微服务可以使用不同的语言来编写。

传统企业系统架构中，我们针对一个复杂的业务需求通常使用对象或业务类型来构建一个单体项目。项目中通常将需求分为3个主要部分：数据库，服务端处理器，前端展现。
随着企业发展，系统为了应对不同的业务需求会不断为该单体项目增加不同业务模块。后续还需要在移动端展现，后端向前端的支持需要更多的接口模块。
单体应用的问题就逐渐凸显，由于单体系统部署在一个进程内，往往我们修改一个很小的功能，为了部署上线会影响其他功能的运行。并且单体应用中这些功能模块的使用场景，并发量，消耗的资源类型各不相同，对于资源的利用都互相影响，这使得我们对各个业务模块的系统容量很难给出准确的评估。
所以，单体系统在初期可以非常方面地进行开发和使用，但随着系统发展，维护成本会越来越大，且难以控制。

将不同功能模块拆分成不同服务，这些服务都能独立部署和扩展。
由于每个服务都运行在自己的进程内，在部署上有稳固的边界，这样每个服务的更新都不会影响其他服务的运行。由于是独立部署，我们可以更精确地为每个服务评估性能容量，通过配合服务间的协作流程也可以更容易地发现系统的瓶颈位置。


由服务的拆分引发了诸多在单体应用中没有的问题。
运维的新挑战：运维需要维护的进程数量大大增加。运维过程需要更多的自动化，这就要求运维人员具有一定的开发能力来编排运维过程并让它们能自动运行起来。
接口的一致性：虽然拆分了服务，但是业务逻辑上的依赖依然在，只是从单体应用中的代码依赖变成了服务间的通信依赖。当我们对原有接口进行一些修改，那么交互方也需要协调这样的改变来进行发布。我们需要更完善的接口和版本管理，或是严格地遵循开闭原则。
分布式的复杂性：拆分后各个微服务都是独立部署并运行在各自的进程内，它们只能通过通信来协作，so分布式问题是微服务架构系统设计时需要考虑的重要因素，如网络延迟，分布式事务，异步消息等。

微服务有缺点和问题，但其实现的敏捷开发和自动化部署等优点。。瑕不掩瑜

Matrin Fwoler在Mircoservices中，提炼出微服务架构的9大特性：
1. 服务组件化
组件是一个可以独立更换和升级的单元。就像电脑中的cpu，内存，显卡。。
在微服务架构中，需要对服务进行组件化分解。服务是一种进程外的组件，通过http等通信协议来进行协作，而不是传统组件那般以嵌入的方式协同工作。

2. 按业务组织团队
划分微服务时，往往需要对团队进行重新规划与组织。以往的做法：从技术的层面将团队划分为多个，如DBA，运维，后端，前团，设计师。
如果继续按这种方法划分，当一个服务需要一个简单修改，如对人物描述增加一个字段，这需要从数据库一直到前端设计，虽然大家的改动都非常小，但这会引起跨团队的时间消耗和预算审批。
实施微服务架构时，采用不同的团队分割。对微服务团队的拆分更加建议按照业务线的方式进行拆分，减少服务内部修改所产生的内耗，团队边界更清晰。

3. 做"产品"的态度
每个小团队都应该以做产品的方式，对其产品的整个生命周期负责。而不是以项目的模式，以开发完成与交付并将成果交接给维护者为最终目标。
开发团队了解服务在具体生产环境中的情况，可能会发现一些潜在问题或需求。持续关注服务的运行情况，并不断分析以斑竹用户来改善业务功能。

4. 智能端点与哑管道
如果仅仅将原本在进程内的方法调用改成RPC方式调用，会导致微服务之间产生繁琐的通信，使系统更糟糕。所以，我们需要粗粒度的通信协议
通常采用以下两种服务调用方式：
1. 使用http和Restful_API或轻量级的消息发送协议，实现信息传递与服务调用的触发。
2. 通过在轻量级消息总线上传递消息，类似RabtitMQ等一些提供可靠异步交换的中间件。
。。？？2个名字的定义是什么


5. 去中心化治理
采用集中化的架构方案时，通常在技术平台上会制定统一的标准。但每种技术平台都有其短板，处理不好那就是系统瓶颈。
微服务架构，采用轻量级的契约定义接口，使得我们对服务本身的具体技术平台不再那么铭感，这样不同服务就能针对其业务特点选择不同的技术平台。

6. 去中心化管理数据
每个服务管理其自有的数据库
可以让数据管理更加细致化，通过采用更合适的技术让数据存储和性能达到最优。
但是数据一致性也成了微服务架构中亟待解决的问题之一。
分布式事务本身的实现难度就非常大，所以在微服务架构中，我们更强调在各服务之间进行"无事务"的调用，对于数据一致性，只要求数据在最后的处理状态是一致的即可：如果在过程中发现错误，通过补偿机制来处理，使得错误的数据能达到最终的一致性。

7. 基础设施自动化
云计算服务，容器化技术，使得运行基础设施的工作越来越容易。
但是，实施微服务时，数据库，应用程序变小了，且数量成倍增长，这使得运维需要关注的内容也成本增长，操作性任务也增长。
所以在微服务架构中，务必从一开始就构建起"持续交付"平台来支持整个实施过程，该平台必须要2大内容：
1. 自动化测试
2. 自动化部署

8. 容错设计
单体应用中，通常是一挂全挂。
微服务架构中，快速检测出故障源并尽可能地自动恢复服务是必须被设计和考虑的。通常，我们希望每个服务中实现监控和日志记录的组件，比如服务状态，断路器状态，吞吐量，网络延迟等。

9. 演进式设计
初期，以单体系统设计和实施。
随着业务发展或需要，将一些经常改动或是有一定时间效应的内容进行微服务处理，逐渐将单体系统中多变的模块逐步拆分出来，稳定的模块就形成一个核心微服务存在与整个架构之中。


微服务的许多框架
服务治理：alibaba的Dubbo及当当网扩展出的DubboX，Netflix的Eureka,Apache的Consul等
分布式配置管理：baidu的Disconf，Netflix的Archaius，360的QConf，Spring Could的Config，taobao的Diamond等
批量任务：当当网的Elastic-Job，LinkedIn的Azkaban，Spring Cloud的Task。。。
服务跟踪：京东的Hydra，SpringCloud的Sleuth，Twitter的Zipkin。。。

上面是一些在实施微服务架构初期就需要考虑的问题的 开源解决方案。

SpringCloud不像上面列举的框架那样只是解决微服务中的某个问题。
它是一个就觉微服务架构实施的综合性解决框架，整合了诸多框架作为实施的基础部分，又在该体系基础上创建了一些很优秀的边缘组件。


SpringCloud是一个基于SpringBoot实现的微服务架构开发工具。
为微服务架构中涉及的配置管理，服务治理，断路器，智能路由，微代理，控制总线，全局锁，决策竞选，分布式会话，集群状态管理等提供了一种简单的开发方式。


SpringCloud是一个其他开源框架+自己的组件的组合。其他的开源框架也进行者它们自己的迭代，它们有自己的版本号。
为了管理每个版本的子项目清单，避免springcloud的版本号和其子项目的版本号混淆，所以没有采用版本号的方式，而是通过命名的方式。
版本的名字来自伦敦地铁站的名字，根据字母表顺序来对于版本发布顺序。

Angel.RS6,Brixton.SR5中的SR6，SR5就是版本号了。

本书基于Brixton.SR5版本，基于SpringBoot1.3.7。
本书完成时Brixton已经升级到SR7。本书中的例子都可以在SR7中运行。但SPringBoot版本必须是用1.3.x。若要使用1.4.x的springBoot，则需要升级到Camden版本。Camden中将Brixton中某些方法Deprecated了，但是能运行。


30
chapter 微服务构建：Spring Boot

springboot可以很好融入docker，其本身就支持嵌入式tomcat，jetty等容器。所以通过springboot构建的应用不再需要安装tomcat，将应用打包成war，部署到tomcat了。只需要将springboot应用打出jar包，通过java -jar命令，直接就能启动一个标准化的web应用。


构建maven项目
1.通过官方的SpringInitializr工具来产生基础项目(这个工具就是下面的网页)。
2.访问start.spring.io。该页面提供了maven或gradle构建sboot项目。
3.页面上选择MavenProject，sboot版本选择1.3.7，填写group，artifact信息。searchForDependencies中可以搜索需要的其他依赖包，我们要实现RestFUL-API,所以可以添加web依赖。
4.单击Generate Project,下载项目压缩包。
5.解压，在ide以maven项目导入，(导入-选择项目，选择maven)。


sboot基础结构有3大块
src/main/java。。主程序入口HelloApplication，可以直接运行该类来启动sboot应用
src/main/resource。。配置信息。包含了static，templates目录，前者存放静态资源(图片，CSS，javaScript)，后者存放web页面的木板文件。
src/test。。测试，HellpApplicationTests通过Junit4实现，可以直接运行sboot的测试。

maven中<packing>默认jar包。而非war，运维默认的web模块依赖会包含嵌入式tomcat。

spring-boot-starter-web:包含嵌入式tomcat，SpringMVC
spring-boot-starter-test:junit,hamcreat,mockito.

希望具备访问数据库的能力时，spring-boot-starter-jdbc，或者更好用的spring-boot-starter-data-jpa.

这种web，test，模块，在sboot生态中被称为Starter POMs，是一系列轻便的依赖包。这样就不需要pom.xml中写大量的依赖配置。

pom的<build>中引入了spring-boot-maven-plugin,这样开放式就不需要找到主类或者打包成jar来运行，直接mvn spring-boot:run就可以启动sboot项目

36
实现RESTful API
新建package(随意)..HelloController类：
@RestController
public class HelloController {
	@RequestMapping("/hello")
	public String index() {
		return "hello world";
	}
}
启动应用，浏览器访问localhost:8080/hello就可以看到返回的结果hello world
。。artifact的名字是hello


启动sboot有多种方式：
1.直接运行含有main函数的类来启动。
2.maven中的spring-boot-maven-plugin。执行mvn spring-boot:run。或是右击Ide中maven插件(或许是右键工程，找到maven，查看命令)，左键执行命令。

3.在服务器上部署。先用mvn install将应用打包成jar包，在通过java -jar xxx.jar来启动应用。


单元测试

import static org.hamcreat.Matchers.equalTo;
import static org.springfacmework.test.web.servlet.result.MockMvcResultMathcers.content;
impoer static ...同上...status;

@RunWith(SpringJunit4ClassRunner.class)	// 引入spring对junit4的支持

// 指定sboot的启动类
@SpringApplicationConfiguration(classes = HelloApplication.class)
@WebAppConfiguration	// 开启web应用的配置，用于模拟ServletContext
public classs HelloApplicationTests {
	private MockMvc mvc;	// 模拟调用Controller的接口发起请求
				// perform执行一次请求调用，accpet执行接收的数据类型
					// andExpect判断返回的期望值。
	@Before
	public void setUp() throws Exception {
		mvc = MockMvcBuilders.standalongSetup(new HelloController()).build();
	}
	@Test
	public void hello() throws Exception {
		mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON))
			.addExpect(status().isOk());
			.addExpect(content().string(equalTo("hello world")));
	}
}


sboot默认配置文件路径：src/main/resources/application.properties
spring.application.name=hello来指定应用名(该名字在后续springCloud中会被注册为服务名)

sboot配置处理properties文件外，还支持现在被广泛推荐使用的YAML文件

environments：
	dev:
		url: http://dev.bar.com
		name: Developer Setup
	prod:
		url: http://foo.bar.com
		name: My Cool App
等价的properties：
environments.dev.url=http://dev.bar.com
environments.dev.name=...
environments.prod.url=...
environments.prod.name=...

..dev,prod 是开发环境，生产环境

yaml还可以在一个单个文件中通过使用spring.profile属性来定义多个不同的环境配置。
下面内容，test环境时，端口使用8882，prod使用8883端口，没有指定环境8881端口

server:
	port:8881
---
spring:
	profiles: test
server:
	port: 8882
---
spring:
	profiles:prod
server:
	port: 8883

yaml还有一些不足，无法通过@PropertySource注解来加载配置。
但是yaml将属性加载到内存中时时有序的。当配置文件中的信息需要具备顺序含义时，yaml更合适。


自定义参数
除了可以在sboot的配置文件中设置各个Starter模块中预定义的配置属性，也可以在配置文件中定义一些我们需要的自定义操作，如在application.properties中添加：
book.name=SpringCloudInAction
book.author=ZhaiYongchao
然后可以通过@Value来加载
@Component
public class Book {
	@Value("${book.name}")
	private String name;
	@Value("${book.author}")
	private String author;
	//...
}

@Value加载属性值是可以使用2中表达式
1. 上面的PlaceHolder方式，${...}，大括号内是PlaceHolder
2. SpEL表达式，#{...}，括号内是SpEL表达式

application.properties中各个参数可以直接通过${}来引用
book.desc=${book.name} is waiting ${book.name}


st.我想希望参数加载时是一个随机值，如密钥，端口。，sboot配置文件中，可以通过${random}配置来产生随机int，long，string。

com.didispace.blog.value=${random.value}		// 随机stirng
com.number = ${random.int}			//
com.bignumber = ${random.long}
com.test1 = ${random.int(10)}			// 10以内的随机数
com.test2 = ${random.int(10, 20)}		// 10～20的随机数。。
。。不清楚[] or ()


42
命令行参数
java -jar xxx.jar --server.port=8888, 以命令行的方式设置端口。
用命令行启动sboot时，连续2个减号就是对application.properties中属性进行赋值。

以前只有重新编译才能修改properties，现在可以在启动时。


多环境配置
开发，测试，生产。每个环境的数据库地址，服务器端口等配置各不相同。如果为不同环境打包时需要修改配置的话，很容易出错。

对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，在通过打包命令指定需要打包的内容之后进行区分打包。sboot亦是。

sboot中，多环境配置的文件名需要满足application-{profile}.properties的格式。{profile}对应你的环境标识。如下所示
application-dev.properties		开发环境
application-test.properties		测试
application-prod.properties		生产

具体加载哪个，需要在application.properties文件中spring.profiles.active属性来设置，其值对应{profile}值。
spring.profiles.active=dev

java -jar xxx.jar --spring.profiles.active=test，启动

依照上面的实现，可以总结多环境的配置思路：
在application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置
在application-{profiles}.properties中配置各个环境不同的内容
通过命令行方式去激活不同环境的配置。
。。看来application.properties是始终加载的。

sboot使用下面的顺序加载属性
1. 命令行参数
2. SPRING_APPLICATION_JSON中属性，这是以json格式配置在系统环境变量中的内容。
3. java:comp/env 中jndi属性
4. java的系统属性，可以通过System.getProperties()获得其内容。
5. os的环境变量
6. 通过random.*配置的随机属性
7. 位于当前应用jar包外，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或YAML定义的配置文件
8. 当前应用jar包之内。。。。同上。
9. 当前应用jar包之外的application.properties和YAML
10.当前应用jar包之内的。。。同上
11.在@Configuration注解修改的类中，通过@PropertySource注解定义的属性。
12.应用默认属性，SpringApplication.setDefaultProperties()定义的内容。

数字越小优先越高。

7，9是从应用jar包之外读取配置文件，所以实现外部化配置的原理就是从此切入，为其指定外部配置文件的加载位置来取代jar包中的配置。
。。。how？如何指定？


监控与管理
sboot的Starter POMs提供了一个特殊依赖块spring-boot-starter-actuator
引入该模块能为sboot应用提供一系列用于监控的端点。
sCloud在实现各个微服务组件时，进一步扩展了actuator，增加了更多的指标和度量信息。

pom添加actuator的dependency后，重启，控制台会输出些东西，是端点定义。是starter-actuator根据应用依赖和配置自动创建出来的监控和管理端点。通过这些端点，我们可以实时获取应用的各项监控指标，
比如访问/health端点。可以获得如下信息：
{
	"status":"UP",
	"diskSpace":{
		"statis":"UP",
		"total":49217583924,
		"free":38285475322,
		"threshold":1045643
	}
}
在没有引入其他依赖前，该端点的内容较为简单，后续在使用sCloud的各个组件之后，返回会变得丰富。


原生端点
介绍spring-boot-starter-actuator模块中已经实现的一些原生端点。根据作用，可以分为3类：
应用配置类，获取应用程序中加载的应用配置，环境变量，自动化配置报告等与sboot应用密切相关的配置类信息
度量指标类，获取应用程序运行过程中用于监控的度量指标，如内存信息，线程池信息，http请求统计等。
操作控制类，提供对应用的关闭等操作类功能。

应用配置类
sboot为了改善传统spring应用复杂的配置内容，采用了包扫描和自动化配置的机制来加载原本集中与xml文件中的各项内容。
使代码变得简洁，但整个应用的实例创建和依赖关系等信息都离散到各个配置类的注解上，使得分析整个应用中资源和实例的各种关系变得非常困难。
这类端点可以帮我们轻松获取一系列关于spring应用配置内容的详细报告。如自动化配置的报告，bean创建的报告，环境属性的报告等

/autoconfig:。获取应用的自动化配置报告，包括所有自动化配置的候选项。还列出了每个候选项时候满足自动化配置的各个先决条件。内容分为2部分：
positiveMatches返回条件匹配成功的自动化配置
negativeMatches匹配不成功

/beans：获取应用上下文中创建的所有bean。每个bean包含以下信息：
bean：名字
scope：作用域
type：bean的java类型
resource：class文件具体路径
dependencies，依赖的bean名称

/configprops：获取应用中配置的属性信息报告。prefix代表属性的匹配前缀，properties代表属性的名称和值。
endpoints.configprops.enabled=false来关闭这个端点。

/env，与/configprops不同，它用来获取应用所有可用的环境属性报告。包括环境变量，jvm属性，应用的配置属性，命令行参数。还包含了应用没有使用的配置，所以它可以帮助我们方便地看到当前应用可以加载的配置信息，并配合@ConfigurationProperties注解将它们引入到我们的应用程序中来使用。

/mappings：返回所有springMVC的控制器映射关系报告。

/info。返回一些应用自定义信息，默认情况下，返回一个空json，可以在application.properties中通过info前缀来设置一些属性：
info.app.name=spring-boot-hello
info.app.version=v1.0.0
再访问info，得到以下报告
{
	"app":{
		"name":"spring-boot-hello",
		"version":"v1.0.0"
	}
}

度量指标类
上面介绍的应用配置类端点所提供的信息在应用启动时就已经基本确定了。可以说是一个静态报告。
度量指标类端点提供的报告时动态变化的。提供了应用程序在一些过程中的一些快照信息，如内存使用情况，http请求统计，外部资源指标等。

/metrics，返回当前应用的各类重要度量指标，如内存信息，线程信息，垃圾回收信息等
/metrics/{name}来更细粒度的获取度量信息
/metrics/mem.free获得当前可用内存数量

/health，各类健康指标，starter-actuator中自带实现了一些常用资源的健康指标检测器，这些检测器都通过HealthIndicator接口实现。
@Component
public class RocketMQHealthIndicator implements HealthIndicator {
	public Health health() {
		int errCode = check();
		if (errCode != 0)
			return Health.down().withDetail("Error Code", errCode).build();
		return Health.up().build();
	}
	private int check() {....}
}
自定义健康信息检测器。

/dump，暴露程序运行中的线程信息，使用java.lang.management.ThreadMXBean的dumpAllThreads方法来返回所有含有同步信息的额活动线程详情。

/trace，返回基本的http跟踪信息。


操作控制类
/shutdown。关闭应用，后续引入Eureka之后，会引入更多控制端点。
需要通过endpoints.shudown.enabled=true来开启。


58
chapter 3
服务治理：Spring Cloud Eureka

scloud Eureka是scloud Netflix微服务套件中的一部分，基于Netflix Eureka做二次封装，主要负责完成微服务架构中的服务治理功能。
sCloud通过为Eureka增加sboot风格的自动化配置，我们只需要通过简单引入依赖和注解配置就能让sboot构建的微服务与Eureka服务治理体系进行整合。

核心内容：
构建服务注册中心
服务注册与服务发现
Eureka的基础架构
Eureka的服务治理机制
Eureka的配置


服务治理
可以说是微服务架构中最核心和基础的模块，主要用来实现各个微服务实例的自动化注册与发现。

刚开始，服务不多，可以通过静态配置来完成服务的调用。
随着业务发展，系统功能越来越复杂，微服务也不停增加，静态配置难以维护。并且，我们的集群规模，服务的位置，服务的命名等都有可能发生变化。

为了解决服务实例维护问题，产生了大量的服务治理框架和产品。这些框架和产品都围绕着服务注册与服务发现机制来完成对微服务应用实例的自动化管理。
服务注册：。每个服务单元想注册中心登记自己的服务，将主机ip，端口号，版本号，通信协议等一些附加信息告诉注册中心，注册中心按照服务名分类组织服务清单。
服务注册中心还要以心跳的方式去检测清单中的服务是否可用，不可用则从服务清单中剔除，达到排除故障服务的效果
服务名		位置
服务A		192.168.0.100:8000,192.168.0.101:8000
服务B		192.168.0.100:9000,xxxx101:9000,xxx102:9000

服务发现：。在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起请求调用实现。服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有服务的实例清单，以实现对具体服务实例的访问。服务C向注册中心咨询，获得服务A的情况，服务C发起调用时会选择服务A的一个地址来进行调用，这里涉及到服务负载均衡。

Netflix Eureka
spring cloud Eureka使用Netflix Eureka来实现服务注册于发现，它既包含了服务端组件，也包含了客户端组件，并且服务端和客户端都使用java编写，所以Eureka适用于通过java实现的分布式系统，或是与jvm兼容语言构建的系统。
由于eureka服务端的服务治理机制提供了完备的restful api，所以它也支持将非java构建的微服务纳入eurake的服务治理系统中。只是在使用其他语言平台时，需要自己来实现eurake客户端程序(不过，一些流行的开发平台上，已经有了针对rureka注册中心的客户端实现框架。)。

eureka服务端，也称为服务注册中心。同其他服务注册中心一样，支持高可用配置。它依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。如果eureka以集群模式部署，当集群中有分片出现故障时，eureka就转入自我保护模式，它允许在分片故障期间继续提供服务的发现与注册，当故障分片恢复运行时，集群中的其他分片会把它们的状态再次同步回来。

eureka客户端，主要处理服务的注册于发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务的查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。


搭建服务注册中心。
创建基础的sboot工厂，命名为eureka-server。pom.xml中引入依赖：
depengdencies-dependency:spring-cloud-starter-eureka-server
dependencyManagement-dependencies-dependency:spring-cloud-dependencies-Brixton.SR5

。。test。。dependencyManagement中的不会被子pom继承，只有子pom写了该依赖项，但是没有写版本号，才会使用父类的版本号，子pom有版本号就用它自己的。。。dependencies，子pom会继承。

在普通的sboot应用中添加@EnableEurekaServer注解启动一个服务注册中心。
@EnableEurekaServer
@SpringBootApplication
public class Application {
	public static void main(String[] args) {
		new SpringApplicationBuilder(Application.class).web(true).run(args);
	}
}

@SpringBootApplication=@Configuration,@EnableAutoConfiguration,@ComponentScan
。。自己是个beans；自动配置spring上下文，猜测你想要的bean；自动扫描有@Component的类，并注册成bean；
https://www.cnblogs.com/MaxElephant/p/8108140.html

默认情况下，服务注册中心也会将自己作为客户端来尝试注册自己，所以我们需要禁用它的客户端注册行为，在application.properties中增加：
server.port = 1111
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/

访问localhost:1111就能看到eureka信息。


注册服务提供者
将上一章的sboot应用加入Eureka的服务治理体系中去
pom.xml同上增加spring cloud eureka的依赖。

改造/hello请求处理接口，通过注入DiscoveryClient对象，在日志中打印出服务的相关内容
@RestController
public class HelloController {
	private final Logger logger = Logger.getLogger(getClass());

	@Autowired
	private DiscoveryClient client;

	@RequestMapping(value="/hello", method=RequestMethod.GET)
	public String index() {
		ServiceInstance instance = client.getLocalServiceInstance();
		logger.info(instance.getHost() + instance.getServiceId());
		return "Hello World";
	}
}

然后，在主类中加上@EnableDiscoveryClient，激活eureka中的DiscoveryClient实现。
@EnableDiscoveryClient
@SpringBootApplication
public class HelloApplication {
	public static void main(String[] args) {
		StringApplication.run(HelloApplication.class, args);
	}
}

最后，在application.properties中通过spring.application.name来为服务命名，通过eureka.client.serviceUrl.defaultZone属性来指定服务注册中心的地址。
spring.application.name=hello-service
eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka

分别启动服务注册中心和这里的服务。在hello-service服务控制台中，com.netflix.discovery.DisconveryClient对象打印了该服务的注册信息。

在服务注册中心也会出现输出，hello-service with status UP

页面的eurake也会有，在instances currently registered with Eureka一栏中。

访问localhost:8080/hello，向服务发起请求，在控制台中会看到输出。


高可用注册中心
65

服务中心可以将自己作为服务向其他服务注册中心注册自己。
。配置的时候spring.application.name，多个节点都是相同的
可以一台电脑上2个端口都是服务中心，都向对方注册(默认情况)

双节点的服务注册中心集群：
application-peer1.properties,作为peer1服务中心的配置，并将serviceUrl指向peer2：
spring.application.name=eureka-server
server.port=1111
eureka.instance.hostname=peer1
eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/

application-peer2.properties作为peer2服务中心的配置，
spring.application.name=eureka-server
server.port=1112
eureka.instance.hostname=peer2
eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/

在/etc/hosts中添加peer1和peer2的转换，使上面的host形式能正确访问
127.0.0.1 peer1
127.0.0.1 peer2

通过spring.profiles.active来分别启动peer1，peer2
java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1
java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2

访问localhost:1111/，可以看到有peer2节点的eureka-server了，处于可用分片中。
关闭peer2，localhost:1111/中会把peer2的节点变为不可用分片。

。。test。。不是localhost:1111/eureka/？下面也不是，只到端口号。。

设置多节点的服务注册中心后，服务提供方还需要一些配置才能将服务注册到Eureka Server集群中。
application.properties
spring.application.name=hello-service
eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka
。。就是告诉服务提供商，有哪些注册中心。

如果不想用主机名来定义注册中心的地址，可以使用IP方式，需要在配置文件中配置参数eureka.instance.perfer-ip-address=true.该值默认false


服务发现与消费
服务发现是有Eureka的客户端完成
服务消费的任务由Ribbon完成。
ribbon是一个基于http和tcp的客户端负载均衡器，通过在客户端中配置ribbonServerList服务端列表去轮询访问以达到负载均衡的作用。

ribbon与eureka联合使用时，ribbon的服务实例清单RibbonServerList会被DisconveryEnabledNIWSServerList重写，扩展成从Eureka注册中心获得服务端列表，同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已启动。

本章不对Ribbon详细介绍，只需要理解它在Eureka服务发现的基础上，实现了一套对服务实例的选择策略，从而实现对服务的消费。

例子来看Eureka的服务治理体系下如何实现服务的发现与消费。
1. 启动之前的服务注册中心eureka-server及hello-service服务。
为了试验ribbon的客户端负载均衡功能，通过java-jar启动2个不同端口的hello-service
java -jar hello-service-0.0.1-SHAPSHOT.jar --server.port=8081
.....port=8082

2.在eureka信息面板中能看到hello-service的服务有2个实例。分别是8081，8082端口的服务(和上面匹配)

3.创建一个sboot基础工程来实现服务消费者，取名ribbon-consumer。
pom.xml中增加以下依赖，对于之前的hello-service，这里新增了ribbon模块的依赖。
parent-artificatId-(spring-boot-starter-parent..version1.3.7.RELEASE)
dependencies-dependency--(spring-boot-starter-web,eureka,ribbon)
dependencyManagement-dependencies-dependency-(spring-cloud-dependencies..Brixton.SR5)
。。p68

4.创建应用主类ConsumerApplication，通过@EnableDiscoveryClient使该应用注册为eureka客户端应用，以获得发现服务的能力。在该类汇总创建RestTemplate的springBean实例，通过@LoadBalanced开启客户端负载均衡。
@EnableDiscoveryClient
@SpringBootApplication
public class ConsumberApplication {
	@Bean
	@LoadBalanced
	RestTemplate restTemplate() {
		return new RestTemplate();
	}
	public static void main(String[] args) {
		SpringApplication.run(ConsumerApplication.class, args);
	}
}

5.创建ConsumerController并发现ribbon-consumer接口。通过上面的resttemplate来实现对hello-service服务提供的/hello的调用。这里访问的地址是服务名HELLO-SERVICE，而不是一个具体的地址。
@RestController
public class ConsumerController {
	@Autowired
	RestTemplate restTemplate;
	@RequestMapping(value="/ribbon-consumer", method=RequestMethod.GET)
	public String helloConsumer() {
		return restTemplate.getForEntry("http://HELLO-SERVICE/hello", String.class).getBody();
	}
}
。。test。。。似乎有点道理，restTemplate直接返回new的，毕竟地址是getForEntry传进去的。。。还有http://HELLO-这个大小写有关吗？似乎是无关的。。无关的，下面的properties中配置的是小写，但是在eureka信息面板的截图中是大写。

6.application.properties中配置eureka服务注册中心的位置，需要与之前的hello-service一样，不然无法发现服务。同时设置端口为9000，不能与其他冲突。
spring.application.name=ribbon-consumer
server.port=9000
eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/

启动ribbon-consumer应用后，可以在eureka信息面板中看到，除了hello-service外，还多了ribbon-consumerf服务。

。。消费者也非把自己注册成服务。。。也是啊，没人调用你的话，你怎么运行，有人调用你，你就是服务了。。

访问http://localhost:9000/ribbon-consumer，成功返回"hello world"。此时，可以在ribbon-consumer应用的控制台中看到很多信息，ribbon输出了当前客户端维护的hello-service的服务列表情况。包含了各个实例的位置(ribbon按此信息轮询访问，以实现负载均衡)，各个实例请求总数量，第一次连接信息，上一次连接信息，总的请求失败数量等。

多访问几次，可以看到2个hello-service的控制台，轮流打印日志。


eureka服务治理体系的3个核心角色，服务注册中心，服务提供者，服务消费者。


服务提供者
服务注册
服务提供者在启动时会通过发送rest请求的方式将自己注册到eureka server上，同时带上自身服务的一些元数据信息。eurekaserver接收到这个rest请求后，将元数据信息存储在一个双层结构map中，第一次key是服务名，第二次key是具体服务的实例名。
在服务注册时，确认eureka.client.register-with-eureka是否为默认的true。false不会启动注册操作。

服务同步
由于服务注册中心互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。

服务续约
注册完后，服务提供者会维护一个心跳来持续告诉eureka-server"可用"，以防止eureka-server的剔除任务。
有2个重要属性，
eureka.instance.lease-renewal-interval-in-seconds=30
eureka.instance.lease-expiration-duraion-in-seconds=90
第一个用于定义服务续约任务的调用间隔，默认30s。
用于定义服务失效的时间，默认90s

。。test。。？2个属性应该是注册中心的吧，续约任务，服务失效，这2个肯定是注册中心啊。。。。心跳能自定义间隔吗？
。。但是这里是服务提供者啊。。难道说30s是心跳？但是90s怎么解释？。。难道说这2个属性会发送给注册中心？对对对，不可能每个服务都是相同的心跳间隔(毕竟有些服务很重要，要确保正常运行，所以心跳很快。)，所以心跳间隔由服务提供者定义。
。。而且这里是eureka.instance..不是eureka.client,eureka.server..

73
服务消费者

获取服务
服务注册中心已经注册了一个服务，且该服务有2个实例。当我们启动服务消费者(??。。test。。是指getForEnity，还是项目启动？前者？。。但下面才是服务调用，所以可能是后者。。那就是说new Resttemplate会做很多事情，包括从properties中读取注册中心的ip。端口。。。不不不，不清楚了。。)时，它会发送一个rest请求给服务注册中心，来获取已注册的服务清单。为了性能考虑，eurekaServer会维护一份只读的服务清单来返回给客户端，同时，该缓存清单每30s刷新一次。

获取服务是服务消费者的基础，必须确保eureka.client.fetch-registry是默认的true。。eureka.client.registry-fetch-interval-seconds是缓存清单的更新时间，默认30s。

服务调用
获得服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例。在ribbon中默认使用轮询的方法进行调用。

对于访问实例的选择，eureka中有region和zone的概念，一个region可以包含多个zone，每个服务客户端需要被注册到一个zone中，所以每个客户端对于一个region，一个zone。在进行服务调用的时候，优先发访问同处一个zone中的服务提供方，如果没有，就访问其他zone。。后续介绍。

服务下线
在客户端程序中，当服务实例进行正常的关闭操作时，它会触发一个服务下线的rest请求给eureka server，告诉服务注册中心。服务端收到后，将该服务状态置为down，并把该下线事件传播出去。


服务注册中心
失效剔除
eureka server在启动时会创建一个定时任务，默认每隔一段时间(默认60s)将当前清单中超时(默认90s)没有续约的服务剔除

自我保护
服务注册到eurekaServer后，会维护一个心跳连接，告诉eurekaServer存活。
eurekaServer运行期间，统计心跳失败的比例在15min中是否低于85%。如果低于，eurekaServer会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。但是如果在这段保护器件内实例出现了问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败的情况。所以客户端必须有容错机制，比如请求重发，断路器等。
。。这样不就和90s超时，剔除的规则违背了嘛？难道是90s超时且15min中高于85%才会剔除？。。test。。

本地调试很容易触发注册中心的保护机制，这会使得注册中心维护的服务实例不那么准确。所以本地开发时，eureka.server.enable-self-preservation=false来关闭保护机制，以确保注册中心可以将不可用的实例正确剔除。
。。对，本地调试，服务随便开/关的。所以不确定失去心跳是正确的(人为关闭了服务)还是错误的。。。生产不能随便开关，所以失去心跳很大可能就是宕机了或网路堵塞。

p75
源码分析

从配置中加载eureka-server时，会配置该服务所属的region，zone，
region默认default。eureka.client.region中可以定义
zone默认defaultZone。这也是之前eureka.client.serviceUrl.defaultZone的由来，eureka.client.availability-zones来设置，可以设置多个，逗号分隔。
所以region一对多zone
。。test。。eureka.client.serviceUrl.defaultZone。最后一个改掉会出什么事？defaultZone是否就是zone的默认值？如果zone的值改了，defaultZone是否也要改？应该需要改的


84
配置详解

org.springframeword.cloud.netflix.eureka.EurekaClientConfigBean中定义了常用配置参数以及说明和默认值。

org.springframeword.cloud.netflix.eureka.EurekaInstanceConfigBean，服务实例元数据的配置。
服务实例元数据：eureka的客户端向服务注册中心发送注册请求时，用来描述自身服务信息的对象，其中包含了一些标准化的元数据，如服务名称，实例名称，实例ip，实例端口等用于服务治理的重要信息，及一些用于负载均衡策略或其他特殊用途的自定义元数据信息。

eureke.instance.<properties>=<value>对标准化元数据直接进行配置。<properties>就是EurekaInstanceConfigBean对象中成员变量名。

对于自定义数据，可以通过eureka.instance.metadataMap.<key>=<value>来进行配置。


健康检测
默认下，eureka中各个服务实例的健康监测并不是通过spring-boot-actuator模块的/health端点来实现的，而是依靠客户端心跳的方式来白痴服务实例的存活。
默认的心跳实现方式可以有效检查客户端进程是否正常运作，但无法保证客户端应用能正常提供服务。大多数微服务都需要使用外部资源，如数据库，缓存，消息代理等，如果我们的应用无法与外部资源联通，那么实际上已经无法提供服务了，但心跳继续，服务消费者依赖会调用服务。

spring cloud eureka中，我们可以把eureka的健康检测交给spring-boot-actuator模块的/health端点，以实现更加全面的健康状态维护。
1.pom.xml引入spring-boot-starter-actuator模块
2.application.properties中增加参数配置eureka.client.healthcheck.enabled=true.
3.客户端的/health端点路径做特殊处理，让服务注册中心可以访问到健康监测端点。


org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean中也有部分配置。主要是perferIpAdress,leaseRenewalInterbalInSeconds,leaseExpirationDurationInSeconds.


跨平台支持
通信协议
默认情况下，Eureka使用Jersey和XStream配合JSON作为server和client之间的通信协议。可以选择实现自己的协议来替代。




chpater 4
客户端负载均衡：Spring Cloud Ribbon

sCloud ribbon是基于http和tcp的客户端负载工具。基于Netflix ribbon实现
通过springCloud的封装，轻松将面向服务的rest模板请求自动转换为客户端负载均衡的服务调用。
sCloudRibbon虽然只是一个工具类框架，它不像服务注册中心，配置中心，api网关那样需要独立部署，但是它几乎存在与每一个springCloud构建的微服务和基础设施中。
因为微服务的调用，api网关的请求转发等内容，实际上都是通过ribbon来实现的。

负载均衡是对系统的高可用，网络压力的缓解，处理能力扩容的重要手段之一。
负载均衡是指服务端负载均衡，其中分为硬件负载均衡，软件负载均衡，硬件负载均衡主要通过在服务器节点之间安装专门用于负载均衡的设备，如F5等。软件负载均衡则是通过在服务器上安装一些具有均衡负载功能的软件来完成请求分发工作，如Nginx等。

硬件负载均衡设备及软件负载均衡软件都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务端节点(保证清单都可用)。
客户端请求到达负载均衡时，按某种算法(轮询，按权重负载，按流量负载等)从维护的可用服务端清单中取出一台服务端的地址，然后转发。

客户端负载均衡和服务端负载均衡最大的不同在于，上述服务清单所存储的位置。客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，这些清单来自与服务注册中心。与服务端负载均衡类似，客户端负载均衡也需要心跳以维护服务端清单的健康性，这个步骤需要与服务注册中心配合完成。

springCloud的服务治理框架中，默认创建针对各个服务治理框架的ribbon自动化整合配置。
如Eureka中的org.spring..cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration
Consul中的org.spring..cloud.consul.discovery.RibbonConsulAutoConfiguration
具体使用时，可以查看这2个类的实现，来寻找它们的配置详情以便更好地使用。

通过springCloudRibbon的封装，微服务架构中使用客户端负载均衡调用非常简单，只需2步：
1.服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心。
2.服务消费者直接通过调用被@LoadBalanced注解修饰的RestTemplate来实现面向服务的接口调用。


RestTemplate 详解
RestTemplate会使用Ribbon的自动化配置，同时通过配置@LoadBalanced还能够开启客户端负载均衡。

在RestTemplate中，对GET请求可以通过下面2个方法进行调用实现

getForEntity，返回ResponseEntity(是spring对http请求响应的封装)，存储http几个重要元素，如http请求状态码的枚举对象HttpStatus(404，500等)，在它的父类HttpEntity中还有http请求的头信息对象HttpHeaders以及泛型类型的请求体对象。
下面的例子，访问user-service服务的/user请求，同时最后一个参数didi会替换url中的{1}占位符，而返回的ResponseEntity对象中的body内容类型会根据第二个参数转换为String类型
RestTemplate restTemplate = new RestTemplate();
ResponseEntity<String> respEnty = restTemplate.getForEntity("http://USER-SERVICE/user?name={1}",Stirng.class, "didi");
String body = respEntiy.getBody();

如果希望返回一个User对象，则：
RestTemplate restTemplate = new RestTemplate();
ResponseEntity<User> respEnty = restTemplate.getForEntity("http://USER-SERVICE/user?name={1}",Usert.class, "didi");
User body = respEntiy.getBody();

上面是比较常用的方法，getForEntity提供了3种重载
getForEntity(String url, Class resposeType, Object...urlVariable)
urlVariables参数是一个数组，所以它的顺序会对于url中占位符定义的数字顺序。

getForEntity(Stirng url, Class responseType, Map urlVariable)
占位符的标志是urlVariable这个map的key。
Map<Stirng, String> params = new HashMap<>();
params.put("name", "dada");
ResponseEntity<String> resp = restTemplate.getForEntity("http://USER-SERVICE/user?name={name}", String.class, params);

getForEntity(URI url, Class responseType)
使用URI对象来代替url+urlVariable。
UriComponents uriC = UriComponentsBuilder.fromUriString("http://USER-SERVICE/user?name={name}").build().expand("dodo").encode();
URI uri = uriC.toUri();
ReponseEntity<String> resp = restTemplate.getForEntity(uri, String.class).getBody();

getForObject,可以理解为对getForEntity的进一步封装，它通过HttpMessageConverterExtrator对http的请求响应体body内容进行对象转换，实现请求直接返回包装好的对象内容。
String result = restTemplate.getForObject(uri, String.class);

当不需要关注请求响应处body外的内容，这个函数就非常好用，少一个从Reponse中获得body的步骤。
有3种重载

getForObject(String url, Class responseType, Object...urlVariable)
getForObject(String url, Class responseType, Map urlVariable)
getForObject(URI uri, Class responseType)


96
POST请求
3个方法
1. postForEntity，和getForEntity类似。返回ResponseEntity<T>对象
User user = new User("didi", 30);
ResponseEntity<String> resp = restTemplate.postForEntity("http://USER-SERVICE/user", user, String.class);
String body = resp.getBody();

3种重载
postForEntity(String url, Object request, Class responseType, Object... uriVariables)
postForEntity(String url, Object request, Class responseType, Map uriVariables)
postForEntity(URI uri, Object request, Class responseType)

request参数可以是一个非HttpEntity的普通对象，也可以是一个HttpEntity对象。如果是普通对象，restTemplate会将请求转为HttpEntity对象来处理，其中Object就是request的类型，request内容会被视作完整的body来处理。如果是request是一个HttpEntity对象，那么会被当作一个完整的http请求对象来处理，这个request不仅包含body，也包含header的内容。

2. postForObject函数，和getForObject类似，简化了对postForEntity的后续处理，直接将响应的body内容包装成对象返回使用。

3种重载
postForObject(String url, Object request, Class responseType, Object... uriVariables)
postForObject(String url, Object request, Class responseType, Map uriVariables)
postForObject(String url, Object request, Class responseType)


3. postForLocation,实现了以post请求提交资源，并返回资源的uri
User user = new User("dod", 40);
URI resp = restTemplate.postForLocation("http://USER-SERVICE/user", user);
。。。test。。。对面是怎么实现的？。应该还是在数据库里，调用xxx方法(url)获得？getForObject(uri, clz)

3种重载
postForLocation(String url, Object request, Object... urlVariables)
postForLocation(String url, Object request, Map urlVariables)
postForLocation(URI url, Object request)

返回URI，所以不再需要responseType来指明类型。


PUT请求
Long id = 1001L;
User user = new User("ddd", 44);
restTemplate.put("http://USER-SERVICE/user/{1}", user, id);

3种重载
put(String url, Object request, Object... urlVariables)
put(String url, Object request, Map urlVariables)
put(URI url, Object request)

put返回void，自然不需要responseType


DELETE请求
Long id = 1000L;
restTemplate.delete("http://USER-SERVICE/user/{1}", id);

3种重载
delete(String url, Object... urlVariables)
delete(String url, Map urlVariables)
delete(URI uri)

通常将delete请求的唯一标识符拼接在url中，所以delete请求不需要request的body信息。


99
源码分析

@LoadBalanced，使用LoadBalancerClient接口的实现类来配置。

从LoadBalancerAutoConfiguration类头上注解可以得知，ribbon实现负载均衡自动化配置需要满足以下2个条件
1. @ConditionalOnClass(RestTemplate.class):RT类必须在当前工程的环境汇总。
2. @ConditionalOnBean(LoadBalancerClient.class):spring的bean中必须有LoadBalancerClient的实现Bean

该自动化配置类，完成下面3件事：
1.创建一个LoadBalancerInterceptor的bean，用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡
2.创建RestTemplateCustomizer的bean，用于给RestTem增加LoadBalancerInterceptor拦截器
3.维护一个被@LoadBalanced修饰的RestT对象列表，在进行初始化时，通过RestTemplateCoustomier的实例来给需要客户端负载均衡的RestTem增加LoadBalancerInterceptor拦截器。
。。test。。拦截器怎么实现。拦截器依赖jdk动态代理。

LoadBalancerClient只是一个接口，org.spring..cloud.netflix.ribbon下有实现类RibbonLoadBalancerClient。

RibbonClientConfiguration配置类中，@ConditionalOnMissingBean的ribbonLoadBalancer，可以得知默认采用ZoneAwareLoadBalancer来实现负载均衡器。

ServerList
DomainExtractingServerList
DisconveryEnabledNIWSServerList
DiscoveryEnabledServer-DomainExtractingServer
DyanmicServerListLoadBalancer...ServerListUpdater.UpdateAction

ZoneAwareLoadBalancer负载均衡器是对DynamicServerListLoadBalancer的扩展。

。。。
128_
负载均衡策略

策略根类是IRule，只有一个子类，是个抽象类，AbstractLoadBalancerRule，该抽象类中定义了ILoadBalancer对象，这个对象可以在具体实现选择服务策略时，获取到一些负载均衡器中维护的信息来作为分配依据，并以此设计一些算法来实现针对特定场景的高效策略。

以下是继承AbstractLoadBalancerRule或其子类的实现类。

RandomRule
IRule接口的choose(Object key)方法委托给了该类中的choose(ILoadBalancer lb, Object key)
根据rand.nextInt(serverCount)获得一个随机值，然后upList.get(index)来返回具体实例。。选择逻辑在一个while(server==null)循环中。
serverCount是所有server的数量。upList是可用实例列表。如果serverCount为0，则returnNull，否则就rand(serverCount)，然后从upList中根据随机值选择，如果是null，就Thread.yield，continue，非null，还需要判断isAlive，存活就return，不存活就server=null，Thread.yield()

RoundRobinRule
线性轮询，有个自增count，while(server==null&&count++<10)。所以只会尝试10次，没有就returnNUll。
实现是通过AtomicInteger.nextServerCyclicCounter对象实现。
。。。test。。。有这个方法？。。这里是allServers.get(xx),xx是最终通过上面的方法来的。

RetryRule
实现了一个具备重试机制的实例选择功能。
内部还定义了一个IRule对象，默认使用RoundRobinRule实例，在choose方法中对内部定义的策略进行反复尝试，能选择到具体服务实例就返回，选不到就根据设置的超时时间，超时后返回null。

WeightedResponseTimeRule
对RoundRobinRule的扩展，根据实例的运行情况来计算权重，根据权重选择实例。主要有3个核心内容
	定时任务
初始化时通过serverWeightTimer.schedule(new DynamicServerWeightTask(), 0, serverWeightTaskTimerInterval)启动一个定时任务，用来为每个服务实例计算权重，该任务默认30s执行一次。
	权重计算
存储权重的对象List<Double> accumulatedWeights,每个元素的位置对应了服务实例清单中所有实例在清单中的位置。
1.先forEach(server)，累加响应时间。
2.a=0；forEach(server)，{a = a + (total响应时间-本server响应时间)}
a就是权重。
这里的权重是区间，a始终是增长的。120，210，300，500，那么就是4个区间[0,120],(120,210],(210,300],(300,500)
每个区间的宽度=总响应时间-实例响应时间。。实例响应越快，权重宽度越大。区间的开闭和实例选择有关(<or<=)
	实例选择
1.获得最后一个实例的权重，如果<0.001d，那么采用父类的线性轮询策略。
。。<0.001d说明只有一个服务实例吧。
2.如果最后一个实例的权重>=0.001d,就产生一个[0,最后实例的权重)的随机数。forEach权重清单，如果权重大于等于随机数，那么就选择这个实例。
for(Double d : currentWeights) {
	if (d >= randomW) {
		serverIndex = n;
		break;
	} else {
		n++;
	}
}
server = allList.get(serverIndex);

ClientConfigEnabledRoundRobinRule
一般不使用，因为它没有特殊逻辑，它在内部定义了一个RoundRobinRule，choose也是使用RoundRobinRule的线性轮询机制，所以它完成的功能和RoundRobinRule一致。
一般继承这个类，子类中实现一些高级策略，高级策略有时无法确定服务/无法实施，那么可以使用父类的实现作为备选。

后续的高级策略都是基于ClientConfigEnabledRoundRobinRule的扩展。

BestAvailableRule
继承自ClientConfixxxxxx。在实现中它注入了负载均衡器的统计对象loadBalancerStats，在choose中利用loadBalancerStats保存的数据来选择实例。
策略：通过遍历负载均衡器中文胡的所有服务实例，过滤掉故障的实例，并找出并发请求数最小的一个。该策略的特性是可以选出最空闲的实例。
算法的核心依据是loadBalancerStats，当该对象为空时，会采用父类的线性轮询策略。

PredicateBasedRule
继承自ClientConxxxxxx。
这是个抽象类，定义了一个抽象函数getPredicate。在choose中，调用getPredicate.chooseRoundRobinAfterFiltering。从名字可以看出：通过predicate过滤，然后线性轮询。
这里的predicate是AbstractServerPredicate，这个类很不错。Optional.absent，或者Optional.of(eligible.get(nextIndex.getAndIncrement()%eligible.size()))

AvailabilityFilteringRule
继承自PredicateBasedRule。过滤条件是AvailabilityPredicate
主要过滤逻辑位于shouldSkipServer中，主要判断2项内容：
1.是否故障，即断路器是否生效已断开
2.实例的并发请求数大于阈值，默认intMax，可以通过参数<clinetName>.<nameSpace>.ActiveConnectionsLimit来修改。
有一个满足就返回false(代表故障或负载过高)

choose也做了一定的修改，不像父类那样遍历所有节点进行过滤，然后在过滤后的集合中选择实例。。而是先以线性的方式选择一个实例，然后用过滤条件来判断实例是否满足要求，满足就使用，不满足就线性选择下一个，并判断。过程重复10次还没有找到，就采用父类中的方案。
该策略通过线程抽样的方式直接尝试寻找可用且较空闲的实例来使用，优化了父类每次都要遍历所有实例的开销。

ZoneAvoidanceRule
之前介绍负载均均衡器ZoneAwareLoadBalancer时已提到过，该rule也是PredicateBasedRule的具体实现类。之前的介绍主要正对该rule中用于Zone选择策略的一些静态函数，如createSnapshot，getAvailableZones。
它使用ConpositePredicate来进行过滤，这是一个组合过滤，在构造条件中，是以ZoneAvoidancePredicate为主过滤条件，AvailabilityPredicate为次过滤条件初始化了组合过滤条件的实例。
没有重写choose，依然按照父类的过滤主逻辑:先过滤清单，在轮询选择。
在CompositionPredicate的getEligibleServers方法中获取过滤结果。处理逻辑如下：
1.使用主过滤过滤所有实例
2.依次使用次过滤条件对1的结果进行过滤
3.每次过滤后(包括主过滤和次过滤条件)，都需要判断下面2个条件，有一个不符合就不再过滤，将当前结果返回供线性轮询算法选择
。过滤后实例总数>=最小过滤实例数(minimalFilteredServers.默认1)
。过滤后实例比例>最小过滤百分比(minimalFilteredPercentage,默认0)
。。按照默认的，岂不是找出一个就直接返回了。


142
配置详解

Ribbon中定义的每一个接口都有多种不同策略实现，这些接口间又有一定的依赖关系，这使得第一次使用Ribbon的开发者很难上手，不知道如何选择具体的实现策略以及如何组织它们的关系。
springCloud Ribbon的自动化配置恰恰能够解决这些痛点，在引入springCloudRibbon之后，就能自动化构建下面这些接口的实现。
IClientConfig。。ribbon客户端配置，默认采用com.netflix.client.config.DefaultClientConfigImpl实现
IRule。。ribbon的负载均衡策略。默认使用com.net.loadbal..ZoneAvoidanceRule实现，该策略能在多区域环境下选择出最佳区域的实例进行访问。
IPing。。ribbon的实例检查策略。默认使用com.netf.loadbal.NoOpPing实现，是一个特殊实现，它不检查实例是否可以，始终返回true
ServerList<Server>。。服务实例清单维护机制，默认com.netl.loadbal.ConfigutationBasedServerList.
ServerListFilter<Server>。。服务实例清单过滤机制，默认org.springf.cloud.netf.ribbon.ZonePreferenceServerListFilter，该策略能优先过滤出与请求调用方处于同区域的服务实例。
ILoadBalancer。。负载均衡器，默认com.netf.loadbal.ZoneAwareLoadBalancer实现。

上面的自动化配置内容仅在没有引入springCloudEureka时如此，同时引入eureka和ribbon，自动化配置会有些不同。

可以方便地替换上面的默认实现，只需要在sBoot中创建对应的实现实例就能覆盖默认的配置，如下面，由于创建了PingUrl实例，所以默认额NoOpPing就不会被创建
@Configuration
public class MyRibbonConfiguration {
	@Bean
	public IPing ribbonPing(IClientConfig config) {
		return new PingUrl();
	}
}

另外，也可以通过使用@RibbonClient注解来实现更细粒度的客户端配置，下面的代码实现类为hello-server服务使用HelloServiceConfiguration中的配置
@Configuration
@RibbonClient(name="hello-servive", configuration=HelloServeiceConfiguration.class)
public class RibbonConfiguration {}


144
Camden版本对RibbonClient配置的优化
上面介绍了Brixton版本对RibbonClient的IPing，IRule等接口实现个性化定制的方法，主要通过创建一个Configuration类来定义IPing，IRule等接口的具体实现bean，然后在创建RibbonClient时指定要使用的具体COnfiguration类来覆盖自动化配置的默认实现。
当有大量这类配置的时候，信息将分散在这些配置类的注解定义中，使得管理和修改都十分不方便。

所以Camden版本中。springCloudRibbon对RibbonClient定义个性化配置的方法做了进一步优化。可以直接通过<clientName>.ribbon.<key>=<value>形式进行配置。
比如我们要实现和上面例子一样的配置(将hello-service服务客户端的IPing接口替换为PingUrl)，只需要在application.properties中增加下面的内容即可：
hello-service.ribbon.NFLoadBalancerPingClassName=com.netflix.loadbalancer.PingUrl

camden版本中，springCloudRibbon新增了一个org.springfr.cloud.netflix.ribbon.PropertiesFactory类来动态地为RibbonCLient创建这些接口实现。
。。通过接口映射string(NFLoadBalancePingClassName等类似)，string映射实现类。

NFLoadBalancerClassName。配置ILoadBalancer接口的实现
NFLoadBalancerPingClassName。。IPing
NFLoadBalancerRUleClassName。。IRule
NIWSServerListClassName。。。ServerList
NIWSServerListFilterClassName。。ServerListFilter


参数配置
对于Ribbon的参数配置通常有2种方式，全局配置以及指定客户端配置。
全局配置很简单，只要ribbon.<key>=<value>..<key>代表ribbon客户端配置的参数名，<value>则代表对于参数的值。
如，下面全局配置了ribbon创建连接的超时时间
ribbon.ConnetTimeout=250
全局配置可以作为默认值进行设置，当客户端配置了相应key的值时，将覆盖全局配置

指定客户端配置，<client>.ribbon.<key>=<value>。<client>代表了客户端的名字。如上文中我们在@RibbonClient中指定的名字，也可以将它理解为是一个服务名。
假如，有一个服务消费者通过restTemplate来访问hello-service服务的/hello接口，这时会通过restTemplate.getForEntity("http://hello-service/hello", String.class).getBody()调用。如果没有服务治理框架的帮助，我们需要为该客户端指定具体的实例清单，可以指定服务名来做详细的配置，具体如下：
hello-service.ribbon.listOfServers=localhost:8001,localhost:8002

对于ribbon参数的key以及value类型的定义，可以通过查看com.netflix.client.config.CommonClientConfigKey类获得详细信息。


与Eureka结合
当在springCloud的应用中同时引入springCloudRibbon和springCloudEureka依赖时，会触发eureka中实现的对ribbon的自动化配置，
这时，serverList的维护机制实现将被com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList的实例所覆盖，该实现会把服务清单列表交给eureka的服务治理机制来维护。
IPing的实现将被com.netfl.niws.loadbalance.NIWSDiscoveryPing的实例所覆盖，该实现也将实例检查的任务交给了服务治理框架来进行维护。
默认情况下，用于获取实例请求的ServerList接口实现将采用springCloudEureka中封装的org.springf.cloud.netfl.ribbon.eureka.DomainExtractingServerList，其目的是为了让实例维护策略更加通用，所以将使用武力元回溯据来进行负载均衡，而不是使用原始的AWS AMI 元数据。

在与springCloudEureka结合使用时，配置将更简单。不再需要通过类似hello-serivice.ribbon.listOfServers的参数来指定具体的服务实例清单，因为eureka将会为我们维护所有服务的实例清单。
对于ribbon的参数配置，我们依然可以采用之前的2种配置方式，指定客户端的配置方式可以直接使用Eureka中的服务名作为<client>来完成个性化配置。

scloudRibbon默认实现类区域亲和策略，所以我们可以通过eureka实例的元数据配置来实现区域化的实例配置方案。比如，可以将处于不同机房的实例配置成不同的区域值，以作为跨区域的容错机制实现。实现方式很简单，只需在服务实例的元数据中增加zone参数指定自己所在的区域，如
eureka.instance.metadataMap.zone=shanghai

springCLoudRibbon与springCloudEureka结合的工程中，我们也可以通过参数配置的方式来禁用eureka对ribbon服务实例的维护。在配置中加入如下参数，这是我们对于服务实例的维护就又回到了<client>.ribbon.listOfServers参数配置。
ribbon.eureka.enabled=false

147
重试机制
spCloudEureka实现的服务治理机制强调CAP原理中的AP，即可用性与可靠性，它与ZooKeeper这类强调CP(一致性，可靠性)的服务治理框架最大的区别就是，eureka为了实现更高的服务可用性，牺牲了一定的一致性。在极端情况下它宁愿接受故障实例也不要丢掉"健康"实例。

sCloudEureka在可用性与一致性上的取舍，不论是由于触发了保护机制还是服务剔除的延迟，引发服务调用故障实例。我们还是希望能够增强对象这类问题的容错。。在目前的Brixton版本中，重试机制需要我们自己来扩展实现。从Camden SR2版本开始，springCloud整合了springRetry来增强restTemplate的重试能力。，对于开发者来说，只需简单配置，原来那些通过restTemplate实现的服务访问就会自动根据配置来实现重试策略。

以hello-service服务调用为例，可以在配置文件中增加以下内容：
spring.cloud.loadbalancer.retry.enabled=true	// 开启重试机制，默认关闭的。
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000		// 断路器的超时时间需要大于Ribbon的超时时间，不然不会触发重试
hello-service.ribbon.ConnectionTimeout=250	// 请求连接的超时时间
hello-service.ribbon.ReadTimeout=1000	// 请求处理的超时时间
hello-service.ribbon.OkToRetryOnAllOperations=true	// 对所有操作请求都进行重试
hello-service.ribbon.MaxAutoRetriesNextServer=2		// 切换实例的重试次数
hello-service.ribbon.MaxAutoRetries=1	// 对当前实例的重试次数

根据如上配置，当访问到故障请求时，会再尝试访问一次当前实例(次数有MaxAutoRetries决定)，如果不行，就换一个实例，如果还是不行，再换一个实例(更换次数有MaxAutoRetriesNextServer配置)。如果还是不行，返回失败信息。


149
chapter 5
服务容错保护：Spring Cloud Hystrix

当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。

springCloudHystrix实现类断路器，线程隔离等一系列服务保护功能。是基于netflix的开源框架Hystrix实现的，该框架的目标在于通过控制那些访问远程系统，服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。hystrix具备服务降级，服务熔断，线程和信号隔离，请求缓存，请求合并，服务监控等强大功能。


引入sCloud Hystrix
ribbon-consumer工程pom引入dependency-(spring-cloud-starter-hystrix)

ribbon-consumer主类ConsumberApplication中使用@EnableCircuitBreaker开启断路器功能
@EnableCircuitBreaker
@EnableDiscoveryClient
@SpringBootApplication
public class ConsumerApplication {
	@Bean
	@LoadBalanced
	RestTemplate restTemplate() {
		return new RestTemplate9);
	}

	public static void main(Stirng[] args) {
		SpringApplication.run(ConsumerApplication.class, args);
	}
}
这3个注解可以用@SpringCloudApplication来替代

修改服务消费方式，新增HelloService类，注入RestTemplate实例。然后，将在ConsumberController中对RestTemplate的使用迁移到helloService函数中，最后在helloService函数上添加@HystrixCommand注解来指定回调方法：
@Service
public class HelloService {
	@AutoWired
	RestTemplate restt;

	@HystrixCommand(fallbackMethod = "helloFallBakc")
	public String helloService() {
		return restt.getForEntity("http://HELLO-SERVICE/hello", String.class).getBody();
	}

	public String helloFallBack() { return "error"; }
}
。。test。。不清楚回调方法何时被调用，正常返回，超时，有异常？，现在看起来是超时或非HystrixBadRequestException的异常。。@HystrixCommand有ignoreException={xx.class}参数，可以忽略某些异常,被忽略的异常会被封装成一个HystrixBadRequestException，这样就不会触发fallback逻辑

修改ComsumerController类，注入上面的HelloService，并调用
@RestController
public class ConsumerController {
	@Autowired
	HelloService helloService;

	@RequestMapping(value="/ribbon-consumer", method=RequestMethod.GET)
	public String helloConsumer() {
		return helloService.helloService();
	}
}


154
原理分析


170
使用详解

创建请求命令


服务降级，就是靠fallBackMethod来指定一个方法来继续尝试获得数据，这个方法也可以用@HystrixCommand来注解。

@HystrixCommand 中有很多功能

异常传播，获取
传统方式的Hystrix命令中，使用getFallback().getExecutionException来获取异常。
注解配置方式同样也可以获得异常。只需要fallback实现的方法的参数中增加Throwable e对象。
@HystrixCommand(fallbackMethod="fallback1")
User getUserById(String id) {
	throw new RuntimeException("get fail");
}

User fallback1(String id, Throwable e) {
	assert "get fail".equals(e.getMessage());
}

命令名称，分组即线程池划分
以继承方式实现的Hystrix命令使用类名作为默认的命令名称，我们也可以在构造函数中通过Setter静态类来设置，如：
public UserCommand() {
	super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("GroupName")).addCommandKey(HystrixCommandKey.Factory.asKey("CommandName")));
}
groupKey是必须的，CommandKey是可选的。


默认情况下，hystrix会让相同组名的命令使用同一个线程池，在创建hystrix命令是为其指定组名来实现默认的线程划分。

显式划分
public UserCommand() {
	super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("CommandGroupKey")).addCommandKey(HystrixCommandKey.Factory.asKey("CommandKey")).andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey("ThreadPoolKey")));
}

@HystrixCommand(commandKey="getUserById", groupKey="UserGroup", threadPoolKey="getUserByIdThread")
public User getUserById(Long id) {
}
相同的效果


请求缓存
开启和使用缓存，减轻高并发时的请求线程消耗，降低请求响应时间。

开启，只需要在实现HystrixCommand或HystrixObservableCommand时，通过重载getCacheKey()方法来开启请求缓存。

public class UserCommand extends HystrixCommand<User> {
	pivate RestTemplate rest;
	private Long id;

	public UserCommand(RestTemplate rest, Long id) {
		super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("UserGroup")));
		this.rest = rest;
		this.id = id;
	}

	@Override
	protected User run() {
		return rest.getForObject("http://user-service/users/{1}", User.class, id);
	}

	@Override
	protected String getCacheKey() { return String.valueOf(id); }
}

getCacheKey返回，请求缓存key值，就能让该请求具备缓存功能。
当不同外部请求处理逻辑调用了同一个依赖服务时，Hystrix会根据getCacheKey返回值来区分是否重复请求，如果它们的cacheKey相同，那么该依赖服务只会在第一个请求到达时被调用一次，其他的请求则是直接或从请求缓存中赶回结果。
开启请求缓存可以让我们实现的hystrix命令具有以下好处：
1.减少重复的请求数，降低依赖服务的并发量。
2.在同一用户请求的上下文中，相同依赖服务的返回数据始终保持一致。
3.请求缓存在run和construct执行之前生效，可以减少不必要的线程开销。

。。2既有好处也有坏处啊。会丢失其他线程的更新吧。如果再保存下。。下面有。。

清理失效缓存功能
如果只有读操作，那么不需要考虑缓存中内容是否正确。
如果还有更新数据的写操作，那么缓存中的数据就需要我们在进行写操作时进行及时处理，以防止读操作的请求命令获取实效数据。

通过HystrixRequestCache.clear来清理缓存。

180例子

clear包装成一个static方法。

在更新操作的run中调用static方法(参数Id)，来clear
static方法中是：HystrixRequestCache.getInstance(GETTER_KEY, HystrixConcurrencyStrategyDefault.getInstance()).clear(String.valueOf(id));

GETTER_KEY是类属性private static final修饰。。x = HystrixCommandKey.Factory.asKey("CommandKey");

Hystrix的请求缓存，还可以通过注解方式进行配置。注解配置的定义实现同JSR107的定义非常相似，但由于Hystrix不需要独立外置的缓存系统来支持，所以没有JSR107的定义那么复杂，它只提供了3个专用于请求缓存的注解。

注解			描述							属性
@CacheResult	用来标记请求命令返回的结果应该被缓存，必须和@HystrixCommand注解结合使用				cacheKeyMethod
@CacheRemove	让请求命令的缓存失效，失效的缓存更具定义的key决定		commandKey，cacheKeyMethod
@CacheKey	用在请求命令的参数上标记，使其作为缓存的key值，如果没有标注则会使用所有参数。如果同时还有@CacheResult和@CacheRemove注解的cacheKeyMethod方法指定缓存Key的生成，那么该注解将不会起作用		value
。。根据下面的意思，使用所有参数是指：形参.toString。。value可以指定形参里的某个属性，不知道能不能多个属性，可能不行，毕竟value没有s，看注解里究竟怎么写的吧。

184
设置请求缓存：当该依赖服务被调用并发挥User对象时，由于该方法被@CacheResult注解，所以Hystrix会将该结果置入请求缓存中，而它缓存Key值会使用所有的参数，也就是这里Long类型的id值。
@CacheResult
@HystrixCommand
public User getUserById(Long id) {
	return restTemplate.getForObject("http://user-service/users/{1}", User.class, id);
}

定义缓存Key，可以使用@CacheResult，@CahceRemove的cacheKeyMethod方法来指定具体的生成函数，也可以通过使用@CacheKey注解在方法参数中指定用于组装缓存Key的元素。
@CacheResult(cacheKeyMethod="getCacheKey")
@HystrixCommand
public User getUserById(Long id) {}
private Long getCacheKey(Long id) {return id;}
。。这个2个方法的形参是不是需要一致？

通过@CahceKey注解实现更简单。要注意，优先级比cachekeyMethod低，如果已经使用了cacheKeyMethod指定缓存key的生成函数，那么@CacheKey不会生效。
@CacheResult
@HystrixCommand
public User getUserById(@CacheKey("id") Long id) { }

@CacheKey注解除了可以指定方法参数作为缓存Key之外，还允许访问参数对象内部属性作为缓存Key，下面指定User对象的id属性作为缓存Key。
@CacheResult
@HystrixCommand
public User getUserById(@CacheKey("id") User user) { }


缓存清理，@CacheRemove实现对失效缓存的清理。
@CacheResult
@HystrixCommand
public User getUserById(@CacheKey("id") Long id) { }

@CacheRemove(commandKey="getUserById")
@HystrixCommand
public void update(@CacheKey("id") User user) { }

commandKey是必须的，用来指明需要使用请求缓存的请求命令。只有通过该属性的配置，Hystrix才能找到正确的请求命令缓存位置。
。。缓存是 方法+cacheKey 作为Key的。。确实，不同方法，相同cacheKey，就完蛋了。。


请求合并
微服务架构中的依赖通常通过远程调用实现，而远程调用中最常见的问题就是通信消耗与连接数占用。

高并发下，因通信次数的增加，总的通信时间消耗将会变得不那么理想。
同时，因为依赖服务的线程池资源有限，将出现排队等待与响应延迟的情况。

为了优化这2个问题，Hystrix提供了HystrixCollapser来实现请求的合并，以减少通信消耗和线程数的占用。

HystrixCollapser实现了在HystrixCommand之前放置一个合并处理器，将处于一个很短的时间窗(默认10ms)内对同一个依赖服务的多个请求进行整合并以批量方式发起请求的功能(服务提供方需要提供相应的批量实现接口)
通过HystrixCollapser的封装，开发者不需要关注线程合并的细节过程，只需关注批量化服务和处理。

public abstract class HystrixCollapser<BatchReturnType, ResponseType, RequestArgumentTypee> implements HystrixExecutable<ResponseType>, HystrixObservable<ResponseType> {}

指定了3个不同类型
BatchReturnType。。合并后批量请求的返回类型。
ResponseType。。单个请求返回的类型。
RequestArgumentType。。请求参数类型。

这3个类型的使用可以在它的三个抽象方法中看到
。。。

186__
简单例子来直观理解实现请求合并的过程

假设当前微服务USER-SERVICE提供了2个获取User的接口
/users/{id}。。根据id返回User对象的GET请求接口
/users?ids={ids}。。根据ids返回User对象列表的GET请求接口，其中ids为以逗号分隔的id集合。

服务消费端为这2个远程接口通过restTemplate实现了简单的调用
@Service
public class UserServiceImpl implements UserService {
	@Autowired
	private RestTemplate restTemplate;

	@Override
	public User find(Long id) {
		return restTemplate.getForObject("http://USER-SERVICE/users/{1}", User.class, id);
	}

	@Override
	public List<User> findAll(List<Long> ids) {
		return restTemplate.getForObject("http://USER-SERVICE/users?ids={1}", List.class, StringUtils.join(ids, ","));
	}
}

接着，我们实现将段时间内多个获取单一User对象的请求命令进行合并。
1. 为请求合并的实现准备一个批量请求命令的实现：
public class UserBatchCommand extends HystrixCommand<List<User>> {
	UserService userService;
	List<Long> userIds;

	public UserBatchCommand(UserService userService, List<Long> userIds) {
		super(Setter.withGroupKey(asKey("userServiceCommand")));
		this.userIds = userIds;
		this.userService = userService;
	}

	@Override
	protected List<User> run() throws Exception {
		return userService.findAll(userIds);
	}
}
批量请求命令实际上就是一个简单的HystrixCommand实现，从上面的实现中可以看到它通过调用userService.findAll方法来返回/users?ids={ids}接口以返回User的列表结果。

2.通过继承HystrixCollapser实现请求合并器。
public class UserCollapseCommand extends HystrixCollapser<List<User>, User, Long> {
	private UserService userService;
	- Long userId;

	+ UserCollapseCommand(UserService userService, Long userId) {
		super(Setter.withCollapserKey(HystrixCollapserKey.Factroy.asKey("userCollapseCommand")).addCollapserPropertiesDefaults(
		HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(100)
		));
		this.userService = userService;
		this.userId = userId;
	}

	@Override
	public Long getRequestArgument() {
		return userId;
	}

	@Override
	protected HystrixCommand<List<User>> createCommand(Collection<CollapsedRequest<User, Long>> collapsedRequests) {
		List<Long> userIds = new ArrayList<>(collapsedRequests.size());
		userIds.addAll(collapsedRequests.stream().map(CollapsedRequest::getArgument).collext(Collectors.toList()));
		return new UserBatchCommand(userService, userIds);
	}

	@Override
	protected void mapResourceToRequests(List<User> batchResponse, Collection<CollapsedRequest<User, Long>> collapsedRequests) {
		int count = 0;
		for (CollapsedRequest<User, Long> collapsedRequest : collapsedRequests) {
			User user = batchResponse.get(count++);
			collapsedRequest.setResponse(user);
		}
	}
}



Feign
通过接口绑定服务，直接调用这个接口就可以了，不再需要restTemplate.(locahost:555/ser1/getSth)，这种了。直接接口.方法，接口不需要实现。


Zuul
网关，路由。集合安全验证。提供统一的访问接口。
server.port=5555
zuul.routes.api-a-url.path=/api-a-url/**
zuul.routes.api-a-url.url=http://localhost:8080/

localhost:5555/api-a-url/hello,转发到localhost:8080/hello上。

zuul.routes.user-service.path=/user-service/**
zuul.routes.user-service.serviceId=user-serivce
ribbon.eureka.enabled=false
user-service.ribbon.listOfServers=http://localhost:8080,http://localhost:8081/


276
动态路由
通过eureka服务注册中心
zuul.routes.service-a.path=/service-a/**
zuul.routes.service-a.serviceId=hello-service


286
spring cloud config
动态刷新配置
/refresh


314
spring cloud bus
对消息队列的封装。。？
与config整合


363
spring cloud stream
消息队列的封装.。不。构建消息驱动微服务的框架。


spring cloud sleuth
跟踪，信息的保存和展现。
































===============================
spring mvc


DispatcherServlet间接继承了HttpServlet，并且父类重写了doGet，会最终调用DispatcherServlet的doService，doDispatcher。
doDispatcher从handlerMapping中寻找能用的HandlerExecutionChain，包装成HandlerAdapter。
applyDefaultViewName 设置view名字
processDispatchResult方法 中的 render方法 根据view名字找view。

View view = viewResolver.resolveViewName(viewName, locale);


1、清晰的角色划分：前端控制器（DispatcherServlet）、请求到处理器映射（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）、处理器或页面控制器（Controller）、验证器（   Validator）、命令对象（Command  请求参数绑定到的对象就叫命令对象）、表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。



xml配置
web.xml
<servlet>
	<servlet-name>chapter2</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>chapter2</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>


DispatcherServlet会加载WEB-INF/[DispatcherServlet的Servlet名字]-servlet.xml配置文件。本示例为WEB-INF/ chapter2-servlet.xml。


WEB-INF/ chapter2-servlet.xml

<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>

<bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>

<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
    <property name="prefix" value="/WEB-INF/jsp/"/>
    <property name="suffix" value=".jsp"/>
</bean>
viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，classpath中必须包含jstl的相关jar包；

<bean name="/hello" class="cn.javass.chapter2.web.controller.HelloWorldController"/>
name="/hello"：前边配置的BeanNameUrlHandlerMapping，表示如过请求的URL为 “上下文/hello”，则将会交给该Bean进行处理。















web端开发历程
CGI - Servlet - JSP - Model2(Web MVC)
				\Model1		\Front Controller+Page Controller

CGI：（Common Gateway Interface）公共网关接口，一种在web服务端使用的脚本技术，使用C或Perl语言编写，用于接收web用户请求并处理，最后动态产生响应给用户，但每次请求将产生一个进程，重量级。

Servlet：一种JavaEE web组件技术，是一种在服务器端执行的web组件，用于接收web用户请求并处理，最后动态产生响应给用户。但每次请求只产生一个线程（而且有线程池），轻量级。而且能利用许多JavaEE技术（如JDBC等）。本质就是在java代码里面 输出 html流。但表现逻辑、控制逻辑、业务逻辑调用混杂。



JSP：（Java Server Page）：一种在服务器端执行的web组件，是一种运行在标准的HTML页面中嵌入脚本语言（现在只支持Java）的模板页面技术。本质就是在html代码中嵌入java代码。JSP最终还是会被编译为Servlet，只不过比纯Servlet开发页面更简单、方便。但表现逻辑、控制逻辑、业务逻辑调用还是混杂。


Model1：可以认为是JSP的增强版，可以认为是jsp+javabean
特点：使用<jsp:useBean>标准动作，自动将请求参数封装为JavaBean组件；还必须使用java脚本执行控制逻辑。



Model2：在JavaEE世界里，它可以认为就是Web MVC模型
Model2架构其实可以认为就是我们所说的Web MVC模型，只是控制器采用Servlet、模型采用JavaBean、视图采用JSP，



服务到工作者：Front Controller + Application Controller + Page Controller + Context
即，前端控制器+应用控制器+页面控制器（也有称其为动作）+上下文，也是Web MVC，只是责任更加明确

职责：
Front Controller：前端控制器，负责为表现层提供统一访问点，从而避免Model2中出现的重复的控制逻辑（由前端控制器统一回调相应的功能方法，如前边的根据submitFlag=login转调login方法）；并且可以为多个请求提供共用的逻辑（如准备上下文等等），将选择具体视图和具体的功能处理（如login里边封装请求参数到模型，并调用业务逻辑对象）分离。

Application Controller：应用控制器，前端控制器分离选择具体视图和具体的功能处理之后，需要有人来管理，应用控制器就是用来选择具体视图技术（视图的管理）和具体的功能处理（页面控制器/命令对象/动作管理），一种策略设计模式的应用，可以很容易的切换视图/页面控制器，相互不产生影响。

Page Controller(Command)：页面控制器/动作/处理器：功能处理代码，收集参数、封装参数到模型，转调业务对象处理模型，返回逻辑视图名交给前端控制器（和具体的视图技术解耦），由前端控制器委托给应用控制器选择具体的视图来展示，可以是命令设计模式的实现。页面控制器也被称为处理器或动作。

Context：上下文，还记得Model2中为视图准备要展示的模型数据吗，我们直接放在request中（Servlet API相关），有了上下文之后，我们就可以将相关数据放置在上下文，从而与协议无关（如Servlet API）的访问/设置模型数据，一般通过ThreadLocal模式实现。



Spring Web MVC也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器其实拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View Resolver)进行视图管理；页面控制器/动作/处理器为Controller接口（仅包含ModelAndView handleRequest(request, response) 方法）的实现（也可以是任何的POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。

具体执行步骤如下：
1、  首先用户发送请求――――>前端控制器，前端控制器根据请求信息（如URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；图2-1中的1、2步骤；
2、  页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在Spring Web MVC中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView（模型数据和逻辑视图名）；图2-1中的3、4、5步骤；
3、  前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；图2-1中的步骤6、7；
4、  前端控制器再次收回控制权，将响应返回给用户，图2-1中的步骤8；至此整个结束。


问题：
1、  请求如何给前端控制器？
2、  前端控制器如何根据请求信息选择页面控制器进行功能处理？
3、  如何支持多种页面控制器呢？
4、  如何页面控制器如何使用业务对象？
5、  页面控制器如何返回模型数据？
6、  前端控制器如何根据页面控制器返回的逻辑视图名选择具体的视图进行渲染？
7、  不同的视图技术如何使用相应的模型数据？


核心架构的具体流程步骤如下：
1、  首先用户发送请求――>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；
2、  DispatcherServlet――>HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；
3、  DispatcherServlet――>HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；
4、  HandlerAdapter――>处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；
5、  ModelAndView的逻辑视图名――> ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；
6、  View――>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；
7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。


在此我们可以看出具体的核心开发步骤：
1、  DispatcherServlet在web.xml中的部署描述，从而拦截请求到Spring Web MVC
2、  HandlerMapping的配置，从而将请求映射到处理器
3、  HandlerAdapter的配置，从而支持多种类型的处理器
4、  ViewResolver的配置，从而将逻辑视图名解析为具体视图技术
5、处理器（页面控制器）的配置，从而进行功能处理



需要添加jstl标签库支持，此处使用的是jstl-1.1.2.jar和standard-1.1.2.jar；

web.xml中添加
<servlet>
	<servlet-name>chapter2</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>chapter2</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>


自此请求已交给Spring Web MVC框架处理，因此我们需要配置Spring的配置文件，默认DispatcherServlet会加载WEB-INF/[DispatcherServlet的Servlet名字]-servlet.xml配置文件。本示例为WEB-INF/ chapter2-servlet.xml。


在Spring配置文件中配置HandlerMapping、HandlerAdapter
具体配置在WEB-INF/ chapter2-servlet.xml文件中：
<!-- HandlerMapping -->
<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
<!-- HandlerAdapter -->
<bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>

BeanNameUrlHandlerMapping：表示将请求的URL和Bean名字映射，如URL为 “上下文/hello”，则Spring配置文件必须有一个名字为“/hello”的Bean，上下文默认忽略。
SimpleControllerHandlerAdapter：表示所有实现了org.springframework.web.servlet.mvc.Controller接口的Bean可以作为Spring Web MVC中的处理器。如果需要其他类型的处理器可以通过实现HadlerAdapter来解决。


在Spring配置文件中配置ViewResolver
具体配置在WEB-INF/ chapter2-servlet.xml文件中：
<!-- ViewResolver -->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
	<property name="prefix" value="/WEB-INF/jsp/"/>
	<property name="suffix" value=".jsp"/>
</bean>


InternalResourceViewResolver：用于支持Servlet、JSP视图解析；
viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，classpath中必须包含jstl的相关jar包；
prefix和suffix：查找视图页面的前缀和后缀（前缀[逻辑视图名]后缀），比如传进来的逻辑视图名为hello，则该该jsp视图页面应该存放在“WEB-INF/jsp/hello.jsp”；



public class HelloWorldController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {
       //1、收集参数、验证参数
       //2、绑定参数到命令对象
       //3、将命令对象传入业务对象进行业务处理
       //4、选择下一个页面
       ModelAndView mv = new ModelAndView();
       //添加模型数据 可以是任意的POJO对象
       mv.addObject("message", "Hello World!");
       //设置逻辑视图名，视图解析器会根据该名字解析到具体的视图页面
       mv.setViewName("hello");
       return mv;
    }
}

org.springframework.web.servlet.mvc.Controller：页面控制器/处理器必须实现Controller接口，注意别选错了；后边我们会学习其他的处理器实现方式；

public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) ：功能处理方法，实现相应的功能处理，比如收集参数、验证参数、绑定参数到命令对象、将命令对象传入业务对象进行业务处理、最后返回ModelAndView对象；

ModelAndView：包含了视图要实现的模型数据和逻辑视图名；“mv.addObject("message", "Hello World!");

”表示添加模型数据，此处可以是任意POJO对象；“mv.setViewName("hello");”表示设置逻辑视图名为“hello”，视图解析器会将其解析为具体的视图，如前边的视图解析器InternalResourceVi。wResolver会将其解析为“WEB-INF/jsp/hello.jsp”。


我们需要将其添加到Spring配置文件(WEB-INF/chapter2-servlet.xml)，让其接受Spring IoC容器管理:
<!-- 处理器 -->
<bean name="/hello" class="cn.javass.chapter2.web.controller.HelloWorldController"/>

name="/hello"：前边配置的BeanNameUrlHandlerMapping，表示如过请求的URL为 “上下文/hello”，则将会交给该Bean进行处理。


${message}：表示显示由HelloWorldController处理器传过来的模型数据。


spring Web MVC框架提供了org.springframework.web.filter.CharacterEncodingFilter用于解决POST方式造成的中文乱码问题
<filter>
	<filter-name>CharacterEncodingFilter</filter-name>
	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
	<init-param>
		<param-name>encoding</param-name>
		<param-value>utf-8</param-value>
	</init-param>
</filter>
<filter-mapping>
	<filter-name>CharacterEncodingFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>



Spring2.5引入注解式处理器支持，通过@Controller 和 @RequestMapping注解定义我们的处理器类

需要通过处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter来开启支持@Controller 和@RequestMapping注解的处理器。

@Controller：用于标识是处理器类；
@RequestMapping：请求到处理器功能方法的映射规则；
@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；
@ModelAttribute：请求参数到命令对象的绑定；
@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；
@InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；


Spring3.0引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持：
@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；
@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；
@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；
@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；
@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；
@ExceptionHandler：注解式声明异常处理器；
@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定，从而支持RESTful架构风格的URI；



JSR-303验证框架的无缝支持（通过@Valid注解定义验证元数据）；
使用Spring 3开始的ConversionService进行类型转换（PropertyEditor依然有效），支持使用@NumberFormat 和 @DateTimeFormat来进行数字和日期的格式化；
Spring 3 引入 一个  mvc XML的命名空间用于支持mvc配置，包括如：
<mvc:annotation-driven>：
自动注册基于注解风格的处理器需要的DefaultAnnotationHandlerMapping、AnnotationMethodHandlerAdapter
支持Spring3的ConversionService自动注册
支持JSR-303验证框架的自动探测并注册（只需把JSR-303实现放置到classpath）
自动注册相应的HttpMessageConverter（用于支持@RequestBody  和 @ResponseBody）（如XML输入输出转换器（只需将JAXP实现放置到classpath）、JSON输入输出转换器（只需将Jackson实现放置到classpath））等。
<mvc:interceptors>：注册自定义的处理器拦截器；
<mvc:view-controller>：和ParameterizableViewController类似，收到相应请求后直接选择相应的视图；
<mvc:resources>：逻辑静态资源路径到物理静态资源路径的支持；
<mvc:default-servlet-handler>：当在web.xml 中DispatcherServlet使用<url-pattern>/</url-pattern> 映射时，能映射静态资源（当Spring Web MVC框架没有处理请求对应的控制器时（如一些静态资源），转交给默认的Servlet来响应静态文件，否则报404找不到资源错误，）。


对Servlet 3.0的全面支持。
@EnableWebMvc：
用于在基于Java类定义Bean配置中开启MVC支持，和XML中的<mvc:annotation-driven>功能一样；

新的@Contoller和@RequestMapping注解支持类：处理器映射RequestMappingHandlerMapping 和 处理器适配器RequestMappingHandlerAdapter组合来代替Spring2.5开始的处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter，提供更多的扩展点，它们之间的区别我们在处理器映射一章介绍。

新的@ExceptionHandler 注解支持类：ExceptionHandlerExceptionResolver来代替Spring3.0的AnnotationMethodHandlerExceptionResolver，在异常处理器一章我们再详细讲解它们的区别。

@RequestMapping的"consumes" 和 "produces" 条件支持：用于支持@RequestBody 和 @ResponseBody，
1consumes指定请求的内容是什么类型的内容，即本处理方法消费什么类型的数据，如consumes="application/json"表示JSON类型的内容，Spring会根据相应的HttpMessageConverter进行请求内容区数据到@RequestBody注解的命令对象的转换；
2produces指定生产什么类型的内容，如produces="application/json"表示JSON类型的内容，Spring的根据相应的HttpMessageConverter进行请求内容区数据到@RequestBody注解的命令对象的转换，Spring会根据相应的HttpMessageConverter进行模型数据（返回值）到JSON响应内容的转换

URI模板变量增强：URI模板变量可以直接绑定到@ModelAttribute指定的命令对象、@PathVariable方法参数在视图渲染之前被合并到模型数据中（除JSON序列化、XML混搭场景下）。
@Validated：JSR-303的javax.validation.Valid一种变体（非JSR-303规范定义的，而是Spring自定义的），用于提供对Spring的验证器（org.springframework.validation.Validator）支持，需要Hibernate Validator 4.2及更高版本支持；
@RequestPart：提供对“multipart/form-data”请求的全面支持，支持Servlet 3.0文件上传（javax.servlet.http.Part）、支持内容的HttpMessageConverter（即根据请求头的Content-Type，来判断内容区数据是什么类型，如JSON、XML，能自动转换为命令对象），比@RequestParam更强大（只能对请求参数数据绑定，key-alue格式），而@RequestPart支持如JSON、XML内容区数据的绑定；详见本章的第×××节；
Flash 属性 和 RedirectAttribute：通过FlashMap存储一个请求的输出，当进入另一个请求时作为该请求的输入，典型场景如重定向（POST-REDIRECT-GET模式，1、POST时将下一次需要的数据放在FlashMap；2、重定向；3、通过GET访问重定向的地址，此时FlashMap会把1放到FlashMap的数据取出放到请求中，并从FlashMap中删除；从而支持在两次请求之间保存数据并防止了重复表单提交）。

Spring Web MVC提供FlashMapManager用于管理FlashMap，默认使用SessionFlashMapManager，即数据默认存储在session中。





DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下：

1、文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；

2、通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）；

3、通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)；

4、通过ViewResolver解析逻辑视图名到具体视图实现；

5、本地化解析；

6、渲染具体的视图等；

7、如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。




该DispatcherServlet默认使用WebApplicationContext作为上下文，Spring默认配置文件为“/WEB-INF/[servlet名字]-servlet.xml”。

DispatcherServlet也可以配置自己的初始化参数，覆盖默认配置：

contextClass
实现WebApplicationContext接口的类，当前的servlet用它来创建上下文。如果这个参数没有指定， 默认使用XmlWebApplicationContext。

contextConfigLocation
传给上下文实例（由contextClass指定）的字符串，用来指定上下文的位置。这个字符串可以被分成多个字符串（使用逗号作为分隔符） 来支持多个上下文（在多上下文的情况下，如果同一个bean被定义两次，后面一个优先）。

namespace
WebApplicationContext命名空间。默认值是[server-name]-servlet。


<servlet>
	<servlet-name>chapter2</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<load-on-startup>1</load-on-startup>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:spring-servlet-config.xml</param-value>
	</init-param>
</servlet>

如果使用如上配置，Spring Web MVC框架将加载“classpath:spring-servlet-config.xml”来进行初始化上下文而不是“/WEB-INF/[servlet名字]-servlet.xml”。


集成Web环境的通用配置：

<context-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>
          classpath:spring-common-config.xml,
          classpath:spring-budget-config.xml
      </param-value>
</context-param>
<listener>
  	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

如上配置是Spring集成Web环境的通用配置；一般用于加载除Web层的Bean（如DAO、Service等），以便于与其他任何Web框架集成。
contextConfigLocation：表示用于加载Bean的配置文件；
contextClass：表示用于加载Bean的ApplicationContext实现类，默认WebApplicationContext。

创建完毕后会将该上下文放在ServletContext：
servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,this.context);


DispatcherServlet初始化的上下文加载的Bean是只对Spring Web MVC有效的Bean，如Controller、HandlerMapping、HandlerAdapter等等，该初始化上下文应该只加载Web相关组件。


HttpServletBean继承HttpServlet
FrameworkServlet继承HttpServletBean
DispatcherServlet继承FrameworkServlet

整个DispatcherServlet初始化的过程和做了些什么事情，具体主要做了如下两件事情：
1、初始化Spring Web MVC使用的Web上下文，并且可能指定父容器为（ContextLoaderListener加载了根上下文）；
2、初始化DispatcherServlet使用的策略，如HandlerMapping、HandlerAdapter等。



DispatcherServlet默认配置
DispatcherServlet的默认配置在DispatcherServlet.properties（和DispatcherServlet类在一个包下）中，而且是当Spring配置文件中没有指定配置时使用的默认策略：

org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver
org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver
org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping

org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter

org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver

org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator

org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver

org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager



DispatcherServlet默认使用WebApplicationContext作为上下文，因此我们来看一下该上下文中有哪些特殊的Bean：

1、Controller：处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理；

2、HandlerMapping：请求到处理器的映射，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器；

3、HandlerAdapter：HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理；

4、ViewResolver：ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为jsp视图；

5、LocalResover：本地化解析，因为Spring支持国际化，因此LocalResover解析客户端的Locale信息从而方便进行国际化；

6、ThemeResovler：主题解析，通过它来实现一个页面多套风格，即常见的类似于软件皮肤效果；

7、MultipartResolver：文件上传解析，用于支持文件上传；

8、HandlerExceptionResolver：处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息）；

9、RequestToViewNameTranslator：当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名；

10、FlashMapManager：用于管理FlashMap的策略接口，FlashMap用于存储一个请求的输出，当进入另一个请求时作为该请求的输入，通常用于重定向场景，后边会细述。



Controller控制器，是MVC中的部分C，为什么是部分呢？因为此处的控制器主要负责功能处理部分：

1、收集、验证请求参数并绑定到命令对象；
2、将命令对象交给业务对象，由业务对象处理并返回模型数据；
3、返回ModelAndView（Model部分是业务对象返回的模型数据，视图部分为逻辑视图名）。


还记得DispatcherServlet吗？主要负责整体的控制流程的调度部分：
1、负责将请求委托给控制器进行处理；
2、根据控制器返回的逻辑视图名选择具体的视图进行渲染（并把模型数据传入）。

因此MVC中完整的C（包含控制逻辑+功能处理）由（DispatcherServlet + Controller）组成。


直接在控制器通过response写出响应呢，以下代码帮我们阐述：
public class HelloWorldWithoutReturnModelAndViewController extends AbstractController {
	@Override
	protected ModelAndView handleRequestInternal(HttpServletRequest req, HttpServletResponse resp) throws Exception {

		resp.getWriter().write("Hello World!!");
		//如果想直接在该处理器/控制器写响应 可以通过返回null告诉DispatcherServlet自己已经写出响应了，不需要它进行视图解析
		return null;
	}
}



<!― 在chapter4-servlet.xml配置处理器 -->
<bean name="/helloWithPOST" class="cn.javass.chapter4.web.controller.HelloWorldController">
        <property name="supportedMethods" value="POST"></property>
</bean>

以上配置表示只支持POST请求，如果是GET请求客户端将收到“HTTP Status 405 - Request method 'GET' not supported”。



<!― 在chapter4-servlet.xml配置处理器 -->
<bean name="/helloRequireSession"
class="cn.javass.chapter4.web.controller.HelloWorldController">
        <property name="requireSession" value="true"/>
</bean>

在进入该控制器时，一定要有session存在，否则抛出HttpSessionRequiredException异常。


Session同步：
即同一会话只能串行访问该控制器。



package cn.javass.chapter4.web.controller;
//省略import
public class HelloWorldCacheController extends AbstractController {
	@Override
	protected ModelAndView handleRequestInternal(HttpServletRequest req, HttpServletResponse resp) throws Exception {

		//点击后再次请求当前页面
		resp.getWriter().write("<a href=''>this</a>");
		return null;
	}
}

<!― 在chapter4-servlet.xml配置处理器 -->
<bean name="/helloCache"
class="cn.javass.chapter4.web.controller.HelloWorldCacheController">
<property name="cacheSeconds" value="5"/>
</bean>

如上配置表示告诉浏览器缓存5秒钟：5s内再点击链接是不会发送请求到服务器的。

下面提到一些关于缓存控制的一些特殊情况：
1、对于一般的页面跳转（如超链接点击跳转、通过js调用window.open打开新页面都是会使用浏览器缓存的，在未过期情况下会直接使用浏览器缓存的副本，在未过期情况下一次请求也不发送）；
2、对于刷新页面（如按F5键刷新），会再次发送一次请求到服务器的；


不缓存，cacheSeconds=0

cacheSeconds<0，将不添加任何数据
响应头什么缓存控制信息也不加。


客户端强制缓存过期：
（1、可以按ctrl+F5强制刷新（会添加请求头 HTTP1.0 Pragma:no-cache和 HTTP1.1 Cache-Control:no-cache、If-Modified-Since请求头被删除）表示强制获取服务器内容，不缓存。

（2、在请求的url后边加上时间戳来重新获取内容，加上时间戳后浏览器就认为不是同一份内容：
http://sishuok.com/?2343243243 和 http://sishuok.com/?34334344 是两次不同的请求。

Spring也提供了Last-Modified机制的支持，只需要实现LastModified接口

Spring判断是否过期，通过如下代码，即请求的“If-Modified-Since” 大于等于当前的getLastModified方法的时间戳，则认为没有修改：
this.notModified = (ifModifiedSince >= (lastModifiedTimestamp / 1000 * 1000));


ETag（实体标记）缓存机制
（1：浏览器第一次请求，服务器在响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：“ETag:"0f8b0c86fe2c0c7a67791e53d660208e3"”
（2：浏览器第二次请求，客户端的查询更新格式是这样的：“If-None-Match:"0f8b0c86fe2c0c7a67791e53d660208e3"”，如果ETag没改变，表示内容没有发生改变，则返回状态304。

Spring也提供了对ETag的支持，具体需要在web.xml中配置如下代码：
<filter>
   <filter-name>etagFilter</filter-name>
   <filter-class>org.springframework.web.filter.ShallowEtagHeaderFilter</filter-class>
</filter>
<filter-mapping>
   <filter-name>etagFilter</filter-name>
   <servlet-name>chapter4</servlet-name>
</filter-mapping>


缓存的目的是减少相应延迟 和 减少网络带宽消耗，比如css、js、图片这类静态资源应该进行缓存。
实际项目一般使用反向代理服务器（如nginx、apache等）进行缓存。


WebContentGenerator
用于提供如浏览器缓存控制、是否必须有session开启、支持的请求方法类型（GET、POST等）等

AbstractController
该抽象类实现了Controller，并继承了WebContentGenerator


ServletForwardingController
将接收到的请求转发到一个命名的servlet
public class ForwardingServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
	throws ServletException, IOException {

		resp.getWriter().write("Controller forward to Servlet");

	}
}

<servlet>
	<servlet-name>forwarding</servlet-name>
	<servlet-class>cn.javass.chapter4.web.servlet.ForwardingServlet</servlet-class>
</servlet>

<!― 在chapter4-servlet.xml配置处理器 -->
<bean name="/forwardToServlet"
class="org.springframework.web.servlet.mvc.ServletForwardingController">
		<property name="servletName" value="forwarding"></property>
</bean>

当我们请求/forwardToServlet时，会被转发到名字为“forwarding”的servlet处理，该sevlet的servlet-mapping标签配置是可选的。



BaseCommandController
命令控制器通用基类，提供了以下功能支持：

1、数据绑定：请求参数绑定到一个command object（命令对象，非GoF里的命令设计模式），这里的命令对象是指绑定请求参数的任何POJO对象；
commandClass：表示命令对象实现类，如UserModel；
commandName：表示放入请求的命令对象名字（默认command），request.setAttribute(commandName, commandObject);

2、验证功能：提供Validator注册功能，注册的验证器会验证命令对象属性数据是否合法；
validators：通过该属性注入验证器，验证器用来验证命令对象属性是否合法；

该抽象类没有没有提供流程功能，只是提供了一些公共的功能，实际使用时需要使用它的子类。


AbstractCommandController
命令控制器之一，可以实现该控制器来创建命令控制器，该控制器能把自动封装请求参数到一个命令对象，而且提供了验证功能。

public class MyAbstractCommandController extends AbstractCommandController {
    public MyAbstractCommandController() {
        //设置命令对象实现类
        setCommandClass(UserModel.class);
    }
    @Override
    protected ModelAndView handle(HttpServletRequest req, HttpServletResponse resp, Object command, BindException errors) throws Exception {
        //将命令对象转换为实际类型
        UserModel user = (UserModel) command;
        ModelAndView mv = new ModelAndView();
        mv.setViewName("abstractCommand");
        mv.addObject("user", user);
        return mv;
    }
}

<!― 在chapter4-servlet.xml配置处理器 -->
<bean name="/abstractCommand"
class="cn.javass.chapter4.web.controller.MyAbstractCommandController">
		<!-- 也可以通过依赖注入 注入命令实现类 -->
		<!-- property name="commandClass" value="cn.javass.chapter4.model.UserModel"/-->
</bean>

<!― WEB-INF/jsp/abstractCommand.jsp视图下的主要内容 -->
${user.username }-${user.password }

在浏览器中输入“http://localhost:9080/springmvc-chapter4/abstractCommand?username=123&password=123”，会自动将请求参数username和password绑定到命令对象；绑定时按照JavaBean命名规范绑定；


AbstractFormController
用于支持带步骤的表单提交的命令控制器基类，使用该控制器可以完成：
1、定义表单处理（表单的渲染），并从控制器获取命令对象构建表单；
2、提交表单处理，当用户提交表单内容后，AbstractFormController可以将用户请求的数据绑定到命令对象，并可以验证表单内容、对命令对象进行处理。

SimpleFormController
提供了更好的两步表单支持：
1、准备要展示的数据，并到表单展示页面；
2、提交数据数据进行处理。

CancellableFormController
一个可取消的表单控制器，继承SimpleFormController，额外提供取消表单功能。
1、表单展示：和SimpleFormController一样；
2、表单取消：和SimpleFormController一样；
3、表单成功提交：取消功能处理方法为：onCancel(Object command)，而且默认返回cancelView属性指定的逻辑视图名。

AbstractWizardFormController
向导控制器类提供了多步骤（向导）表单的支持（如完善个人资料时分步骤填写基本信息、工作信息、学校信息等）
假设现在做一个完善个人信息的功能，分三个页面展示：
1、页面1完善基本信息；
2、页面2完善学校信息；
3、页面3完善工作信息。
这里我们要注意的是当用户跳转到页面2时页面1的信息是需要保存起来的，还记得AbstractFormController中的sessionForm吗？ 如果为true则表单数据存放到session中，哈哈，AbstractWizardFormController就是使用了这个特性。

ParameterizableViewController
参数化视图控制器，不进行功能处理（即静态视图），根据参数的逻辑视图名直接选择需要展示的视图。
<bean name="/parameterizableView"
class="org.springframework.web.servlet.mvc.ParameterizableViewController">
<property name="viewName" value="success"/>
</bean>
该控制器接收到请求后直接选择参数化的视图，这样的好处是在配置文件中配置，从而避免程序的硬编码，比如像帮助页面等不需要进行功能处理，因此直接使用该控制器映射到视图。


AbstractUrlViewController
提供根据请求URL路径直接转化为逻辑视图名的支持基类，即不需要功能处理，直接根据URL计算出逻辑视图名，并选择具体视图进行展示：
urlDecode：是否进行url解码，不指定则默认使用服务器编码进行解码（如Tomcat默认ISO-8859-1）；
urlPathHelper：用于解析请求路径的工具类，默认为org.springframework.web.util.UrlPathHelper。
UrlFilenameViewController是它的一个实现者，因此我们应该使用UrlFilenameViewController。

UrlFilenameViewController
将请求的URL路径转换为逻辑视图名并返回的转换控制器，即不需要功能处理，直接根据URL计算出逻辑视图名
<bean name="/*.htm" class="org.springframework.web.servlet.mvc.UrlFilenameViewController">
		<property name="prefix" value="test"/>
		<property name="suffix" value="test"/>
</bean>


MultiActionController
之前学过的控制器如AbstractCommandController、SimpleFormController等一般对应一个功能处理方法（如新增），如果我要实现比如最简单的用户增删改查（CRUD Create-Read-Update-Delete），那该怎么办呢？

1、每一个功能对应一个控制器，如果是CRUD则需要四个控制器，但这样我们的控制器会暴增，肯定不可取；

2、使用Spring Web MVC提供的MultiActionController，用于支持在一个控制器里添加多个功能处理方法，即将多个请求的处理方法放置到一个控制器里，这种方式不错。


Spring Web MVC提供了MethodNameResolver（方法名解析器）用于解析当前请求到需要执行的功能处理方法的方法名。默认使用InternalPathMethodNameResolver实现类，另外还提供了ParameterMethodNameResolver和PropertiesMethodNameResolver，当然我们也可以自己来实现。

public (ModelAndView | Map | String | void) actionName(HttpServletRequest request, HttpServletResponse response, [,HttpSession session] [,AnyObject]);





数据类型转换和数据验证
1、首先创建数据绑定器，在此此会创建ServletRequestDataBinder类的对象，并设置messageCodesResolver（错误码解析器）；

2、提供第一个扩展点，初始化数据绑定器，在此处我们可以覆盖该方法注册自定义的PropertyEditor（请求参数――>命令对象属性的转换）；

3、进行数据绑定，即请求参数――>命令对象的绑定；

4、提供第二个扩展点，数据绑定完成后的扩展点，此处可以实现一些自定义的绑定动作；

5、验证器对象的验证，验证器通过validators注入，如果验证失败，需要把错误信息放入Errors（此处使用BindException实现）；

6、提供第三个扩展点，此处可以实现自定义的绑定/验证逻辑；

7、将errors传入功能处理方法进行处理，功能方法应该判断该错误对象是否有错误进行相应的处理。


请求参数（String）――>命令对象属性（可能是任意类型）的类型转换，即数据绑定时的类型转换，使用PropertyEditor实现绑定时的类型转换。




public class DataBinderTestController extends AbstractCommandController {
    public DataBinderTestController() {
        setCommandClass(DataBinderTestModel.class); //设置命令对象
        setCommandName("dataBinderTest");//设置命令对象的名字
    }
    @Override
    protected ModelAndView handle(HttpServletRequest req, HttpServletResponse resp, Object command, BindException errors) throws Exception {
        //输出command对象看看是否绑定正确
        System.out.println(command);
        return new ModelAndView("bindAndValidate/success").addObject("dataBinderTest", command);
    }
    @Override
    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {
        super.initBinder(request, binder);
        //注册自定义的属性编辑器
        //1、日期
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        CustomDateEditor dateEditor = new CustomDateEditor(df, true);
        //表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换
        binder.registerCustomEditor(Date.class, dateEditor);
        //自定义的电话号码编辑器
        binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());
    }
}

initBinder:第一个扩展点，初始化数据绑定器，在此处我们注册了两个属性编辑器；

CustomDateEditor：自定义的日期编辑器，用于在String<――>日期之间转换；

binder.registerCustomEditor(Date.class, dateEditor)：表示如果命令对象是Date类型，则使用dateEditor进行类型转换；

PhoneNumberEditor：自定义的电话号码属性编辑器用于在String<――> PhoneNumberModel之间转换；

binder.registerCustomEditor(PhoneNumberModel.class, newPhoneNumberEditor())：表示如果命令对象是PhoneNumberModel类型，则使用PhoneNumberEditor进行类型转换；



注册PropertyEditor

1、使用WebDataBinder进行控制器级别注册PropertyEditor（控制器独享）
使用WebDataBinder注册控制器级别的PropertyEditor，这种方式注册的PropertyEditor只对当前控制器独享，即其他的控制器不会自动注册这个PropertyEditor，如果需要还需要再注册一下。

2、使用WebBindingInitializer批量注册PropertyEditor
如果想在多个控制器同时注册多个相同的PropertyEditor时，可以考虑使用WebBindingInitializer。


<!-- 注册WebBindingInitializer实现 -->
<bean id="myWebBindingInitializer" class="cn.javass.chapter4.web.controller.support.initializer.MyWebBindingInitializer"/>
<bean name="/dataBind" class="cn.javass.chapter4.web.controller.DataBinderTestController">
	<!-- 注入WebBindingInitializer实现 -->
	<property name="webBindingInitializer" ref="myWebBindingInitializer"/>
</bean>


3、全局级别注册PropertyEditor（全局共享）
只需要将我们自定义的PropertyEditor放在和你的模型类同包下即可，且你的Editor命名规则必须是“模型类名Editor”，这样Spring会自动使用标准JavaBean架构进行自动识别



public class ErrorController extends AbstractCommandController {
       public ErrorController() {
              setCommandClass(DataBinderTestModel.class);
              setCommandName("command");
       }
       @Override
       protected ModelAndView handle(HttpServletRequest req, HttpServletResponse resp, Object command, BindException errors) throws Exception {
              //表示用户名不为空
              errors.reject("username.not.empty");
              //带有默认错误消息
              errors.reject("username.not.empty1", "用户名不能为空1");
              //带有参数和默认错误消息
              errors.reject("username.length.error", new Object[]{5, 10});

              //得到错误相关的模型数据
              Map model = errors.getModel();
              return new ModelAndView("bindAndValidate/error", model);
       }
}


errors.reject("username.length.error", new Object[]{5, 10})：错误码为“username.length.error”，而且错误信息需要两个参数，如我们在我们的配置文件中定义“用户名长度不合法，长度必须在{0}到{1}之间”，则实际的错误消息为“用户名长度不合法，长度必须在5到10之间”

errors.getModel()：当有错误信息时，一定将errors.getModel()放入我们要返回的ModelAndView中，以便使用里边的错误对象来显示错误信息。




<bean id="messageSource"
	   class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
	<property name="basename" value="classpath:messages"/>
	<property name="fileEncodings" value="utf-8"/>
	<property name="cacheSeconds" value="120"/>
</bean>

<bean name="/error" class="cn.javass.chapter4.web.controller.ErrorController"/>

messageSource：用于获取错误码对应的错误消息的，而且bean名字默认必须是messageSource。


messages.properties（需要执行NativeToAscii）
username.not.empty=用户名不能为空
username.length.error=用户名长度不合法，长度必须在{0}到{1}之间


WEB-INF/jsp/bindAndValidate/error.jsp
<%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<!-- 表单的默认命令对象名为command -->
<form:form commandName="command">
	<form:errors path="*"></form:errors>
</form:form>





public class DataBinderErrorTestController extends SimpleFormController {
       public DataBinderErrorTestController() {
              setCommandClass(DataBinderTestModel.class);
              setCommandName("dataBinderTest");
       }
       @Override
       protected ModelAndView showForm(HttpServletRequest request, HttpServletResponse response, BindException errors) throws Exception {
              //如果表单提交有任何错误都会再回到表单展示页面
              System.out.println(errors);
              return super.showForm(request, response, errors);
       }
       @Override
       protected void doSubmitAction(Object command) throws Exception {
              System.out.println(command); //表单提交成功（数据绑定成功）进行功能处理
    }
       @Override
       protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {
              super.initBinder(request, binder);
              //注册自定义的属性编辑器
              //1、日期
              DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
              CustomDateEditor dateEditor = new CustomDateEditor(df, true);
              //表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换
              binder.registerCustomEditor(Date.class, dateEditor);

              //自定义的电话号码编辑器
              binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());
       }
}


showForm：展示表单，当提交表单有任何数据绑定错误会再回到该方法进行表单输入（在此处我们打印错误对象）；

doSubmitAction：表单提交成功，只要当表单的数据到命令对象绑定成功时，才会执行；

xxx-servlet.xml
<bean name="/dataBindError"
class="cn.javass.chapter4.web.controller.DataBinderErrorTestController">
   <property name="formView" value="bindAndValidate/input"/>
   <property name="successView" value="bindAndValidate/success"/>
</bean>


WEB-INF/jsp/bindAndValidate/ input.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"   pageEncoding="UTF-8"%>
<%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<!-- 表单的命令对象名为dataBinderTest -->
<form:form commandName="dataBinderTest">
	<form:errors path="*" cssStyle="color:red"></form:errors><br/><br/>
	bool:<form:input path="bool"/><br/>
	phoneNumber:<form:input path="phoneNumber"/><br/>
	date:<form:input path="date"/><br/>
	<input type="submit" value="提交"/>
</form:form>

<form:form commandName="dataBinderTest">：指定命令对象为dataBinderTest，默认command；

<form:errors path="*" cssStyle="color:red"></form:errors>：显示错误消息，当提交表单有错误时展示错误消息（数据绑定错误/数据不合法）；

<form:input path="bool"/>：等价于（<input type=’text’>），但会从命令对象中取出bool属性进行填充value属性，或如果表单提交有错误会从错误对象取出之前的错误数据（而非空或默认值）；

<input type="submit" value="提交"/>：spring没有提供相应的提交按钮，因此需要使用html的。


数据绑定失败（类型不匹配）会自动生成如下错误码（错误码对应的错误消息按照如下顺序依次查找）：
1、typeMismatch.命令对象名.属性名
2、typeMismatch.属性名
3、typeMismatch.属性全限定类名（包名.类名）
4、typeMismatch


内部使用MessageCodesResolver解析数据绑定错误到错误码，默认DefaultMessageCodesResolver，因此想要详细了解如何解析请看其javadoc；

建议使用第1个进行错误码的配置。

因此修改我们的messages.properties添加如下错误消息（需要执行NativeToAscii）：
typeMismatch.dataBinderTest.date=您输入的数据格式错误，请重新输入（格式：2012-03-19 22:17:17）
#typeMismatch.date=2
#typeMismatch.java.util.Date=3
#typeMismatch=4



对于数据不合法，Spring Web MVC提供了两种验证方式：

◆编程式验证器验证

◆声明式验证


package org.springframework.validation;
public interface Validator {
	boolean supports(Class<?> clazz);
	void validate(Object target, Errors errors);
}

Validator接口：验证器，编程实现数据验证的接口；
supports方法：当前验证器是否支持指定的clazz验证，如果支持返回true即可；
validate方法：验证的具体方法，target参数表示要验证的目标对象（如命令对象），errors表示验证出错后存放错误信息的错误对象。


public class UserModelValidator implements Validator {
    private static final Pattern USERNAME_PATTERN = Pattern.compile("[a-zA-Z]\\w{4,19}");
    private static final Pattern PASSWORD_PATTERN = Pattern.compile("[a-zA-Z0-9]{5,20}");
    private static final Set<String> FORBINDDDEN_WORD_SET = new HashSet<String>();
    static {
       FORBINDDDEN_WORD_SET.add("fuc k"); //删掉空格
       FORBINDDDEN_WORD_SET.add("admin");
    }
    @Override
    public boolean supports(Class<?> clazz) {
       return UserModel.class == clazz;//表示只对UserModel类型的目标对象实施验证
    }
    @Override
    public void validate(Object target, Errors errors) {
       //这个表示如果目标对象的username属性为空，则表示错误（简化我们手工判断是否为空）
       ValidationUtils.rejectIfEmpty(errors, "username", "username.not.empty");

       UserModel user = (UserModel) target;

       if(!USERNAME_PATTERN.matcher(user.getUsername()).matches()) {
           errors.rejectValue("username", "username.not.illegal");//如果用户名不合法
       }

       for(String forbiddenWord : FORBINDDDEN_WORD_SET) {
           if(user.getUsername().contains(forbiddenWord)) {
              errors.rejectValue("username", "username.forbidden", new Object[]{forbiddenWord}, "您的用户名包含非法关键词");//用户名包含屏蔽关键字
              break;
           }
       }
       if(!PASSWORD_PATTERN.matcher(user.getPassword()).matches()) {
           errors.rejectValue("password","password.not.illegal", "密码不合法");//密码不合法
       }
    }
}

supports方法：表示只对UserModel类型的对象验证；

validate方法：数据验证的具体方法.

chapter4-servlet.xml
<bean id="userModelValidator"
class="cn.javass.chapter4.web.controller.support.validator.UserModelValidator"/>
<bean name="/validator"
class="cn.javass.chapter4.web.controller.RegisterSimpleFormController">
	<property name="formView" value="registerAndValidator"/>
	<property name="successView" value="redirect:/success"/>
	<property name="validator" ref="userModelValidator"/>
</bean>



/WEB-INF/jsp/registerAndValidator.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<form:form commandName="user">

<form:errors path="*" cssStyle="color:red"></form:errors><br/>

username:<form:input path="username"/>
<form:errors path="username" cssStyle="color:red"></form:errors>
<br/>

password:<form:password path="password"/>
<form:errors path="password" cssStyle="color:red"></form:errors>
<br/>
<input type="submit" value="注册"/>
</form:form>


声明式验证器
从Spring3开始支持JSR-303验证框架，支持XML风格和注解风格的验证，目前在@RequestMapping时才能使用，也就是说基于Controller接口的实现不能使用该方式（但可以使用编程式验证，有需要的可以参考hibernate validator实现）

到此Spring2风格的控制器我们就介绍完了，以上控制器从spring3.0开始已经不推荐使用了（但考虑到还有部分公司使用这些@Deprecated类，在此也介绍了一下），而是使用注解控制器实现（@Controller和@RequestMapping）。






Spring Web MVC的处理器拦截器（如无特殊说明，下文所说的拦截器即处理器拦截器）

类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。


常见应用场景

1、日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。

2、权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面；

3、性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）；

4、通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。

5、OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。

…………本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。


public interface HandlerInterceptor {
    boolean preHandle(
            HttpServletRequest request, HttpServletResponse response,
            Object handler)
            throws Exception;

    void postHandle(
            HttpServletRequest request, HttpServletResponse response,
            Object handler, ModelAndView modelAndView)
            throws Exception;

    void afterCompletion(
            HttpServletRequest request, HttpServletResponse response,
            Object handler, Exception ex)
            throws Exception;
}

注意到拦截器一个有3个回调方法，而一般的过滤器Filter才两个


preHandle：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）；
返回值：true表示继续流程（如调用下一个拦截器或处理器）；
false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；

postHandle：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。

afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。


有时候我们可能只需要实现三个回调方法中的某一个，如果实现HandlerInterceptor接口的话，三个方法必须实现，不管你需不需要，此时spring提供了一个HandlerInterceptorAdapter适配器（一种适配器设计模式的实现），允许我们只实现需要的回调方法。


看一下DispatcherServlet内部到底是如何工作的吧：
    //doDispatch方法
    //1、处理器拦截器的预处理（正序执行）
    HandlerInterceptor[] interceptors = mappedHandler.getInterceptors();
    if (interceptors != null) {
        for (int i = 0; i < interceptors.length; i++) {
        HandlerInterceptor interceptor = interceptors[i];
            if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) {
                //1.1、失败时触发afterCompletion的调用
                triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);
                return;
            }
            interceptorIndex = i;//1.2、记录当前预处理成功的索引
    }
    }
    //2、处理器适配器调用我们的处理器
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    //当我们返回null或没有返回逻辑视图名时的默认视图名翻译（详解4.15.5 RequestToViewNameTranslator）
    if (mv != null && !mv.hasView()) {
        mv.setViewName(getDefaultViewName(request));
    }
    //3、处理器拦截器的后处理（逆序）
    if (interceptors != null) {
    for (int i = interceptors.length - 1; i >= 0; i--) {
          HandlerInterceptor interceptor = interceptors[i];
          interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);
    }
    }
    //4、视图的渲染
    if (mv != null && !mv.wasCleared()) {
    render(mv, processedRequest, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
    }
    //5、触发整个请求处理完毕回调方法afterCompletion
    triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);



private void triggerAfterCompletion(HandlerExecutionChain mappedHandler, int interceptorIndex,
            HttpServletRequest request, HttpServletResponse response, Exception ex) throws Exception {
        // 5、触发整个请求处理完毕回调方法afterCompletion （逆序从1.2中的预处理成功的索引处的拦截器执行）
        if (mappedHandler != null) {
            HandlerInterceptor[] interceptors = mappedHandler.getInterceptors();
            if (interceptors != null) {
                for (int i = interceptorIndex; i >= 0; i--) {
                    HandlerInterceptor interceptor = interceptors[i];
                    try {
                        interceptor.afterCompletion(request, response, mappedHandler.getHandler(), ex);
                    }
                    catch (Throwable ex2) {
                        logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
                    }
                }
            }
        }
    }


================

拦截器
public class HandlerInterceptor1 extends HandlerInterceptorAdapter {//此处一般继承HandlerInterceptorAdapter适配器即可
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("===========HandlerInterceptor1 preHandle");
        return true;
    }
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("===========HandlerInterceptor1 postHandle");
    }
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("===========HandlerInterceptor1 afterCompletion");
    }
}

控制器
public class TestController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {
        System.out.println("===========TestController");
        return new ModelAndView("test");
    }
}

Spring配置文件chapter5-servlet.xml
<bean name="/test" class="cn.javass.chapter5.web.controller.TestController"/>
<bean id="handlerInterceptor1"
class="cn.javass.chapter5.web.interceptor.HandlerInterceptor1"/>
<bean id="handlerInterceptor2"
class="cn.javass.chapter5.web.interceptor.HandlerInterceptor2"/>


<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
	<property name="interceptors">
		<list>
		   <ref bean="handlerInterceptor1"/>
		  <ref bean="handlerInterceptor2"/>
		</list>
	</property>
</bean>


WEB-INF/jsp/test.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%System.out.println("==========test.jsp");%>
test page



如记录一下请求的处理时间，得到一些慢请求（如处理时间超过500毫秒），从而进行性能改进，一般的反向代理服务器如apache都具有这个功能，但此处我们演示一下使用拦截器怎么实现。

我们的拦截器是单例，因此不管用户请求多少次都只有一个拦截器实现，即线程不安全，那我们应该怎么记录时间呢？
解决方案是使用ThreadLocal，它是线程绑定的变量，提供线程局部变量（一个线程一个ThreadLocal，A线程的ThreadLocal只能看到A线程的ThreadLocal，不能看到B线程的ThreadLocal）。


public class StopWatchHandlerInterceptor extends HandlerInterceptorAdapter {
    private NamedThreadLocal<Long>  startTimeThreadLocal =
new NamedThreadLocal<Long>("StopWatch-StartTime");
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
Object handler) throws Exception {
        long beginTime = System.currentTimeMillis();//1、开始时间
        startTimeThreadLocal.set(beginTime);//线程绑定变量（该数据只有当前请求的线程可见）
        return true;//继续流程
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
Object handler, Exception ex) throws Exception {
        long endTime = System.currentTimeMillis();//2、结束时间
        long beginTime = startTimeThreadLocal.get();//得到线程绑定的局部变量（开始时间）
        long consumeTime = endTime - beginTime;//3、消耗的时间
        if(consumeTime > 500) {//此处认为处理时间超过500毫秒的请求为慢请求
            //TODO 记录到日志文件
            System.out.println(
String.format("%s consume %d millis", request.getRequestURI(), consumeTime));
        }
    }
}


NamedThreadLocal：Spring提供的一个命名的ThreadLocal实现。
在测试时需要把stopWatchHandlerInterceptor放在拦截器链的第一个，这样得到的时间才是比较准确的。



在访问某些资源时（如订单页面），需要用户登录后才能查看，因此需要进行登录检测。

1、访问需要登录的资源时，由拦截器重定向到登录页面；
2、如果访问的是登录页面，拦截器不应该拦截；
3、用户登录成功后，往cookie/session添加登录成功的标识（如用户编号）；
4、下次请求时，拦截器通过判断cookie/session中是否有该标识来决定继续流程还是到登录页面；
5、在此拦截器还应该允许游客访问的资源。

public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
Object handler) throws Exception {
    //1、请求到登录页面 放行
    if(request.getServletPath().startsWith(loginUrl)) {
        return true;
    }

    //2、TODO 比如退出、首页等页面无需登录，即此处要放行 允许游客的请求

    //3、如果用户已经登录 放行
    if(request.getSession().getAttribute("username") != null) {
        //更好的实现方式的使用cookie
        return true;
    }

    //4、非法请求 即这些请求需要登录后才能访问
    //重定向到登录页面
    response.sendRedirect(request.getContextPath() + loginUrl);
    return false;
}


推荐能使用servlet规范中的过滤器Filter实现的功能就用Filter实现，因为HandlerInteceptor只有在Spring Web MVC环境下才能使用，因此Filter是最通用的、最先应该使用的。如登录这种拦截器最好使用Filter来实现。




需要通过处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter来开启支持@Controller 和@RequestMapping注解的处理器。

@Controller：用于标识是处理器类；
@RequestMapping：请求到处理器功能方法的映射规则；
@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；
@ModelAttribute：请求参数到命令对象的绑定；
@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；
@InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；

三、Spring3.0引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持：

@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；
@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；
@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；
@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；
@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；
@ExceptionHandler：注解式声明异常处理器；
@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定，
从而支持RESTful架构风格的URI；


四、Spring3.1使用新的HandlerMapping 和 HandlerAdapter来支持@Contoller和@RequestMapping注解处理器。

新的@Contoller和@RequestMapping注解支持类：处理器映射RequestMappingHandlerMapping和处理器适配器RequestMappingHandlerAdapter组合来代替Spring2.5开始的处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter，提供更多的扩展点。


请求的映射分为如下几种：
URL路径映射：使用URL映射请求到处理器的功能处理方法；
请求方法映射限定：如限定功能处理方法只处理GET请求；
请求参数映射限定：如限定只处理包含“abc”请求参数的请求；
请求头映射限定：如限定只处理“Accept=application/json”的请求。



@Controller         // 或 @RequestMapping               //①将一个POJO类声明为处理器
public class HelloWorldController {
    @RequestMapping(value = "/hello")                  //②请求URL到处理器功能处理方法的映射
    public ModelAndView helloWorld() {
        //1、收集参数
        //2、绑定参数到命令对象
        //3、调用业务对象
        //4、选择下一个页面
        ModelAndView mv = new ModelAndView();
        //添加模型数据 可以是任意的POJO对象
        mv.addObject("message", "Hello World!");
        //设置逻辑视图名，视图解析器会根据该名字解析到具体的视图页面
        mv.setViewName("hello");
        return mv;                                         //○3 模型数据和逻辑视图名
    }
}

可以通过在一个POJO类上放置@Controller或@RequestMapping，即可把一个POJO类变身为处理器；
@RequestMapping(value = "/hello") 请求URL(/hello) 到 处理器的功能处理方法的映射；模型数据和逻辑视图名的返回。



HandlerMapping和HandlerAdapter的配置

如果您使用的是Spring3.1之前版本，开启注解式处理器支持的配置为：
DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter。

chapter6-servlet.xml
<!―Spring3.1之前的注解 HandlerMapping -->
<bean   class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"/>

<!―Spring3.1之前的注解 HandlerAdapter -->
<bean   class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"/>


使用的Spring3.1开始的版本，建议使用RequestMappingHandlerMapping和RequestMappingHandlerAdapter。

<!--Spring3.1开始的注解 HandlerMapping -->
<bean   class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
<!--Spring3.1开始的注解 HandlerAdapter -->
<bean  class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/>



视图解析器的配置
还是使用之前的org.springframework.web.servlet.view.InternalResourceViewResolver。


处理器的配置
<bean class="cn.javass.chapter6.web.controller.HelloWorldController"/>

只需要将处理器实现类注册到spring配置文件即可，spring的DefaultAnnotationHandlerMapping或RequestMappingHandlerMapping能根据注解@Controller或@RequestMapping自动发现。

..?。。这个还需要？不是Controller自动发现吗？。不过这里说是spring配置文件，不是spring mvc配置文件。但spring要这个bean干什么。。


1、HandlerMapping实现：使用DefaultAnnotationHandlerMapping（spring3.1之前）或RequestMappingHandlerMapping（spring3.1）替换之前的BeanNameUrlHandlerMapping。
注解式处理器映射会扫描spring容器中的bean，发现bean实现类上拥有@Controller或@RequestMapping注解的bean，并将它们作为处理器。

2、HandlerAdapter实现：使用AnnotationMethodHandlerAdapter（spring3.1之前）或RequestMappingHandlerAdapter（spring3.1）替换之前的SimpleControllerHandlerAdapter。
注解式处理器适配器会通过反射调用相应的功能处理方法（方法上拥有@RequestMapping注解）。



处理器定义
    @Controller
    public class HelloWorldController {
    ……
    }
推荐使用这种方式声明处理器，它和我们的@Service、@Repository很好的对应了我们常见的三层开发架构的组件。



    @RequestMapping
    public class HelloWorldController {
    ……
    }
这种方式也是可以工作的，但如果在类上使用@ RequestMapping注解一般是用于窄化功能处理方法的映射的

窄化请求映射
    package cn.javass.chapter6.web.controller;
    @Controller
    @RequestMapping(value="/user")                 //①处理器的通用映射前缀
    public class HelloWorldController2 {
        @RequestMapping(value = "/hello2")        //②相对于①处的映射进行窄化
        public ModelAndView helloWorld() {
             //省略实现
        }
    }
①类上的@RequestMapping(value="/user") 表示处理器的通用请求前缀；
②处理器功能处理方法上的是对①处映射的窄化。

因此http://localhost:9080/springmvc-chapter6/hello2 无法映射到HelloWorldController2的 helloWorld功能处理方法；而http://localhost:9080/springmvc-chapter6/user/hello2是可以的。


窄化请求映射可以认为是方法级别的@RequestMapping继承类级别的@RequestMapping。

窄化请求映射还有其他方式，如在类级别指定URL，而方法级别指定请求方法类型或参数等等，




http请求信息包含六部分信息：
①请求方法，如GET或POST，表示提交的方式；
②URL，请求的地址信息；
③协议及版本；
④请求头信息（包括Cookie信息）；
⑤回车换行（CRLF）；
⑥请求内容区（即请求的内容或数据），如表单提交时的参数数据、URL请求参数（?abc=123 ？后边的）等。

那此处我们可以看到有①、②、④、⑥一般是可变的，因此我们可以这些信息进行请求到处理器的功能处理方法的映射，因此请求的映射分为如下几种：
URL路径映射：使用URL映射请求到处理器的功能处理方法；
请求方法映射限定：如限定功能处理方法只处理GET请求；
请求参数映射限定：如限定只处理包含“abc”请求参数的请求；
请求头映射限定：如限定只处理“Accept=application/json”的请求。



普通URL路径映射
@RequestMapping(value={"/test1", "/user/create"})：多个URL路径可以映射到同一个处理器的功能处理方法。

URI模板模式映射
@RequestMapping(value="/users/{userId}")：{×××}占位符， 请求的URL可以是 “/users/123456”或“/users/abcd”，通过6.6.5讲的通过@PathVariable可以提取URI模板模式中的{×××}中的×××变量。
@RequestMapping(value="/users/{userId}/create")：这样也是可以的，请求的URL可以是“/users/123/create”。
@RequestMapping(value="/users/{userId}/topics/{topicId}")：这样也是可以的，请求的URL可以是“/users/123/topics/123”。

Ant风格的URL路径映射
@RequestMapping(value="/users/**")：可以匹配“/users/abc/abc”，但“/users/123”将会被【URI模板模式映射中的“/users/{userId}”模式优先映射到】
@RequestMapping(value="/product?")：可匹配“/product1”或“/producta”，但不匹配“/product”或“/productaa”;
@RequestMapping(value="/product*")：可匹配“/productabc”或“/product”，但不匹配“/productabc/abc”;
@RequestMapping(value="/product/*")：可匹配“/product/abc”，但不匹配“/productabc”;
@RequestMapping(value="/products/**/{productId}")：可匹配“/products/abc/abc/123”或“/products/123”，也就是Ant风格和URI模板变量风格可混用;


正则表达式风格的URL路径映射是一种特殊的URI模板模式映射：
URI模板模式映射是{userId}，不能指定模板变量的数据类型，是数字还是字符串；
正则表达式风格的URL路径映射，可以指定模板变量的数据类型，可以将规则写的相当复杂。


组合使用是“或”的关系
如 @RequestMapping(value={"/test1", "/user/create"}) 组合使用是或的关系，即“/test1”或“/user/create”请求URL路径都可以映射到@RequestMapping指定的功能处理方法。



请求方法映射限定
展示表单一般为GET请求方法；提交表单一般为POST请求方法。

我们使用@RequestMapping来实现SimpleFormController的功能吧。

@Controller
@RequestMapping("/customers/**")	//①处理器的通用映射前缀
public class RequestMethodController {
    @RequestMapping(value="/create", method = RequestMethod.GET)//②类级别的@RequestMapping窄化
    public String showForm() {
        System.out.println("===============GET");
        return "customer/create";
    }
    @RequestMapping(value="/create", method = RequestMethod.POST)//③类级别的@RequestMapping窄化
    public String submit() {
        System.out.println("================POST");
        return "redirect:/success";
    }
}

①处理器的通用映射前缀（父路径）：表示该处理器只处理匹配“/customers/**”的请求；

②对类级别的@RequestMapping进行窄化，表示showForm可处理匹配“/customers/**/create”且请求方法为“GET”的请求；

③对类级别的@RequestMapping进行窄化，表示submit可处理匹配“/customers/**/create”且请求方法为“POST”的请求。


组合使用是“或”的关系
@RequestMapping(value="/methodOr", method = {RequestMethod.POST, RequestMethod.GET})：即请求方法可以是 GET 或 POST。


1、一般浏览器只支持GET、POST请求方法，如想浏览器支持PUT、DELETE等请求方法只能模拟，稍候章节介绍。

2、除了GET、POST，还有HEAD、OPTIONS、PUT、DELETE、TRACE。

3、DispatcherServlet默认开启对 GET、POST、PUT、DELETE、HEAD的支持；

4、如果需要支持OPTIONS、TRACE，请添加DispatcherServlet在web.xml的初始化参数：dispatchOptionsRequest 和 dispatchTraceRequest 为true。



请求数据中有指定参数名

@RequestMapping("/parameter1")
public class RequestParameterController1 {

@RequestMapping(params="create", method=RequestMethod.GET)
public String showForm() {

@RequestMapping(params="create", method=RequestMethod.POST)
public String submit() {


@RequestMapping(params="create", method=RequestMethod.GET) ：表示请求中有“create”的参数名且请求方法为“GET”即可匹配，如可匹配的请求URL“http://×××/parameter1?create”；

@RequestMapping(params="create", method=RequestMethod.POST)：表示请求中有“create”的参数名且请求方法为“POST”即可匹配；



//请求参数不包含 create参数名
@RequestMapping(params="!create", method=RequestMethod.GET)//进行类级别的@RequestMapping窄化


请求数据中指定参数名=值
@RequestMapping(params="submitFlag=create", method=RequestMethod.GET)


请求数据中指定参数名!=值
@RequestMapping(params="submitFlag!=create", method=RequestMethod.GET)


组合使用是“且”的关系
@RequestMapping(params={"test1", "test2=create"})
表示请求中的有“test1”参数名 且 有“test2=create”参数即可匹配，如可匹配的请求URL“http://×××/parameter3?test1&test2=create。



请求头数据中有指定参数名
@RequestMapping(value="/header/test1", headers = "Accept")：
表示请求的URL必须为“/header/test1” 且 请求头中必须有Accept参数才能匹配。


@RequestMapping(value="/header/test1", headers = "abc")：
表示请求的URL必须为“/header/test1”且 请求头中必须有abc参数才能匹配



请求头数据中没有指定参数名
@RequestMapping(value="/header/test2", headers = "!abc")：
表示请求的URL必须为“/header/test2”且 请求头中必须没有abc参数才能匹配。


请求头数据中指定参数名=值
@RequestMapping(value="/header/test3", headers = "Content-Type=application/json")：
表示请求的URL必须为“/header/test3” 且 请求头中必须有“Content-Type=application/json”参数即可匹配。


@RequestMapping(value="/header/test4", headers = "Accept=application/json")：
表示请求的URL必须为“/header/test4” 且 请求头中必须有“Accept =application/json”参数即可匹配。


@RequestMapping(value="/header/test5", headers = "Accept=text/*") ：表示请求的URL必须为“/header/test5” 且 请求头中必须有如“Accept=text/plain”参数即可匹配。
Accept=text/*：表示主类型为text，子类型任意，如“text/plain”、“text/html”等都可以匹配。


@RequestMapping(value="/header/test6", headers = "Accept=*/*") ：表示请求的URL必须为“/header/test6” 且 请求头中必须有任意Accept参数即可匹配。
Accept=*/*：表示主类型任意，子类型任意，如“text/plain”、“application/xml”等都可以匹配。


请求头数据中指定参数名!=值
@RequestMapping(value="/header/test7", headers = "Accept!=text/vnd.wap.wml")：表示请求的URL必须为“/header/test7” 且 请求头中必须有“Accept”参数但值不等于“text/vnd.wap.wml”即可匹配。


组合使用是“且”的关系
@RequestMapping(value="/header/test8", headers = {"Accept!=text/vnd.wap.wml","abc=123"})：表示请求的URL必须为“/header/test8” 且 请求头中必须有“Accept”参数但值不等于“text/vnd.wap.wml”且 请求中必须有参数“abc=123”即可匹配。



生产者、消费者限定

https://jinnianshilongnian.iteye.com/blog/1695047

如tomcat服务器的 “conf/web.xml”中指定了扩展名到媒体类型的映射，在此我们可以看到服务器支持的媒体类型。

①客户端―发送请求―服务器：客户端通过请求头Content-Type指定内容体的媒体类型（即客户端此时是生产者），服务器根据Content-Type消费内容体数据（即服务器此时是消费者）；

②服务器―发送请求―客户端：服务器生产响应头Content-Type指定的响应体数据（即服务器此时是生产者），客户端根据Content-Type消费内容体数据（即客户端此时是消费者）。

①服务器端可以通过指定【headers = "Content-Type=application/json"】来声明可处理（可消费）的媒体类型，即只消费Content-Type指定的请求内容体数据；

②客户端如何告诉服务器端它只消费什么媒体类型的数据呢？即客户端接受（需要）什么类型的数据呢？服务器应该生产什么类型的数据？此时我们可以请求的Accept请求头来实现这个功能。


当你有如下Accept头：
①Accept：text/html,application/xml,application/json
将按照如下顺序进行produces的匹配 ①text/html ②application/xml ③application/json

②Accept：application/xml;q=0.5,application/json;q=0.9,text/html
将按照如下顺序进行produces的匹配 ①text/html ②application/json ③application/xml
q参数为媒体类型的质量因子，越大则优先权越高(从0到1)

③Accept：*/*,text/*,text/html
将按照如下顺序进行produces的匹配 ①text/html ②text/* ③*/*


窄化时是覆盖 而 非继承

如类级别的映射为 @RequestMapping(value="/narrow", produces="text/html")，方法级别的为@RequestMapping(produces="application/xml")，此时方法级别的映射将覆盖类级别的，因此请求头“Accept:application/xml”是成功的，而“text/html”将报406错误码，表示不支持的请求媒体类型。


组合使用是“或”的关系
@RequestMapping(produces={"text/html", "application/json"}) ：将匹配“Accept:text/html”或“Accept:application/json”。



消费的数据，如JSON数据、XML数据都是由我们读取请求的InputStream并根据需要自己转换为相应的模型数据，比较麻烦；

生产的数据，如JSON数据、XML数据都是由我们自己先把模型数据转换为json/xml等数据，然后输出响应流，也是比较麻烦的。

Spring提供了一组注解（@RequestBody、@ResponseBody）和一组转换类（HttpMessageConverter）来完成我们遇到的问题




1、@RequestParam绑定单个请求参数值；

2、@PathVariable绑定URI模板变量值；

3、@CookieValue绑定Cookie数据值

4、@RequestHeader绑定请求头数据；

5、@ModelValue绑定参数到命令对象；

6、@SessionAttributes绑定命令对象到session；

7、@RequestBody绑定请求的内容区数据并能进行自动类型转换等。

8、@RequestPart绑定“multipart/data”数据，除了能绑定@RequestParam能做到的请求参数外，还能绑定上传的文件等。

除了上边提到的注解，我们还可以通过如HttpServletRequest等API得到请求数据，但推荐使用注解方式，因为使用起来更简单。



功能处理方法支持的参数类型

在继续学习之前，我们需要首先看看功能处理方法支持哪些类型的形式参数，以及他们的具体含义。

一、ServletRequest/HttpServletRequest 和 ServletResponse/HttpServletResponse

public String requestOrResponse (  ServletRequest servletRequest, HttpServletRequest httpServletRequest,  ServletResponse servletResponse, HttpServletResponsehttpServletResponse
)

Spring Web MVC框架会自动帮助我们把相应的Servlet请求/响应（Servlet API）作为参数传递过来。


InputStream/OutputStream 和 Reader/Writer

public void inputOrOutBody(InputStream requestBodyIn, OutputStream responseBodyOut)  throws IOException {
	responseBodyOut.write("success".getBytes());
}

requestBodyIn：获取请求的内容区字节流，等价于request.getInputStream();
responseBodyOut：获取相应的内容区字节流，等价于response.getOutputStream()。


public void readerOrWriteBody(Reader reader, Writer writer)  throws IOException {
	writer.write("hello");
}
reader：获取请求的内容区字符流，等价于request.getReader();

writer：获取相应的内容区字符流，等价于response.getWriter()。


InputStream/OutputStream 和 Reader/Writer两组不能同时使用，只能使用其中的一组。



WebRequest/NativeWebRequest

WebRequest是Spring Web MVC提供的统一请求访问接口，不仅仅可以访问请求相关数据（如参数区数据、请求头数据，但访问不到Cookie区数据），还可以访问会话和上下文中的数据；NativeWebRequest继承了WebRequest，并提供访问本地Servlet API的方法。


public String webRequest(WebRequest webRequest, NativeWebRequest nativeWebRequest) {
	System.out.println(webRequest.getParameter("test"));//①得到请求参数test的值
	webRequest.setAttribute("name", "value", WebRequest.SCOPE_REQUEST);//②
	System.out.println(webRequest.getAttribute("name", WebRequest.SCOPE_REQUEST));
	HttpServletRequest request =
	nativeWebRequest.getNativeRequest(HttpServletRequest.class);//③
	HttpServletResponse response =
	nativeWebRequest.getNativeResponse(HttpServletResponse.class);
	return "success";
}

① webRequest.getParameter：访问请求参数区的数据，可以通过getHeader()访问请求头数据；

② webRequest.setAttribute/getAttribute：到指定的作用范围内取/放属性数据，Servlet定义的三个作用范围分别使用如下常量代表：
SCOPE_REQUEST ：代表请求作用范围；
SCOPE_SESSION ：代表会话作用范围；
SCOPE_GLOBAL_SESSION ：代表全局会话作用范围，即ServletContext上下文作用范围。

③ nativeWebRequest.getNativeRequest/nativeWebRequest.getNativeResponse：得到本地的Servlet API。



public String session(HttpSession session) {
	System.out.println(session);
	return "success";
}

此处的session永远不为null。

注意：session访问不是线程安全的，如果需要线程安全，需要设置AnnotationMethodHandlerAdapter或RequestMappingHandlerAdapter的synchronizeOnSession属性为true，即可线程安全的访问session。



Spring Web MVC能够自动将请求参数绑定到功能处理方法的命令/表单对象上。
@RequestMapping(value = "/commandObject", method = RequestMethod.GET)
public String toCreateUser(HttpServletRequest request, UserModel user) {
	return "customer/create";
}
@RequestMapping(value = "/commandObject", method = RequestMethod.POST)
public String createUser(HttpServletRequest request, UserModel user) {
	System.out.println(user);
	return "success";
}



Spring Web MVC 提供Model、Map或ModelMap让我们能去暴露渲染视图需要的模型数据。

@RequestMapping(value = "/model")
public String createUser(Model model, Map model2, ModelMap model3) {
	model.addAttribute("a", "a");
	model2.put("b", "b");
	model3.put("c", "c");
	System.out.println(model == model2);
	System.out.println(model2 == model3);
	return "success";}


@RequestMapping(value = "/mergeModel")
public ModelAndView mergeModel(Model model) {
	model.addAttribute("a", "a");//①添加模型数据
	ModelAndView mv = new ModelAndView("success");
	mv.addObject("a", "update");//②在视图渲染之前更新③处同名模型数据
	model.addAttribute("a", "new");//③修改①处同名模型数据
	//视图页面的a将显示为"update" 而不是"new"
	return mv;
}

从代码中我们可以总结出功能处理方法的返回值中的模型数据（如ModelAndView）会 合并 功能处理方法形式参数中的模型数据（如Model），但如果两者之间有同名的，返回值中的模型数据会覆盖形式参数中的模型数据。



Errors/BindingResult

@RequestMapping(value = "/error1")
public String error1(UserModel user, BindingResult result)

@RequestMapping(value = "/error2")
public String error2(UserModel user, BindingResult result, Model model) {

@RequestMapping(value = "/error3")
public String error3(UserModel user, Errors errors)


Spring3.1之前（使用AnnotationMethodHandlerAdapter）错误对象必须紧跟在命令对象/表单对象之后，如下定义是错误的：

@RequestMapping(value = "/error4")
public String error4(UserModel user, Model model, Errors errors)  {

如上代码从Spring3.1开始（使用RequestMappingHandlerAdapter）将能正常工作，但还是推荐“错误对象紧跟在命令对象/表单对象之后”，这样是万无一失的。



public String other(Locale locale, Principal principal)

java.util.Locale：得到当前请求的本地化信息，默认等价于ServletRequest.getLocale()，如果配置LocaleResolver解析器则由它决定Locale，后续介绍；

java.security.Principal：该主体对象包含了验证通过的用户信息，等价于HttpServletRequest.getUserPrincipal()。

。。以上应该是@RequestMapping的方法的方法签名/形参列表



@RequestParam绑定单个请求参数值
@RequestParam用于将请求参数区数据映射到功能处理方法的参数上。

public String requestparam1(@RequestParam String username)
请求中包含username参数（如/requestparam1?username=zhang），则自动传入。

此处要特别注意：右击项目，选择“属性”，打开“属性对话框”，选择“Java Compiler”然后再打开的选项卡将“Add variable attributes to generated class files”取消勾选，意思是不将局部变量信息添加到类文件中
当你在浏览器输入URL，如“requestparam1?username=123”时会报如下错误Name for argument type [java.lang.String] not available, and parameter name information not found in class file either，表示得不到功能处理方法的参数名，此时我们需要如下方法进行入参

public String requestparam2(@RequestParam("username") String username)

即通过@RequestParam("username")明确告诉Spring Web MVC使用username进行入参。


@RequestParam注解主要有哪些参数：
value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；
required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；
defaultValue：默认值，表示如果请求中没有同名参数时的默认值，默认值可以是SpEL表达式，如“#{systemProperties['java.vm.version']}”。


public String requestparam4(@RequestParam(value="username",required=false) String username)

表示请求中可以没有名字为username的参数，如果没有默认为null，此处需要注意如下几点：
原子类型：必须有值，否则抛出异常，如果允许空值请使用包装类代替。
Boolean包装类型类型：默认Boolean.FALSE，其他引用类型默认为null。

public String requestparam5(
@RequestParam(value="username", required=true, defaultValue="zhang") String username)
表示如果请求中没有名字为username的参数，默认值为“zhang”。



如果请求中有多个同名的应该如何接收呢？如给用户授权时，可能授予多个权限
public String requestparam7(@RequestParam(value="role") String roleList)

如果请求参数类似于url?role=admin&rule=user，则实际roleList参数入参的数据为“admin,user”，即多个数据之间使用“，”分割；我们应该使用如下方式来接收多个请求参数：
public String requestparam7(@RequestParam(value="role") String[] roleList)
public String requestparam8(@RequestParam(value="list") List<String> list)


@PathVariable绑定URI模板变量值

@RequestMapping(value="/users/{userId}/topics/{topicId}")
public String test(
	   @PathVariable(value="userId") int userId,
	   @PathVariable(value="topicId") int topicId)
如请求的URL为“控制器URL/users/123/topics/456”，则自动将URL中模板变量{userId}和{topicId}绑定到通过@PathVariable注解的同名参数上，即入参后userId=123、topicId=456。


@CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上。

public String test(@CookieValue(value="JSESSIONID", defaultValue="") String sessionId)

public String test2(@CookieValue(value="JSESSIONID", defaultValue="") Cookie sessionId)

传入参数类型也可以是javax.servlet.http.Cookie类型。
@CookieValue也拥有和@RequestParam相同的三个参数，含义一样。



@RequestHeader用于将请求的头信息区数据映射到功能处理方法的参数上。
@RequestMapping(value="/header")
public String test(
       @RequestHeader("User-Agent") String userAgent,
       @RequestHeader(value="Accept") String[] accepts)

@RequestHeader也拥有和@RequestParam相同的三个参数，含义一样。



@ModelAttribute绑定请求参数到命令对象
@ModelAttribute一个具有如下三个作用：

①绑定请求参数到命令对象：放在功能处理方法的入参上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用；

②暴露表单引用对象为模型数据：放在处理器的一般方法（非功能处理方法）上时，是为表单准备要展示的表单引用对象，如注册时需要选择的所在城市等，而且在执行功能处理方法（@RequestMapping注解的方法）之前，自动添加到模型对象中，用于视图页面展示时使用；

③暴露@RequestMapping方法返回值为模型数据：放在功能处理方法的返回值上时，是暴露功能处理方法的返回值为模型数据，用于视图页面展示时使用。


一、绑定请求参数到命令对象

如用户登录，我们需要捕获用户登录的请求参数（用户名、密码）并封装为用户对象，此时我们可以使用@ModelAttribute绑定多个请求参数到我们的命令对象。

public String test1(@ModelAttribute("user") UserModel user)
和6.6.1一节中的五、命令/表单对象功能一样。只是此处多了一个注解@ModelAttribute("user")，它的作用是将该绑定的命令对象以“user”为名称添加到模型对象中供视图页面展示使用。我们此时可以在视图页面使用${user.username}来获取绑定的命令对象的属性。

绑定请求参数到命令对象支持对象图导航式的绑定，如请求参数包含“?username=zhang&password=123&workInfo.city=bj”自动绑定到user中的workInfo属性的city属性中。
@RequestMapping(value="/model2/{username}")
public String test2(@ModelAttribute("model") DataBinderTestModel model) {

URI模板变量也能自动绑定到命令对象中，当你请求的URL中包含“bool=yes&schooInfo.specialty=computer&hobbyList[0]=program&hobbyList[1]=music&map[key1]=value1&map[key2]=value2&state=blocked”会自动绑定到命令对象上。

当URI模板变量和请求参数同名时，URI模板变量具有高优先权。


二、暴露表单引用对象为模型数据
@ModelAttribute("cityList")
public List<String> cityList() {
	return Arrays.asList("北京", "山东");
}
如上代码会在执行功能处理方法之前执行，并将其自动添加到模型对象中，在功能处理方法中调用Model 入参的containsAttribute("cityList")将会返回true。

@ModelAttribute("user")  //①
public UserModel getUser(@RequestParam(value="username", defaultValue="") String username) {
//TODO 去数据库根据用户名查找用户对象
UserModel user = new UserModel();
user.setRealname("zhang");
	 return user;
}
如你要修改用户资料时一般需要根据用户的编号/用户名查找用户来进行编辑，此时可以通过如上代码查找要编辑的用户。

@RequestMapping(value="/model1") //②
public String test1(@ModelAttribute("user") UserModel user, Model model)

此处我们看到①和②有同名的命令对象，那Spring Web MVC内部如何处理的呢：

(1、首先执行@ModelAttribute注解的方法，准备视图展示时所需要的模型数据；@ModelAttribute注解方法形式参数规则和@RequestMapping规则一样，如可以有@RequestParam等；

（2、执行@RequestMapping注解方法，进行模型绑定时首先查找模型数据中是否含有同名对象，如果有直接使用，如果没有通过反射创建一个，因此②处的user将使用①处返回的命令对象。即②处的user等于①处的user。


三、暴露@RequestMapping方法返回值为模型数据

public @ModelAttribute("user2") UserModel test3(@ModelAttribute("user2") UserModel user)

大家可以看到返回值类型是命令对象类型，而且通过@ModelAttribute("user2")注解，此时会暴露返回值到模型数据（名字为user2）中供视图展示使用。那哪个视图应该展示呢？此时Spring Web MVC会根据RequestToViewNameTranslator进行逻辑视图名的翻译

@RequestMapping注解方法的入参user暴露到模型数据中的名字也是user2，其实我们能猜到：
（3、@ModelAttribute注解的返回值会覆盖@RequestMapping注解方法中的@ModelAttribute注解的同名命令对象。




四、匿名绑定命令参数
public String test4(@ModelAttribute UserModel user, Model model)
或
public String test5(UserModel user, Model model)

此时我们没有为命令对象提供暴露到模型数据中的名字，此时的名字是什么呢？Spring Web MVC自动将简单类名（首字母小写）作为名字暴露，如“cn.javass.chapter6.model.UserModel”暴露的名字为“userModel”。


public @ModelAttribute List<String> test6()
或
public @ModelAttribute List<UserModel> test7()

对于集合类型（Collection接口的实现者们，包括数组），生成的模型对象属性名为“简单类名（首字母小写）”+“List”，如List<String>生成的模型对象属性名为“stringList”，List<UserModel>生成的模型对象属性名为“userModelList”。

其他情况一律都是使用简单类名（首字母小写）作为模型对象属性名，如Map<String, UserModel>类型的模型对象属性名为“map”。




@SessionAttributes绑定命令对象到session

有时候我们需要在多次请求之间保持数据，一般情况需要我们明确的调用HttpSession的API来存取会话数据，如多步骤提交的表单。Spring Web MVC提供了@SessionAttributes进行请求间透明的存取会话数据。

/1、在控制器类头上添加@SessionAttributes注解
@SessionAttributes(value = {"user"})    //①
public class SessionAttributeController

//2、@ModelAttribute注解的方法进行表单引用对象的创建
@ModelAttribute("user")    //②
public UserModel initUser()

//3、@RequestMapping注解方法的@ModelAttribute注解的参数进行命令对象的绑定
@RequestMapping("/session1")   //③
public String session1(@ModelAttribute("user") UserModel user)

//4、通过SessionStatus的setComplete()方法清除@SessionAttributes指定的会话数据
@RequestMapping("/session2")   //③
public String session(@ModelAttribute("user") UserModel user, SessionStatus status) {
    if(true) { //④
        status.setComplete();
    }
    return "success";
}

@SessionAttributes(value = {"user"})含义：
@SessionAttributes(value = {"user"}) 标识将模型数据中的名字为“user” 的对象存储到会话中（默认HttpSession），此处value指定将模型数据中的哪些数据（名字进行匹配）存储到会话中，此外还有一个types属性表示模型数据中的哪些类型的对象存储到会话范围内，如果同时指定value和types属性则那些名字和类型都匹配的对象才能存储到会话范围内。


包含@SessionAttributes的执行流程如下所示：
① 首先根据@SessionAttributes注解信息查找会话内的对象放入到模型数据中；
② 执行@ModelAttribute注解的方法：如果模型数据中包含同名的数据，则不执行@ModelAttribute注解方法进行准备表单引用数据，而是使用①步骤中的会话数据；如果模型数据中不包含同名的数据，执行@ModelAttribute注解的方法并将返回值添加到模型数据中；
③ 执行@RequestMapping方法，绑定@ModelAttribute注解的参数：查找模型数据中是否有@ModelAttribute注解的同名对象，如果有直接使用，否则通过反射创建一个；并将请求参数绑定到该命令对象；

此处需要注意：如果使用@SessionAttributes注解控制器类之后，③步骤一定是从模型对象中取得同名的命令对象，如果模型数据中不存在将抛出HttpSessionRequiredException Expected session attribute ‘user’(Spring3.1)或HttpSessionRequiredException Session attribute ‘user’ required - not found in session(Spring3.0)异常。

④ 如果会话可以销毁了，如多步骤提交表单的最后一步，此时可以调用SessionStatus对象的setComplete()标识当前会话的@SessionAttributes指定的数据可以清理了，此时当@RequestMapping功能处理方法执行完毕会进行清理会话数据。



我们通过Spring Web MVC的源代码验证一下吧，此处我们分析的是Spring3.1的RequestMappingHandlerAdapter，读者可以自行验证Spring3.0的AnnotationMethodHandlerAdapter，流程一样：

（1、RequestMappingHandlerAdapter.invokeHandlerMethod

//1、RequestMappingHandlerAdapter首先调用ModelFactory的initModel方法准备模型数据：
modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);
//2、调用@RequestMapping注解的功能处理方法
requestMappingMethod.invokeAndHandle(webRequest, mavContainer);
//3、更新/合并模型数据
modelFactory.updateModel(webRequest, mavContainer);

（2、ModelFactory.initModel

Map<String, ?> attributesInSession = this.sessionAttributesHandler.retrieveAttributes(request);
//1.1、将与@SessionAttributes注解相关的会话对象放入模型数据中
mavContainer.mergeAttributes(attributesInSession);
//1.2、调用@ModelAttribute方法添加表单引用对象
invokeModelAttributeMethods(request, mavContainer);
//1.3、验证模型数据中是否包含@SessionAttributes注解相关的会话对象，不包含抛出异常
for (String name : findSessionAttributeArguments(handlerMethod)) {
	if (!mavContainer.containsAttribute(name)) {
	//1.4、此处防止在@ModelAttribute注解方法又添加了会话对象
	//如在@ModelAttribute注解方法调用session.setAttribute("user", new UserModel());
	Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);
	if (value == null) {
	throw new HttpSessionRequiredException("Expected session attribute '" + name + "'");
	}
	mavContainer.addAttribute(name, value);
}


（3、ModelFactory.invokeModelAttributeMethods

for (InvocableHandlerMethod attrMethod : this.attributeMethods) {
	String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
	//1.2.1、如果模型数据中包含同名数据则不再添加
	if (mavContainer.containsAttribute(modelName)) {
		continue;
	}
	//1.2.2、调用@ModelAttribute注解方法并将返回值添加到模型数据中，此处省略实现代码
}


（4、requestMappingMethod.invokeAndHandle 调用功能处理方法，此处省略

（5、ModelFactory.updateMode 更新模型数据
//3.1、如果会话被标识为完成，此时从会话中清除@SessionAttributes注解相关的会话对象
if (mavContainer.getSessionStatus().isComplete()){
	this.sessionAttributesHandler.cleanupAttributes(request);
}
//3.2、如果会话没有完成，将模型数据中的@SessionAttributes注解相关的对象添加到会话中
else {
	this.sessionAttributesHandler.storeAttributes(request, mavContainer.getModel());
}
//省略部分代码


到此@SessionAtrribute介绍完毕



@Value绑定SpEL表示式
@Value用于将一个SpEL表达式结果映射到到功能处理方法的参数上。
public String test(@Value("#{systemProperties['java.vm.version']}") String jvmVersion)


通过@Value将外部的值动态注入到Bean中，使用的情况有：
    注入普通字符串
    注入操作系统属性
    注入表达式结果
    注入其他Bean属性：注入beanInject对象的属性another
    注入文件资源
    注入URL资源

@Value("normal")
private String normal; // 注入普通字符串

@Value("#{systemProperties['os.name']}")
private String systemPropertiesName; // 注入操作系统属性

@Value("#{ T(java.lang.Math).random() * 100.0 }")
private double randomNumber; //注入表达式结果

@Value("#{beanInject.another}")
private String fromAnotherBean; // 注入其他Bean属性：注入beanInject对象的属性another，类具体定义见下面

@Value("classpath:com/hry/spring/configinject/config.txt")
private Resource resourceFile; // 注入文件资源

@Value("http://www.baidu.com")
private Resource testUrl; // 注入URL资源


@Component
public class BeanInject {
    @Value("其他Bean的属性")
    private String another;
	// getter setter
}
...上面用到的beanInject.another


第一个属性文件config.properties内容如下：
${anotherfile.configinject}作为第二个属性文件加载路径的变量值
book.name=bookName
anotherfile.configinject=placeholder

第二个属性文件config_placeholder.properties内容如下：
book.name.placeholder=bookNamePlaceholder

使用：
@PropertySource({"classpath:com/hry/spring/configinject/config.properties",
    "classpath:com/hry/spring/configinject/config_${anotherfile.configinject}.properties"})
public class ConfigurationFileInject{
    @Value("${app.name}")
    private String appName; // 这里的值来自application.properties，spring boot启动时默认加载此文件

    @Value("${book.name}")
    private String bookName; // 注入第一个配置外部文件属性

    @Value("${book.name.placeholder}")
    private String bookNamePlaceholder; // 注入第二个配置外部文件属性
	//....
}







在Spring3之前，我们使用如下架构进行类型转换、验证及格式化：

①：类型转换：首先调用PropertyEditor的setAsText（String），内部根据需要调用setValue(Object)方法进行设置转换后的值；

②：数据验证：需要显示调用Spring的Validator接口实现进行数据验证；

③：格式化显示：需要调用PropertyEditor的getText进行格式化显示。

使用如上架构的缺点是：

（1、PropertyEditor被设计为只能String<――>Object之间转换，不能任意对象类型<――>任意类型，如我们常见的Long时间戳到Date类型的转换是办不到的；

（2、PropertyEditor是线程不安全的，也就是有状态的，因此每次使用时都需要创建一个，不可重用；

（3、PropertyEditor不是强类型的，setValue（Object）可以接受任意类型，因此需要我们自己判断类型是否兼容；

（4、需要自己编程实现验证，Spring3支持更棒的注解验证支持；

（5、在使用SpEL表达式语言或DataBinder时，只能进行String<--->Object之间的类型转换；

（6、不支持细粒度的类型转换/格式化，如UserModel的registerDate需要转换/格式化类似“2012-05-01”的数据，而OrderModel的orderDate需要转换/格式化类似“2012-05-01
15：11：13”的数据，因为大家都为java.util.Date类型，因此不太容易进行细粒度转换/格式化。


在Spring Web MVC环境中，数据类型转换、验证及格式化通常是这样使用的：
①、类型转换：首先表单数据（全部是字符串）通过WebDataBinder进行绑定到命令对象，内部通过PropertyEditor实现；

②：数据验证：在控制器中的功能处理方法中，需要显示的调用Spring的Validator实现并将错误信息添加到BindingResult对象中；

③：格式化显示：在表单页面可以通过如下方式展示通过PropertyEditor格式化的数据和错误信息：
<%@taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
首先需要通过如上taglib指令引入spring的两个标签库。

//1、格式化单个命令/表单对象的值（好像比较麻烦，真心没有好办法）
<spring:bind path="dataBinderTest.phoneNumber">${status.value}</spring:bind>
//2、通过form标签，内部的表单标签会自动调用命令/表单对象属性对应的PropertyEditor进行格式化显示
<form:form commandName="dataBinderTest">
	<form:input path="phoneNumber"/><!-- 如果出错会显示错误之前的数据而不是空 -->
</form:form>
//3、显示验证失败后的错误信息
<form:errors></form:errors>

如上PropertyEditor和验证API使用起来比较麻烦，而且有许多缺点，因此Spring3提供了更强大的类型转换（Type Conversion）支持，它可以在任意对象之间进行类型转换，不仅仅是String<――>Object；也提供了强大的数据验证支持；同时提供了强大的数据格式化支持。



从Spring3开始，我们可以使用如下架构进行类型转换、验证及格式化：
①：类型转换：内部的ConversionService会根据S源类型/T目标类型自动选择相应的Converter SPI进行类型转换，而且是强类型的，能在任意类型数据之间进行转换；

②：数据验证：支持JSR-303验证框架，如将@Valid放在需要验证的目标类型上即可；

③：格式化显示：其实就是任意目标类型---->String的转换，完全可以使用Converter SPI完成。


Spring为了更好的诠释格式化/解析功能提供了Formatter SPI，支持根据Locale信息进行格式化/解析，而且该套SPI可以支持字段/参数级别的细粒度格式化/解析，流程如下：

①：类型解析（转换）：String---->T类型目标对象的解析，和PropertyEditor类似；

③：格式化显示：任意目标类型---->String的转换，和PropertyEditor类似。

。。123，是图上的流程。。


Formatter SPI最大特点是能进行字段/参数级别的细粒度解析/格式化控制，即使是Converter SPI也是粗粒度的（到某个具体类型，而不是其中的某个字段单独控制），目前Formatter SPI还不是很完善，如果您有好的想法可以到Spring官网提建议。

Formatter SPI内部实现实际委托给Converter SPI进行转换，即约束为解析/格式化String<---->任意目标类型。



在Spring Web MVC环境中，数据类型转换、验证及格式化通常是这样使用的：
①、类型转换：首先表单数据（全部是字符串）通过WebDataBinder进行绑定到命令对象，内部通过Converter SPI实现；

②：数据验证：使用JSR-303验证框架进行验证；

③：格式化显示：在表单页面可以通过如下方式展示通过内部通过Converter SPI格式化的数据和错误信
<%@taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
首先需要通过如上taglib指令引入spring的两个标签库。

//1、格式化单个命令/表单对象的值（好像比较麻烦，真心没有好办法）
<spring:bind path="dataBinderTest.phoneNumber">${status.value}</spring:bind>

//2、<spring:eval>标签，自动调用ConversionService并选择相应的Converter SPI进行格式化展示
<spring:eval expression="dataBinderTest.phoneNumber"></spring:eval>

如上代码能工作的前提是在RequestMappingHandlerMapping配置了ConversionServiceExposingInterceptor，它的作用是暴露conversionService到请求中以便如<spring:eval>标签使用。

//3、通过form标签，内部的表单标签会自动调用命令/表单对象属性对应的PropertyEditor进行格式化显示
<form:form commandName="dataBinderTest">
	<form:input path="phoneNumber"/><!-- 如果出错会显示错误之前的数据而不是空 -->
</form:form>

//4、显示验证失败后的错误信息
<form:errors></form:errors>




数据类型转换

Spring3之前的PropertyEditor

使用WebDataBinder进行控制器级别注册PropertyEditor（控制器独享）
@InitBinder
//此处的参数也可以是ServletRequestDataBinder类型
public void initBinder(WebDataBinder binder) throws Exception {
	//注册自定义的属性编辑器
	//1、日期
	DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	CustomDateEditor dateEditor = new CustomDateEditor(df, true);
	//表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换
	binder.registerCustomEditor(Date.class, dateEditor);
	//自定义的电话号码编辑器(和【4.16.1、数据类型转换】一样)
	binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());
}

使用WebBindingInitializer批量注册PropertyEditor
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
  <property name="webBindingInitializer">
	<bean class="cn.javass.chapter7.web.controller.support.initializer.MyWebBindingInitializer"/>
  </property>
</bean>

全局级别注册PropertyEditor（全局共享）
。。和很久之前的一样。。。






Spring3开始的类型转换系统


Spring3引入了更加通用的类型转换系统，其定义了SPI接口（Converter等）和相应的运行时执行类型转换的API（ConversionService等），在Spring中它和PropertyEditor功能类似，可以替代PropertyEditor来转换外部Bean属性的值到Bean属性需要的类型。

该类型转换系统是Spring通用的，其定义在org.springframework.core.convert包中，不仅仅在Spring Web MVC场景下。目标是完全替换PropertyEditor，提供无状态、强类型且可以在任意类型之间转换的类型转换系统，可以用于任何需要的地方，如SpEL、数据绑定。

Converter SPI完成通用的类型转换逻辑，如java.util.Date<---->java.lang.Long或java.lang.String---->PhoneNumberModel等。


类型转换器：提供类型转换的实现支持。
一个有如下三种接口：
（1、Converter：类型转换器，用于转换S类型到T类型，此接口的实现必须是线程安全的且可以被共享。

public interface Converter<S, T> { //① S是源类型 T是目标类型
    T convert(S source); //② 转换S类型的source到T目标类型的转换方法
}

我们可以看到Converter接口实现只能转换一种类型到另一种类型，不能进行多类型转换，如将一个数组转换成集合，如（String[] ----> List<String>、String[]----->List<PhoneNumberModel>等）。


（2、GenericConverter和ConditionalGenericConverter：GenericConverter接口实现能在多种类型之间进行转换，ConditionalGenericConverter是有条件的在多种类型之间进行转换。

public interface GenericConverter {
	Set<ConvertiblePair> getConvertibleTypes();
	Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
getConvertibleTypes:指定了可以转换的目标类型对；
convert：在sourceType和targetType类型之间进行转换。

public interface ConditionalGenericConverter extends GenericConverter {
    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}
matches：用于判断sourceType和targetType类型之间能否进行类型转换。

如org.springframework.core.convert.support.ArrayToCollectionConverter和CollectionToArrayConverter用于在数组和集合间进行转换的ConditionalGenericConverter实现，如在String[]<---->List<String>、String[]<---->List<PhoneNumberModel>等之间进行类型转换。

对于我们大部分用户来说一般不需要自定义GenericConverter, 如果需要可以参考内置的GenericConverter来实现自己的。


（3、ConverterFactory：工厂模式的实现，用于选择将一种S源类型转换为R类型的子类型T的转换器的工厂接口。

package org.springframework.core.convert.converter;
public interface ConverterFactory<S, R> {
	<T extends R> Converter<S, T> getConverter(Class<T> targetType);
}

S：源类型；R目标类型的父类型；T：目标类型，且是R类型的子类型；

getConverter：得到目标类型的对应的转换器。

示例：如org.springframework.core.convert.support.NumberToNumberConverterFactory用于在Number类型子类型之间进行转换，如Integer--->Double， Byte---->Integer， Float--->Double等。

对于我们大部分用户来说一般不需要自定义ConverterFactory，如果需要可以参考内置的ConverterFactory来实现自己的。



类型转换器注册器、类型转换服务：提供类型转换器注册支持，运行时类型转换API支持。

一共有如下两种接口：
（1、ConverterRegistry：类型转换器注册支持，可以注册/删除相应的类型转换器。

public interface ConverterRegistry {
    void addConverter(Converter<?, ?> converter);
    void addConverter(Class<?> sourceType, Class<?> targetType, Converter<?, ?> converter);
    void addConverter(GenericConverter converter);
    void addConverterFactory(ConverterFactory<?, ?> converterFactory);
    void removeConvertible(Class<?> sourceType, Class<?> targetType);
}

可以注册：Converter实现，GenericConverter实现，ConverterFactory实现。


（2、ConversionService：运行时类型转换服务接口，提供运行期类型转换的支持。
public interface ConversionService {
    boolean canConvert(Class<?> sourceType, Class<?> targetType);
    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);
    <T> T convert(Object source, Class<T> targetType);
    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
convert：将源对象转换为目标类型的目标对象。

Spring提供了两个默认实现（其都实现了ConverterRegistry、ConversionService接口）:

DefaultConversionService:默认的类型转换服务实现；

DefaultFormattingConversionService：带数据格式化支持的类型转换服务实现，一般使用该服务实现即可。



Spring内建的类型转换器如下所示：

第一组：标量转换器

StringToBooleanConverter
String----->Boolean
true:true/on/yes/1； false:false/off/no/0

ObjectToStringConverter
Object----->String
调用toString方法转换

StringToNumberConverterFactory
String----->Number（如Integer、Long等）

NumberToNumberConverterFactory
Number子类型(Integer、Long、Double等)<――> Number子类型(Integer、Long、Double等)

StringToCharacterConverter
String----->java.lang.Character
取字符串第一个字符

NumberToCharacterConverter
Number子类型(Integer、Long、Double等)――> java.lang.Character

CharacterToNumberFactory
java.lang.Character ――>Number子类型(Integer、Long、Double等)

StringToEnumConverterFactory
String----->enum类型
通过Enum.valueOf将字符串转换为需要的enum类型

EnumToStringConverter
enum类型----->String
返回enum对象的name()值

StringToLocaleConverter
String----->java.util.Local

PropertiesToStringConverter
java.util.Properties----->String
默认通过ISO-8859-1解码

StringToPropertiesConverter
String----->java.util.Properties
默认使用ISO-8859-1编码



第二组：集合、数组相关转换器
ArrayToCollectionConverter
任意S数组---->任意T集合（List、Set）

CollectionToArrayConverter
任意T集合（List、Set）---->任意S数组

ArrayToArrayConverter
任意S数组<---->任意T数组

CollectionToCollectionConverter
任意T集合（List、Set）<---->任意T集合（List、Set）
即集合之间的类型转换

MapToMapConverter
Map<---->Map之间的转换

ArrayToStringConverter
任意S数组---->String类型

StringToArrayConverter
String----->数组
默认通过“,”分割，且去除字符串的两边空格(trim)

ArrayToObjectConverter
任意S数组---->任意Object的转换
(如果目标类型和源类型兼容，直接返回源对象；否则返回S数组的第一个元素并进行类型转换)

ObjectToArrayConverter
Object----->单元素数组

CollectionToStringConverter
任意T集合（List、Set）---->String类型

StringToCollectionConverter
String----->集合（List、Set）
默认通过“,”分割，且去除字符串的两边空格(trim)

CollectionToObjectConverter
任意T集合---->任意Object的转换
(如果目标类型和源类型兼容，直接返回源对象；否则返回S数组的第一个元素并进行类型转换)

ObjectToCollectionConverter
Object----->单元素集合


第三组：默认（fallback）转换器：之前的转换器不能转换时调用
ObjectToObjectConverter
Object（S）----->Object（T）
首先尝试valueOf进行转换、没有则尝试new 构造器(S)

IdToEntityConverter
Id(S)----->Entity(T)
查找并调用public static T find[EntityName](S)获取目标对象，EntityName是T类型的简单类型

FallbackObjectToStringConverter
Object----->String
ConversionService作为恢复使用，即其他转换器不能转换时调用（执行对象的toString()方法）


如上的转换器在使用转换服务实现DefaultConversionService和DefaultFormattingConversionService时会自动注册。


（1、自定义String----->PhoneNumberModel的转换器
public class StringToPhoneNumberConverter implements Converter<String, PhoneNumberModel> {
    Pattern pattern = Pattern.compile("^(\\d{3,4})-(\\d{7,8})$");
    @Override
    public PhoneNumberModel convert(String source) {
        if(!StringUtils.hasLength(source)) {
            //①如果source为空 返回null
            return null;
        }
        Matcher matcher = pattern.matcher(source);
        if(matcher.matches()) {
            //②如果匹配 进行转换
            PhoneNumberModel phoneNumber = new PhoneNumberModel();
            phoneNumber.setAreaCode(matcher.group(1));
            phoneNumber.setPhoneNumber(matcher.group(2));
            return phoneNumber;
        } else {
            //③如果不匹配 转换失败
            throw new IllegalArgumentException(String.format("类型转换失败，需要格式[010-12345678]，但格式是[%s]", source));
        }
    }
}



集成到Spring Web MVC环境

（1、注册ConversionService实现和自定义的类型转换器
<!-- ①注册ConversionService -->
<bean id="conversionService" class="org.springframework.format.support.
											 FormattingConversionServiceFactoryBean">
	<property name="converters">
	   <list>
			<bean class="cn.javass.chapter7.web.controller.support.
							 converter.StringToPhoneNumberConverter"/>
			<bean class="cn.javass.chapter7.web.controller.support.
							 converter.StringToDateConverter">
				<constructor-arg value="yyyy-MM-dd"/>
			</bean>
		</list>
	</property>
</bean>

FormattingConversionServiceFactoryBean：是FactoryBean实现，默认使用DefaultFormattingConversionService转换器服务实现；

converters：注册我们自定义的类型转换器，此处注册了String--->PhoneNumberModel和String--->Date的类型转换器。


（2、通过ConfigurableWebBindingInitializer注册ConversionService
<!-- ②使用ConfigurableWebBindingInitializer注册conversionService -->
<bean id="webBindingInitializer" class="org.springframework.web.bind.support.
																		ConfigurableWebBindingInitializer">
	<property name="conversionService" ref="conversionService"/>
</bean>

此处我们通过ConfigurableWebBindingInitializer绑定初始化器进行ConversionService的注册；


注册ConfigurableWebBindingInitializer到RequestMappingHandlerAdapter
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
	<property name="webBindingInitializer" ref="webBindingInitializer"/>
</bean>

通过如上配置，我们就完成了Spring3.0的类型转换系统与Spring Web MVC的集成。此时可以启动服务器输入之前的URL测试了。


如果我同时使用PropertyEditor和ConversionService，执行顺序是什么呢？内部首先查找PropertyEditor进行类型转换，如果没有找到相应的PropertyEditor再通过ConversionService进行转换。

如上集成过程看起来比较麻烦，后边我们会介绍<mvc:annotation-driven>和@EnableWebMvc，ConversionService会自动注册，后续章节再详细介绍。






在如Web /客户端项目中，通常需要将数据转换为具有某种格式的字符串进行展示，因此上节我们学习的数据类型转换系统核心作用不是完成这个需求，因此Spring3引入了格式化转换器（Formatter SPI） 和格式化服务API（FormattingConversionService）从而支持这种需求。在Spring中它和PropertyEditor功能类似，可以替代PropertyEditor来进行对象的解析和格式化，而且支持细粒度的字段级别的格式化/解析。

Formatter SPI核心是完成解析和格式化转换逻辑，在如Web应用/客户端项目中，需要解析、打印/展示本地化的对象值时使用，如根据Locale信息将java.util.Date---->java.lang.String打印/展示、java.lang.String---->java.util.Date等。

该格式化转换系统是Spring通用的，其定义在org.springframework.format包中，不仅仅在Spring Web MVC场景下。


1、格式化转换器：提供格式化转换的实现支持。
一共有如下两组四个接口：

（1、Printer接口：格式化显示接口，将T类型的对象根据Locale信息以某种格式进行打印显示（即返回字符串形式）；

public interface Printer<T> {
    String print(T object, Locale locale);
}

（2、Parser接口：解析接口，根据Locale信息解析字符串到T类型的对象；
public interface Parser<T> {
    T parse(String text, Locale locale) throws ParseException;
}

（3、Formatter接口：格式化SPI接口，继承Printer和Parser接口，完成T类型对象的格式化和解析功能；
package org.springframework.format;
public interface Formatter<T> extends Printer<T>, Parser<T> {
}

（4、AnnotationFormatterFactory接口：注解驱动的字段格式化工厂，用于创建带注解的对象字段的Printer和Parser，即用于格式化和解析带注解的对象字段。

public interface AnnotationFormatterFactory<A extends Annotation> {//①可以识别的注解类型
    Set<Class<?>> getFieldTypes();//②可以被A注解类型注解的字段类型集合
    Printer<?> getPrinter(A annotation, Class<?> fieldType);//③根据A注解类型和fieldType类型获取Printer
    Parser<?> getParser(A annotation, Class<?> fieldType);//④根据A注解类型和fieldType类型获取Parser
}

返回用于格式化和解析被A注解类型注解的字段值的Printer和Parser。如JodaDateTimeFormatAnnotationFormatterFactory可以为带有@DateTimeFormat注解的java.util.Date字段类型创建相应的Printer和Parser进行格式化和解析。


2、格式化转换器注册器、格式化服务：提供类型转换器注册支持，运行时类型转换API支持。

一个有如下两种接口：
（1、FormatterRegistry：格式化转换器注册器，用于注册格式化转换器（Formatter、Printer和Parser、AnnotationFormatterFactory）；

public interface FormatterRegistry extends ConverterRegistry {
    //①添加格式化转换器（Spring3.1 新增API）
    void addFormatter(Formatter<?> formatter);
    //②为指定的字段类型添加格式化转换器
    void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);
    //③为指定的字段类型添加Printer和Parser
    void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);
    //④添加注解驱动的字段格式化工厂AnnotationFormatterFactory
    void addFormatterForFieldAnnotation(
                AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory);
}

（2、FormattingConversionService：继承自ConversionService，运行时类型转换和格式化服务接口，提供运行期类型转换和格式化的支持。

我们可以看到FormattingConversionService内部实现如上所示，当你调用convert方法时：

⑴若是S类型----->String：调用私有的静态内部类PrinterConverter，其又调用相应的Printer的实现进行格式化；

⑵若是String----->T类型：调用私有的静态内部类ParserConverter，其又调用相应的Parser的实现进行解析；

⑶若是A注解类型注解的S类型----->String：调用私有的静态内部类AnnotationPrinterConverter，其又调用相应的AnnotationFormatterFactory的getPrinter获取Printer的实现进行格式化；

⑷若是String----->A注解类型注解的T类型：调用私有的静态内部类AnnotationParserConverter，其又调用相应的AnnotationFormatterFactory的getParser获取Parser的实现进行解析。

注：S类型表示源类型，T类型表示目标类型，A表示注解类型。


此处可以可以看出之前的Converter SPI完成任意Object与Object之间的类型转换，而Formatter SPI完成任意Object与String之间的类型转换（即格式化和解析，与PropertyEditor类似）。


Spring内建的格式化转换器如下所示：
DateFormatter
java.util.Date<---->String
实现日期的格式化/解析

NumberFormatter
java.lang.Number<---->String
实现通用样式的格式化/解析

CurrencyFormatter
java.lang.BigDecimal<---->String
实现货币样式的格式化/解析

PercentFormatter
java.lang.Number<---->String
实现百分数样式的格式化/解析

NumberFormatAnnotationFormatterFactory
@NumberFormat注解类型的数字字段类型<---->String
①通过@NumberFormat指定格式化/解析格式
②可以格式化/解析的数字类型：Short、Integer、Long、Float、Double、BigDecimal、BigInteger

JodaDateTimeFormatAnnotationFormatterFactory
@DateTimeFormat注解类型的日期字段类型<---->String
①通过@DateTimeFormat指定格式化/解析格式
②可以格式化/解析的日期类型：
joda中的日期类型（org.joda.time包中的）：LocalDate、LocalDateTime、LocalTime、ReadableInstant
java内置的日期类型：Date、Calendar、Long
classpath中必须有Joda-Time类库，否则无法格式化日期类型


NumberFormatAnnotationFormatterFactory和JodaDateTimeFormatAnnotationFormatterFactory（如果classpath提供了Joda-Time类库）在使用格式化服务实现DefaultFormattingConversionService时会自动注册。



类型级别的解析/格式化
一、直接使用Formatter SPI进行解析/格式化
//二、CurrencyFormatter：实现货币样式的格式化/解析
CurrencyFormatter currencyFormatter = new CurrencyFormatter();
currencyFormatter.setFractionDigits(2);//保留小数点后几位
currencyFormatter.setRoundingMode(RoundingMode.CEILING);//舍入模式（ceilling表示四舍五入）

//1、将带货币符号的字符串“$123.125”转换为BigDecimal("123.00")
Assert.assertEquals(new BigDecimal("123.13"), currencyFormatter.parse("$123.125", Locale.US));
//2、将BigDecimal("123")格式化为字符串“$123.00”展示
Assert.assertEquals("$123.00", currencyFormatter.print(new BigDecimal("123"), Locale.US));
Assert.assertEquals("￥123.00", currencyFormatter.print(new BigDecimal("123"), Locale.CHINA));
Assert.assertEquals("￥123.00", currencyFormatter.print(new BigDecimal("123"), Locale.JAPAN));

parse方法：将带格式的字符串根据Locale信息解析为相应的BigDecimal类型数据；

print方法：将BigDecimal类型数据根据Locale信息格式化为字符串数据进行展示。

不同于Convert SPI，Formatter SPI可以根据本地化（Locale）信息进行解析/格式化。


@Test
public void testWithDefaultFormattingConversionService() {
	DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
	//默认不自动注册任何Formatter
	CurrencyFormatter currencyFormatter = new CurrencyFormatter();
	currencyFormatter.setFractionDigits(2);//保留小数点后几位
	currencyFormatter.setRoundingMode(RoundingMode.CEILING);//舍入模式（ceilling表示四舍五入）
	//注册Formatter SPI实现
	conversionService.addFormatter(currencyFormatter);

	//绑定Locale信息到ThreadLocal
	//FormattingConversionService内部自动获取作为Locale信息，如果不设值默认是 Locale.getDefault()
	LocaleContextHolder.setLocale(Locale.US);
	Assert.assertEquals("$1,234.13", conversionService.convert(new BigDecimal("1234.128"), String.class));
	LocaleContextHolder.setLocale(null);

		LocaleContextHolder.setLocale(Locale.CHINA);
		Assert.assertEquals("￥1,234.13", conversionService.convert(new BigDecimal("1234.128"), String.class));
	Assert.assertEquals(new BigDecimal("1234.13"), conversionService.convert("￥1,234.13", BigDecimal.class));
	LocaleContextHolder.setLocale(null);}



自定义Formatter进行解析/格式化

public class PhoneNumberFormatter implements Formatter<PhoneNumberModel> {
    Pattern pattern = Pattern.compile("^(\\d{3,4})-(\\d{7,8})$");
    @Override
    public String print(PhoneNumberModel phoneNumber, Locale locale) {//①格式化
        if(phoneNumber == null) {
            return "";
        }
        return new StringBuilder().append(phoneNumber.getAreaCode()).append("-")
                                  .append(phoneNumber.getPhoneNumber()).toString();
    }

    @Override
    public PhoneNumberModel parse(String text, Locale locale) throws ParseException {//②解析
        if(!StringUtils.hasLength(text)) {
            //①如果source为空 返回null
            return null;
        }
        Matcher matcher = pattern.matcher(text);
        if(matcher.matches()) {
            //②如果匹配 进行转换
            PhoneNumberModel phoneNumber = new PhoneNumberModel();
            phoneNumber.setAreaCode(matcher.group(1));
            phoneNumber.setPhoneNumber(matcher.group(2));
            return phoneNumber;
        } else {
            //③如果不匹配 转换失败
            throw new IllegalArgumentException(String.format("类型转换失败，需要格式[010-12345678]，但格式是[%s]", text));
        }
    }
}

类似于Convert SPI实现，只是此处的相应方法会传入Locale本地化信息，这样可以为不同地区进行解析/格式化数据。


字段级别的解析/格式化
一、使用内置的注解进行字段级别的解析/格式化：
public class FormatterModel {
    @NumberFormat(style=Style.NUMBER, pattern="#,###")
    private int totalCount;
    @NumberFormat(style=Style.PERCENT)
    private double discount;
    @NumberFormat(style=Style.CURRENCY)
    private double sumMoney;

    @DateTimeFormat(iso=ISO.DATE)
    private Date registerDate;

    @DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")
    private Date orderDate;

    //省略getter/setter
}

此处我们使用了Spring字段级别解析/格式化的两个内置注解：

@Number：定义数字相关的解析/格式化元数据（通用样式、货币样式、百分数样式），参数如下：

style：用于指定样式类型，包括三种：Style.NUMBER（通用样式） Style.CURRENCY（货币样式） Style.PERCENT（百分数样式），默认Style.NUMBER；

pattern：自定义样式，如patter="#,###"；


@DateTimeFormat：定义日期相关的解析/格式化元数据，参数如下：

pattern：指定解析/格式化字段数据的模式，如”yyyy-MM-dd HH:mm:ss”

iso：指定解析/格式化字段数据的ISO模式，包括四种：ISO.NONE（不使用）  ISO.DATE(yyyy-MM-dd) ISO.TIME(hh:mm:ss.SSSZ)  ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ)，默认ISO.NONE；

style：指定用于格式化的样式模式，默认“SS”，具体使用请参考Joda-Time类库的org.joda.time.format.DateTimeFormat的forStyle的javadoc；

优先级： pattern 大于 iso 大于 style。




@Test
public void test() throws SecurityException, NoSuchFieldException {
	//默认自动注册对@NumberFormat和@DateTimeFormat的支持
	DefaultFormattingConversionService conversionService =
								new DefaultFormattingConversionService();

	//准备测试模型对象
	FormatterModel model = new FormatterModel();
	model.setTotalCount(10000);
	model.setDiscount(0.51);
	model.setSumMoney(10000.13);
	model.setRegisterDate(new Date(2012-1900, 4, 1));
	model.setOrderDate(new Date(2012-1900, 4, 1, 20, 18, 18));

	//获取类型信息
	TypeDescriptor descriptor =
			new TypeDescriptor(FormatterModel.class.getDeclaredField("totalCount"));
	TypeDescriptor stringDescriptor = TypeDescriptor.valueOf(String.class);

	Assert.assertEquals("10,000", conversionService.convert(model.getTotalCount(), descriptor, stringDescriptor));
	Assert.assertEquals(model.getTotalCount(), conversionService.convert("10,000", stringDescriptor, descriptor));

}

TypeDescriptor：拥有类型信息的上下文，用于Spring3类型转换系统获取类型信息的（可以包含类、字段、方法参数、属性信息）；通过TypeDescriptor，我们就可以获取（类、字段、方法参数、属性）的各种信息，如注解类型信息；

conversionService.convert(model.getTotalCount(), descriptor, stringDescriptor)：将totalCount格式化为字符串类型，此处会根据totalCount字段的注解信息（通过descriptor对象获取）来进行格式化；

conversionService.convert("10,000", stringDescriptor, descriptor)：将字符串“10,000”解析为totalCount字段类型，此处会根据totalCount字段的注解信息（通过descriptor对象获取）来进行解析。


（3、通过为不同的字段指定不同的注解信息进行字段级别的细粒度数据解析/格式化

descriptor = new TypeDescriptor(FormatterModel.class.getDeclaredField("registerDate"));
Assert.assertEquals("2012-05-01", conversionService.convert(model.getRegisterDate(), descriptor, stringDescriptor));
Assert.assertEquals(model.getRegisterDate(), conversionService.convert("2012-05-01", stringDescriptor, descriptor));

descriptor = new TypeDescriptor(FormatterModel.class.getDeclaredField("orderDate"));
Assert.assertEquals("2012-05-01 20:18:18", conversionService.convert(model.getOrderDate(), descriptor, stringDescriptor));
Assert.assertEquals(model.getOrderDate(), conversionService.convert("2012-05-01 20:18:18", stringDescriptor, descriptor));

通过如上测试可以看出，我们可以通过字段注解方式实现细粒度的数据解析/格式化控制，但是必须使用TypeDescriptor来指定类型的上下文信息，即编程实现字段的数据解析/格式化比较麻烦。


二、自定义注解进行字段级别的解析/格式化：

（1、定义解析/格式化字段的注解类型：
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface PhoneNumber {
}

(2、实现AnnotationFormatterFactory注解格式化工厂：
public class PhoneNumberFormatAnnotationFormatterFactory
    implements AnnotationFormatterFactory<PhoneNumber> {//①指定可以解析/格式化的字段注解类型

    private final Set<Class<?>> fieldTypes;
    private final PhoneNumberFormatter formatter;
    public PhoneNumberFormatAnnotationFormatterFactory() {
        Set<Class<?>> set = new HashSet<Class<?>>();
        set.add(PhoneNumberModel.class);
        this.fieldTypes = set;
        this.formatter = new PhoneNumberFormatter();//此处使用之前定义的Formatter实现
    }
    //②指定可以被解析/格式化的字段类型集合
    @Override
    public Set<Class<?>> getFieldTypes() {
        return fieldTypes;
    }
    //③根据注解信息和字段类型获取解析器
    @Override
    public Parser<?> getParser(PhoneNumber annotation, Class<?> fieldType) {
        return formatter;
    }
    //④根据注解信息和字段类型获取格式化器
    @Override
    public Printer<?> getPrinter(PhoneNumber annotation, Class<?> fieldType) {
        return formatter;
    }
}

AnnotationFormatterFactory实现会根据注解信息和字段类型获取相应的解析器/格式化器。

（3、修改FormatterModel添加如下代码：
@PhoneNumber
private PhoneNumberModel phoneNumber;


@Test
ublic void test() throws SecurityException, NoSuchFieldException {
DefaultFormattingConversionService conversionService =
                                    new DefaultFormattingConversionService();//创建格式化服务
conversionService.addFormatterForFieldAnnotation(
                new PhoneNumberFormatAnnotationFormatterFactory());//添加自定义的注解格式化工厂

FormatterModel model = new FormatterModel();
TypeDescriptor descriptor =
        new TypeDescriptor(FormatterModel.class.getDeclaredField("phoneNumber"));
TypeDescriptor stringDescriptor = TypeDescriptor.valueOf(String.class);

PhoneNumberModel value = (PhoneNumberModel) conversionService.convert("010-12345678", stringDescriptor, descriptor); //解析字符串"010-12345678"--> PhoneNumberModel
model.setPhoneNumber(value);

Assert.assertEquals("010-12345678", conversionService.convert(model.getPhoneNumber(), descriptor, stringDescriptor));//格式化PhoneNumberModel-->"010-12345678"

此处使用DefaultFormattingConversionService的addFormatterForFieldAnnotation注册自定义的注解格式化工厂PhoneNumberFormatAnnotationFormatterFactory。


集成到Spring Web MVC环境
一、注册FormattingConversionService实现和自定义格式化转换器：

<bean id="conversionService"
class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
  <!―此处省略之前注册的自定义类型转换器-->
  <property name="formatters">
	  <list>
		  <bean class="cn.javass.chapter7.web.controller.support.formatter.
												  PhoneNumberFormatAnnotationFormatterFactory"/>
	  </list>
  </property>
</bean>


示例：
（1、模型对象字段的数据解析/格式化：
@RequestMapping(value = "/format1")
public String test1(@ModelAttribute("model") FormatterModel formatModel) {
	return "format/success";
}

totalCount:<spring:bind path="model.totalCount">${status.value}</spring:bind><br/>
discount:<spring:bind path="model.discount">${status.value}</spring:bind><br/>
sumMoney:<spring:bind path="model.sumMoney">${status.value}</spring:bind><br/>
phoneNumber:<spring:bind path="model.phoneNumber">${status.value}</spring:bind><br/>
<!-- 如果没有配置org.springframework.web.servlet.handler.ConversionServiceExposingInterceptor将会报错 -->
phoneNumber:<spring:eval expression="model.phoneNumber"></spring:eval><br/>

<br/><br/>
<form:form commandName="model">
	<form:input path="phoneNumber"/><br/>
	<form:input path="sumMoney"/>
</form:form>

在浏览器输入测试URL：
http://localhost:9080/springmvc-chapter7/format1?totalCount=100000&discount=0.51&sumMoney=100000.128&phoneNumber=010-12345678

数据会正确绑定到我们的formatModel，即请求参数能被正确的解析并绑定到我们的命令对象上，而且在JSP页面也能正确的显示格式化后的数据（即正确的被格式化显示）。


（2、功能处理方法参数级别的数据解析：
@RequestMapping(value = "/format2")
public String test2(
	@PhoneNumber @RequestParam("phoneNumber") PhoneNumberModel phoneNumber,
	@DateTimeFormat(pattern="yyyy-MM-dd") @RequestParam("date") Date date) {
	System.out.println(phoneNumber);
	System.out.println(date);
	return "format/success2";
}

此处我们可以直接在功能处理方法的参数上使用格式化注解类型进行注解，Spring Web MVC能根据此注解信息对请求参数进行解析并正确的绑定。

在浏览器输入测试URL：
http://localhost:9080/springmvc-chapter7/format2?phoneNumber=010-12345678&date=2012-05-01

数据会正确的绑定到我们的phoneNumber和date上，即请求的参数能被正确的解析并绑定到我们的参数上。




数据验证
编程式数据验证

声明式数据验证

Spring3开始支持JSR-303验证框架，JSR-303支持XML风格的和注解风格的验证，接下来我们首先看一下如何和Spring集成。

（1、添加jar包：
此处使用Hibernate-validator实现（版本：hibernate-validator-4.3.0.Final-dist.zip），将如下jar包添加到classpath（WEB-INF/lib下即可）

（2、在Spring配置总添加对JSR-303验证框架的支持

<!-- 以下 validator  ConversionService 在使用 mvc:annotation-driven 会 自动注册-->
<bean id="validator"
class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean">
		<property name="providerClass"  value="org.hibernate.validator.HibernateValidator"/>
		<!-- 如果不加默认到 使用classpath下的 ValidationMessages.properties -->
		<property name="validationMessageSource" ref="messageSource"/>
</bean>

此处使用Hibernate validator实现：

validationMessageSource属性：指定国际化错误消息从哪里取，此处使用之前定义的messageSource来获取国际化消息；如果此处不指定该属性，则默认到classpath下的ValidationMessages.properties取国际化错误消息。

通过ConfigurableWebBindingInitializer注册validator：
<bean id="webBindingInitializer"
class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer">
		<property name="conversionService" ref="conversionService"/>
		<property name="validator" ref="validator"/>
</bean>

如上集成过程看起来比较麻烦，后边我们会介绍<mvc:annotation-driven>和@EnableWebMvc，ConversionService会自动注册，后续章节再详细介绍。

（3、使用JSR-303验证框架注解为模型对象指定验证信息
import javax.validation.constraints.NotNull;
public class UserModel {
    @NotNull(message="{username.not.empty}")
    private String username;
}
通过@NotNull指定此username字段不允许为空，当验证失败时将从之前指定的messageSource中获取“username.not.empty”对于的错误信息，此处只有通过“{错误消息键值}”格式指定的才能从messageSource获取。



（4、控制器
@Controller
public class HelloWorldController {
    @RequestMapping("/validate/hello")
    public String validate(@Valid @ModelAttribute("user") UserModel user, Errors errors) {

        if(errors.hasErrors()) {
            return "validate/error";
        }
        return "redirect:/success";
    }
}
通过在命令对象上注解@Valid来告诉Spring MVC此命令对象在绑定完毕后需要进行JSR-303验证，如果验证失败会将错误信息添加到errors错误对象中。


（5、验证失败后需要展示的页面（/WEB-INF/jsp/validate/error.jsp）
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

<form:form commandName="user">
	<form:errors path="*" cssStyle="color:red"></form:errors><br/>
</form:form>

（6、测试

在浏览器地址栏中输入http://localhost:9080/springmvc-chapter7/validate/hello，即没有username数据，请求后将直接到验证失败界面并显示错误消息“用户名不能为空”，如果请求时带上“?username=zhang”将重定向到成功页面。


内置的验证约束注解

验证注解
验证的数据类型
说明

@AssertFalse
Boolean,boolean
验证注解的元素值是false

@AssertTrue
Boolean,boolean
验证注解的元素值是true

@NotNull
任意类型
验证注解的元素值不是null

@Null
任意类型
验证注解的元素值是null

@Min(value=值)
BigDecimal，BigInteger, byte,
short, int, long，等任何Number或CharSequence（存储的是数字）子类型验证注解的元素值大于等于@Min指定的value值

@Max（value=值）
和@Min要求一样
验证注解的元素值小于等于@Max指定的value值

@DecimalMin(value=值)
和@Min要求一样
验证注解的元素值大于等于@ DecimalMin指定的value值

@DecimalMax(value=值)
和@Min要求一样
验证注解的元素值小于等于@ DecimalMax指定的value值

@Digits(integer=整数位数, fraction=小数位数)
和@Min要求一样
验证注解的元素值的整数位数和小数位数上限

@Size(min=下限, max=上限)
字符串、Collection、Map、数组等
验证注解的元素值的在min和max（包含）指定区间之内，如字符长度、集合大小

@Past
java.util.Date,java.util.Calendar;Joda Time类库的日期类型
验证注解的元素值（日期类型）比当前时间早

@Future
与@Past要求一样
验证注解的元素值（日期类型）比当前时间晚


@NotBlank
CharSequence子类型
验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的首位空格

@Length(min=下限, max=上限)
CharSequence子类型
验证注解的元素值长度在min和max区间内

@NotEmpty
CharSequence子类型、Collection、Map、数组
验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）

@Range(min=最小值, max=最大值)
BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型
验证注解的元素值在最小值和最大值之间

@Email(regexp=正则表达式,flag=标志的模式)
CharSequence子类型（如String）
验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式

@Pattern(regexp=正则表达式,flag=标志的模式)
String，任何CharSequence的子类型
验证注解的元素值与指定的正则表达式匹配

@Valid
任何非原子类型
指定递归验证关联的对象；
如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证


此处只列出Hibernate Validator提供的大部分验证约束注解，请参考hibernate validator官方文档了解其他验证约束注解和进行自定义的验证约束注解定义。


错误消息
当验证出错时，我们需要给用户展示错误消息告诉用户出错的原因，因此我们要为验证约束注解指定错误消息。错误消息是通过在验证约束注解的message属性指定。验证约束注解指定错误消息有如下两种方式：

1、硬编码错误消息；

2、从资源消息文件中根据消息键读取错误消息。


一、硬编码错误消息

直接在验证约束注解上指定错误消息，如下所示：
    @NotNull(message = "用户名不能为空")
    @Length(min=5, max=20, message="用户名长度必须在5-20之间")
    @Pattern(regexp = "^[a-zA-Z_]\\w{4,19}$", message = "用户名必须以字母下划线开头，可由字母数字下划线组成")
    private String username;

如上所示，错误消息使用硬编码指定，这种方式是不推荐使用的，因为在如下场景是不适用的：

1、在国际化场景下，需要对不同的国家显示不同的错误消息；

2、需要更换错误消息时是比较麻烦的，需要找到相应的类进行更换，并重新编译发布。


二、从资源消息文件中根据消息键读取错误消息
默认的错误消息文件是/org/hibernate/validator/ValidationMessages.properties，
消息键默认为：验证约束注解的全限定类名.message


自定义的错误消息文件和错误消息键值

自定义的错误消息文件里的错误消息键值将覆盖默认的错误消息文件中的错误消息键值。我们自定义的错误消息文件是具有国际化功能的。

（1、定义错误消息文件

在类装载路径的根下创建ValidationMessages.properties文件，如在src目录下创建会自动复制到类装载路径的根下，并添加如下消息键值（需要native2ascii，可以在eclipse里装Properties Editor，自动保存为ASCII码）：
javax.validation.constraints.Pattern.message=用户名必须以字母或下划线开头，后边可以跟字母数字下划线，长度在5-20之间

需要在你的spring配置文件WEB-INF/chapter7-servlet.xml修改之前的validator Bean：
<bean id="validator"
class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean">
		<property name="providerClass"
value="org.hibernate.validator.HibernateValidator"/>
</bean>
此时错误消息键值的查找会先到classpath下ValidationMessages.properties中找，找不到再到默认的错误消息文件中找。
。。这个没有没有把文件URI注入进去吧。。



（2、使用Spring的MessageSource Bean进行消息键值的查找

如果我们的环境是与spring集成，还是应该使用Spring提供的消息支持，具体配置如下：

在spring配置文件WEB-INF/chapter7-servlet.xml定义MessageSource Bean：
<bean id="messageSource"
class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
		<property name="basename" value="classpath:messages"/>
		<property name="fileEncodings" value="utf-8"/>
		<property name="cacheSeconds" value="120"/>
</bean>

在spring配置文件WEB-INF/chapter7-servlet.xml定义的validator Bean，添加如下属性：
    <property name="validationMessageSource" ref="messageSource"/>


在消息文件src/messages.properties中添加如下错误消息：
javax.validation.constraints.Pattern.message=用户名必须以字母或下划线开头，后边可以跟字母数字下划线，长度在5-20之间

输入测试地址：http://localhost:9080/springmvc-chapter7/validate/pattern?value=zhan，将看到我们自定义的错误消息显示出来了。


当我们配置了messageSource Bean时，默认将为验证的对象自动生成如下错误消息键：

验证错误注解简单类名.验证对象名.字段名
验证错误注解简单类名.字段名
验证错误注解简单类名.字段类型全限定类名
验证错误注解简单类名


使用的优先级是：从高到低，即最前边的具有最高的优先级，而且以上所有默认的错误消息键优先级高于自定义的错误消息键。


（3、自定义错误消息键值

在验证约束注解上指定错误消息键：
public class PatternModel {
    @Pattern(regexp = "^[a-zA-Z_][\\w]{4,19}$", message="{user.name.error}")
    private String value;
}

在消息文件src/messages.properties中添加如下错误消息：
user.name.error=用户名格式不合法


@Length(min=5, max=20, message="{user.name.length.error}")

user.name.error=用户名长度必须在5-20之间

错误消息中的5-20应该是从@Length验证约束注解中获取的，而不是在错误消息中硬编码，因此我们需要占位符的支持：

●如@Length(min=5, max=20, message="{user.name.length.error}")，错误消息可以这样写：用户名长度必须在{min}-{max}之间


错误消息占位符规则：
{验证注解属性名}，如@Length有min和max属性，则在错误消息文件中可以通过{min}和{max}来获取；如@Max有value属性，则在错误消息文件中可以通过{value}来获取。


功能处理方法上多个验证参数的处理
当我们在一个功能处理方法上需要验证多个模型对象时，需要通过如下形式来获取验证结果：

@RequestMapping("/validate/multi")
public String multi(
			@Valid @ModelAttribute("a") A a, BindingResult aErrors,
			@Valid @ModelAttribute("b") B b, BindingResult bErrors) {

		if(aErrors.hasErrors()) { //如果a模型对象验证失败
			return "validate/error";
		}
		if(bErrors.hasErrors()) { //如果a模型对象验证失败
			return "validate/error";
		}
		return "redirect:/success";
}


每一个模型对象后边都需要跟一个Errors或BindingResult对象来保存验证结果，其方法体内部可以使用这两个验证结果对象来选择出错时跳转的页面。


在错误页面，需要针对不同的模型来显示错误消息：
<form:form commandName="a">
	<form:errors path="*" cssStyle="color:red"></form:errors><br/>
</form:form>
<form:form commandName="b">
	<form:errors path="*" cssStyle="color:red"></form:errors><br/>
</form:form>











IOC即控制反转，一种将控制权转移的设计模式，由传统的程序控制转移到容器控制；

DI即依赖注入，将相互依赖的对象分离，在Spring的配置（注解）中描述它们之间的依赖关系，这些依赖关系也只在使用时才被建立。

AOP即面向切面，一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。




<context:annotation-config/>
只是开启装配。注解扫描是针对已经在Spring容器里注册过的Bean。并不会新增bean。
<context:component-scan>:不仅具备<context:annotation-config>的所有功能，还可以在指定的package下面扫描对应的bean



singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。
prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。
request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。
Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。
global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。
全局作用域与Servlet中的session作用域效果相同。



















