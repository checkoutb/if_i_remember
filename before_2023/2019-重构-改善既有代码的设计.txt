

重构是这样一个过程：在不改变代码外在行为的前提下，对代码作出修改，以改进程序的内部结构。。本质上说，重构就是在代码写好之后改进它的设计。

26


每当进行重构时，第一步永远相同：为即将修改的代码建立一组可靠的测试环境。

分解并重组
代码块越小，代码的功能就越容易管理，代码的处理和移动也就越轻松。

找到代码的逻辑团，并提取到独立的函数中。

重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易就能发现它。

。。选择代码，重构-extract method，输入新方法名。。不知道eclipse有？
。。肯定有，下面有译者的注释：本文写于1999，10年之后，各种IDE都提供了良好的重构支持。

变量名是代码清晰的关键。
。改变变量名也是一种重构。
。无论什么名字，机器都(不.)能理解，但是人。。

代码应该表现自己的目的，阅读代码时，经常进行重构，这样，随着对程序的理解逐渐加深，也就不断地把这些理解嵌入代码中，不会遗忘。


搬移代码
看这个方法的内部是否用到了本类的属性。只用到了另一个类的属性，就搬移到另一个类中。
。。不过，现在基本都是service层搞这些了，pojo里没有这种计算的方法了。
。。但是觉得也不错，如果方法的输入没有要求其他类的数据。。
。。但是，这种基本都是新建一个类属性，然后在原来的set其他属性的方法中，对这个新的类属性进行计算。
。。如果新属性需要多个原来的属性计算而出呢？用builder模式？还是只开放一个构造器接口，这个构造器需要多个属性？
。。。builder需要一个新类，：内部类.getInstance().setA(x).setB(x).build()。。。。不过看到的基本都是一个新的独立类。。而且都是返回固定配置的对象。并不是手动一步步的。。。手动一步步，不如直接之开放一个构造器。。或者新建一个initializer(x,x,x)方法。
。。builder是为了多变的对象的扩展，每出现一个变化，就builder里增加一个组合+输出，，而不必每次都手动生成这种变化。。runoob上的例子是一个套餐，套操是多变的，但也是有固定的组合的(不是无穷变化的)。。
。。那上面那种setA.setB.build是什么模式。。。
。。test。。。

将一些被赋值后没有发生变化，且只被使用0/1次的临时变量删除。。删除后的地方直接用赋值号右边的表达式来代替没有变化的临时变量。


。将forEach遍历从而得到数据的代码，提取出来放到被forEach的类中去，最好是有个变量能保存这些值。
。。不要因为代码段小，或者觉得降低效率(forEach中对多个值进行累加，如果提取出来的话，会变成多个方法，每个方法里各自forEach)而放弃。。毕竟你永远不会知道是不是还有其他地方需要这些结果中的部分值。
。。最好的还是在set/remove的时候就计算出这些结果值。或者增加类属性，和boolean，有set/remove发生的时候就boolean=false。。false就重新计算，不过这种无法注意到元素中值的修改，只能注意到元素是否被修改。
。。或者增加一个元素数量的类属性，如果实际数量和元素数量不相等就计算并缓存。


58
运用多态来取代与价格相关的条件逻辑。
最好不要在另一个对象的属性基础上运用switch语句。不得不使用switch时，应该在对象自己的数据上使用。
class Rental
	double getCharge() {
		switch(getMoive().getPriceCode)

这暗示getCharge应该移到Movie类中去：
class Movie
	double getCharge(int daysRented) {
		switch(getPriceCode())

为了方法能正确，必须把租期长度传进去。租期长度来自Rental对象。
为了选择将租期长度传给Movie，而不是把影片类型传给Rental？因为可能的变化是加入新影片类型，尽量控制影片类型发生变化所造成的影响，所以选择在Movie中计算费用。

。。方法所需要的参数，哪个容易变化，就放在哪个类中。。但是，现在很少有这种pojo+service混合的类了。

影片的不同类型是通过类属性来标记的(普通，新，儿童)。
现在建立Movie的3个子类，分别来代表普通，新，儿童，这3类影片。子类中有自己的计费方法。
这样，我们能使用多态来代替switch语句了。

有个严重问题，一部影片可以在生命周期内修改自己的分类，但是一个对象不能修改自己所属的类。。有一个解决方法，State模式。
。。。
状态模式，runoob上的好像有问题，下面有人提到了。正确应该是：增加一个抽象层，把可变状态以及和可变状态有关的代码抽取出来，形成接口，一个状态一个实现类。这样的话，只需要修改这个接口的实际对象，就能修改整个类的行为。
。。

书上是：
增加一个Price接口，3个实现代表3类影片的价格。Price代替类型。
movie.getCharge方法调用Price.getCharge()，这样可以修改，且是多态。

。。就是把多态的范围缩小，原来是影片多态，现在是价格多态。
。。看这个方法的输入，只对这些输入进行多态。而不是包含这些输入-的类进行多态。
。。也不算，主要是因为类型是可变的，对象无法改变它所属的类。所以无法变化，所以只能在类型上进行变化。。
。。应该是找一个最大的可变范围，。。这个好像没有。。。直接就是将原来的switch的参数改成一个接口，进行多态就可以了。。。这样的话，以后有什么新的值需要和类型有关，那么只要在Price中开个方法就可以了。。。不过，名字得改，不能叫Price.

这是一个state，还是一个strategy？这取决于Price类是代表计费方式，还是代表影片的某个状态。

。。。只是把switch放到了Price中。。并没有取消。。。
p69.。。。

movie.getCharge(int) { return price.getCharge(int); }，getCharge是多态的，这里不需要switch，每个子类完成自己类型的计算就可以了。
而且movie的构造器调用setPriceCode()，setPriceCode中switch形参，new不同的Price来赋值。。

书上，Price是抽象类。
。。不过接口应该也行，没看到抽象类里有什么通用的方法，变量。

下面又有个计算积分的方法，移到了Price中，这次Price中是普通方法，某些子类覆盖了这个方法，有些没覆盖。


引入state模式的收获是：如果需要修改任何和价格有关的行为，或添加新的价格定价标准，或加入其他取决于价格的行为，程序的修改会变得容易很多。
。。集中，只有一个地方有代码。

。。Price可以单例吧，就像ThreadLocal一样，数据保存在Thread上，它只是一个util。
。。如果PriceUtil.getCharge(Movie)的话，依然需要switch(movie.getType).如果多个PriceUtil的话，依然需要swith确定使用哪个。
。。。书上是在setPriceCode中swith决定的。
。。花样好多，比如：PriceUtil.getCharge()中swith决定用哪个子类来处理。。。
。。test。。还是喜欢工具类，主要是pojo+service的组合类，现在不行了。。直接movie.getCharge() { PriceUtil.getChage(this); }
。。不过一个只能movie使用的util。。有点。。。内部的util类？
。。util和Price的区别是，什么时候switch，util是在执行的时候，Price是在构造器初始化的时候。Price快。。而且util，却只有movie能用，有点。。。要改名，且内部类，，，Price也应该内部类。。但是内部类多了，很影响阅读。。那就private class。。一个文件中多个类。


77
chapter 2
重构原则

对软件内部结构的一种调整，目的是在不降低软件可观察行为的前提下，提高其可理解性，降低其修改成本。

使用重构技术开发软件时，把时间分配给2种行为：添加新功能，重构。
添加新功能时，不应该修改既有代码，只管添加新功能，通过测试。
重构时，不能再添加功能，只管改进程序结构。


重构改进软件设计
没有重构，程序的设计会逐渐腐败。当只为短期目的，或在完全理解整体设计之前，就贸然修改代码，程序将逐渐失去自己的结构，越来越难以通过阅读源码来理解原来的设计。
重构很像是在整理代码，你所做的就是让所有东西回到应处的位置上。
代码结构的流失是累计性的。越难看出代码所代表的设计意图，就越难保护其中的设计，于是该设计腐败得越快。

完成同样一件事，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事情。因此改进设计的一个重要方向就是消除重复代码。
这个动作的重要性在于方便未来的修改。代码量减少不会使系统运行得更快，使未来可能的程序修改动作容易得多。

重构使软件更容易理解

随着代码简洁，可以发现一些以前看不到的设计层面的东西。

重构帮助找到bug
重构可以深入理解代码的行为->搞清程序结构->便于找到bug。


重构提高编程速度
良好的设计是快速开发的根本。


何时重构
三次法则
第三次做类似的事情时，就应该重构。

添加功能时重构
最常见的重构时机。
重构的直接原因是为了帮助我们理解需要修改的代码。
在前进过程中把代码结构理清，就可以从中理解更多东西。
重构的另一个原动力是：代码的设计无法帮助我们轻松添加所需要的特性。看着设计，对自己说："如果使用某种方式来设计，添加特性会容易很多"，不要因为过去的错误而懊恼---现在可以用重构来弥补它。
重构后添加特性，比直接添加特性更节省时间。并且也节省了以后增加特性的时间。

修补错误时重构
如果收到一份错误报告，这就是需要重构的信号，因为显然代码还不够清晰---没有清晰到让你一眼就看出bug(。。导致测试时出错)。

复审代码时重构
集思广益，考虑是否可以通过重构轻松实现。


难以阅读、逻辑重复、添加新行为时需要修改已有代码、带复杂条件逻辑的程序，是难以修改的。
我们希望程序：容易阅读，所有逻辑都只在唯一地点指定，新的改动不会危及现有行为，尽可能简化表达条件逻辑。


重构的难题
数据库

修改接口
不要过早发布接口。。
throws子句增加一个异常。这不是对函数签名的修改，所以无法以委托的方法隐藏它，但如果用户代码不做修改，编译器不会让它通过。这个问题很难解决，可以为这个函数选择一个新名字，让旧函数调用它，并将这个新增的受控异常转换为非受控异常。也可以抛出一个非受控异常，不过这样你就失去了检验能力。，我喜欢为整个包定义一个异常基类(就像java.sql的SQLException)，并确保所有public函数只在自己的throws子句中声明这个异常。这样，就能随意定义异常子类，不会影响调用者，因为调用者只知道更具一般性的异常基类。


何时不该重构
有时现有代码过于混乱，重构不如重写。
项目最后期限时，避免重构。此时，从重构过程赢得的生产力只有在最后期限之后才能体现出来。


重构与设计
重构和设计彼此互补。
。。类似敏捷，不再需要非常详实的需求分析，UML设计，而是编码中重构以改进设计。


重构与性能
大半时间都耗费在一小半代码上。首先使用一个度量工具来监控程序的运行，让它告诉你程序中哪些地方大量消耗时间和空间。关注这些性能热点，优化它们。要保持谨慎，和重构一样，应该小幅度进行修改，每走一步都需要编译，测试，再次度量。如果性能没有提高，就放弃此次修改。
构造良好的程序可以从2方面帮助这一优化形式：
1.构造良好，就能更快添加功能，有更多时间用在性能问题上。
2.构造良好，在进行性能分析时有较细的粒度，度量工具能给出范围较小的段落中，性能调整也比较容易。


99
chapter 3 代码的坏味道

3.1 Duplicated Code 重复代码
最单纯的情况是：同一个类的2个函数含有相同的表达式。。这时需要提炼出重复的代码，让这2个地点都调用被提炼出来的那段代码。
另一种情况：2个互为兄弟的子类含有相同的表达式。。。提炼代码到超类。如果代码只是类似，并非完全相同，提炼的时候就将相似部分和差异部分割开，构成单独一个函数。然后可能发现可以使用模板方法设计模式(应该是指，相同部分的方法中调用差异部分的代码，父类做一个差异部分的接口，子类各自实现差异部分的代码)。。如果有些函数以不同的算法做相同的事，可以选择其中较清晰的一个，将其他方法中的算法替换掉。

如果2个无关系的类出现重复代码，应该考虑对其中一个类提炼，将重复代码提炼到一个独立类中，然后在另一个类中使用这个新类。。但是，重复代码所在的函数也可能的确只应该属于某个类，另一个类只能调用它，或者这个函数属于第三个类，而第二个类引用这第三个类。(重复代码是在旧类中新建一个方法，然后另一个旧类调用它；或者重复代码提取到一个新类中，2个旧类调用它。)。。你必须决定这个函数放在哪里最合适，并确保它被安置后就不会在在其他任何地方出现。


3.2 Long Method 过长函数
拥有短函数的对象会活得比较好，比较长。
不熟悉面向对象技术的人，常常觉得对象程序中只有无穷无尽的委托，没有进行任何计算。
时间长了以后，才会知道，这些小小函数有多大的价值。
间接层所能带来的全部利益---解释能力，共享能力，选择能力---都是由小型函数支持的。

程序越长越难理解。
小函数容易理解的真正关键在于一个好名字，有了好名字，读者能通过名字了解函数的作用，不必去看其中的实现。

最终的效果是：你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途(而非实现手法)命名。
我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能解释其用途，我们就毫不犹豫地这样做。
关键不在于函数的长度，而在于函数"做什么"和"如何做"之间的语义距离。

99%的场合里，只需要使用方法提炼就能把函数变小，找到函数中适合集中在一起的部分，提炼到一个新函数中。
如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍，如果尝试使用提炼方法，会把许多参数和临时变量当作参数，传递给被提炼出来的新函数，导致可读性没有任何提升。此时，可以经常运用Replace Temp With Query(.。。把临时变量抽取成一个方法)来消除这些临时元素，Introduce Parameter Object(。多个参数组成一个符合逻辑的新类。)和Preserve Whole Object(。当多个参数是来源于同一个类时，直接传递这个类。)则可以将过长的参数列表变得更简洁一些。

如果已经这么做，但还是有太多的临时变量和参数，那就应该使出杀手锏：Replace Method With Object(以函数对象取代函数。将函数放进一个单独对象中，局部变量就变成了对象内的字段，可以在同一个对象中将这个大型函数分解为多个小型函数。)

如何确定该提炼哪一段代码？一个很好的技巧是：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上为这个函数命名。就算只有一行代码，如果它需要以注释来命名，那也值得将他提炼到独立函数去。
条件表达式和循环常常也是提炼的信号。可以使用Decompose Conditional(。。分解条件表达式，将复杂的条件语句的各个部分(条件，then，else各部分)分别提炼出独立的函数。)处理条件表达式，至于循环，你应该将循环和其内的代码提炼到一个独立函数中。


3.3 Large Class 过大的类
如果想利用单个类做太多事情，其内部往往会出现太多实例变量。一旦如此，Duplicated Code也就接踵而至。

可以运用提炼类将几个彼此相关联的变量一起提炼到新类中。通常如果类中的数个变量有相同的前缀或后缀，这就意味着有机会把它们提炼到某个组件中，如果这个组件适合作为一个子类，那么提炼子类往往比较简单。
有时，类并非所有时刻都使用所有实例变量，这种情况下，或许可以多次使用提炼类，提炼子类。

和"太多实例变量"一样，类内如果有太多代码，也是代码重复，混乱的源头。最简单的方案是把多于的东西消弭于类内部，如果有5个百行函数，它们之中有很多代码都相同，那么或许可以变成5个十行函数和十个提炼出来的双行函数。
和"拥有太多实例变量"一样，一个类如果有太多代码，往往也适合提炼类，提炼子类。技巧：先确定客户端如何使用它们，然后提炼接口为每个方法。这或许可以帮助你看清如何分解这个类。

如果LargeClass是一个GUI类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持2边同步。DuplicateObservedData(复制被监视数据。GUI用的。)告诉你该怎么做。


3.4 Long Parameter List 过长参数列
有了对象，就不必把函数需要的所有东西都以参数的形式传递给它。函数中需要的东西多半可以在函数的宿主类中找到。

如果向已有的对象发送一条请求就可以取代一个参数，那么应该是一重构手法Replace Parameter with Method，在这里，"已有对象"可能是函数所属类内的一个字段，也可能是另一个参数。还可以运用Preserver Whole Object将来自同一个对象的一些数据收集起来，并以该对象替换他们。如果某些数据缺乏合理的对象归属，可使用Introduce Paramter Object为它们制造出一个"参数对象"

有一个重要的例外：有时你明显不希望造成"被调用对象"与"较大对象"间某种依赖关系。这时将数据从对象中拆解出来单独作为参数，也是合情理的。但是注意其引发的代价，如果参数列太长或变化太频繁，你就需要重新考虑自己的依赖结构了。


3.5 Divergent Change 发散式变化
我们希望软件能够容易地修改。一旦需要修改，我们希望能跳到系统的某一点，只在该处做修改。如果不能做到这一点，你就嗅出两种紧密相关的刺鼻味道中的一种了。
如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。当你看着一个类说："如果新加入一个数据库，我必须修改这3个方法；如果出现一种新的金融工具，我必须修改这4个方法"。那么此时也许这个对象分成2个会更好，这样一来每个对象就可以只因一种变化而需要修改。
应该找出某特定原因而造成的所有变化，然后运行提炼类将它们提炼到另一个类中。


3.6 Shotgun Surgery 霰弹式修改
和Divergent Change类似，但正好相反。如果没遇到某种变化，你都必须在不同的类中做许多小修改，你所面临的就是Shotgun Surgery。
应该使用移动方法，移动属性把所有需要修改的代码放进同一个类。如果暂时没有合适的类，那么就创建一个，通常运用Inline Class把一系列相关行为放进同一个类。这可能会造成少量的Divergent Change，但可以轻易处理。

Divergent Change是指：一个类受多种变化的影响，Shotgun Surgery是指：一种变化引发多个类响应修改。。这2种情况下，你都会希望整理代码，使"外界变化"与"需要修改的类"趋于一一对应。


3.7 Feature Envy 依恋情结
对象技术的全部要点在于："将数据和对数据的操作行为包装在一起"。
经典的缺陷：函数对某个类的兴趣高于对自己所处类的兴趣。我们看到某个函数为了计算，从另一个对象那里调用了许多的取值函数。。显而易见，我们应该把这个函数移至另一个地点。。你应该使用移动方法把它移动到应该去的地方。有时函数中只有一部分需要另一个对象的数据，使用提炼方法把这一部分提炼到独立函数，在使用移动方法移至应该去的地方。

一个函数往往会用到几个类的功能，如何确定哪个类呢？原则是：判断哪个类拥有最多被此函数使用的数据，然后把这个函数和那些数据摆放在一起。如果先用提炼方法将这个函数分解为数个较小函数并放置于不同地点，上述步骤也就比较容易完成了。

有几个复杂精巧的模式破坏了这个规范，是Strategy和Visitor设计模式和SelfDelegation。使用这些模式是为了对抗Divergent Change。
最根本的原则是：将总是在一起变化的东西放在一起。


3.8 Data Clumps 数据泥团
总是绑在一起出现的数据应该拥有属于它们自己的对象。
先找出这些数据以及字段出现的地方，运用提炼类将它们提炼到一个单独对象中。然后运用Introduce Parameter Object和Preserve Whole Object为它减肥。这样做的好处是可以将很多参数列缩短，简化函数调用。
不必在意Data Clumps只用到了新对象的一部分字段。

一个好的判断方法是：删掉众多数据中的一项。这么做后，其他数据是否失去了意义？如果失去意义，那么就应该为它们产生一个新对象。

得到新对象后，开始寻找Feature Envy，这可以帮你找出能移至新类中的程序行为。


3.9 Primitive Obsession 基本类型偏执
。。差不多就是上面的数据泥团。。缺陷：始终使用基本类型，而不是将多个基本类型组合在一起形成小对象。
使用Replace Data Value with Object(string保存电话号码，但是后期需要"抽取区号"这种行为，此时把数据值变成对象就好了。)将原本单独存在的数据值替换为对象, 如果想要替换的数据值是类型码，那么可以使用：Replace Type Code with Class, 如果有和类型码相关的条件表达式，使用：Replace Type Code with Subclass, Replace Type Code with State/Strategy
。。看了这些方法，不仅仅是数据泥团，特别是最后几个方法，用xxxx替换类型代码。

如果你有一组总该放在一起的字段，可以使用提炼类。如果你在参数列中看到基本型数据，试试Introduce Parameter Object。如果从数组中挑选数据，可以使用Replace Array with Object。


3.10 Switch Statements
面向对象程序的一个明显特征就是：少用switch语句。从本质上说，switch语句的问题在于重复。你常常会发现同样的switch散布于不同地点。如果要为它增加一个新的case，就必须找到所有的switch并修改。。面向对象中的多态可以解决这个问题。

多态该出现在那里？switch常常根据类型码进行选择，你要的是"与该类型码相关的函数或类"，所以应该是一Extract Method将switch语句提炼到一个独立函数中，再以Move Method将它搬移到需要多态性的那个类中。此时必须决定是否使用Replace Type Code with Subclasses 或 Replace Type Code with State/Strategy。一旦这样完成继承结构后，就可以运用Replace Conditional with Polymorphism。

如果你只是在单一函数中有些选择事例，且不想改动它们，那么多态就有点杀鸡用牛刀了，这种情况下Replace Parameter with Explicit Methods是一个不错的选择。如果你的选择条件之一是null，可以试试Introduce Null Object。


3.11 Parallel Inheritance Hierarchies 平行继承体系
是Shotgun Surgery的特殊情况。这种情况下，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。如果你发现某个继承体系的类名前缀和另一个继承体系的类名前缀完全相同，便是这种问题。
消除这种重复的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再使用移动方法和移动属性，就可以将引用端的继承体系消弭与无形。
。。test。。即使引用了，哪有如何，，依然是2个继承体系啊。难道是移动方法/属性的作用？


3.12 Lazy Class 冗赘类
如果一个类的所得不值其身价，它就应该消失。
经常出现：某个类原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作；或开发者事先规划了某些变化，增加了一个类来应对这些变化，但变化实际上没有发生。不论是哪种原因，请移除这个类。如果某些子类没有做足够的工作，试试Collapse Hierachy。对于几乎没用的组件，应该以Inline Class对付它们。


3.13 Speculative Generality 夸夸其谈未来性
当有人说："我想我们总有一天需要做这件事"，并因此企图以各式各样的钩子和特殊情况来处理一些非必要的事情。这么做的结果往往造成系统更难以理解和维护。
如果某个抽象类其实没有太大作用，则运用Collapse Hierachy。不必要的委托可以运用Inline Class除掉。如果函数的某些参数没有被用上，对它实施Remove Parameter。如果函数名带有多余的抽象意味，应该对它试试Rename Method，让它现实一些。
如果函数或类的唯一用户是测试类，则连同测试用例一并移除。

3.14 Temporary Field 令人迷惑的暂时字段
有时会看到这样的对象：其内部某个属性只为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。
使用提炼类给这个属性创建一个类，然后把所有和这个属性有关的代码都放进这个类。或许还可以使用Introduce Null Object在"变量不合法"的情况下创建一个Null对象，从而避免写出条件式代码。
如果类中有一个复杂算法，需要好几个变量，往往可能导致Temporary Field的出现。由于实现者不希望传递一长串参数，所以他把这些参数都放进属性中，但这些属性只有在使用该算法时才有效，其他时候会令人困惑。这时可以提炼类把这些属性和其相关的函数提炼到一个独立的类中。


3.15 Message Chains 过度耦合的消息链
用户向一个对象请求另一个对象，然后再想后者请求另一个对象，然后再请求另一个对象。。这就是消息链。
实际代码中看到的可能是一长串getThis()或一长串临时变量。采取这种方式，意味这客户代码将与查询过程汇总的导航结构紧密耦合。一旦对象间的关系发生了任何变化，客户端就不得不做出修改。

这时应该是一Hide Delegate，可以在消息链的不同位置进行这种重构。理论上可以重构消息链上的任何一个对象，但这么做往往会把一系列对象都变成Middle Man。通常更好的选择是：选观察消息链最终得到的对象是用来干什么的，看看能否以Extract Method把使用该对象的代码提炼到一个独立函数中，在运用Move Method把这个函数推入消息链。如果这条链上的某个对象有多位客户打算航行此航线的剩余部分，就增加一个函数来做这件事。


3.16 Middle Man 中间人
对象的基本特征之一就是封装--对外部世界隐藏其内部细节。封装往往伴随着委托。如，你问主管是否有时间参加一个会议，他就把这个消息"委托"给他的记事簿，然后才能回答你。你没有必要知道这位主管使用纸质还是电子记事簿。
但人们可能过度运用委托，你也许会看到某个类接口有一半的函数都委托给其他类，这就是过度运用。这时应该是一Remove Middle Man，直接和真正负责的对象打交道。如果这样"不干实事"的函数只有少数几个，可以运用InlineMethod把它们放进调用端。如果这些Middle Man还有其他行为，可以运用Replace Delegation with Inheritance把它变成实责对象的子类，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。


3.17 Inappropriate Intimacy
有时会看到2个类过于亲密，花费太多时间去探究彼此的private成分。
使用Move Method，Move Field帮它们划清界限。也可以看看是否可以使用Change Bidirectional Association to Unidirectional让其中一个类对另一个斩断关系。
或者Extract Class，把两者共同点提炼到一个新类，让它们可以使用这个新类。
或者尝试Hide Delegate让另一类来为它们传递数据。

继承往往造成过度亲密，如果子类可以独立，那么使用Replace Inheritance with Delegation让子类离开继承体系。


3.18 Alternative Classes with Different Interfaces 异曲同工的类
如果2个函数做了同一件事，却有着不同的签名，使用Rename Method根据它们的用途重命名。。但这往往不够，请 反复使用Move Method将某些行为移入类，直到两者的协议一致为止。如果你必须重复而赘余地移入代码才能完成这些，或许可以使用Extract Superclass。


3.19 Incomplete Library Class 不完美的类库
如果只想修改库类的一两个函数，可以运用Introduce Foreign Method，如果想要添加一大堆额外行为，就得运用Introduce Local Extension


3.20 Data Class 纯粹的数据类
Data Class是指：拥有一些属性，以及getter/setter，除此之外一无长物。
如果拥有public字段，那么立刻使用Encapsulate Field封装。
如果类中含有容易类的字段，应该检查它们是否得到了恰当的封装，如果没有，那么使用Encapsulate Collection把它们封装。对于那些不该被其他类修改的属性，使用Remove Setting Method。
然后，找到这些getter/setter被使用的地方，尝试以Move Method把那些调用行为搬移到DataClass中。如果无法搬移整个函数，就运用Extract Method产生一个可被搬移的函数。不久之后就可以运用Hide Method把这些getter/setter隐藏起来。
。。test。。究竟是pojo+service好还是混合好？


3.21 Refused Bequest 被拒绝的遗赠
子类应该继承父类的函数和数据。但如果它们不像或不需要继承，又该如何？
传统说法，这意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再对父类运用Push Down Method和Push Down Field把所有用不到的函数下推给那个兄弟。这样，父类就只持有子类共享的东西。。你常常会听到这样的建议：所有父类都应该是抽象的。
我们并不建议使用传统。

如果Refused Bequest引起困惑和问题，请遵照上面的传统。但十有八九这种缺陷非常微小，不值得理睬。

如果子类复用率父类的行为(实现)，但不愿支持父类的接口，那么这个缺陷很严重。。我们不介意拒绝继承超类的实现。但不可以拒绝继承超类的接口。不过即使你不愿意继承接口，也不要胡乱修改继承体系，应该运用Replace Inheritance with Delegation来达到目的。


3.22 Comments 过多的注释
当你感觉需要写注释时，请先尝试重构，试着让所有注释都变得多余。


113
chapter 4 构筑测试体系

重构前，需要一个可靠的测试环境。
编写优良的测试程序，可以极大提高编程速度。

4.1 自测试代码的价值
编码只是非常小的一部分，时间花费在：决定下一步干什么，设计，最多的时间则是用来测试。
修复错误通常是比较快的，但找出错误确实噩梦一场。
当你修好一个错误，总会有另一个错误出现。

确保所有的测试都能完全自动化，让它们检查自己的测试结果
。。可能是，最后加一个assert，看结果和预定义的是否一致。这样人就不必自己对比结果。

每次完成后，直接测试，这样只需要回忆刚写下的代码有什么问题。因为其他的代码在上次完成后就测试通过了。

在添加代码之前，先写相应的测试代码。编写测试代码就是在问自己：这个功能需要做什么。
编写测试代码还能使你的注意力集中与接口而非实现(这永远是一件好事)。
预先写好的测试代码也为你的工作设置了一个明确的结束标志。

频繁测试时极限编程的重要一环。极限编程者都是十分专注的测试者。


4.2 JUnit


127
chapter 5 重构列表


133
chapter 6 重新组织函数

重构手法中，很大一部分是对函数进行整理，使之更恰当地包含代码。
几乎所有时刻，问题都源于LongMethods。
对付过长函数，一项重要的重构手法是ExtractMethod，把一段代码从原来的函数中提取出来，放进一个单独函数中。InlineMethod正好相反：将一个函数调用动作替换为该函数本体。

ExtractMethod最大困难就是处理局部变量，临时变量是其中一个主要的困难源头。处理一个函数时，喜欢运用Replact Temp with Query去掉所有可去掉的临时变量。如果很多地方使用了某个临时变量，就先使用Split Temporary Variable将它变得比较容易替换。

有时临时变量是在太混乱，难以替代。这时就需要Replace Method with Method Object，它让我们可以分解最混乱的函数，代价是引入一个新类。

参数带来的问题比临时变量稍微少一点，前提是你不在函数内赋值给它们。如果你已经这样做了，就得使用Remove Assignments to Parameters。

函数分解完毕后，就可以知道如何让它工作得更好，也许我们会发现算法可以改进，从而是代码更清晰。这时我们就使用Substitute Algorithm引入更清晰的算法。

6.1 Extract Method 提炼函数
将一段可以被组织在一起并独立出来的代码放入一个独立的新函数，并让函数名解释该函数的用途。
当遇见过长的函数或一段需要注释才能让人理解用途的代码时，就把这段代码放进一个独立函数中。
函数需要简短，函数名要信雅达。函数简短--粒度小--被复用几率大/被覆盖也容易/使高层函数读起来就像一系列注释(函数名当作注释读)。

如果需要返回的变量不止一个，该如何？。最好的选择是：选择另一块代码来提炼。让每个函数都只返回一个值，所以会安排多个函数。

临时变量过多时，先尝试使用Replace Temp with Query减少临时变量。如果还是不行，就是要Replace Method with Method Object，这个重构手法不在乎代码中有多少临时变量，也不在乎如何使用它们。


6.2 Inline Method 内联函数
一个函数的本体和名称同样清楚易懂。
在函数调用点插入函数本体取代函数。
。。适合于函数体比较小的情况。
这种就是消除非必要的间接性。

另一种需要Inline Method的情况是：手上有一群组织不合理的函数，你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。。实施Replace Method with Method Object之前这么做，往往可以获得不错的效果

如果使用了太多间接层，使得系统中所有函数都似乎只是对另一个函数的简单委托，那么此时就使用Inline Method。。间接层是有价值的，但不是所有的间接层都有。找到有用的间接层，删除无用的间接层。


6.3 Inline Temp 内联临时变量
一个临时变量，只被一个简单表达式(无副作用)赋值一次，而它妨碍了其他重构手法。
将所有对该临时变量的引用，替换为为临时变量赋值的表达式它自身。

Inline Temp多半是作为Replace Temp with Query的一部分使用的。


6.4 Replace Temp with Query 以查询取代临时变量
程序中以一个临时变量保存某一表达式的运算结果。
将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。

临时变量的问题在于：它们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见。所以它们会驱使你写出更长的函数，因为只有这样你才能访问到需要的临时变量。如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这份信息。
。。举的例子是，方法中使用类属性*另一个类属性，结果赋给临时变量。提炼也只是把乘法提炼到新方法中。

Replace Temp with Query往往是Extract Method之前不可缺少的一个步骤，局部变量会使代码难以被提炼，所以应该尽可能地把它们替换为查询式。

使用临时变量保存循环中的累加信息。这种情况下，整个循环都可以被提炼为一个独立函数。有时，一个循环中累加好几个值，这种情况下，应该针对每个累加值重复一遍循环，这样就能把所有临时变量都替换为查询。
。。每个累加值都重复一遍循环，会不会太慢了。。不过如果其他地方只用到某个累加值的话，倒是挺好的，可以直接调用方法。
。。不过需要评估工具，可能这种循环不会造成瓶颈，，直观的就看下集合的元素多不多，元素少的话，不可能有影响的。。。下面也写了。。

运用此手法，你可能担心性能问题。和其他性能问题一样，我们暂时不管，因为它十有八九不会造成任何影响。如果真有问题，也可以在优化时期解决它。代码组织良好，往往能发现更有效的优化方案。

将临时变量改成final，来确保只被赋值一次。如果被赋值了多次，不能用这种重构方法。


6.5 Introduce Explaining Variable 引入解释性变量
你有一个复杂的表达式。
将该复杂表达式(或其中一部分)的结果放进一个临时变量(final修饰)，以此变量的名称来解释表达式用途。

在条件逻辑中，特别有价值，可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。
另一种情况是，在较长的算法中，运用临时变量来解释每一步的意义。

并不常用，尽量使用Extract Method来解释一段代码的意义。毕竟临时变量只有在它所处的那个函数中才有意义，局限性较大，函数则可以在对象的整个生命周期中有用，并可以被其他对象使用。。当ExtractMethod难以进行(。有大量的临时变量。)的时候，使用Introduce Explaining Variable。


152
6.6 Split Temporary Variable 分解临时变量
某个临时变量被赋值超过一次(它既不是循环变量，也不被用于收集计算结果)
针对每次赋值，创建一个独立的临时变量
。。主要是名字。

变量声明为final，出现第二次赋值时，修改final到第二次赋值间的所有名字。


6.7 Remove Assignments to Parameters 移除对参数的赋值
代码对一个参数(。指形参)进行赋值
以一个临时变量取代该参数的位置。
。。等于就是上面的，一个(临时？)变量被赋值2次。
。。竟然可以在形参上加final。。。。jdk1.1就开始了。


6.8 Replace Method with Method Object 以函数对象取代函数
有一个大型函数，其中对局部变量的使用使得你无法采用Extract Method。
将这个函数放入一个单独对象中，如此一来局部变量就成了类属性，然后可以在这个类中将这个大型函数分解为多个小型函数。


6.9 Substitute Algorithm 替换算法
。。就是把算法方法直接替换。。最好先把算法提炼出来，这样能更好地确定算法边界。



165
chapter 7 在对象之间搬移特性

在对象的设计过程中，"决定把责任放在哪儿"是最重要的事情之一。

运用重构，改变自己原先的设计。

通常只需要Move Method，Move Field简单地移动对象行为，就能解决。如果这2个重构手法都要用到，那么先MoveField，在MoveMethod。

类会因为承担过多的责任而变得臃肿不堪，这种情况下，使用Extract Class将一部分责任分离出去。。如果一个类变得太"不负责任"，那么使用InlineClass将它融入到另一个类。如果一个类使用了另一个类，运用HideDelegate将这种关系隐藏起来通常来说是有帮助的。有时隐藏委托类会导致拥有者的接口经常变化，此时需要使用Remove Middle Man。

IntruduceForeignMethod和IntroduceLocalExetension比较特殊，只有当我们不能访问某个类的源码，却又想把其他责任移进这个不可修改的类时，才会使用这2个重构手法。。如果加入的函数只是1，2个，那么使用IntroduceForeignMethod，多个则IntroduceLocalExtension。


7.1 Move Method 移动函数
有个函数与其所在的类之外的另一个类进行更多的交流：调用后者，或被后者调用。
在该函数最常引用的类中建立一个有着类似行为的新函数，将旧函数编程一个单纯的委托函数，或是将旧函数完全移除。

"搬移函数"是重构理论的重要基础。如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就需要搬移函数，使类更简单。

如果搬移后，函数需要源类的多个特性，那么就把源对象传递过去。不过如果需要太多源类特性，就需要进一步重构。这种情况下，可以分解搬移后的函数，并把其中一部分移回源类。


7.2 Move Field 搬移字段
程序中，某个类属性被其所在类之外的另一个类更多地用到。
在目标类新建一个属性，修改源属性的所有用户，令它们使用新建的属性。
。。可以直接改(就是调用者直接改成新类.get属性)，也可以暴露getter/setter，修改内部(调用者依然是旧类.get属性，只不过get方法里委托给了新类)。


7.3 Extract Class 提炼类
某个类做了应该由2个类做的事
建立一个新类，将相关的字段和函数从旧类中搬移到新类。

如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此依赖，这就表示应该把它们分出去。一个有用的测试是问自己：如果搬移了某些字段和函数，会发生什么？其他字段或函数是否会因此无效？

另一个往往在后期出现的信号时类的子类化方式。如果你发现子类化只影响类的部分特性，或如果你发现某些特性需要以一种方式来子类化，某些特性则需要以另一种方式子类化，这就意味着你需要分解原来的类。。(就是利用重写来覆盖父类的方法，这样一个接口就有多种实现，根据需要选择。)

ExtractClass是改善并发的一种常用技术，因为它使得你可以为提炼后的2个类分别加锁。。。不过也很危险。


7.4 Inline Class 将类内联化
某个类没有做太多事情
将这个类的所有特性搬移到另一个类中，然后移除源类。

将类放到使用它最频繁的另一个类中。

一种是委托给其他类。旧类.getxx，然后getxx中调用了新类.getxx
一种是直接修改调用者。新类.getxx
。。不是，前一个没用的。。只有后者，把代码移到大类后，将小类private，所有调用者全部调用大类。然后删除小类。


7.5 Hide Delegate 隐藏委托关系
客户通过一个委托类来调用林一个对象。
在服务类上建立客户所需要的所有函数，用以隐藏委托关系。
。。就是链式调用。。当委托关系改变时，需要客户端修改代码。。如果链式调用发生在服务端方法的内部，那么客户端不需要做什么。


7.6 Remove Middle Man 移除中间人
某个类做了过多的简单委托动作。
让客户直接调用受托类。

在上面的HideDelegate中，谈了"封装受托对象"的好处，但这层封装也是要付出代价：每当客户要使用受托类的新特性时，就必须在服务端加一个简单委托函数。当受托类的功能越来越多，服务类完全变成了一个"中间人"，此时就应该让客户直接调用受托类。

很难说什么程度的隐藏才是合适的。还好，有了HideDelegate和Remove Middle Man，可以随着系统运行而不断进行调整。
。。变成了链式调用。并不是用受托类替代服务类。


7.7 Introduce Foreign Method 引入外加函数
需要为服务类增加一个函数，但你无法修改这个类。
在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。
例子是：需要一个Date自增一天的功能。Date无法修改。所以就变成了：
private static Date nextDay(Date arg) {
	return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1)
}
。。等于一个工具类，提供扩展功能，Collections。
。。下面也说了，增加的方法多的话，就用Intoduce Local Extension
。。所以这里是，内置工具类方法，因为用到的地方很少，不值得抽取成util。
。。下面也不是util类，是子类或包装类。。。。util似乎毫无意义。。final类就包装。。

如果为一个服务类建立了大量外加函数，或发现许多类都需要同样的外加函数，就不能使用本项重构，而是使用Introduce Local Extension

外加函数终究是权宜之计，如果有可能，还是应该把这些函数搬移到它们的理想家园。
。。直接覆盖class文件？


7.8 Introduce Local Extension 引入本地扩展
你需要为服务类提供一些额外函数，但你无法修改这个类。
建立一个新类，使它包含这些额外函数。让这个新类成为源类的子类或包装类。
在任何可以使用源类的地方，都可以使用本地扩展类。

在扩展类中加入转型构造函数。转型构造函数是指"接受原对象作为参数"的构造函数。如果是子类化，那么转型构造函数应该调用适当的超类构造函数；如果是包装类，那么转型构造函数应该将它得到的传入参数以实例变量的形式保存起来，用来作为接受委托的原对象。

equals方法，需要变成equalsDate。
只能扩展类兼容源类，源类对象无法兼容扩展类。


193
chapter 8 重新组织数据

有人或许认为Self Encapsulate Field有点多余，但是关于"对象应该直接访问其中的数据，还是应该通过访问函数来访问"这一问题的争论从未停止。

面向对象语言有一个很有用的特征：除了允许使用传统语言提供的简单数据类型，它们还允许你定义新类型。。一开始你使用一个简单数值来表示某个概念，但随着对系统的深入了解，你可能明白，以对象表示这个概念，可能更合适。Replace Value with Object让你将"哑"数据变成善表达的对象。如果你发现程序中有太多的地方需要这一类对象，也可以使用Change Value to Reference将它们变成引用对象。

如果你看到一个数组的行为方式很像一个数据结构，就可以使用ReplaceArray with Object把数组变成对象，从而使这个数据结构更清晰地显露出来。这是第一步，当你使用MoveMethod为这个新类添加相应行为时，真正的好处才得以体现。

魔法数---即带有特殊含义的数字，从来都是个问题。。弄清魔法数的用途，使用Replace Magic Number with Symbolic Constant将它们除掉。

对象之间的关系可以是双向，也可以是单向。单向关联比较简单，但有时为了支持一项新功能，你需要使用ChangeUndirectionalAssociationToBidirectional将它变成双向。ChangeBidirectionalAssociationToUndirectional则相反：如果你发现不再需要双向关联，可以使用这项重构将它变成单向关联。

会遇到这样的情况：GUI类竟然去处理不该它们处理的业务逻辑。为了把这些处理业务逻辑的行为移到合适的领域类中，需要在领域类中保存这些逻辑的相关数据，并运用Duplicate Observed Data提供对GUI的支持。一般来说，我不喜欢重复的数据，但这里是一个例外，因为这里的重复数据通常是不可避免的。

面向对象变成关键原则之一是封装。如果一个类公开了任何public数据，你就应该使用Encapsulate Field将它包装起来。如果被公开的数据是集合，就使用Encapsulate Collection，因为集合有其特殊协议。。如果一整条记录都被暴露在外，那么使用Replace Record with Data Class。

需要特别对待的一种数据是类型码。如果这些类型码用来表现某种信息，且不会改变所属类型的行为，可以使用ReplaceTypeCodeWithClass将它们替换掉。
如果当前类型的行为受到类型码的影响，你就应该尽可能使用ReplaceTypeCodeWithSubclasses，如果做不到，就只能使用更复杂(也是更灵活)的ReplaceTypeCodeWithState/Strategy。


8.1 Self Encapsulate Field 自封装字段
你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。
为这个字段建立getter/setter，只通过这些函数来访问字段。

"字段访问方式"这个问题上，存在2种截然不同的观点：
1：在该变量定义所在的类中，你可以自由访问它。
2：即使在这个类中，你也应该通过访问函数间接访问。

间接访问变量的好处：子类可以通过重写来改变获取数据的途径，还支持更灵活的数据管理方式，如延迟初始化。

直接访问的好处：代码阅读比较容易。不必确认getter中是否有业务逻辑。


8.2 Replace Data Value with Object 以对象取代数据值
你有一个数据项，需要与其他数据和行为一起使用才有意义。
将数据项变成对象。

开发初期，决定以简单的数据项表示简单情况，随着开发深入，这些简单数据项不再那么简单。

为待替换数值新建一个类，其中声明一个final字段，类型和源类中的待替换数值类型一致。getter，构造器(待替换数值)
修改源类中的getter，让它return 新类.getter。。。源类setter也改。


8.3 Change Value to Reference 将值对象改为引用对象
你从一个类衍生出许多彼此相等的实例，希望把它们都替换为同一个对象。
将这个值对象变成引用对象。

。。是单例模式。

1. 使用Replace Constructor with Factory Method
2. 决定由什么对象负责提供访问新对象的途径
3. 决定这些引用对象应该预先创建好，还是动态创建。
4. 修改工程函数，令它返回引用对象。

。。有点6.预先创建
class Customer
	static void loadCustomers() {
		new Customer("AA CC").store();
		new Customer("VV QQ").store();
		...
	}
	private void store() {
		_instance.put(this.getName(), this);
	}

。。工厂模式是没有hashMap缓存的，所以需要修改成使用HashMap缓存实例。


8.4 Change Reference to Value 将引用对象改为值对象
有一个引用对象，很小且不可变，也不易管理。
将它变成一个值对象。

如果引用对象开始变得难以使用，也许就应该将它改为值对象。引用对象必须被某种方式控制，你总是必须向其控制者请求适当的引用对象。它们可能造成内存区域间错杂的关系。。在分布式，并发系统中，不可变对象特别有用，因为无需考虑它们的同步问题。

值对象有一个非常重要的特性：它们应该是不可变的。如果保证了这一点，就可以放心地以多个对象表示同一个事物。如果值对象是可变的，你就必须确保对某一对象的修改会自动更新其他"代表相同事物"的对象，这非常痛苦，不如引用对象。

不可变是指：当属性改变时，需要使用一个新对象代替源对象，而不是在源对象上修改。

检查重构目标是否是不可变对象，或是否可以修改为不可变对象(删除setter，这里的对象是指小且不可变的那个对象)。
equals，hashCode
删除工厂方法，public构造器


8.5 Replace Array with Object 以对象代替数组
你有一个数组，其中的元素各自代表不同的东西。
以对象替换数组。对于数组中的每个元素，以一个字段来表示。

数组应该只用于"以某种顺序容纳一组相似对象"。
当含有不同对象时，很难记住诸如"第一个元素是人名"这样的约定。

。。应该是有一个数组，其中的元素保存了有关联的，但不相同的东西。。就是数组表达了一个对象。。不然直接替换，类中的属性如果没有关联关系的话，类也没什么意义，不如直接拆散，一个数组元素一个类。。或者一个数组元素一个临时变量。


8.6 Duplicate Observed Data 复制"被监视数据"
有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据。
将该数据复制到一个领域对象中。建立Observer模式，用以同步领域对象和GUI对象内的重复数据。

java.util.Observale
java.util.Observer


8.7 Change Unidirectional Association to Bidirectional 将单向关联改为双向关联
2个类都需要使用对方的特性，但其间只有一条单向连接。
添加一个反向指针，并使修改函数能够同时更新2条连接。

本重构要求测试访问函数，所以它是极少数需要添加测试的重构手法之一。
1. 在被应用类中增加一个字段，用以保存反向指针。
2. 决定由哪个类---引用端还是被引用端---控制关联关系。
3. 在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途。
4. 如果既有的修改函数在控制端，让它负责更新反向指针。
5. 如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数。

。。修改关联关系。
例子：
Order有Customer引用，反之没有。
为Customer添加一个字段，Set<Order>.
选择由单个类来控制(即Order控制)。
由于Order负责控制关联关系，所以必须为Customer添加一个辅助函数，让Order可以访问Customer中的Set<Order>。Order使用这个函数来对指针2端对象进行同步控制。辅助函数命名为friendOrders，表明这个函数只在这种特殊情况下使用。如果Order和Customer处于同一个包，那么friendOrders的可见性声明为default，降低可见程度。

class Order
	void setCustomer(Customer arg) {
		if(_customer != null)
			_customer.frindOrders().remove(this);
		_customer = arg;
		if (_customer != null)
			_customer.friendOrders().add(this);
	}
.....coooooooool

如果你希望在Customer也能修改连接，就让它调用控制函数：
class Customer
	void addOrder(Order order) {
		arg.setCustomer(this);
	}

如果Order，Cusomter是多对多的关系：
class Order
	void addCustomer(Customer arg) {
		arg.friendOrders().add(this);
		_customers.add(arg);
	}
	void removeCustomer(Customer arg) {
		arg.friendOrders().remove(this);
		_customers.remove(arg);
	}

class Customer
	void addOrder(Order arg) {
		arg.addCustomer(this);
	}
	void removeOrder(Order arg) {
		arg.removeCustomer(this);
	}


8.8 CHange Bidirectional Association to Unidirectional 将双向关联改为单向关联
2个类之间有双向关系，但其中一个类如今不再需要另一个类的特性。

双向关联很有用，但你也必须为它付出代价，那就是维护双向连接，确保对象被正确创建和删除而增加的复杂度。而且，由于很多程序员并不习惯使用双向关联，所以它往往成为错误志愿。
大量的双向连接也很容易造成"僵尸对象"：某个对象本来已经该死亡率，却仍然保留在系统中，因为对它的引用还没有完全消除。
双向关联也迫使两个类之间有了依赖。对其中任一类的任何修改，都可能引发另一个类的变化。如果这2个类位于不同的包，这种依赖就是包与包之间的依赖，过多的跨包依赖会造成系统的紧耦合，使得任何一点小小改动都可能再创许多无法预知的后果。

1. 找出保存"你想取出的指针"的字段，检查它的每个用户，判断是否可以去除该指针：
不但要检查直接访问点，也要检查调用这些直接访问点的函数。
考虑有无可能不通过指针取得被引用对象，如果有可能，你就可以对取值函数使用Substitute Algorithm，从而让客户在没有指针的情况下也可以使用该取值函数。
对于使用该字段的所有函数，考虑将被引用对象作为参数传递进去。

2. 如果客户使用了取值函数，先运用SelfEncapsulateField将待删除字段自我封装起来，然后使用SubstituteAlgorithm对付取值函数，令它不再使用该字段，然后编译，测试。

3. 如果客户未使用取值函数，那就直接修改待删除字段的所有被引用点，改以其他途径获得该字段所保存的对象。每次修改后，编译并测试。

4. 如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段。
如果有许多地方对此字段赋值，先运用SelfEncapsulateField使这些地点改用同一个设值函数，编译，测试，然后将这个设值函数的本体清空。在编译，再测试。如果这些都可行，就可以将此字段和其设值函数，连同对设值函数的所有调用，全部移除。

对于本项重构来说，最难的就是可行性检查。

首先，我们要研究所有读取这个字段的函数和所有使用这些函数的函数，我们能找到另一条途径来提供Customer对象吗？----这通常意味着将Customer对象作为参数传递。下面是一个简化的例子：
class Order
	double getDiscountPrice() {
		return getGrossPrice() * (1 - _customer.getDiscount());
	}
改为：
	double getDiscountPrice(Cusomter c) {
		return getGrossPrice() * (1 - c.getDiscount());
	}

如果待改函数是通过customer调用的，那么这样的修改方案就特别容易实施：
class Customer
	double getPriceFor(Order order) {
		Assert.isTrue(_orders.contains(order));
		return order.getDiscountdPrice();
	}
改成
	double getPriceFor(Order order) {
		Assert.isTrue(_order.contains(order));
		return order.getDiscountPrice(this);
	}

另一种修改方法就是修改取值函数，在其不使用_customer字段的前提下返回一个Customer对象。如果这可行，就是要SubstituteAlgorithm修改Order.getCustomer()函数算法：
Customer getCustomer() {
	Iterator iter = Customter.getInstances().iterator();
	while (iter.hasNext()) {
		Customter each = (Customter) iter.next();
		if (each.containsOrder(this))
			return each;
	}
	return null;
}
比较慢，但可行。
而且在数据库环境下，如果使用sql查询，对系统性能的影响并不显著。


8.9 Replace Magic Number with Symbolic Constant 以字面常量取代魔法数
你有一个字面数值，带有特别含义。
创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。

static final double XXXXX = 2.3;

魔法数是指拥有特殊含义，却不能明确表示出这种意义的数字。

常量不会造成任何性能开销，却可以大大提高代码可读性。

在本项重构前，你应该先寻找其他方案。应该观察魔法数如何被使用，而后往往会发现一种更好的使用方式。如果这个魔法数是一个类型码，使用ReplaceTypeCodeWithClass。


8.10 Encapsulate Field 封装字段
类中存在一个public字段
将它声明为private，并提供相应的访问函数。

面向对象的首要原则之一就是封装，或者称为"数据隐藏"

Encapsulate Field是封装的第一步。通过这项重构手法，可以将数据隐藏起来，并提供相应的访问函数。
这终究是第一步。如果一个类除了访问函数外不提供其他行为，它终究只是一个哑巴类。这样的类并不能享受对象技术带来的好处。浪费任何一个对象都是很不好的。。实施EncapsulateField之后，我们会尝试寻找用到新建访问函数的代码，看看是否可以通过简单的MoveMethod将它们移到新对象上去。


8.11 Encapsulate Collection 封装集合
有个函数返回一个集合
让这个函数返回该集合的一个只读副本，并在这个类中提供add/remove集合元素的函数。

集合可能被用户修改，而拥有者却毫不知情。
集合被很好地封装，可以降低集合拥有者和用户之间的耦合度。


删除setXXX(Set set)..这种，因为set会被用户修改。这个方法名称应该改为initializeXXX。并且里面判断类的set是否为空，为空才添加形参的set。
getSet返回unmodifiableSet。增加add，remnove方法。

接口调整合理后，观察调用取值函数的用户。从中找出应该属于类的代码，并搬移。
。。就是外部调用getSet后，可能对set进行累加，计算某种类型的个数或者直接size()。等。这些操作都应该属于包含set的那个类的方法。而不是外部代码。。

数组也可以这样，只不过有点烦，特别是对整个数组赋值时，(因为数组长度的问题，可能需要重新new一个数组)。。。
setAAAAA(int index, Stirng value);
一般用List代替数组。


8.12 Replace Record with Data Class 以数据类代替记录
需要面对传统编程环境中的记录结构。
为该记录创建一个"哑"数据对象。

记录型结构是许多编程环境的共同性质。有一些理由使它们被带进面向对象程序之中：你可能面对的是一个遗留程序，也可能要通过一个传统api来与记录结构交流，或是处理从数据库读出的记录。
这些时候，就有必要建立一个接口类，用来处理这些外来数据。
最简单的做法就是建立一个看起来类似外部记录的类，以便以后将某些字段和函数搬移到这个类中。
一种不太常见但非常令人注目的情况是：数组中的每个位置上的元素都有特定含义，这种情况下，应该是一ReplaceArrayWithObject。

。。。。？？？没遇到过。。

1. 新建一个类，表示这个记录
2. 对于记录中的每一项数据，在新建类中建立一个private字段+setter/getter

你现在拥有了一个"哑"数据对象，这个对象现在还没有任何有用的行为，但更进一步的重构会解决这个问题。


242
8.13 Replace Type Code with Class 以类型取代类型码
类中有一个数值类型码，当它并不影响类的行为。
以一个新的类替换该数值类型码。

C中，类型码，枚举值很常见。如果带着一个有意义的符号名，类型码的可读性还是不错的。问题在于，符号名终究只是个别名，编译器看见的，进行类型校验的，还是背后那个数值。任何接受类型码作为参数的函数，所期望的实际上是一个数值，无法强制使用符号名。这会大大降低可读性。

如果把那样的数值换成一个类，编译器就可以对这个类进行类型检验。只要为这个类提供工厂函数，你就可以始终抱着只有合法的实例才会被创建，而且它们会被传递给正确的宿主对象。

在使用本方法之前，应该先考虑类型码的其他替换方式，只有当类型码是纯粹数据时(即不会在switch语句中引起行为变化)，你才能用类来取代它。Java不能用类对象作为switch语句的判断依据，所以这种情况下，无法使用类来替代类型码。
更重要的是，任何switch语句都应该运用ReplaceConditionalWithPolymorphism来去掉。为了进行那样的重构，必须先使用ReplaceTypeCodeWithSubclass或ReplaceTypeCodeWithState/Strategy，把类型码处理掉。

宿主中的某些行为有可能更适合放置在类型码类中。

原本Person中一个int代表血型
class BloodGroup
{
	public static final BloodGroup O = new BloodGroup(0);
	private final int _code
	//.... A ...1   B...2 ...AB...3
	- static final BloodGroup[] _values = {O,A,B,AB;
	// private BloodGroup(int code)
	// + int getCode() { return _code}
	// + static BloodGroup code(int arg) {return _values[arg]}
}
Person中所有血型的代码移除，操作放到血型类中。
最后2个+可以变成private，因为不会有人再用了。因为这2个是使用int的，后期不再使用了，


8.14
Replace Type Code with Subclasses 以子类型取代类型码
有一个不可变的类型码，它会影响到类的行为
以子类型取代这个类型码。

上面的重构方法是针对类型码不会影响宿主类行为。
如果会影响，最好的办法是借助多态来处理变化行为。

一般来说，这种情况的标志就是像switch这样的条件表达式。这种条件表达式有2种表现形式：switch或if-else结构。它们都检查类型码值，并根据不同的值执行不同的动作。此时，应该是一ReplaceConditionalWithPolymorphism进行重构。为了能顺利进行那样的重构，首先应该把类型码替换为拥有多态行为的继承体系。这样的一个继承体系应该以类型码的宿主类为基类，并针对每个类型码各自建立一个子类。
。。。。？？？我记得有个是type变成一个全新的继承体系，而不是宿主类为基类。。那个是state/strategy

建立这样的继承体系，最简单的就是本重构方法：以类型码的宿主类为基类，针对每种类型码建立相应子类。

但以下2种情况，你不能这样做：
1.类型码值在对象创建之后发生了变化
2.由于某些原因，类型码宿主类已经有了子类。
这2种情况下，使用ReplaceTypeCodeWithState/Strategy

ReplaceTypeCodeWithSubclasses的主要作用是搭建一个舞台，让ReplaceConditionalWithPolymorphism得以一展身手。
如果宿主类中没有出现条件表达式，那么ReplaceTypeCodeWithClass更合适，风险也较低。

使用本重构方法的另一个原因是：宿主类中出现了"只与具备特定类型码的对象相关"的特性。完成本重构后，可以使用PushDownMethod或PushDownField将这些特性推到合适的子类去，以彰显它们只与特定情况有关这一事实。

本重构的好处在于：它把"对不同行为的了解"从类用户那里转移到了类自身。如果需要加入新的行为变化，添加一个子类即可。如果没有多态机制，就必须找到所有条件表达式，并逐一修改它们。因此，如果未来还有可能加入新行为，这项重构将特别有价值。

1. 使用SelfEncapsulateField将类型码自我封装起来。
如果类型码被传递给构造函数，那么需要把构造函数变成工厂函数。(根据类型码返回相应的子类实例，工厂类可以使用switch，也只有这里会使用switch)
2. 为类型码的每个数值建立一个对应的子类，每个子类重写类型码的取值函数，使其返回相应的类型码值。
3. 每建立一个新子类，编译并测试。
4. 从超类中删除保存类型码的字段，将类型码访问函数声明为抽象函数。
5. 编译测试。


8.15 Replace Type Code with State/Strategy
有一个类型码，影响类的行为，但无法通过继承手法消除它。
以状态对象取代类型码。

和上面的subclass类似，但如果"类型码的值在对象生命周期中发生变化"或"其他原因使得宿主类不能被继承"，依然可以使用本重构。本重构使用State模式或Strategy模式。
这2个模式非常相似，因此无论选择哪个，重构过程都是相同的。
如果打算完成本重构后再使用ReplaceConditionalWithPolymorphism简化一个算法，那么选择Strategy比较合适。
如果打算搬移与状态相关的数据，而且你把新建对象视为一种变迁状态，就应该选择使用State模式。

1.SelfEncapsulateField封装类型码
2.新建一个类，根据类型码的用途为它命名。这就是一个状态对象。
3.为这个新类添加子类，每个子类对于一种类型码。
比起逐一添加，一次性加入所有必要的子类可能更简单些。
4.超类中建立一个抽象的查询函数，用以返回类型码。每个子类重写该函数。
5.编译
6.在源类中建立一个字段，保存新建的状态对象。
7.调整源类中负责查询类型码的函数，将查询动作转发给状态对象。
8.调整源类中为类型码设值的函数，将一个恰当的状态对象子类赋值给保存状态对象的那个属性
9.编译测试

工厂方法中switch。

新建类中保存static final int type1 = 0;...等。用于switch。


8.16 Replace Subclass with Fields
你的各个子类的唯一差别只在"返回常量数据"的函数身上。
移动这些函数，使它们返回超类中某个(新增)字段，然后销毁子类。

对所有子类使用ReplaceConstructorWithFactoryMethod
如果有任何代码直接引用子类，令它改而引用超类
针对每个常量函数，在超类中声明一个final字段
为超类声明一个protected构造函数，用以初始化这些新增字段
新建或修改子类构造函数，使它们调用超类的新增构造函数
编译，测试
在超类中实现所有常量函数，令它们返回相应字段值，然后将该函数从子类中删掉。
每删除一个常量函数，编译测试
子类中所有常量函数都被删除后，使用InlineMethod将子类构造函数内联到超类的工厂函数中。
编译测试
删除子类
编译测试
重复"内联构造函数，删除子类"，直到所有子类都被删除。


chapter 9 简化条件表达式
条件逻辑可能非常复杂，本章提供一些重构手法来简化它们。
核心重构是DecomposeConditional，可以将一个复杂条件逻辑分成若干个小块。这项重构非常重要，因为它使得"分支逻辑"与"操作细节"分离。

如果代码中的多处测试有相同结果，使用ConsolidateConditionalExpression
代码中有任何重复，使用ConsolidateDuplicateConditionalFragments
switch，ReplaceConditionalWithPolymorphism
多态还有一种有用但鲜为人知的用途：IntroduceNullObject去除对于null值的检验。


9.1 Decompose Conditional 分解条件表达式
有一个复杂的条件语句(if-else)
从if，else中提炼出独立函数

if(date.before(SUMMER_START) || date.after(SUMMER_END))
	charge = quantity * _winterRate + _winterServiceCharge;
else
	charge = quantity * _summerRate;

if (notSummer(date))
	charge = winterCharge(quantity);
else
	charge = summberCharge(quantity);

复杂的条件逻辑是最常导致复杂度上升的地点之一。

将每个分支条件分解成心函数：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。

如果有嵌套的条件逻辑，先观察是否可以ReplaceNestedConditionalWithGuardClauses。如果不行，才开始分解其中的每个条件。

通过函数名来描述条件，notSummer比after，before易懂111111倍。


9.2 Consolidate Conditional Expression 合并条件表达式
有一系列条件测试，都得到相同结果。
将这些测试合并为一个表达式，并将这个条件表达式提炼为一个独立函数

double disabilityAmount() {
	if (_seniority < 2) return 0;
	if (_monthsDisabled > 12) return 0;
	if (_isPartTime) return 0;
	// compute amount
}

double disabilityAmount() {
	if (isNotEligableForDisability()) return 0;
	// compute amount
}

检查条件各不相同，最终行为却一致。此时应该使用逻辑与，逻辑或将它们合并成一个条件表达式。

合并条件代码，有2个原因：
1. 合并后的条件代码会告诉你：实际上只有一次条件检查，只不过有多个并列条件需要检查而已。
2. 这项重构为ExtractMethod做好准备。

如果这些检查确实彼此独立，那么就不应该视为同一次检查，就不要使用本重构。

如果条件表达式有副作用，就不能使用本重构。

可以使用三元操作符。


9.3 Consolidate Duplicate Conditional Fragments 合并重复的条件片段
在条件表达式的每个分支上有相同的一段代码
将这段重复代码搬移到条件表达式之外。

if (isSpecialDeal()) {
	total = price * 0.95;
	send();
} else {
	total = price * 0.98;
	send();
}

if (isSpecialDeal())
	total = price * 0.95;
else
	total = price * 0.98;
send();

更清晰地表明哪些东西随条件变化而变化，哪些的东西保持不变。

如果共通代码位于代码块的起始处，那么就移到条件表达式之前。
位于代码块的尾端，移到条件表达式之后。
中段，先移动到代码块的起始处或尾端，再提取出来。
共通代码不止一条，先使用ExtractMethod提炼到一个独立函数，再移动到前面或后面。

也可以用于try，如果try中可能引发异常的语句之后，及所有的catch中，都重复了一段代码，可以移到final中。


9.4 Remove Control Flag 移除控制标记
在一系列布尔表达式中，某个变量带有"控制标记"的作用
以break，continue，return取代控制标记
。。就是循环控制是使用flag作为标记是否继续循环。


9.5 Replace Nested Conditional with Guard Clauses 以卫语句取代嵌套条件表达式
函数中的条件逻辑使人难以看清正常的执行路径
使用卫语句表现所有特殊情况

double getPayAmount()
{
	double result;
	if (_isDead) result = deadAmount();
	else
	{
		if (_isSeprated) result = separatedAmount();
		else
		{
			if (_isRetired) result = retiredAmount();
			else result = normalPayAmount();
		}
	}
	return result;
}

double getPayAmount()
{
	if (_isDead) return deadAmount();
	if (_isSeparated) return separatedAmount();
	if (_isRetired) return retiredAmount();
	return normalAmount();
}

条件表达式通常有2种表现形式：
1.所有分支都属于正常行为。
2.条件表达式所提供的答案中只有一种是正常行为，其他都是不常见的情况。

这2类都不同的用途，应该通过代码表现出来。
如果2条分支都是正常行为，就应该用if。。else。。
如果某个分支极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为"卫语句"。

本重构的精髓就是：给某一条分支以特别的重视，如果使用if。。else。结构，对if和else分支的重视是同等的，这样的代码结构传递给阅读者的消息就是：各个分支有同样的重要性。
卫语句就不同，它告诉读者，这种情况很罕见，如果它真的发生了，请做一些必要的整理工作，然后退出。

。。就是最终return的是常见的行为，罕见的行为已经在之前return了。

条件反转
就是原来<的，改成>=然后直接退出。


9.6 Replace Conditional with Polymorphism 以多态取代条件表达式
手上有个条件表达式，根据对象类型的不同而选择不同的行为。
将这个条件表达式的每个分支放进一个子类内的重写函数中，然后将原始函数声明为抽象函数。

多态最根本的好处就是：如果你需要根据对象的不同类型而采取不同的行为，多态使你不必编写明显的条件表达式。

正因为有了多态，所以会发现："类型码的switch语句","基于类型名称的if。else语句"在面向对象中很少出现。

如果同一组条件表达式在多个地方出现，那么使用多态的收益是最大的。使用条件表达式时，如果你想添加一种新类型，就必须找到并更新所有条件表达式。如果使用多态，只需要新建一个子类，并提供适当的函数就可以了。类的用户不需要了解这个子类，降低了系统各部分间的依赖，使系统升级更容易。

使用本重构前，必须有一个继承结构。
建立继承结构，有2种选择：ReplaceTypeCodeWithSubclasses和ReplaceTypeCodeWithState/Strategy。前一种简单，所以应该尽可能使用它。如果类型码会发生变化，或已经有子类，那么只能使用State/Strategy。

如果若干个switch语句针对的是同一个类型码，你只需要针对这个类型码建立一个继承结构就可以了。

如果条件表达式是一个大函数的一部分，那么就先ExtractMethod提取到一个独立的函数中。如果有必要，使用MoveMethod将条件表达式放置到继承结构的顶端。


9.7 Introduce Null Object 引入Null对象
你需要再三检查某对象是否为null
将null值替换为null对象。

1.为源类建立一个子类，使其行为就像是源类的null版本。在源类和null子类中都加上isNull函数，前面的返回false，后者的返回true。
一个办法：建立一个nullable接口，isNull是方法，让源类实现这个接口。
另外，也可以创建一个测试接口，专门用来检查对象是否是null。

2.编译
3.找到所有"索求源对象却得到一个null"的地方，修改这些地方，使它们改而获得一个空对象。(就是返回null的地方返回子类对象)
4.找到所有"将源对象与null做比较"的地方，修改这些地方，使它们调用isNull函数。
5.编译测试
6.找出这样的程序点：如果对象不是null，做A动作，否则做B动作
7.对于每一个上述地点，在null类中重写A动作，使其行为和B动作相同。
。。？应该是null类中直接做B动作吧。
8.删除"对象是否等于null"的条件测试。编译测试

可以有多种不同的空对象。"没有顾客"，"佚名顾客"。这是一个比NullObject模式更大的模式：SpecialCase模式。


9.8 Introduce Assertion 引入断言
某一段代码需要对程序状态做出某种假设。
以断言明确表现这种假设。

断言是一个条件表达式，应该总是真，如果失败，表示程序员犯了错误。因此断言的失败应该导致一个非受控异常。
断言绝对不能被系统的其他部分使用。实际上，最后的成品往往会删除所有断言。因此，标记"某个东西是断言"是很重要的。
。。所以使用Assert，如果if的话，后期可能不知道当初这个if是断言还是正常程序的一部分。

不要滥用断言，不要用来检查"你认为应该为真"的条件，而是只检查"一定必须为真"的条件。滥用断言可能会导致难以维护的重复逻辑。
在一段逻辑中加入断言是有好处的，因为它迫使你重新考虑这段代码的约束条件。如果不满足这些约束条件，程序也可以正常运行，断言就不会给你任何帮助，反而会使代码变得混乱，并妨碍之后的修改。

如果断言指示的越俗条件不满足时，代码仍能正常运行，那么删除断言。

使用ExtractMethod提取断言中的重复代码。

。。不过觉得，return 0， null， false，等也没问题啊。。使用if代替断言。。不，可能有时候走到这里就说明错了，连0都不是。

Assert除了isTrue外，还应该有equals，shouldNeverReachHere等函数。


295
chapter 10 简化函数调用

容易被理解和使用的接口，是开发良好面向对象软件的关键。本章介绍几个使接口变得更简洁易用的重构手法。
最简单也是最重要的就是修改函数名称。也可以在适当时机修改变量名称和类名称。

函数参数在接口中扮演十分重要的角色。AddParameter和RemoveParameter都是很常见的重构手法。
如果来自同一个对象的多个值被当作参数传递，你可以运用PreserverWholeObject将它们替换为单一对象，从而缩短参数列。
如果此前不存在这样一个对象，可以运用IntroduceParameterObject将它创建出来。
如果函数参数来自该函数可以获取的一个对象，使用ReplaceParameterWithMethod避免传递参数。
如果某些参数被用来在条件表达式中做选择一句，实施ReplactParameterWithExplicitMethod。
ParameterizeMethod为数个相似函数添加参数，将它们合并到一起。

DougLea。。。。可怕。。
关于缩减参数列的重构方法，DougLea提出了一个警告：并发编程往往需要较长的参数列，因为这样你可以保证传递给函数的参数都是不可被修改的，例如内置型对象和值对象一定是不可变的。通常，你可以使用不可变对象取代这样的长参数列，但另一方面，你也必须对此类重构保持谨慎。

一个很有价值的习惯：明确地将"修改对象状态"的方法和"查询对象状态"的方法分开设计。。如果修改函数和查询函数混在一起，使用SeparateQueryFromModifier将它们分开。

如果一个接口暴露了过多的细节，你可以将不必要保留的东西隐藏，以改进接口的质量。
所有数据都应该隐藏起来，同时所有可以隐藏的函数都应该被隐藏起来。重构是，往往需要暂时暴露某些东西，最后再以HideMethod和RemoveSettingMethod将它们隐藏起来。

构造函数是一个麻烦的东西，因为它迫使你必须知道要创建的对象属于哪个类，而你往往并不需要知道这一点。你可以使用ReplaceConstructorWithFactoryMethod避免了解这不必要的信息。

尽量使用EncapsulateDowncast将向下转型封装隐藏起起来，避免用户使用。

使用ReplaceErrorCodeWithException替换错误码。


10.1 Rename Method 函数改名
函数的名称未能揭示函数的用途。
修改函数名称。

如果方法被超类或子类实现过，那么需要：
新建一个函数，命名为你想要的名称。旧函数中的代码复制到新函数中。
修改就函数，令它将调用转发给新函数。
编译，测试。
找出旧函数的所有被引用点，修改它们，令它们改而引用新函数，每次修改后，编译测试。
删除旧函数。如果旧函数是接口的一部分，那么设置@Deprecated
编译测试


10.2 Add Parameter 添加参数
某个函数需要从调用端得到更多信息。
为此函数添加一个对象参数，让该对象携带所需信息进入函数。

除了添加参数外，你往往还有其他选择，只要可能，其他选择都比添加参数要好。因为它们不会增加参数列表的长度。

检查函数是否被超类或子类实现过。实现过的话，新建同名函数，增加参数，旧代码复制进去。让旧函数调用新函数。所有旧函数的调用点用新函数替代。删除旧函数或者deprecated。


10.3 Remove Parameter 移除参数
函数本体不再需要某个参数
将该参数移除

无论如何，多余的参数不会引起任何问题，而且以后还可能用上它。。这是错误的。。参数代表函数所需的信息，不同参数值有不同意义，函数调用者必须为每个参数考虑传递什么进去。如果不去除多余的参数，就是让每位用户多费一份心。

对于多态函数，则有所不同。可能多态函数的另一个实现使用了这个参数，此时你就不能去除它。你可以添加一个独立函数，在这些情况下使用，不过应该先检查调用者如何使用这个函数，以决定是否值得这么做。
如果某些调用者已经知道他们正在处理的是一个特点的子类，并且已经做了额外工作找出自己需要的参数，或者已经利用对类体系的了解来避免取到null，那么就值得你建立一个新函数，去除那多余的参数。如果调用者不需要了解该函数所属的类，你也可以继续保持调用者无知而幸福的状态。

检查是否被超类或子类实现过，如果实现过，那么声明一个同名新函数，去除不必要参数，复制旧函数的代码。编译。修改旧函数，让它调用新函数。编译，测试，旧函数所有被引用点都替换成对新函数的引用。编译测试，删除或Deprecated旧函数，编译，测试。


10.4 Separate Query from Modifier 将查询函数和修改函数分离
某个函数即返回对象状态值，又修改对象状态。
建立2个不同的函数，一个负责查询，一个负责修改。

如果一个函数只是提供一个值，没有任何看得到的副作用，那么这是个很有价值的东西。你可以任意调用这个函数，也可以把调用动作搬到函数的其他地方。
明确表现出"有副作用"和"无副作用"两种函数之间的差异，是个很好的想法。下面是一条好规则：
任何有返回值的函数，都不应该有看得到的副作用。

"看得到的副作用"。这是因为有一种优化：将查询结果缓存于某个字段中，这么一来后续的重复查询就可以大大加快速度。虽然这种做法改变了对象的状态，但这一修改是察觉不到的，因为不论如何查询，你总是获得相同的结果。

新建查询函数，令它返回和原函数系统的结果。
修改原函数，令它调用查询函数，并返回查询函数的结果。
编译测试
将调用原函数的代码改为调用查询函数，并且在前面一行增加对原函数的调用。编译测试。。。就是原函数变成 原函数+查询函数。。由于原函数是void，所以原先接收返回值的变量现在接收查询函数的结果。
将原函数返回值改为void，并删除return


在并发系统中，将查询和修改分开仍然很有价值，但你需要第3个方法来同时做这件事。这个"查询-修改"函数将调用各自独立的查询函数和修改函数，比被声明为synchronized。如果查询函数，修改函数不是synchronized，那么应该把这2个方法的可见性限制在包或private级别。。这样，就拥有了一个安全，同步的操作，它由2个较易理解的函数组成。这2个较低层的函数也可以用于其他场合。


10.5 Parameterize Method 令函数携带参数
若干函数做了类似的工作，但在函数本体中却包含了不同的值。
建立单一函数，以参数表达那些不同的值。

例子：
fivePercentRaise，tenPercentRaise。改成raise(percentage)

。。差不多也是：addOne(date).addTwo(date).变成add(date, days)

几个函数，做着类似的工作，但因为少数几个值导致行为略有不同。这种情况下，可以将这些各自分离的函数统一起来，并通过参数来处理那些变化情况。

有时，无法处理整个函数，但可以处理一部分，这种情况下，先把这部分代码提炼到独立函数，然后再使用本重构方法。
。。下面的例子有，函数中是个分段函数，每段只是系数不同。。把非系数部分提取成新方法，然后结果乘以系数。


10.6 Replace Parameter with Explicit Methods 以明确函数取代参数
有一个函数，其中完全取决于参数值的不同而采取不同行为。
针对该参数的每个可能值，建立一个独立函数。

void setValue(String name, int value) {
	if (name.equals("height")) {
		_height = value;
		return;
	}
	if (name.equals("width")) {
		_width = value;
		return;
	}
	Assert.shouldNeverReachHere();
}
变成setHeight，setWidth。。

如果参数值不会对函数行为有太多影响，就不应该使用本重构方法。
。。不过或许能抽取出来，然后再。。不行，变成2个函数后，原方法依然要判断选择哪个。。
。。所以是替换整个方法的。


10.7 Preserve Whole Object 保持对象完整
你从某个对象中取出若干值，将它们作为某一次函数调用时的参数
改为传递整个对象。

例子：
int low = daysTempRange().getLow();
int high = daysTempRange().getHigh();
withinPlan = plan.withinRange(low, high);
变成
withPlan = plan.withinRange(daysTempRange());

被调用方法可能需要新的数据项。
能提高代码可读性，过长的参数列很难使用。因为调用者和被调用者都必须记住这些参数的用途。
不使用完整对象会造成重复代码，因为被调用函数无法利用完整对象中的函数来计算某些中间值。。。不过应该还有low，high的重复吧。

如果你传递的是数值，被调用函数只依赖于这些数值，而不依赖于它们所属的对象。如果传入整个对象，被调用函数所在的对象就需要依赖参数对象。如果这会使你的依赖结构恶化，就不需要使用本重构。
。。还有，通用性应该也被降低了。

如果被调用函数使用了来自另一个对象的很多数据，那么意味着该函数实际上应该定义在另一个对象中。所以，本项重构前，先考虑MoveMethod。

本项重构前，可能还没有定义完整对象，那么就先使用IntroduceParameterObject。

还有一种常见情况：调用者将自己的若干数据作为参数，传递给被调用函数，这种情况下，如果该对象有合适的取值函数，你可以使用this取代这些参数值，并且无需关心对象依赖问题。

在被调用函数中增加一个形参，代表原数据所在的完整对象。
被调用函数中原来引用某参数的地方，改为调用新添加的参数对象的getter。


10.8 Replace Parameter with Methods 以函数取代参数
对象调用某个函数，并将所得结果作为参数，传递给另一个函数，而接受该参数的函数本身也能调用前一个函数。
让参数接受者取出该项参数，并直接调用前一个函数。

。。调用者和被调用者都能访问到某个数据，设计方法的时候，形参包含了这个数据，导致调用者需要提前访问，然后传递。。实际上这个数据完全可以在被调用者中自己获得。

如果函数可以通过其他途径获得参数值，那么它就不应该通过参数获得该值。这会导致形参过多，增加理解难度。


10.9 Introduce Parameter Object 引入参数对象
某些参数总是很自然地同时出现
以一个对象取代这些参数

价值在于缩短参数列。

把这些参数组织到一起之后，往往很快就能发现一些可以被移至新建类的行为。通常，原本使用这些参数的函数对这些参数会有一些通用的处理，如果将这些共通行为移动到新对象中，你可以减少很多重复代码。

建立不可变类(final属性，(final导致只有getter，没有setter)，靠构造器传入数据)

原先一组参数的地方，用new 新类(参数)代替。

ExtractMethod，MoveMethod。


10.10 Remove Setting Method 移除设值函数
类中某个字段应该在对象创建时被设置，然后就不再改变。
去掉该字段的所有setter。

如果有setter，就暗示这个属性可以被修改。
如果你保留了setter，就可能经常有人盲目地使用它们。这些人甚至会在构造函数中使用设置函数。我猜他们或许是为了代码的一致性，但却忽视了设置函数往后可能带来的混淆。
。。。test。。。什么混淆？？？
。。搜不到，只看到一个：构造器的行为受到setter的影响。
。。不过觉得这个是优点。。。
。。不，这里是不可变属性+setter，setter暗示可变。那么privateSetter呢？不过private，基本只有构造器会调用，那还不如删除setter，构造器里直接写逻辑。
。。在构造器中使用自定义的initialize方法，而不是setter。

1.检查设置函数被使用情况，看它是否只被构造函数调用，或被构造函数调用的另一个函数调用。
2.修改构造器，让它直接访问变量。
如果某个子类通过setter给超类的某个private属性设置值，那么你就不能这样修改。此时应该尝试在超类中提供一个protected函数(最好是构造函数)来给这些字段设值，不管怎么做，都不要给超类中的函数起一个与设值函数混淆的名字。
3.属性改为final


10.11 Hide Method 隐藏函数
有一个函数，从来没有被其他任何类用到
将这个函数修改为private

。。得使用工具，书上写的是lint。。不知道能不能注意到反射。反射有点难弄。保存在数据库中呢，或者说只要反射本类，就要确认究竟反射了哪个方法。


10.12 Replace Constructor with Factory Method 以工厂函数取代构造函数
你希望在创建对象时不仅仅是做简单的构建动作。
将构造器替换为工厂方法。

使用本重构最常见的动机是：就是在派生子类的过程中以工厂函数取代类型码。你可能常常需要根据类型码来创建对应的对象，现在，创建名单上还得加上子类，那些子类也是根据类型码来创建。然而由于构造器只能返回单一类型的对象，因此你需要将构造函数替换为工厂函数。


10.13 Encapsulate Downcast 封装向下转型
某个函数返回的对象，需要由函数调用者执行向下转型。
将向下转型动作移动到函数中。

java5加入模板方法之后，必须向下转型的场合几乎绝迹。如果需要向下转型，先考虑是否能以模板类代替。。。译者。
。。之前是List，保存的是Object，后来可以直接List<String>了。


10.14 Replace Error Code with Exception 以异常取代错误码
某个函数返回一个特点的代码，用以表示某种错误情况。
改用异常。

。。生成错误码的地方直接throw

1.决定抛出受控还是非受控异常。
如果调用者有责任在调用前检查必要状态，就抛出非受控异常。
。。受控异常，外层必须有try。catch。

2.找到该函数的所有调用者，调整它们，让它们使用异常。
如果抛出非受控异常，那么就调整调用者，使其在调用函数前做适当检查。
抛出受控异常，try catch

3.修改方法签名，令它反映出新用法。

如果受控异常，那么调用者需要添加try。catch。。
如果调用者太多，那么借助一个中间函数，try。catch封装被调用者，然后所有调用的地方换成中间函数。。这样可以逐一修改编译测试。


10.15 Replace Exception with Test 以测试取代异常。
面对一个调用者可以预先检查的条件，你抛出了一个异常。
修改调用者，使它在调用函数之前先做检查。

异常只应该用于异常的，罕见的行为，而不应该成为条件检查的替代品。
例子是：
try {
	return arr[i];
} catch (数组越界) {
	return 0;
}
应该是:
if(i >= arr.length) return 0;
return arr[i];


chapter 11 处理概括关系
概括关系==继承关系。。。
主要是将函数上下移动于继承体系中。。field，method，constructor都能上下移动。PullUpField，PullUpMethod,PullDownField,PullDownMethod,PullUoConstructorBody。。我们不会将构造函数向下推，因为ReplaceConstructorWithFactoryMethod更管用。

如果若干函数大体上相同，只在细节上有所差异，使用FromTemplateMethod将它们的共同点和不同点分开。

建立新类，改变整个继承体系。ExtractSubclass，ExtractSuperclass，ExtractInterface。。如果想在类型系统中标识一小部分函数，ExtractInterface特别有用。如果发现继承体系中某些类没有存在必要，使用CollapseHierarchy将它们移除。

有时会发现，继承并非最佳选择，你真正需要的是委托，那么ReplaceInheritanceWithDelegation可以帮你把继承改为委托。。有时又想反向修改，那么使用ReplaceDelegationWithInheritance。


11.1 Pull Up Field 字段上移
2个子类拥有相同的字段。
将该字段移至超类。

如果字段是private的，那么超类中需要声明为protected，这样子类才能引用它。
。。。getter？


11.2 Pull Up Method 函数上移
有些函数，在各个子类中产生完全相同的结果。
将该函数移至超类。

避免重复是很重要的。尽管重复的2个函数可以各自工作得很好，但重复自身只会成为错误的孳生地，此外毫无价值。无论何时，只要系统之内出现重复，你就会面临"修改其中一个却未能修改另一个"的风险。通常，找出重复也有一定的困难。

本重构往往跟随其他重构而使用。或许你能找到数个身处不同子类内的函数，而它们又可以通过某种形式的参数调整成为相同的函数。这时候，最简单的方法就是首先分别调整这些函数的参数，然后再将它们概括到超类中。当然，也能一次完成这2个步骤。

一种特殊情况也需要PullUpMethod，子类函数重写了超类函数，但做的是相同的工作。

PullUpMethod最麻烦的一点是：被提升的函数可能会引用只出现于子类而不出现于超类的特性，如果被引用的是个函数，你可以将该函数也一同提升到超类，或者在超类中建立一个抽象函数。此过程中，可能需要修改某个函数的签名或建立一个委托函数。

如果2个函数相似但不相同，或许可以先借助FromTemplateMethod构造出相同的函数，然后再提升它们。


1.检查待提升函数，确认它们是完全一致的。
如果这些函数看上去做了相同的事，但并不完全一致，可使用SubstituteAlgotrithm让它们变得完全一致。

2.如果待提升函数的签名不同，将那些签名都修改为你想要在超类中使用的签名。
3.超类中建立一个函数，将某一个待提升函数的代码复制到其中，适当调整，编译。(如果函数中引用了只在子类中的方法，那么超类声明一个抽象函数；如果引用了只在子类中的属性，使用PullUpField，或者SelfEncapsulateField，然后超类中声明setter的抽象函数)
4.剔除一个待提升的子类函数。
5.编译，测试。


11.3 Pull Up Constructor Body 构造函数本体上移
各个子类中有一些构造函数，它们的本体几乎完全相同
在超类中新建一个构造器，并在子类构造器中调用它。

。。就是子类中都会对某几个属性赋值。那么超类中新建一个构造器，对这几个属性赋值，子类调用super(几个属性).

很多时候，子类构造器的唯一动作就是调用超类构造器。但这里不能PullUpMethod，因为无法在子类中继承超类构造函数。

如果重构过程过于复杂，可以考虑使用ReplaceConstructorWithFactroyMethod代替本重构。

如果日后子类构造器中再出现共同代码，你可以先使用ExtractMethod将那一部分提炼到一个独立函数，然后使用PullUpMethod上移到超类。
。。。为什么不是直接共同代码移到超类构造器？。


11.4 Push Down Method 函数下移
超类中某个函数只与部分子类有关。
将这个函数移到相关的那些子类去。

使用ExtractSubclass之后你可能需要本重构方法。


11.5 Push Down Field 字段下移
超类中某个字段只被部分子类用到
将这个字段移到需要它的那些子类去。


11.6 Extract Subclass  提炼子类
类中某些特性只被部分实例用到
新建一个子类，将上面所说的那部分特性移到子类中。

使用本重构的主要动机：你发现类中的某些行为只被一部分实例用到，其他实例不需要它们。有时，这种行为上的差异是通过类型码区分的，此时你可以使用ReplaceTypeCodeWithSubclasses或ReplaceTypeCodeWithState/Strategy。但是并非一定要出现了类型码才表示需要考虑使用子类。

ExtractClass是ExtractSubclass之外的一种选择。2者之间的抉择其实就是委托和继承之间的抉择。
ExtractSubclass通常更容易进行，但它也有限制：一旦对象创建完成，你无法再改变与类型相关的行为。
使用ExtractClass，你只需要插入另一个组件就可以改变对象的行为。此时子类只能用来表现一组变化。如果你希望一个类以几种不同的方式变化，就必须使用委托。
。。是指：委托类不变，被委托类变化，这样就有多种变化方式？


11.7 Extract Superclass 提炼超类
两个类有相似特性
为这2个类建立一个超类，将相同特性移至超类。

重复代码的某种形式就是：两个类以相同的方式做类似的事情，或者以不同的方式做类似的事情。继承可以简化这种情况。当然，在建立这些具有共通性的类之前，往往无法发现这种共同性。因此经常在具有共通性的类出现之后，才开始建立其间的继承结构。

另一种选择就是ExtractClass，这2种方案之间的选择其实就是继承和委托之间的选择。如果2个类可以共享行为，也可以共享接口，那么继承比较简单。


11.8 Extract Interface 提炼接口
多个客户使用类接口中的同一个子集，或者2个类接口有部分相同。
将相同的子集提炼到一个独立的接口中。

类之间彼此互用的方式有若干种。"使用一个类"通常意味着用到该类的所有责任区。另一种情况是，某一组客户只使用类责任区中的一个特定子集。再一种情况是，这个类需要与所有协助处理某些特定请求的类合作。
对于后2种情况，将真正用到的这部分责任分离出来通常很有意义，因为这样可以使系统的用法更清晰，同时也更容易看清系统的责任划分。如果新类需要支持上述子集，也比较能够看清子集内有些什么东西。

ExtractSuperclass和本方法有相似之处。本方法只能提炼共通接口，不能提炼共同代码。使用本重构方法可能会导致重复代码，幸而你可以使用ExtractClass先把共通行为放进一个组件中，然后将工作委托该组件，从而解决这个问题。如果有不少共同行为，ExtractSuperclass比较简单，但每个类只能有一个超类。

如果某个类在不同环境扮演不同的角色，使用接口就是一个好主意。你可以针对每个角色通过ExtractInterface提炼出相应接口。
。。LinkedList。。

另一种可以用上ExtractInterface的情况是：你想要描述一个类的外部依赖接口(outbound interface，即这个类要求服务提供方提供的操作)。如果你打算将来加入其他种类的服务对象，只需要求它们实现这个接口即可。
。。就是List，可以通过LinkedList，也有ArrayList，还有synxxList等。。。应该是吧。。


11.9 Collapse Hierarchy 折叠继承体系
超类和子类之间无太大区别。
将它们合为一体。

将函数/属性在继承体系中上移，下移后，很可能发现某个子类并没有带来任何价值，因此需要把超类和子类合并起来。


11.10 From Template Method 塑造模板函数
在一些子类中，其中相应的某些函数以相同的顺序执行类型的操作，在但各个操作的细节上有所不同。
将这些操作分别放入独立函数中，并保持它们拥有相同的签名，于是原函数也就变得相同的，然后将原函数上移至超类。

。。将差异部分提出出来形成新方法，拥有相同的方法签名。这样原方法就相同了，然后上移到超类，提取出来的方法形成抽象方法放入超类中。


11.11 Replace Inheritance with Delegation 以委托取代继承
某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。
在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者间的继承关系。

。。继承一个有10+个方法的父类，但你只需要其中2个方法，其他无意义，那么就用委托取代继承。


11.12 Replace Delegation with Inheritance 以继承取代委托
两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。
让委托类继承受委托类。

。。委托了一个类，本类中很多方法只是被委托类.getXX(),就结束了。那么就选择继承取代委托。

两条告诫：
1.如果你没有使用委托类的所有函数，那么就不应该使用本重构手法。因为子类总是遵循超类的接口。。如果过多的委托函数让你烦心，你有别的选择：通过RemoveMiddleMan让客户端自己调用受托函数，也可以使用ExtractSuperclass让2个类接口相同的部分提炼到超类，然后让两个类都继承这个超类，还可以用类似的手法ExtractInterface。

2.另一种需要当先的情况是：受托对象被不止一个其他对象共享，而且受托对象是可变的。此时，不能使用本重构方法，因为那样的话就无法在共享数据了。数据共享是必须由委托关系承担的一种责任，你无法将它转给继承关系。如果受托对象是不可变的，数据共享就不成问题，因为你可以放心地复制对象。
。。其他类用到了本类的受托对象。。但是直接把其他类中调用本类.受托改成本类就可以用本重构手法了吧。。当然如果受托类可变，那是真的不能用本重构手法了。。


383
chapter 12 大型重构

12.1 Tease Apart Inheritance 梳理并分解继承体系
某个继承体系同时承担2项责任。
建立2个继承体系，并通过委托关系让其中一个可以调用另一个。

1.首先辨别出继承体系所承担的不同责任，然后建立一个二维表格(或三维，四维表格，如果你的继承体系够混乱且你的绘图工具够酷的话)，并以坐标轴标识出不同的任务。
2.判断哪一项责任更重要些，并准备将它留在当前的继承体系中。准备将另一项责任移动到另一个继承体系中。
3.使用ExtractClass从当前超类中提炼出一个新类，用以表示重要性稍低的责任，并在原超类中添加一个新类的实例变量。
4.对应原继承体系中的每个子类，创建上述新类的一个子类。在原继承体系的子类中，将超类中添加的实例变量初始化为新建子类的实例。
5.针对原继承体系中的每个子类，使用MoveMethod将其中的行为搬移到与之对应的新建子类中。
6.当原继承体系中的某个子类不再有任何代码时，删除它。
7.重复以上步骤，直到原继承体系中所有子类都被处理过。观察新继承体系，看看是否有可能对它实施其他重构手法，如PullUpMethod，PullUpField等。


12.2 Convert Procedural Design to Objects 将过程化设计转化为对象设计
手上有一些传统过程化风格的代码。
将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中。

。。哇哦。。看下面的描述，cms似乎是过程化的。。。

往往你会面对一些过程化风格的代码所带来的问题，典型情况是：类中有着长长的过程化函数和极少的数据，旁边则是一堆哑数据对象。

。。但是，不这样还能怎么办呢？。。没，批处理那些就很不错(?)。

1.针对每个记录类型，将其转变为只含访问函数的哑数据对象。
如果数据来自关系型数据库，那么把数据库中每个表变成一个哑数据对象
2.针对每一处过程化风格，将该处的代码提炼到一个独立类中
可以把提炼所得的类做出一个Singleton(方便重新初始化)，或是把提炼所得的函数声明为static。
3.针对每一段长长的程序，实施ExtractMethod及其他相关重构将它分解，再以MoveMethod将分解后的函数分别移到它所相关的哑数据类中。
4.重复上述步骤，直到原始类中所有函数被移除。


12.3 Separate Domain from Presentation 将领域和表述/显示分离
某些GUI类之中包含了领域逻辑。
将领域逻辑分离出来，为它们建立独立的领域类。

MVC。


12.4 Extract Hierarchy 提炼继承体系
你有某个类做了太多工作，其中一部分是以大量条件表达式完成的。
建立继承体系，以一个子类表示一种特殊情况。

在渐进式设计过程中，常常会有这样的情况：一开始设计者只想以一个类实现一个概念，但随着设计方案的演化，最后却可能一个类实现了多个不同的概念。一开始，你建立了这个简单的类。一段时间后，你可能发现：只要加入一个标记和一两个测试，就可以在另一个环境下使用这个类，又过段时间后你又发现了这样的一个机会。。长此以往，这个类就变得一团糟，标记变量和条件表达式到处都是。

本重构能将复杂类的各个功能梳理并分开。不过，请注意，只有当条件逻辑在对象的整个生命周期保持不变，本重构所导入的策略才适用。否则你可能必须在分离各种状况之前先使用ExtractClass。

本重构是一个大型重构，可能一天之内无法完成，不要放弃。将一个极度混乱的设计方案梳理出来，可能需要数周甚至数月的时间。你可以先进行本重构中的一些简易步骤，休息一下，再花几天编写一些能体现产出的代码。当你领悟到更多东西，再回来继续本项重构的其他步骤---这些步骤将因为你的领悟而显得更加简单明了。


准备了两组重构做法
第一种情况是：你无法确定哪些地方会发生变化，这是你会希望每次一小步地前进。
1.鉴别出一种变化情况
如果这种变化可能在对象生命周期的不同阶段而有不同体现，就运用ExtractClass将它提炼成为一个独立的类。
2.针对这种变化，新建一个子类，并对原始类实施ReplaceConstructorWithFactoryMethod。再修改工程函数，令它返回适当的子类实例。
3.将含有条件逻辑的函数，一次一个，逐一复制到子类，然后在明确情况下(对子类明确，对超类不明确)，简化这些函数。
如有必要隔离函数中的条件逻辑和非条件逻辑，可对超类实施ExtractMethod。
。。子类知道自己处理的是那种情况下的代码。所以只需要保留这种情况下的代码。
4.重复上述过程，将所有变化情况都分离出来，直到可以将超类声明为抽象类为止。
5.删除超类中那些被所有子类重写的函数体，并将它们声明为抽象函数。

如果你非常清楚原始类有哪些变化情况，可以使用另一种做法。
1.针对原始类的每一种变化情况，建立一个子类。
2.使用ReplaceConstructorWithFactoryMethod将原始类的构造函数转变为工厂函数，并令它针对每一种变化情况返回适当的子类实例。
如果原始类中各种变化情况是以类型码标示，先使用ReplaceTypeCodeWithSubclasses；如果那些变化情况在对象生命周期的不同阶段会有不同体现，请使用ReplaceTypeCodeWithState/Strategy。
3.针对带有条件逻辑的函数，实施ReplaceConditionalWithPolymorphism。如果并非整个函数的行为有所变化，而只是函数一部分有所变化，请先运用ExtractMethod将变化部分和不变部分分隔开来。



chapter 13 重构，复用与现实


程序分析器。


chapter 14 重构工具


chapter 15 总结

重构很难，可能无法再前进一步，丧失信心。此时应该停下来，如果现有的代码比重构前好，那么就发布。如果不好，那就放弃。
可能过段时间，灵感就来了。

重构时，你可能会发现某些代码并不正确，你坚信自己的判断，因此想改过来。。别这么做，重构时你的目标之一就是保持代码的功能完全不变，不多不少。对于那些需要修改的东西，列个清单记录下来，重构之后再做这些事。










