

代码
56，57，纯Hibernate启动
79 纯jpa
82 纯jpa配置
120 jpa的xml描述元数据
128 3.4 其他实体表示法，hibernate有3种内建实体模式，pojo,map,xml。
147 键生成器

默认情况下，对简单问题选择每个类层次结构一张表，对于复杂问题或被要求严格遵循范式，考虑每个子类一张表。
但，这时需要问自己，对象模型中，重新把继承建模为委托是否更好？
对于无关持久化或orm的各种原因，通常最好避免复杂的继承。

<class>:每个带有隐式多态的具体类一张表---使用非显式的继承映射和默认的运行时多态行为。
union-subclass:每个具体类一张表---完全放弃来自sql模式的多态和继承关系
subclass:每个类层次结构一张表---通过反规范化sql模式启用多态，并利用保存类型信息的一个类型辨别标志列
joined-subclass:每个子类一张表---把is a表示为 has a关系


341
9.5 EJB组件中使用Java Persistence

hib启动时生成的sql保存在哪里？如何被使用？





















UDT，User-defined DataType

对象/关系不匹配。

。。java对象中属性，关系型数据库中列无法一一对应。。不。就是一个对象不一定是一个表，可能是多个，也可能是表中的某几个字段。。继承特别明显，父类只有一部分的列是有用的。


对于sql而言，UDT支持是许多所谓的对象-关系扩展之一。这意味着数据库关系系统有一个完善的数据类型系统
UDT支持是大部分sql数据库管理系统的一个有点模糊的特性。
sql标准支持用户定义的数据类型，但是少得可怜。
。。Hibernate的UserType.

即使sql数据库管理系统中使用了完善的udt系统，但是我们仍然可能重复类型声明，在java中编写新类型，并在sql中再次重复。
因而，在sql数据库内部使用udt或java类型，都还不是目前行业的一项共通的实现。


java: User中有Address，Adress中有String保存zipcode.但是在数据库中是User表中1个varchar保存zipcode

User有3个粒度，数据库中只有2种粒度：表，列。


继承，多态。这是数据库所缺乏的。一个外键约束精确地引用了一张目标表。定义一个引用多张表的外键不容易，必须编写一个程序化的约束来加强这种完整性规则。


对象/关系不匹配问题的另一个方面是对象同一性，哪个字段作为表的主键，我们如何处理java中的同一对象。


2个对象是否为同一对象，有3种方法，2种java，一种sql数据库
1.对象同一性(粗略等同于内存位置，用a==b校验)
2.等同性，通过equals，也称为值等同。
3.数据库行的同一性用主键值表达。

几个不恒等的对象同时表示数据库的同一行很常见，例如，在并发运行的应用程序线程中。



代理键，对用户没有意义的主键列。


面向对象的语言使用对象引用来表示关联，但是关系领域中，关联则被表示为外键。
对象引用具有固有的方向性。如果对象间的关联应该在2个方向导航，就必须定义两次关联。
外键关联不是生来就有方向性。

对象的关联可能是多对多的(双方都保存对象的set)
表关联始终是1多对或1对1。
如果要保存多对多，就必须引入一张新表，称为链接表。这张表不会出现在领域模型中。


上面主要考虑的是结构性的问题。

但，对象持久化中最困难的就是动态的问题，涉及关联。

java中，user.getBilling().getAccountNumber()，访问用户的账单信息，这是非常自然的方式，通常称为遍历对象网络。跟着实例之间的指针，从一个对象导航到另一个对象。
不幸的是，这并不是从sql数据库中获取对象的有效方法。
为了提高数据访问代码性能，你能做到的最重要的事情就是将请求数据库的次数减到最少。最明显的做法是将sql查询的次数减到最少。
因此，使用sql有效地访问关系型数据通常需要在有关的表之间使用联结。
获取数据时联结中包含的表的数目决定了能够在内存中遍历对象网络的深度。
例如，要获取一个User，但是对账单不感兴趣，则可以：
select * from users u where u.user_id=123

如果需要获得一个User，并随后访问每个关联的账单明细，则可以编：
select * from users u left outer join billing_details bd on bd.user_id=u.user_id where u.user_id=123

要有效地使用联结，就必须在你遍历对象网络之前直到你计划访问对象网络的哪个部分。

另一方面，只有当对象被初次访问时，所有对象持久化解决方案才提供抓取关联对象的数据的功能。然而这种渐进风格的数据访问在关系数据库的上下文中效率很低，因为它要给每个节点或每个被访问的对象网络的集合执行一条语句，这就是可怕的n+1查询问题。


在java和关系型数据库中访问对象的这种不匹配，可能是java程序中性能问题的一个最普遍的根源。


领域模型不匹配并不是低灵活性和导致更高成本的低生产力的唯一根源，更深层次的原因是jdbc api本身。jdbc和sql提供了一个面向语句/面向命令的方法，把数据从sql数据库移进移出。如果要涉及查询或操作数据，涉及的表和列至少被指定3次(插入，更新，选择)，这增加了设计和实现所需要的时间。
。。就是延迟更新？commit时才更新？


在一个大中型应用程序中，按关注点组织类通常比较有意义。持久化是一个关注点，其他还包括表现，工作流和业务逻辑。也有所谓的横切关注点，典型的横切关注点包括日志，授权和事务划分。


一个典型，公认的高级应用程序架构使用3个层，用于表现，业务逻辑，和持久化。

表现层，负责页面以及屏幕导航的表现和控制的代码在表现层。
业务层，负责实现任何业务规则或者会被用户理解为问题领域一部分的系统需求。
持久化，负责向/从一个或多个数据存储器中存储/读取数据。这个层必须包括一个业务领域实体的模型。
数据库
辅助和工具类


java有个内建的持久化机制：序列化提供了把对象网络(应用程序的状态)快照写到字节流的能力，然后它可能被持久化到一个文件或数据库中。序列化也被java的远程方法调用(RMI)用于给复杂的对象实现传递值语义。序列化的另一个用法是在集群机器中跨节点复制应用程序状态。
但，序列化后的关联对象网络只能被当作一个整体访问，没有反序列化整个流，就不可能从流中获取任何数据。



ORM本质上是把数据从一种表示法(可逆)转换为另一种表示法进行工作。

ORM解决方案包含4个部分
1.在持久化类的对象上执行基本的CRUD操作的一个API
2.用于指定引用类或者类属性的查询的一种语言或api
3.用于指定映射元数据的一种工具
4.用于实现ORM的一项技术，与事务对象交互，执行脏检查，延迟关联抓取及其他优化功能。



HQL,Criteria,Example查询。。。。。最后一个？？？



hibernate tools 插件
hbm2java,annotationconfiguration,hbm2dao,hbm2doc
hbm2ddl,jdbcconfiguration,hbm2hbmxml,configuration,hbm2cfgxml,hbmtemplate
AndroMDA


常见开发场景
自顶向下，从现有的领域模型开始，使用java完成领域模型的实现，并(理想地)完成数据库schema方面的自主。必须构建元数据(xml或注解)，然后选择性地用hbm2ddl工具产生数据库schema。没有现成的数据库schema，对于大部分java开发人员来说，是最舒适的开发风格。

自底向上，始于现有的数据库schema和数据模型。最容易进行的方式是使用反向工程工具从数据库抽取元数据(如hbm2hbmxml)。利用hbm2java生成java持久化类。

起自中间层，hibernate的xml映射元数据提供充分的信息来完全推导出数据库schema，并给应用的持久层生成java源代码。hbm2ddl，hbm2java。这种开发风格只建议经验丰富的hibernate专家使用。

在中间会合，最难的场景是合并现有的java类和现有的数据库schema，此时，hibernate工具集就无能为力了。


hibernate发行包中的lib/README.txt，这个文件包含了所有必须的和可选的第三方程序库的一个最新列表。



无参构造是个必要条件，hibernate在这个构造器上使用反射来实例化对象。


持久化类都可以被用在任何执行环境中---不需要专门的容器，这些实体也是简单的java对象。


<many-to-one name="next" cascade="all" column="next_id" foreign-key="FK_NEXT" />


所有可重用的sql语句都是在启动时生成。。。。？really？

脏检查：在一个工作单元内部修改对象状态时，这个特性为你免除了显示要求hibernate去更新数据库的动作。
。。就是没有save，它也会自动保存。。flush的dirty check 应该就是这个。
。。所以flush时，update，insertion越多，慢得越厉害。

sql的顺序和设置属性的顺序不同，hibernate使用完善的运算规则来确定一种有效的顺序，避免违背数据库外键约束。这个特性称为事务迟写。


初始化Hibernate的常规方法时从一个Configuration对象中创建一个SessionFactory对象。


SessionFactory sf = new Configuration().configure().buildSessionFactory();

调用new Configuration()时，hibernate在classpath的根目录下搜索hibernate.properties文件。如果找到，所有的hibernate.*属性都会被加载并添加到Configuration对象。

调用configure()时，hibernate在classpath的根目录下搜索名为hibernate.cfg.xml的文件。找不到就抛异常。
如果没有这个配置文件，就不一定要调用这个方法。
xml配置的设置，后来的设置会覆盖前面的设置。

hibernate.properties配置文件的位置始终在classpath的根目录中，处在任何包之外。
如果要使用一个不同的文件，或者要hibernate在classpath的子目录中查找xml配置文件，就必须把路径当作configure()方法的一个实参进行传递。

SessionFactory sf = new Configuration().configure("/persistence/auction.cfg.xml").buildSessionFactory();

在创建SessionFactory之前，始终可以在Configuration对象中编程式地设置额外的选项或映射文件位置
SessionFactory sf = new Configuration().configure("/persistence/auction.cfg.xml").setProperty(Environment.DEFAULT_SCHEMA, "CAVEATEMPTOR").addResource("auction/CreditCard.hbm.xml").buildSessionFactory();

首先读取classpath的Hibernate.properties文件，然后添加来自/persistence/auction.cfg.xml的所有设置，并覆盖之前的任何设置，最后通过编程设置另一个配置属性(默认的数据库Schema名称)，并添加另一个HibernateXML映射元数据文件到配置中。

<mapping resource="hello/Message.hbm.xml" />
这个标签在<hibernate-configuration><session-factory>中。在hibernate.cfg.xml文件中。

cfg.xml配置文件中，可以指定hibernate属性而不必hibernate作为前缀。
属性名称和值与编程式的配置属性是一致的，也就是说，与org.hibernate.cfg.Environment中定义的常量一致，例如hibernate.connect.drive_class属性具有常量Environment.DRIVER。
。。真正的属性在Environment的接口AvailableSettings中(5.2在原来的基础上有插入了一层AvailableSettings，废弃了原来的。)


启动应用的命令行中增加系统属性java-showsql=true，来赋值<property name="show_sql">${showsql}</property>,来开关显示sql。


数据库连接池
3个原因使用连接池
1.获得新的连接很昂贵。有些数据库管理系统甚至给每个连接启动一个全新的服务器进程
2.为数据库管理系统维护许多闲置的连接很昂贵，连接池可以最优化闲置连接的使用。
3.给某些驱动程序创建预编译的语句也很昂贵，连接池可以对跨请求的连接高速缓存语句。


配置连接池的一种做法是把设置放进hibernate.cfg.xml中。另一种做法是放入classpath根目录的hibernate.properties文件。

hibernate.c3p0.min_size = 5     c3p0中做好准备的最少jdbc连接数量
hibernate.c3p0.max_size = 20    最多连接数量，超过时会运行时抛出异常
hibernate.c3p0.timeout = 300    超时周期300秒，超过后，闲置连接将从池中移除。
hibernate.c3p0.max_statements = 50      最多高速缓存50个预编译的语句。高速缓存预编译的语句是利用hibernate获得最好性能的要素。
hibernate.c3p0.idle_test_period = 3000  这是在连接被自动验证之前，一个以秒为单位的闲置时间

max_size是必须的。

提供自己的连接：实现org.hibernate.engine.jdbc.connections.spi.ConnectionProvider，使用hibernate.connection.provider_class配置选项命名你的实现。
。。书上是org.hibernate.connection.ConnectionProvider。但是5.2是上面这个(应该)


大部分hibernate应用程序中，SessionFactory应该在程序初始化期间被实例化一次。然后单独的实例应该为特定程序中所有的代码所使用。任何Session都应该用这个单独的SessionFactory来创建。SessionFactory是线程安全的，且能够被共享。Session是单线程的对象。


一个经常出现的问题，这个工厂创建后应该被存储到什么地方，它如何被轻松地访问。有更高级而舒适的选项，如JNDI和JMX，但它们通常只能在完全的JavaEE应用程序服务器中才能使用。

我们引入一个实用快速的解决方案，解决hibernate启动的问题，和SessionFactory的存储和访问：你将使用一个静态的全局变量和静态的初始化。
变量和初始化这两者都可以在单个类中实现，这个类被称作HibernateUtil。在没有javaEE服务的普通java应用程序中，它是hibernate启动的一种常用模式。

package persistence;

import org.hibernate.*;
import org.hibernate.cfg.*;

public class HiernateUtil {
    private static SessionFactory sessionFactory;

    static {
        try {
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(Ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        // alternatively, you could look up in JNDI here
        return sessionFactory;
    }

    public static void shutdown() {
        // close caches and connection pools
        getSessionFactory().close();
    }
}

java.lang.ExceptionInInitializerError的包装对于静态初始化器来说是强制的。


hibernate.show_sql
hibernate.format_sql
hibernate.use_sql_comments，把注释放在所有生成的sql语句内部，来提示它们的出处。可以看到某个特定sql是从显式的查询还是所需的集合初始化中生成的。

sql会延迟执行，所以追踪和调试orm并不容易。

Hibernate通过日志工具输出日志，可以使用log4j.使用log4j.properties来配置。
可以查阅Hibernate发行包的etc/目录下log4j.properties文件。
不要记录debug级别的日志，会严重影响性能


也可以通过启用实时统计来监控Hibernate，没有应用程序服务器(即没有JMX部署环境)，运行时从Hibernate引擎之外获得统计的最容易的方法就是SessionFactory
Statistics stats = HibernateUtil.getSessionFactory().getStatistics();
stats.setStatisticsEnabled(true);
...

stats.getSessionOpenCount();
stats.logSummary();

EntityStatistics itemStats = stats.getEntityStatistics("auction.model.Item");
itemState.getFetchCount();

Statistics用于全局信息，EntityStatistics用于有关一个特定实体的信息，CollectionStatistics用于一个特定的集合任务。QueryStatistics用于sql和hql查询。
SecondLevelCacheStatistics用于详细的关于可选的二级数据高速缓存中的一个特定区域的运行时信息。

logSummary()，单个调用就可以把一个完整的摘要打印到控制台。


运行hbm2ddl这个工具并创建schema的方法有3种：
1 在常规的构建过程中，在一个Ant任务中运行
2 在应用程序代码中运行SchemaExport，可能在HibernateUtil启动类中。这不常用。
3 设置hibernate.hbm2ddl.auto为create或create-drop。这样创建SessionFactory时会启用Schema的自动导出。create会在创建SessionFactory时产生drop，然后create，第二个在关闭应用时drop。。另一个配置选项是update，开发期间很有用，它使用内建的SchemaUpodate工具，使得Schema的演变更加容易。如果启用，hibernate在启动时读取jdbc数据库元数据，通过把旧的Schema和当前的映射元数据相比较，来创建新的表和约束。这项功能取决于jdbc驱动程序提供的元数据的特性，一个缺乏许多驱动程序的领域，因而，这个特性在实际应用中并没有它听起来那么令人激动和有用。

SchemaUpdate自动更新产品数据库的Schema，这可能很快带来灾难。

2 的编程式生成Schema很简单
Configuration cfg = new Configuration().configure();
SchemaExport se = new SchemaExport(cfg);
se.create(false, true);

开发过程中hbm2ddl.auto的另一个有用的配置是validate，它使SchemaValidate能够在启动时运行，这个工具可以把映射和jdbc数据库进行比较，并告诉你这个schema和映射是否匹配。不匹配则抛出异常。
可以编程式运行
Configuration cfg = new Configuration().configure();
new SchemaValidator(cfg).validate();




Hibernate Annotation,Hibernate EntityManager

使用Hibernate Annotation，用内嵌元数据替代Hibernate XML映射文件。

import javax.persistence.*;

@Entity
@Table(name="MESSAGE")
public class Message {
    @Id @GeneratedValue
    @Column(name="Message_ID")
    private Long id;

    @Column(name="message_text")
    private String text;

    @ManyToOne(cascade=Cascade.ALL)
    @JoinColumn(name="Next_Message_id")
    private Message nextMessage;

    // getter setter
}

@Table,@Column,@JoinColumn是可选的，一个实体的所有属性自动被认为是持久化的，使用默认的策略和表/列名称。

hibernate.cfg.xml中：<mapping class="hello.Message" />

使用SessionFactory编程式配置，addAnnotatedClass()方法就会替代addResource()方法。
AnnotationConfiguration cfg = new AnnotationConfiguration();    // 从hibernate.properties中加载配置
//...其他配置
cfg.addAnnotatedClass(hello.Message.class);
SessionFactory sf = cfg.buildSessionFactory();


<mapping class="hello.Message" />
<mapping package="hello" />

AnnotationConfiguration cfg = new AnnotationConfiguration();
cfg.addClass(hello.Message.class);
cfg.addPackage("hello");
SessionFactory sf = cfg.buildSessionFactory();


Hibernate EntityManager是围绕提供JPA编程接口的Hibernate Core的一个包装，支持jpa实体实例的生命周期，并允许你用标准的java persistence查询语句。

jpa功能是hibernate原生能力的一个子集。

一旦配置Hibernate EntityManager到项目，可以立刻看到一种简化：不再必须在配置文件中列出所有被注解的类(或xml映射文件)了。


SessionFactory -> EntityManagerFactory

持久化单元配置，持久化单元：EMF的配置，与一组映射元数据(通常是被注解的类)。

/etc/META-INF/persistence.xml
<persistence xmlns=""
    // ...
    version="1.0">

    <persistence-unit name="helloworld">
        <properties>
            <property name="hibernate.ejb.cfgfile" value="/hibernate.cfg.xml" />
        </properties>
    </persistence-unit>
</persistence>

每个持久化单元都需要一个名称，在这里是helloworld

使用任意数量的属性对持久化单元进行进一步配置，这些属性全是特定于供应商的。
hibernate.ejb.cfgfile的引用了-包含着这个持久化单元所有设置的hibernate.cfg.xml文件。将其中的所有配置细节移进persistence.xml文件。

jpa标准指出，persistence.xml文件要出现在被部署的持久化单元的META-INF目录。


java persistence主要编程接口
javax.persistence.Persistence，给EntityManagerFactory的创建提供一种静态方法的一个启动类。

javax.persistence.EntityManagerFactory，等同于Hibernate SessionFactory。这个运行时对象表示一个特定的持久化单元。线程安全。通常被当作一个单例。并给EntityManager实例的创建提供方法。

javax.persistence.Entityanager，等同于Session，单线程，非共享，表示数据访问的一个特定工作单元。提供方法去管理实体实例的生命周期并创建Query实例。

javax.persistence.Query，等同Hibernate Query。一个对象是一种特定的jpa查询语言或原生的sql查询表示法，允许参数的安全绑定，并给查询的执行提供各种方法。

javax.persistence.EntityTransaction,等同于Hibernate Transaction，在java se环境中用于RESOURCE_LOCAL事务的划分。在javaEE中，依赖jta标准的javax.transaction.UserTransaction接口进行编程式的事务划分。


79
import java.util.*;
import javax.persistence.*;

public class HelloWorld {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("helloworld");
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        Message msg = new Message("hi");
        em.persist(message);
        tx.commit();
        em.close();

        EntityManager em2 = emf.createEntityManager();
        EntityTransaction tx2 = em2.getTransaction();
        tx2.begin();
        List messages = em2.createQuery("select m from Message m order by m.text asc").getResultList();

        tx2.commit();
        em2.close();

        emf.close();
    }
}

jpa支持编程式配置，通过选项的映射(map)
Map properties = new HashMap();
properties.put("hibernate.hbm2ddl.auto", "create-drop");
EntityManagerFactory emf = Persistence.createEntityManagerFactory("helloworld", properties);

定制的程序属性覆盖persistence.xml中配置的属性。


之前说过不一定要在配置中列出所有的被注解的类或xml映射文件，但是它们现在仍在hibernate.cfg.xml中。我们来启用jpa的自动侦测特性。
打开日志的debug级别。。。

启动时，Persistence.createEntityManagerFactory()方法试图查找具有helloworld的持久化单元的位置。它在classpath中搜索所有META-INF/persistence.xml文件，如果发现匹配就配置EMF。
jpa持久化提供程序-试图在构建输出目录下找到所有被注解的类和所有hibernateXML映射文件。不需要hibernate.cfg.xml中被注解类的列表(或xml映射文件的列表)，因为hello.Message这个被注解的实体类已经找到了。

所以可以移除整个hibernate.cfg.xml，把配置细节移到persistence.xml中。

82
<persistence-unit name="helloworld">
    <provider>org.hibernate.ejb.HibernatePersistence</provider>
// 这个没了，似乎是：org.hibernate.jpa.HibernatePersistenceProvider

    <!-- 不再需要 <class>hello.Message</class> -->

    <properties>
        <property name="hibernate.archive.autodetection" value="class, hbm" />
        //。。。。hibernate.cfg.xml中其他配置。
    </properties>
</persistence-unit>

有3个值得关注的新元素。
需要为这个持久化单元设置一个<provider>。这通常只在你同时使用几个jpa实现是才需要。
<class>变成可选的。
hibernate.archive.autodetection告知hibernate要自动扫描哪些元数据：被注解的类(class)和/或hibernateXML映射文件(hbm.xml)。默认情况下，HibernateEntityManager对两者都进行扫描。


所有jpa配置都捆绑在persistence.xml中，hibernate在启动时自动扫描并找到元数据。相比纯粹的hibernate，现在你拥有这些好处：
被部署元数据的自动扫描。
标准的，简化的配置。
标准的数据访问代码，实体实例的生命周期，完全可移植的查询。

。。书上的Ejb3Configuration，5.2已经没了。。

Ejb3Configuration和常规的Hibernate Configuration一样，并没有进行扩展。

如果需要编程式地控制二级高级缓存区，SessionFactory接口就很有用。可以先通过转换EntityManagerFactory获得SessionFactory
HibernateEntityManagerFactory hibEMF = (HibernateEntityManagerFactory) emf;
SessionFactory sf = hibEMF.getSessionFactory();

。。现在5.2已经不需要HibernateEntityManagerFactory了，可以直接强转为SessionFactory
。。现在SessionFactory 实现了HibernateEntityManagerFactory， HibernateEntityManagerFactory这个继承了 EntityManagerFactory。

。。大约就是，hibernate是jpa的超集，所以SessionFactory提供了EMF没有的功能，所以有时需要使用SF。

使用同样的方法可以从EntityManager获得Session。
HibernateEntityManager hiEM = (HibernateEntityManager) em;
Session s = hibEM.getSession();

。。现在5.2能直接强转了。


jpa也支持返回底层实现的getDelegate()方法。
Session s = (Session) entityManager.getDelegate();

极少数情况下，能够从Hibernate Session退回到简单的jdbc接口。
Connection conn = session.connection();

。。这个接口是，SessionImpl的接口SessionImplementor的父接口SharedSessionContractImplementor提供的。
最后这个选项有一些警告，不允许你关闭从hibernate中获得的jdbc Connection，它会自动关闭。这个规则的例外情况是，在一个依赖于积极的连接释放的环境中，这意味这在JTA或CMT环境中，你必须关闭在应用程序代码中返回的连接。
。。应该是说有些环境，不会自动关闭，需要手动。

直接访问jdbc更好更安全的方法是通过java的资源注入
@Resource(mappedName="java:/HelloWorldDS") DataSource ds;



90
2.3 反向工程遗留数据库

HibernateToolTask

<hibernate-reverse-enginnering> 来设置一些规则，缩小范围。

hbm2java
编写本书时，hbm2java导出器支持17种元属性用于调优代码的生成

。。但是eclipse market中搜不到 hbm2java.. hibernate ,hibernate tools 都搜不到了。估计要直接install的。




2.4 与Java EE服务整合

如果你使用jpa，就已经深入到java ee，不需要额外的整合步骤。

java ee应用程序服务器，如JBoss AS, BEA WebLogic和IBM WebSphere，为java实现标准的(特定于Java EE)的托管环境。Hibernate能够与之整合的三大最值得关注的JavaEE服务是JTA，JNDI，JMX.

jta允许hibernate参与托管资源中的事务。hibernate可以通过jndi查找托管资源(数据库连接)，并且能够把自身当作一项服务绑定到jndi上。最后hibernate可以通过jmx被部署，然后通过jmx容器被当作一项服务来管理，并使用标准的jmx客户端程序在运行时被监控。


Tomcat不是javaEE应用程序服务器，只是一个servlet容器。










chapter3 领域模型和元数据



。。EJB = pojo+service ？


hibernate和jpa都要求每个持久化类都有个无参构造器。构造器可以是非public的，但至少是包可见的。如果运行时需要生成代理来优化性能的话，则要求这个类不是final的(也没有final方法)

可以选择持久化类的实例状态应该如何被hibernate持久化，通过直接访问它的字段，或访问方法。
访问方法很普遍，可以让类的内部表示法与公共接口之间提供一个缓冲，允许两者独立重构。


hibernate使用集合类型的接口，因而必须使用Set，List，而不是HashSet。
运行时，hibernate用它自己的一个类的实例把HashSet实例包起来。(..应该是说Proxy或懒加载)



public class User {
    public String getName() {
        return firstName + ' ' + lastName;
    }
}
。。现在应该都是通过getter方法来进行持久化数据的吧。。但是@Column能写属性上。。xml怎么决定配置的property是属性还是getter/setter？。。。
当setter有特殊逻辑时，告诉hibernate直接访问实例变量就有意义了。

脏检查，hibernate自动侦测对象状态的改变，以便使更新过的状态与数据库同步。

public String getName() {
    return new String(name);
}
不会导致不必要的sql-update。。hibernate按值比较对象，而不是按对象同一性，来确定一个属性的持久化状态是否需要被更新。

例外：集合是按同一性比较的，对于一个被映射为持久化集合的属性，getter应该返回setter设置的集合实例，如果不是，hibernate将更新数据库。getter，setter应该避免：
public void setNames(List namesList) {
    names = (String[]) namesList.toArray();
}
public List getNames() {
    return Arrays.asList(names);
}

必须知道访问方法中的异常如何处理，如果在加载和存储实例时配置hibernate使用这些方法的话，如果抛出RuntimeException，当前事务就会回滚，你要自己处理这个异常。如果抛出已检异常的话，hibernate会把这个异常包在一个RuntimeException中。


116
3.3 ORM元数据

ORM工具要求元数据指定 类和表，属性和列，关联和外键，java类型和sql类型 等 之间的映射。

元数据是关于数据的数据，映射元数据定义和支配-面向对象和sql系统中不同类型系统和关系表示法之间的转换。


hibernate的xml元数据格式非常易读，并定义了有用的默认值。如果没有属性值，就在被映射的类上用反射来确定默认值。

<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
    <class name="auction.model.Category" table="CATEGORY">
        <id name="id" column="CATEGORY_ID" type="long">
            <generator class="native"/>
        </id>
        <property name="name" column="NAME" type="string" />
    </class>
</hibernate-mapping>


hbm.xml中的type="string",这个string是一个内建的hibernate类型，不是java/sql的类型，是这两个类型系统间的桥梁/转换器。


可以在一个xml中使用多个<class>为多个类声明映射。但建议是给每个持久化类使用一个映射文件。习惯上是用被映射的类名+一个后缀(如Category.hbm.xml)，并把它放在与Category类相同的包中。

jdk5中，最好是使用基于EJB3.0和Java Persistence标准的Hibernate Annotations。



3.2.2 基于注解的元数据
基本思想是把元数据与它所描述的信息放在一起，而不是把它分离到一个不同的文件中去。
jdk5之前并没有这项功能，因而开发了一种可供选择的方案，XDoclet项目使用支持键/值对的特殊javadoc标签，引入了包含元信息的java源代码的注解。


@Target(TYPE)
@Retention(RUNTIME)
public @interface Entity {
    String name() default "";
}


@Entity
@Table(name="ITEM")
public class Item {}

如果没有@Table，jpa的默认表名是未限定类名(。。不含包的类名)，这和xml中省略表名时，hibernate的处理一样。

有时还需要使用供应商扩展，如抓取和高速缓存设置，都是Hibernate的注解。

@Entity
@Table(name="ITEM")
@org.hibernate.annotations.BatchSize(size=10)
@org.hibernate.annotations.DiscriminatorFormula(
    "case where item_is_special is not null then A else B end"
)
public class Item {}

@BatchSize是一个抓取选项。
@DiscriminatorFormula是一个hibernate映射注解，用于当类继承无法用简单的文字值决定的时候，对于遗留的模式特别有用。
这2个注解都用限定名，这样可以区分来自jpa规范还是特定于供应商。
还可以搜索org.hibernate.annotations，对整个项目中用到的非标准注解有一个全面的概览。

ejb3.0和java persistence都争先包含了注解。然而，专家组注意到了xml部署描述在某些情况下的优势，特别对于随着每次部署而改变的配置元数据。结果，ejb3.0,jpa中的每个注解都可以用一个xml描述符元素替换。

<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings
    xmlns
    ....>

    <persistence-unit-metadata>
        <xml-mapping-metadata-complete/>
        <persistence-unit-defaults>
            <schema>MY_SCHEMA</schema>
            <catalog>my_catalog</catalog>
            <cascade-persist/>
        </persistence-unit-defaults>
    </persistence-unit-defaults>

    <package>auction.model</package>

    <entity class="Item" access="PROPERTY" metadata-complete="true">
        <attributes>
            <id name="id">
                <generated-value strategy="AUTO"/>
            </id>
        </attributes>
    </entity>
</entity-mappings>

实体类的所有其他属性通过一个默认映射自动地被认为是持久化的。

也可以给整个持久化单元设置默认映射，例如schema的名称和默认的级联选项。如果包含<xml-mapping-metadata-complete>元素，jpa完全忽视这个持久化单元中实体类的全部注解，仅以来xml中的映射。
可以在一个实体级别上用metadata-complete="true"启用它。

如果不想忽略，而是向覆盖注解元数据，就先移除xml-mapping-metadata-complete,metadata-complete="true"。
<entity class="Item">
    <attributes>
        <basic name="initialPrice" optional="false">
            <column name="init_price"/>
        </basic>
    </attributes>
</entity>

此处把initialPrice属性映射到了init_price列，并指定它不可为空。
Item类的initialPrice属性上的任何注解都将被忽略。但Item类中所有其他注解仍然得到应用。
这里没有指定访问策略，因此字段或getter访问根据Item中@Id注解的位置来使用。
。。就是@Id在属性上，所有的数据get/set都是直接属性的？


jpa的xml映射与hibernateXML完全不兼容。你需要决定使用哪一种。

hibernateXML格式支持所有可能的hibernate映射，如果有些东西无法在jpa/hibernate的注解中被映射，那么可以使用原生的hibernateXML文件映射。
同样的事情对jpaXML描述符则不是如此--它们只提供用于覆盖规范的元数据。

无法用hibernateXML映射文件覆盖注解。必须用xml定义一个完整的实体类映射。


3.3.4 处理全局的元数据

查看xml的dtd，可以看到<hibernate-mapping>元素有全局的选项，被应用到它内部的类映射。

<!ATTLIST hibernate-mapping schema CDATA #IMPLIED>									<!-- default: none -->
<!ATTLIST hibernate-mapping catalog CDATA #IMPLIED>									<!-- default: none -->
<!ATTLIST hibernate-mapping default-cascade CDATA "none">
<!ATTLIST hibernate-mapping default-access CDATA "property">
<!ATTLIST hibernate-mapping default-lazy (true|false) "true">
<!ATTLIST hibernate-mapping auto-import (true|false) "true">
<!ATTLIST hibernate-mapping package CDATA #IMPLIED>									<!-- default: none -->

。。default-lazy 是懒加载！。。。default-access的property和field有什么区别？还有其他选项？
。。access找不到，file|property|ClassName，这个估计不是。。


全局注解可以放在类的源文件的顶部。
还可以把全局的元数据放在一个单独的文件(package-info.java)中，称为包元数据。
。。这个package-info.java只在包中有效，eclipse新建包的时候，下面有个勾选框可以自动新建。
。。而且看书上，注解是写在package之上的。。。

124

@org.hibernate.annotations.TypeDefs({
    @org.hibnernate.annotations.TypeDef(
        name="monetary_amount_usd",
        typeClass=MonetaryAmountType.class,
        parameters={@Parameter(name="convertTo", value="USD")}
    ),
    @org.hibernate.annotations.TypeDef(
        name="monetary_amount_eur",
        typeClass=MonetaryAmountType.class,
        parameters={@Parameter(name="convertTo", value="EUR")}
    )
})
@org.hibernate.annotations.NamedQueries({
    @org.hibernate.annotations.NamedQuery(
        name="findItemsOrderByPrice",
        query="select i from Item i order by i.initialPrice"
    )
})
package auction.persistence.types;

在包auction.persistence.types中，声明了2个hibernate类型转换器。一个具体化查询。


jpa移除了jpa注解的包可见性，结果，没有任何java persistence注解可以被放在package-info.java文件中。如果需要可以移植的全局的java persistence元数据，就把它放在orm.xml文件中。

如果没有使用自动侦测，就必须在hibernate或jpa持久化单元配置中指定一个包含元数据文件的包。

全局注解(hibernate和jpa)也可以放在特定类的源代码中，在import之后，语法和上面相同。


主键生成策略，通常不能跨数据库系统移植。
如果现在的主键策略不是你想要的。你可能有一个定制的标识符生成器，你编写了一个类实现了Hibernate的IdentifierGenerator接口。
。。这个接口！。，，SequenceHiLoGenerator，hilo也是一个实现类。虽然deprecated了。。表名也是这里的。默认表名是这个：hibernate_sequence

<id name="id" column="category_id" type="long">
    <generator class="auction.custom.MyOracleGenerator" />
</id>

现在xml被绑定到了一个特定的数据库产品。损失了可移植性
处理这种问题的方法是在xml中使用一个占位符，在映射文件被复制到目标目录下的构建期间，这个xml文件被替换。ant支持这个。只有你有ant经验，才建议使用这个机制。

更优雅的变更方法是，使用定制的xml实体。
<id name="id" column="category_id" type="long">
    <generator class="&idgenerator;" />
</id>

&idgenerator; 称为实体占位符，可以在xml文件的顶部定义它的值为实体声明，作为文档类型定义的一部分。

<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping SYSTEM
    "http://....dtd"
[
<!ENTITYT idgenerator "auction.custom.MyOracleGenerator">
]>

读取映射文件时，xml解析器将在hibernate启动时替换占位符。


更推进一步，在单个文件中把这个新增物具体化到DTD，并在所有其他的映射文件中包括全局的选项。
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping SYSTEM
    "http://....dtd"
[
<!ENTITYT % globals SYSTEM "classpath://persistence/globals.dtd">
%globals;
]>

。。上面这个应该是dtd文件的内容(?不是，人家开头都写了<?xml>)，再上面是xml文件。

所有全局配置都被添加到classpath的persistence包中的globals.dtd文件中：
<!ENTITY idgenerator "auction.custom.MyOracleGenerator">

现在要从oracle切换到其他数据库，只需要部署一个不同的globals.dtd文件。


如果所有类都需要created属性：
Created.hbm.xml中
<property name="created" column="creat_date" type="timestamp"/>
这个文件不需要任何xml首部或其他标签。

<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping SYSTEM "http://hibernate...dtd"
[
<! ENTITY created SYSTEM "classpath://model/Created.hbm.xml">
]>
<hibernate-mapping>
    <class name="Item" table="item">
        <id ... >
        &created;
    </class>
</hibernate-mapping>

&created;占位符 会被Created.hbm.xml中的内容替代。




3.3.5 运行时操作元数据

xml api(如dom,dom4j,jdom)都允许运行时操作xml文档。所以你能在运行时，将xml文档传递给Configuration对象之前，修改xml。

hibernate也公开了一个配置时的元模型，包含了在静态映射元数据中声明的所有信息。可以在编程时操作。
一种更强大的方法时，映射元数据全部动态的定义，没有任何静态映射。

下面将一个新的属性motto添加到User类
PersistentClass userMapping = cfg.getClassMapping(User.class.getName());

Column col = new Column();
col.setName("MOTTO");
col.setNullable(false);
col.setUnique(true);
userMapping.getTable().addColumn(col);

SimpleValue val = new SimpleValue();
val.setTable(userMapping.getTable());
val.setTypeName("string");
val.addColumn(column);

Property prop = new Property();
prop.setValue(value);
prop.setName("motto");
prop.setNodeName(prop.getName());
userMapping.addProperty(prop);

SessionFactory sf = cfg.buildSessionFactory();



添加属性到已有的持久化类映射很容易。给之前未被映射的类编程创建一个新的映射就比较麻烦了。

一旦创建SessionFactory，它的映射就不可变了。没有办法从sf会退到Configuration。
可以使用getClassMetadata(),getCollectionMetadata()，来 读取 sf的元模型

Item item = ...;
ClassMetadata meta = sf.getClassMetadata(Item.class);
String[] metaPropertyName = meta.getPropertyNames();
Object[] propertyValues = meta.getPropertyValues(item, EntityMode.POJO);

为一个特定实例获取Item类的持久化属性名称和那些属性的值。

。。javax.persistence.EntityManagerFactory.getMetamodel()。不知道是不是jpa的模型。



3.4 其他实体表示法
目前讨论的都是java类的领域模型实现。基于包含一般属性，集合等的java类的领域模型实现，是类型安全的。编译器会检查源代码是否正确。

下面介绍hibernate不通过java类实现领域模型的能力。用类型安全换取其他好处。
hibernate中，可以给应用程序选择一种实体模式，甚至混合多种实体模式得到一个新的模型，甚至可以在单个session中的不同实体模式之间切换。

hibernate有3种内建的实体模式
pojo，默认的实体模式
map，不需要java类，用hashmap在java应用中表示实体。这个模式允许程序使用完全动态的快速模型
dom4j，不需要java，实体通过dom4j表示为xml元素，对于导出或导入数据，或通过xslt来渲染和转换数据，特别有用。

好像就是把<class name="" 替换成<class entity-name=""
还有一些标签。<bag>

session.save(String entity-name, Map map);

hql的from后面是entity-name


混合动态和静态的实体模式
<class name="model.ItemPojo" entity-name="ItemEntity" table="ITEM_ENTITY">
    ...
    <many-to-one name="seller" entity-name="UserEntity" column="USER_ID"/>
</class>

可以全局或临时地切换到一个动态的映射表示法，但是实体模式的全局转换会带来严重的后果。
在hibernate.cfg.xml中添加下面配置来全局转换为动态映射表示法
<property name="default_entity_mode">dynamic-map</property>


在session中切换到动态映射：
Session dynamic = session.getSession(EntityMode.MAP);

。。但是5.2没有这个方法了。。EntityMode是有的。不知道怎么转了，sf里也没有。


把两张表都映射给同一pojo
为了完成2表映射给1个pojo，需要使用不同的实体名称(通常是不同的属性映射)

session.save("ItemSale", itemForSale);
由于逻辑实体名称，所以hibernate知道它应该把数据插入到那张表



xml只是一种文本文件格式，没有称为数据存储或数据管理的媒介的继承能力。
xml模型脆弱，类型系统复杂且低能。
xml格式的数据对于java很有吸引力，因为我们有一些好工具。如xslt转换xml数据。

默认在pojo模式下工作，并且想快速获得一些以xml表示的数据：
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Element userXml = (Element) dom4jSession.load(User.class, storedUserId);

。。EntityMode没有内置这个。估计要自己parse。。

返回一个dom4j的Element，使用dom4j api来读取和操作它。
打印：
OutputFormat format = OutputFormat.createPrettyPrint();
XMLWriter writer = new XMLWriter(System.out, format);
writer.write(userXml);

<User>
    <id>1</id>
    <username>john</username>
    <itemsForSale>
        <Item>
            <id>2</
            <initialPrice>99</
            <description>AAAA</
            <seller>1</
        </Item>
        <Item>
            //...
        </Item>
    </itemsForSale>
</User>


<class name="Item" table="Item_Entity" node="item">
    <id name="id" type="long" column="ID" node="@id">
        <generator class="native"/>
    </id>
    <property name="initialPrice" type="bid_decimal" column="init_price" node="item-details/@initial-price"/>
    //...
</class>

<class>
    ...
    <bag name=""itemsForSale" inverse="true" cascade="all" embed-xml="true" node="items-for-sale">
        <key column="user_id"/>
        <one-to-many class="Item"/>
    </bag>
</class>



hibernate core
如果使用基于代理的延迟加载的话，持久化类需要一个public或protected无参构造。
持久化集合必须使用接口
持久化属性可以在运行时通过字段或访问方法被访问，或者可以应用一种完全定制的策略
xml元数据格式支持所有可能的hibernate映射选项
xml映射元数据可以被全局地定义，并且xml占位符被用来使元数据免于依赖

java persistence && ejb3.0
jpa规范强制所有实体类有一个public/protected的无参构造器。
持久化集合必须使用接口
实体类的持久化属性通过字段或访问方法被访问，但是如果需要完全的可移植性，并非这两种都行。
jpa涵盖了所有基础的和最高级的映射选项，怪异的映射和调优需要hibernate annotations
全局的元数据只有在标准的orm.xml元数据文件中声明，才是完全可移植的。







chapter4 映射持久化类

提倡类比表多的设计：一行表示多个实例。

Item,User是明显的实体，它们各自都有自己的同一性。
Address是一个值，因为一个Addreee只能被单个User实例引用。User完全负责Address实例的生命周期。
Bid类是一个问题，由Item管理所有Bid对象生命周期，所以Item对所有Bid对象有一个引用的集合。同时Item还对一个Bid进行关联，它可能持有对它成功出价的Bid的一个引用。这个成功出价必然是引用集合中的一个对象。不管如何，你必须处理对Bid实例可能的共享引用，因此Bid必须是一个实体。它有一个依赖的生命周期，但必须有自己的同一性来支持共享引用。

会经常发现这种混合行为，但是第一反应应该是使所有的东西都成为值类型的类，如无必要，不要把它提升为实体。
试着简化关联，例如，集合有时增加了无益的复杂性。不要映射Bid引用的一个持久化集合，而是可以编写一个查询，来获得Item的所有出价。。。。就是单向多对1啊。

小心3件东西
共享引用，以一种避免对值类型实例共享引用的方式编写pojo。例如，确保Address只被一个User引用。例如，使它不可变，并用Address构造器强制这种关系。
生命周期依赖，值类型实例的生命周期依赖于实体限制。如果User被删除，Address也必须被删除。java中没有这种概念。
。。级联删除，但是对于地址来说，一个string就完事了啊。。可能是分表。还有邮政的简单，毕竟一个string很难切割出邮政编码之类的东西，但是多个string就非常简单了。
同一性，实体类几何在任何情况下都需要标识符属性。用户自定义的值类型类(和jdk类)没有标识符属性，这些通过自己的实体被标记。
。。。这书的翻译太垃圾了。2个翻译版好像都是垃圾。。。唉。。不过。。。



对象同一性，由jvm定义，如果2个对象引用指向相同的内存地址，它们就是同一的。
对象等同性，通过equals()方法定义。有时也被认为是等值

数据库同一性，如果2个对象在一个关系型数据库中是相同行，或者它们共享相同的表和主键值，它们就是同一的。

hibernate用2种方法把数据库同一性公开给应用程序
1 持久化实例的标识符属性值
2 Session.getIdentifier(Object entity)返回的值

标识符属性的值是持久化实例表示的数据库行的主键值。领域模型中通常不显示标识符属性。

数据库标识符经常被应用程序当作特定实例的一个方便的句柄使用，甚至在持久层之外。用户选择一个特定元素，应用程序可能需要获取该对象，通常是通过标识符来查找。所个getId()是公有的。
setId通常是私有的，让hibernate生成和设置。或者直接字段访问映射，没有setter
hibernate不允许持久化实例的标识符值在第一个分配后再修改。主键值永远不变--否则该属性不是合适的主键备选对象。


<id>映射一个普通的(非复合的)标识符属性

<class name="Category" table="category">
    <id name="id" column="category_id" type="long">
        <generator class="native"/>
    </id>
    ...
</class>

hibernate类型是long，在大部分数据库中被映射为bigint类型


jpa实体

@Entity
@Table(name="category")
public class Category {
    private Long id;

    @Id
    @GeneratedValue(strategy = GrenerationType.AUTO)
    @Column(name = "category_id")
    public Long getId() {
        return this.id;
    }

    private void setId(Long id) {
        this.id = id;
    }
}

@Id 标志这它是标识符属性。
strategy默认AUTO，AUTO和native一样。
@Column,如果没有，hibernate使用属性名称作为列名。

也可以对所有属性使用字段访问，包括数据库标识符
@Entity
@Table(name="category")
public class Category {
    @Id @GeneratedValue
    @Column(name="category_id")
    private Long id;

    public Long getId() {
        return this.id;
    }
}
。。没有setter

启动字段还是属性访问，取决于@Id注解的位置。

jpa,xml中：
<entity class="xxx" access="FIELD">
    <table name="category" />
    <attributes>
        <id name="id">
            <generated-value strategy="AUTO" />
        </id>
        。。。
    </attributes>
</entity>


现在
a==b
a.equals(b)
a.getId().equals(a.getId())



主键

键
1 值永远不为空
2 每行都有唯一值
3 一个特定行的值永远不变

许多遗留的sql数据模型使用自然主键，自然键是带有业余意义的建。例子：美国社会保障号码，澳大利亚税务档案号码。
自然键，在数据库上下文之外有意义，无论是否自动生成。
。。那用毫秒数不也是自然键了。。

很少有实体属性能作为一个好的主键。而且有些无法被sql数据库有效地索引

强烈建议：代理键，没有业务意义，由程序或数据库生成的唯一值


键生成器

生成器名称    JPA GenerationType      选项
native      AUTO                    -
    native生成器挑选其他同一性生成器(如identity，sequence，hilo)，取决于数据库的能力。保证映射元数据可以移植到不同数据库管理系统。

identity    IDENTITY                -
    支持db2,mysql,MS SQL Server,sybase,hypersonicSQL的同一性列。返回的标识符类型为long/short/int

sequence    SEQUENCE                sequence，parameters
    在db2,postgresql,oracle,sapdb,mckoi中创建一个序列，或者使用interbase中的一个生成器。标识符类型long/short/int,如果创建序列的其他设置要被添加到ddl，就使用sequence选项给序列定义一个目录名称(默认是hibernate_sequence)和paramters

increment   不可用                   -
    hibernate启动时，这个生成器读取表的最大(数字)主键列值，每插入一个新行就加1。long/short/int，如果单服务器的hibernate应用程序对数据库具有排他性访问时，这个生成器特别有效，但不应该被用于其他任何场合。

hilo        不可用                   table,column,max_lo
    高/低位算法时生成long类型标识符的一种高效方法。给定表和列(默认时hibernate_unique_key,next)作为高值来源。高/低位算法生成仅对特定数据库唯一的标识符。高值从全局的源中获取，并通过添加本地的低值被变成唯一。这种算法在标识符的单个源必须被多个插入访问时避免拥堵。这个生成器每次获取高值时总需要一个单独的数据库连接，因此它不受用户提供的数据库连接支持。换句话说，别把它与sf.openSession(myConnection)共用。max_lo选项定义了直到获取一个新的高值时添加了多少个低值，只有大于1的设置才有意义，默认为32767(Short.MAX_VALUE)

seqhilo     不可用                   Sequence，parameters,max_lo
    就像一般的hilo生成器，除了它使用一个具名的数据库序列来生成高值

(只适用于JPA) TABLE                  Table,catalog,Schma,PkColumnName,ValueColumnName,PkColumnValue,allocationSize
    很像hilo，TABLE依赖持有最新生成的整数主键值的数据库表，每个生成器都被映射到这张表中的一行，每一行有2列，pkColumnName,valueColumnName。pkColumnValue把每行分配到特定的生成器，并且值列持有最新的主键。持久化提供程序每次都分配到allocationSize为整数为止。

uuid.hex    不可用         separator
    是一个128位的uuid(生成String类型的标识符的一种算法，在网络内部唯一)。ip地址与一个唯一的时间戳结合使用。uuid被编码成长度为32的16进制数字的一个字符串。uuid表示法的每个组件之间带有一个可选的separator字符串。仅当你全局地需要唯一标识符时才使用这个生成器策略，例如你必须规则地合并2个数据库时。

guid        不可用         -
    在mysql,sql server中提供一个数据库生成的全局唯一的标识符字符串

select      不可用         key
    这个生成器获取由数据库触发器分配的一个主键，它按某些唯一键选择行并获取主键。这个策略需要另一个唯一的备选键列，且key选项必须被设置成唯一键列的名字


有些内建的标识符生成器可以通过选项来配置。
原生hibernate xml，把选项定义为键值对：
<id column="my_id">
    <generator class="sequence">
        <para name="sequence"my_sequence</parameter>
        <para name="parameters">
            increment by 1 start with 1
        </para>
    </generator>
</id>

可以通过注解使用hibernate生成器，即使没有直接可用的注解
@Entity
@org.hibernate.annotations.GenericGenerator(
    name="hibernate-uuid",
    strategy="uuid"
)
class name MyEntity {
    @Id
    @GeneratedValue(generator="hibernate-uuid")
    @Column(name="my_id")
    String id;
}

@GenericGenerator 用来给hibernate标识符生成器提供一个名字，这里名字是hibernate-uuid，这个名称被标准的generator属性引用。
。。真正的 生成器是uuid， hibernate-uuid是一个自定义的名字。


要在所有实体类中使用一个定制的序列生成器，由于这个生成器必须是全局的，所以在orm.xml中：
<sequence-generatro name="mySequenceGenerator"
    sequence-name="MY_SEQUENCE"
    initial-value="123"
    allocation-size="20" />

声明了MY_SEQUENCE的数据库序列，初始值123，可以用作数据库标识符生成的来源，并且每当持久化引擎需要标识符时，它就应该获得20个值。

@Entity
class name MyEntity {
    @Id @GeneratedValue(generator = "mySequenceGenerator")
    String id;
}
。。。？String？？？

如果在实体级声明了另一个同名的生成器，且在class关键字之前，它就覆盖全局的标识符生成器。可以用相同的方法声明和应用@TableGenerator

可以实现hibernate的IdentifierGenerator接口创建自己的标识符生成器。


类映射选项
查看dtd的<hibernate-mapping>，<class>元素，还有一些选项：
CRUD SQL语句的动态生成
实体易变性控制
给查询命名实体
映射包名称
引用关键字和被保存的数据库标识符
实现数据库命名约定


默认情况下，hibernate在启动时给每个持久化类创建sql语句，这些语句用来读取单个行，删除一行等的简单创建，读取，更新和删除。

启动时创建的update语句，sql语句更新所有的列，如果特定列的值没有被修改，这个语句就会把它设置为它的旧值。

如果有极大量的表，或者表的字段数百列，会影响启动时间。hibernate必须为crud提前生成所有sql语句。并且这些高速缓存的内存消耗也很高(通常这不成问题)

class元素中2个属性可以禁用启动时crud sql的生成。
<class name="Item" dynamic-insert="true" dynamic-update="true">
    ...
</class>

dynamic-insert是告诉hibernate是否在sql的insert中包含空的属性值。
dynamic-update告诉hibernate是否在update中包括未被修改的属性。

@Entity
@org.hibernate.annotations.Entity(
    dynamicInsert=true, dynamicUpdate=true
)
public class Item {...}

。。但是dynamic-insert=true的话，每次insert都会重新生成sql？有没有懒汉模式？

有时可以避免生成任何update，如果持久化类被映射为不可变的话。


部分类是不可变的，如之前的Bid，它永远不需要update。
hibernate也可以进行一些其他优化，如通过把mutable设置为false，来映射一个不可变类，就可以避免脏检查。

<hibernate-mapping default-access="field">
    <class name="Bid" mutable="false">
        ...
    </class>
</hibernate-mapping>

如果没有公开类的任何属性的公有设置方法，pojo就是不可变的。
hibenate直接access=field，这样就不必写私有/公有的getter了。

@Entity
@org.hibernate.annotations.Entity(mutable=false)
@org.hibernate.annotations.AccessType("field")
public class Bid {}

默认的访问范围一般由@Id的位置隐式声明。但是也可以直接@AccessType，这个注解甚至可以放在特定字段或访问方法中。



默认情况下，所有类名都自动"导入"到hibernate查询语言(hql)的命名空间。换句话说，可以在hql中使用没有包前缀的短类名。如果给定的SessionFactory存在2个同名的类，这2个类可能在不同包中，这个自动导入就可以关闭。

<hibernate-mapping>的autoimport="false"，该文件中关闭自动导入。

。。我以为autoimport 和 package是一起的。。

实体名称也可以被显示导入到HQL命名空间。甚至可以导入非显示映射的类和接口，这样，短名称可以被用在多态的hql查询中。
<hibernate-mapping>
    <import class="auction.mode.Auditable" rename="IAuditable" />
</hiernate-mapping>

现在hql：from IAuditable 可以获得实现auction.mode.Auditable接口的类的所有持久化实例。

<import>元素是适用于整个应用程序的声明，所以不能重复定义。

注解给实体一个显式的名称，如果短名称在jpa ql或hql命名空间中导致冲突的话
@Entity(name="AcutionItem")
public class Item {..}


package属性，这样 关联，子类，组件映射中 就不需要全名了。
<hibernate-mapping package="auction.model">
    <class name="Item" table="item">
        ...
    </class>
</


默认情况下，hibernate没有在生成的sql中用引号把表和列民括起来。
容易阅读，
大部分sql数据库在比较没有用括号括起来的标识符时都是不区分大小写的。

hibernate默认设置，可能把类/属性名称转化为dbms中不允许的表/列名称。User类映射到USER，这通常是一个保留字。这会导致数据库系统在启动或运行时抛错。

如果在映射文档中用反括号把表/列名括起来，hibernate生成的sql中就会把这个标识符用引号括起来。

<property name="description" column="`DESCRIPTION`"

任何时候，都不应该使用保留的关键字！
这是hibernate的细节，不是jpa规范。


hibernate可以自动强制执行命名标准
假设CaveatEmptor的所有表名都应该遵循 CE_<tablename>，一种方案是手动在映射文件的所有class和集合元素上指定table属性。
另一种，实现Hibernate的NamingStrategy接口

public class CENamingStrategy extends ImprovedNamingStrategy {
    public String classToTableName(Stirng className) {
        return StringHelper.unqualify(className);
    }

    public String propertyToColumnName(String propertyName) {
        return propertyName;
    }

    public String tableName(String tableName) {
        return "CE_" + tableName;
    }
    
    public String columnName(String columnName) {
        return columnName;
    }

    public String propertyToTableName(String className, String propertyName) {
        return "CE_" + classToTableName(className) + '_' + propertyToColumnName(propertyName);
    }
}

仅当<class>没有指定显式的table名称时，才调用classToTableName()方法。如果属性没有显示的column名称，就调用propertyToColumnName()。当有显示名称时，调用tableName,columName方法。

<class name="BankAccount">
表名是，CE_BANKACCOUNT

<class name="BankAccount" table="BANK_ACCOUNT">
表名：CE_BANK_ACCOUNT

为了启动命名策略，可以将NamingStrategy实例传递给hibernate的Configuration

Configuration cfg = new Configuration();
cfg.setNamingStrategy(new CENamingStrategy());
SessionFacotry sf = cfg.configure().buildSessionFactory();

这允许你有基于相同映射文件的SessionFactory实例，但每一个都使用不同的NamingStrategy。
这在多客户端的安装中极为有用，每个客户端需要唯一的表名，但要相同的数据模型。。然而，这种需求更好的方法是使用一个SQL Schema。

jpa中，使用hibernate.ejb.naming_strategy选项在persistence.xml中设置一个命名策略实现。


4.4
2种不同的值类型：jdk自带的(String,int)，开发人员定义的(Address，Bid)

如果用xml映射持久化类，无论它是实体还是值类型。所有持久化属性都必须在xml映射文件种被显式地映射。
如果用注解映射类，它的所有属性都是默认持久化的。可以用@javax.persistence.Transient注解给属性来排除它。或者使用transient的java关键字(通常只用于java序列化排除字段)。

jpa xml种排除一个特定字段或属性
<entity class="auction.model.User" access="FIELD">
    <attributes>
        。。。
        <transient name="age"/>
    </attributes>
</entity>


典型的hibernate属性映射定义了一个pojo的属性名称，一个数据库列名，一个hibnernate类型名称。
如果属性desc是java的String，hibernate就默认使用hibernate的string。
hibernate利用反射获得属性的java类型，下面是等价的
<property name="desc" column="desc" type="string"/>
<property name="desc" column="desc"/>

如果列名和属性名相同(忽略大小写)，那么列名也可以省略。

有时，可能使用<column>元素代替column属性。元素提供更多的灵活性：更多的可选属性，能不止一次地出现(单个属性可以映射到不止一个列)

<property>,<column>还有许多属性。

最好包括not-null，这样在没有提交到数据库时，hibernate就能报告非法的空属性
<property name="initialPrice" column="initial_price" not-null="true"/>


jpa是基于异常模型的一个配置，因此可以依赖默认。如果持久化类的一个属性没有被注解，就应用以下规则：
1 如果属性是jdk自带类型，它自动就是持久化的。换句话说，它在hibernate xml中像<property name="propname">一样处理
2 如果属性的类被注解为@Embeddable，它就被映射为自己的类的组件。
3 如果属性的类是Seriablizable,它的值以序列化的形式保存。这通常不是你想要的。应该始终映射java类，而不是在数据库保存一堆字节。想象数年后，程序消失时，维护这些二进制数据的情景。

如果不想依赖这些默认，就在一个特定的属性上应用@Basic注解。
@Basic(optional=false)
@Column(nullable=false)
public BigDecimal getInitialPrice { return initialPrice; }

@Basic注解把属性标识为在java对象级上不可选。
第二个注解nullable=false，只负责NOT NULL数据库约束的生成。
hibenate jpa实现在任何情况下对待这两个选项都一视同仁，因此使用其中一个注解就能达到目的。

jpa xml描述
<entity class="auction.model.Item" access="PROPERTY">
    <attributes>
        ...
        <basic name="initialPrice" optional="false">
            <column nullable="false"/>
        </bacis>
    </
</

...??那么Basic到底是什么？不映射到数据库？但为什么等同于nullable=false？
。。Basic就是声明持久化属性的默认方式，只不过它可以提供一些额外的属性来特异化。所以上面说不想依赖这些默认。


类的属性由持久化引擎直接(通过字段)或间接(通过getter或设置属性访问方法)访问，xml中，hibernate-mapping中的属性default-access="field|property|noop|custom.Class"属性为类控制默认的访问策略。
被注解的实体从强制的@Id注解的位置继承默认的访问策略。这是jpa默认行为

hibernate允许@org.hibernate.annotations.AccessType(<strategy>)注解灵活地定制访问策略：
类/实体级中设置AccessType，类的所有属性都根据选择的策略访问。属性级的注解是在字段还是获取方法上，这取决于策略。这个设置覆盖@Id注解位置的任何默认值
在属性上AccessType("proerty")，那么运行时就从getter中获取属性，在getter上AccessType("field")，运行时从属性上获得数据。
任何@Embedded类都继承默认的或显式声明的自己根实体类的访问策略。
任何@MappedSuperclass属性都通过被映射实体类的默认或者显示声明的访问策略而被访问。

也可以通过access在xml中控制属性级上的访问策略
<property name="des" column="desc" access="field"/>
或者hibernate-mapping元素中default-access给所有类映射设置访问策略。

除了字段，属性访问外，另一个可能有用的策略时noop。它映射java持久化类中不存在的属性。它能让你在hql中指向这个虚拟属性。换句话说，只在hql查询中使用数据库列。

实现org.hibernate.property.PropertyAccessor定义自己的属性访问策略。在access映射属性或@AccessType注解中设置(完全匹配的)类名。


有些属性根本不映射到类，特别是衍生属性，它从sql表达式中取值。
通过formula属性定义的表达式求值，可以把total属性映射到sql表达式
<property name="total" formula="total+tax_rate*total" type="big_decimal"/>

只在sql时求值，如果其他属性被修改，这个结果可能过时。
不会出现在update，insert中。只在select中。

@org.hibernate.annotataions.Formula("total+tax_rate*tatal")
public BigDecimal getTotal() {
    return total;
}

使用子查询计算平均值
<property name="avg" type="big_decimal" formula="(select avg(b.amount) from bid b where b.item_id=item_id)"/>


生成的和默认的属性值

典型的hibernate应用程序需要刷新包含由数据库为其生成值的任何属性的对象。标识属性定义为generated，让应用程序把刷新这个责任委托给hibernate。
<property name="lastModified" column="last_modified" update="false" insert="false" generated="always"/>

..就是这个lastModified是由数据库生成的。不是由我们/hibernate的代码生成的。
标记为数据库生成的属性还必须是非可插入，非可更新的。属性是只读的。通常该属性没有公共的setter。

这样，每当hibernate执行insert或update后，它会立刻执行select。
。。这样就没办法延迟发送sql了吧。

@Column(updatable=false,insertable=false)
@org.hibernate.annotations.Generated(
    org.hibernate.annotations.GenerationTime.ALWAYS
)
private Date lastModified;

可设置的选项是GenerationTime.ALWAYS,GenerationTime.INSERT，对于xml中的generated="always",generated="insert"。


默认值
首先数据库的ddl，需要设置默认值:
initial_price number(10,2) default '1'

如果通过hbm2ddl，可以把default添加到属性映射来启用这项输出。
<class name="Item" table="item" dynamic-insert="true" dynamic-update="true">
    ..
    <property name="initialPrice" type="big_decimal">
        <column name="initial_price" default="'1'" generated="insert"/>
    </
</

还必须启用动态的插入并更新语句的生成，以便包含默认值的列不会被包括在每个语句中，如果它的值为null(否则将插入null，而不是默认值)。
已经持久化(save)但没有flush的实例，是不会设置默认值的，所以需要手动session.flush。

设置了generated="insert"，hibernate知道insert后需要一个额外的select。

@Column(name="initial_price", columnDefinition="number(10,2) default '1'")
@org.hibernate.annotations.Generated(
    org.hibernate.annotations.GenerateionTime.INSERT
)
private BigDecimal initialPrice;

如果是不可移植的sql数据类型，那么会导致映射绑定到特定的dbms


用户自定义值类型的类。

User和Address由一种特殊的关系。其中一个是依赖的类，即组件。
这种关联关系是一种聚合---是整体-部分的关系。
聚集是一种强关联，对对象的生命周期有一些额外的语义。
我们有更强的形式：复合，部分的生命周期完全依赖于整体的生命周期。

java没有复合的概念。类或者属性无法被标记为组件或复合。唯一的区别是对象标识符：组件没有独立的同一性，因此持久化组件类不需要标识符，只是一个简单pojo
public class Adress {
    private String street;
    private String zipcode;
    private String city;

    // getter setter
}

User和Adress之间的复合是一个元数据级的概念，你只需告诉hibernate，Adress是映射文档中的值类型，或者是包含注解的值类型。


xml中的组件映射
hibernate使用component代表用户自定义的类，该类被持久化到与自己实体相同的表。

<class name="User" table="USER">
    <id name="id" column="user_id" type="long">
        <generator class="native"/>
    </id>
    <property name="loginName" column="LOGIN" type="string"/>
    <component name="homeAdress" class="Adress">
        <property name="street" type="string" column="home_street" not-null="true"/>
        ...
    </component>
    <component name="billingAddress" class="Adress">
        <property name="street" type="string" column="billing_street" not-null="true"/>
        ...
    </component>
</class>

这个例子中，复合关联建模是单向的。无法从Address导航到User

hibernate支持单向和双向的复合，但单向复合更常见。
双向映射：
<component name="homeAdress" class="Adress">
    <parent name="user"/>
    <property name="street" type="string" column="hone_street" not-null="true"/>
    ...
</component>

<parent>元素把类型User的属性映射到自己的实体。pojo中需要增加User user;

组件可以拥有其他组件，甚至关联到其他实体。
<component name="homeAdress" class="Address">
    <parent name="user"/>
    <component name="location" class="Location">
        <property name="streetname" column="Home_streetname"/>
        <property name="housenumber" column="home_housenr"/>
    </component>
    <property name="city" type="string" column="home_city"/>
</component>


jpa把组件称为被嵌入的类。
为了用注解映射被嵌入的类，可以在自己的实体类中声明一个特定的属性为@Embedded：
@Entity
@Table(name="USERS")
pubilc class User {
    @Embedded
    private Address homeAddress;
    ...
}

如果没有把一个属性声明为@Embedded，并且它不是jdk类型，hibernate就在关联的类中寻找@Embeddable注解，如果存在，属性就自动被映射为一个依赖的组件。
被嵌入的类的样子：
@Embeddable
public class Address {
    @Column(name="address_street", nullable=false)
    private String street;
    ...
}

被嵌入的类中可以进一步定制独立的属性映射，如@Column注解。

可以添加后退指针属性到Address，用org.hibernate.annotations.Parent映射它。

有时，你想从外部对一个特定实体覆盖被嵌入类内部所作的设置。
@Entity
@Table(name="USERS")
public class User {
    ...

    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name="street",
                            column=@Column(name="HOME_STREET")),
        @AttributeOverride(...)
    })
    private Address homeAddress;
}

@Column上的所有属性都被替换，所以它们不再nullable=false

jpa xml描述
<embedded class="auction.model.Address" access-type="FIELD"/>
<eneity class="auction.model.User" access="FIELD">
    <attributes>
        ..
        <embedded name="homeAdress">
            <attribute-override name="street">
                <column name="home_street"/>
            </attribute-override>
            ...
        </embedded>
    </a
</e

类被映射为组件有2条重要限制，第一，就像所有的值类型一样，共享引用是不可能的。组件homeAddress没有它自己的数据库同一性(主键)。
第二，没有优雅的方式表示对Adress的空引用。作为替代，hibernate在组件的所有映射映射中，都把空组件表示为空值。这意味着，如果保存了一个全部属性为null的组件对象，hibernate从数据库中获取实体对象时，组件为null。



chapter 5 继承和定制类型

面向对象的继承，即是is a，又是has a。
sql的模型只提供实体间的has a关系。


表示一个继承层次，有4种方法
每个带有隐式多态的具体类一张表---使用非显式的继承映射和默认的运行时多态行为。
每个具体类一张表---完全放弃来自sql模式的多态和继承关系
每个类层次结构一张表---通过反规范化sql模式启用多态，并利用保存类型信息的一个类型辨别标志列
每个子类一张表---把is a表示为 has a关系



每个带有隐式多态的具体类一张表
最简单方法，准确地给每个(非抽象)类使用一张表。类的所有属性，包括继承的属性，都可以被映射到这张表的列。
父类 BillingDetails { string owner }
CredirCard extends BillingDetails { string number, string expMonth, string expYear}
BankAccount extends BillingDetails { string account, string bankName, String swift}

表：
CREDIT_CARD (credit_card_id, owner, number, exp_month, exp_year)
BANK_ACCOUNT (bank_account_id, owner, account, bankname, swift)

在hibernate中不必作任何特别的事情来启用多态。
xml映射时就像CreditCard没有父类一般。
hibernate仍知道这个父类(或任何接口)，因为它在启动时扫描持久化类。

这种方法的问题在于，它不太支持多态关联。
数据库中，关联通常被表示为外键关系。如果子类全部被映射到不同的表，对它们父类的多态关联就无法被表示为一个简单的外键关系。这在领域模型中会出问题。因为BillingDetails与User关联，2张子类表都需要一个对Users表的外键引用。或者，如果User与BillingDetails有多对1的关系，Users表就需要单个的外键列，它必须同时引用2个具体的子类表。一般的外键约束时不可能的。

多态查询也有问题，针对父类的查询必须用几个sql select来执行，每个子类一个。

进一步的概念问题在于，几张不同表的几个不同列具有相同的语义。这使得模式的演变变得更加复杂。对于一个父类属性的改变，导致多个列的变化。它也使得把应用到所有子类的数据库完整性约束实现起来更加困难。


推荐这种方法仅仅用于类层次结构的最顶层，那里通常不需要多态，且未来也不太可能修改父类。


jpa也不支持完全的多态查询，只有被映射的实体(@Entity)可以正式成为jpa查询的一部分(注意hibernate查询接口是多态的，即使你用注解映射)

如果依赖这个隐式多态，就像通常一样用@Entity映射具体的类。必须复制父类的属性，把它们映射到所有具体的类表。
默认情况下，父类的属性被忽略且不是持久化的。需要在具体的子类表中注解超类来启用它属性的嵌入：

@MappedSuperclass
public abstract class BillingDetails {
    @Column(name="owner", nullable=false)
    private String owner;
    ...
}

@Entity
@AttributeOverride(name="owner", column=@Column(name="CC_owner", nullable=false))
public class CreditCard extends BillingDetails {
    @Id @GeneratedValue
    @Column(name="credit_card_id")
    private Long id = null;

    @Column(name="number", nullable=false)
    private String number;

    ...
}

数据库标识符也可以在父类中声明，给所有子类使用一个共同的列名和生成器策略。
。。。hbm.xml中好像还是每次都<id>，虽然是一样的代码。。

jpa xml:
<entity-mappings>
    <mapped-superclass class="auction.model.BillingDetails" access="FIELD">
        <attributes>
            ...
        </attributes>
    </mapped-superclass>
    <entity class="auction.model.CreditCard" access="FIELD">
        <attribute-override name="owner">
            <column name="CC_Owner" nullable="false"/>
        </a
        <attributes>
            ...
        </a
    </e
</e


每个带有联合的具体类一张表
在sql union的帮助下，可以解决多态查询和关联的大部分问题。这些问题是这个映射策略带来的。。

让我们用BillingDetails把联合子类映射为抽象类(或接口)，就像前一节一样。
这种情况下，我们再次拥有了2张表，并在这两张表中都复制超类列：credit_card,bank_account.

<hibernate-mapping>
    <class name="BillingDetails" abstract="true">
        <id name="id" column="billing_details_id" type="long">
            <generator class="natice"/>
        </id>
        <property name="name" column="owner" type="string"/>

        <union-subclass name="CreditCard" table="credit_card">
            <property name="number" column="numner"/>
            <property name="expMonth" column="exp_month"/>
            <property name="expYear" column="exp_year"/>
        </union-subclass>

        <union-subclass name="BankAccount" table="bank_account">
            ...
        </u
    </c
</h


抽象超类或接口必须abstract="true",否则超类的实例就需要一张单独的表
credit_card,bank_account都有billing_details_id主键列。标识符属性为所有子类共享，所以写到BillingDetails中。

子类映射继承父类映射的所有属性(包括标识符)。

第一个好处是，超类或接口属性的共享声明，不再必须为所有具体类复制这些映射了，hibernate会替你完成。sql仍不知道继承，实际上我们把2个不相关的表映射到一个更富有表现力的类结构。


jpa注解中，这个策略称作TABLE_PER_CLASS

@Entity
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
public abstract class BillingDetails {
    @Id @GeneratedValue
    @Column(name="BILLING_DETAILS_ID")
    private Long id = null;

    @Column(name="owner", nullable=false)
    private String owner;

    ...
}

数据库标识符和它的映射 必须 出现在超类中。所有子类和它们的表中共享。
子类并不需要特别的配置

@Entity
@Table(name="credit_card")
public class CreditCard extends BilingDetails {
    @Column(name="number", nullable=false)
    private String number;

    ...
}

TABLE_PER_CLASS在jpa中是可选的，因为并非所有的jpa实现都可以支持它。
实现是由供应商决定的，在hibernate中，它相当于xml文件中的<union-subclass>映射。

jpa xml
<entity-mappings>
    <entity class="auction.model.BillingDetails" access="FIELD">
        <inheritance strategy="TABLE_PER_CLASS"/>
        ...
    </entity>

    <entity class="auction.model.CreditCard" access="FIELD"/>
    <entity class="auction.model.BankAccount" access="FIELD"/>
</e

。。jpa类中的属性默认持久化的 。

如果超类是具体的，就需要另外一张表来存放这个类的实例。

对于BillingDetails的查询sql：
select billing_details_id,owner,number,exp_month,exp_year,account,bankname,swift,clazz_
from
(select billing_details_id,owner,number,exp_month,exp_year,null as account, null as bankname, null as swift, 1 as clazz_ from credit_card
union
select billing_details_id,owner,null as number, null as exp_month, null as exp_year...
account,bankname,swift, 2 as clazz_ from bank_account
)

这个查询是否比2个单独的声明执行得更好？这里我们可以让数据库优化器找到最好的执行计划，合并来自几张表的行。而不是在内存中合并2个结果集(hibernate多态加载器引擎所做的)。

另一个更重要的好处是处理多态关联的能力。
从User到BillingDetails的关联映射现在是可行的。
hibernate用一个union查询把单张表模拟为关联映射的目标。

目前为止的继承映射策略都不需要额外考虑sql schema。不需要外键，并且关系也被适当地标准化。


每个类层次结果一张表。
。。整个继承树共用一张表。。

整个类层次结构可以被映射到单张表，这张表把所有类的所有属性的列都包括在层次结构中。
通过一个类型辨别标识符的值来进行识别具体子类。

表：billing_details
表属性：
billing_details_id
billing_details_type<<Discriminator>>
owner
cc_number
cc_exp_month
cc_exp_year
ba_account
ba_bankname
ba_swift


这个映射策略在性能和简单性方面都胜出一筹。它是表示多态的最佳方法---多态和非多态的查询都执行得很好---并且更易于手工实现。不用复杂的联结或联合也可能生成特殊的报表，Schema演变很简单

由一个重大问题，子类声明的属性的列必须声明为可为空。从数据库完整性角度，没有not null约束可能是一个严重的问题。
另一个重要问题是标准化，我们创建了非键列之间的功能依赖，违背了第三范式。性能的反规范化可能令人误解，因为它为了也能通过sql执行计划的适当优化而也可能实现的即时获取，却牺牲了数据的长期稳定性，可维护性，数据完整性。

<subclass>元素给每个类层次结果映射创建一张表。
<hibernate-mapping>
    <class name="BillingDetails" table="billing_details">
        <id name="id" column="BILLING_DETAILS_ID" type="long">
            <generator class="natice"/>
        </id>
        <discriminator column="BILLING_DETAILS_TYPE" type="string"/>
        <property name="owner" column="owner" type="string"/>
    
        <subclass name="CreditCard" discriminator-value="CC">
            <property name="number" column="CC_NUMBER"/>
            ...
        </subclass>

        <subclass name="BankAccount" discriminator-value="BA">
            ...
        </s
    </c
</h

不允许由not null约束。
<subclass>可以嵌套自己


查询BillingDetails类时生成sql：
select billing_details_id,billing_details_type,owner,cc_number,cc_exp_month...ba_account,
ba_bankname... 
from billing_details

为了查询CreditCard子类，hibernate在辨识标志列中添加一个限制：
select billing_details_id,owner.cc_number,cc_exp_month...
from billing_details
where billing_details_type='CC'


jpa也有这个映射策略，即SINGLE_TABLE
@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(
    name="billing_details_type",
    discriminatorType=DiscriminatorType.STRING
)
public abstract class BillingDetails {
    @Id @GeneratedValue
    @Column(name="BILLING_DETAILS_ID")
    private Long id = null;

    @Column(name="owner", nullable=false)
    private String owner;

    ...
}

如果没有在超类中指定辨别标识列。默认名称时DTYPE，默认类型string。
继承层次结构中所有具体的类都可以有辨别标志值
@Entity
@DiscriminatorValue("CC")
public class CreditCard extends BillingDetails {
    @Column(name="CC_NUMBER")
    private String number;

    ...
}

没有显式的辨别标志值时，如果使用hibernate xml，默认完全限定名。如果注解或jpa xml，默认实体名称。
在jpa中没有非字符传辨别标志类型指定默认值，每个持久化供应商都可以有不用的默认值。

<entity-mappings>
    <entity class="auction.model.BillingDetails" access="FIELD">
        <inheritance strategy="SINGLE_TABLE"/>
        <discriminator-column name="BILLING_DETAILS_TYPE" discriminator-type="STRING"/>
        ...
    </e
    <entity class="auction.model.CreditCard" access="FIELD">
        <discrimintaor-value>CC</c>
        ...
    </entity>
</entity-mappings>

有时，尤其在遗留的Schema中，你无权在实体表中包括一个额外的辨别标志列。此时可以应用一个formula来计算每一行的辨别标志值
<discriminator formula="case when cc_number is not null then 'CC' else 'BA' end" type="string"/>
。。这个是父类中的设置

<subclass name="CreditCard" discriminator-value="CC">

用于辨别的公式不是jpa的一部分。但可以使用hibernate注解
@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@org.hibernate.annotations.DiscriminatorFormula(
    "case when cc_number is not null then 'CC' else 'BA' end"
)
public abstract class BillingDetails {

}

每个类层次结构一张表的策略的缺点对于设计来说可能太严重了---毕竟，反规范化的Schema长期而言会变成一个重大的负担。


每个子类一张表

把继承关系表示为相关的外键关联。声明持久化属性的每个类/子类(包括抽象类甚至接口)都有它自己的表。

不同于每个具体类一张表的策略。此处的表仅包含每个非继承的属性(子类本身声明的属性)以及也是超类表的外键的主键的列。

CreditCard类的一个实例持久化时，由BillingDetails声明的属性值就被持久化到billing_details表的一个新行。只有子类声明的属性值被持久化到credit_card表的一个新行。这两行通过它们的共享主键值链接在一起。
通过联结子类表和超类表，可以从数据库中获取子类实例。

billing_detail: billing_details_id<<PK>>, owner
credit_card: credit_card_id<<PK>><<FK>>, number, exp_month, exp_year
bank_account: bank_account_id<<PK>><<FK>>, account, bankname, swift

好处在于，sql schema被标准化了。schema演变和完整性约束定义很简单。对一个特定子类的多态关联可能被表示为引用这个特定子类的表的一个外键。

hibernate，<joined-subclass>元素给每个子类映射创建一张表。

<hibernate-mapping>
    <class name="BillingDetails" table="billing_details">
        <id name="id" column="billing_details_id" type="long">
            <generator class="native"/>
        </id>
        <property name="owner" column="owner" type="string"/>
        
        <joined-subclass name="CreditCard" table="credit_card">
            <key column="credit_card_id"/>
            <property name="number" column="number"/>
            ...
        </j

        <joined-subclass ...
            ...
        </j
    </class>
</h

查询BillingDetails类时，依赖一个外部联结：
select bd.billing_details_id,bd.owner,cc.number,cc.exp_month...ba.account,ba.bankname...
    case
        when cc.credit_card_id is not null then 1
        when ba.bank_account_id is not null then 2
        when bd.billing_details_id is not null then 0
    end as clazz_
from billing_details bd
left join credit_card cc on bd.billing_details_id=cc.credit_card_id
left join bank_account ba on bd.xxxxxxx

子类查询，内部联结。
select bd.billing_details_id,bd.owner,cc.number...
from credit_card cc inner join billing_details bd on bd.billing_details_id=cc.credit_card_id

这个映射更难以手工实现，如果计划把hibernate和手写sql混合，这就需要考虑是否使用这个映射策略。


虽然这个映射策略似乎很简单，但是根据我们的经验，复杂的类层次结构的sql的性能是无法接受的。


jpa的 joined策略

@Entity
@Inheritance(strategy=InheritanceType.JOINED)
public abstract class BillingDetails {
    @Id @GeneratedValue
    @Column(name="billing_details_id")
    private Long id = null;

    ...
}

子类中，如果子类表的主键列有着与超类表的主键列相同的名称时，就不需要指定联结列
@Entity
public class BankAccount extends BillingDetails {...}

没有标识符属性，它自动从超类继承billng_details_id属性和列，也可以显示指定列名：
@Entity
@PrimaryKeyJoinColumn(name="credit_card_id")
public class CreditCard extends BillingDetials {}


jpa xml
<entity-mappings>
    <entity class="auction.model.BillingDetails" access="Field">
        <inheritance strategy="JOINED"/>
        ...
    </e

    <entity class="auction.model.BankAccount" access="FIELD"/>
    <entity class="auction.model.CreditCard" access="FIELD"/>
        <primary-key-join-column name="credit_card_id"/>
    </
</


混合继承策略

通过嵌套<union-subclass>,<subclass>,<joined-subclass>，可以映射整个继承层次结构，你无法把它们混合起来---例如，用一个辨别标志从"每个类层次结构一张表"策略转换到标准的"每个子类一张表"。一旦决定使用某种继承策略，就必须坚持使用它。

有一些hibernate技巧，可以为一个特定的子类切换映射策略。
例如，可以把一个类层次结构映射到单张表，但是对于特定的子类，则通过外键映射策略切换到单独的表，就像使用每个子类一张表一样。使用<join>
。。这个是一开始就切换的。并不是中途切换。。

<hibernate-mapping>
    <class name="BillingDetails" table="billing_details">
        <id>...</id>
        <discriminator column="billing_details_type" type="string"/>
        
        <subclass name="CreditCard" discriminator-value="CC">
            <join table="credit_card">
                <key column="credit_card_id"/>
                <property name="number" column="cc_number"/>
                ...
            </join>
        </subclass
        <subclass name="BankAccount" discriminator-value="BA">
            <proprty name="account" column="BA_account"/>
            ...
        </subclass>
        ...
    </cla
</hib

<join>元素集合了一些属性,并告诉hibernate到一个二级表中获取它们。
这个映射元素有多种用途。


hibernate，执行外部联结，多态地抓取BillingDetials和所有子类实例。
select biling_detials_id,Billing_details_type,owner,cc.cc_number,cc.cc_exp_month,cc.cc_exp_year,
ba_account,ba_bankname,ba_swift
from billing_detials left outer join credit_card cc on billing_details_id=cc.credit_card_id


如果你有一个非常宽(一个父类，10000个子类)的类层次结构，外部联结就可以成问题。有些数据库系统(如Oracle)限制外部联结操作中的表数目。对于宽层次结构来说，你可能想切换到执行第二次select，而不是外部联结的策略。
<subclass name="CreditCard" discriminator-value="CC">
    <join table="Credit_card" fetch="select">
        <key column="credit_card_id"/>
        ...
    </j
</subclass>

jpa也通过注解支持这种混合的继承映射策略。用InheritanceType.SINGLE_TABLE映射超类BillingDetails。
@Entity
@DiscriminatorValue("CC")
@SecondaryTable(
    name="credit_card"
    pkJoinColumns=@PrimaryKeyJoinColumn(name="credit_card_id")
)
public class CreditCard extends BillingDetails {
    @Column(table="credit_card",name="CC_number",nullable=false)
    private String number;
    ...
}
如果没有给二级表指定主键联结列，就使用单张继承表的主键名称，这里是billing_detials_id。
需要用二级表的名称映射被移到二级表中的所有属性。


可以把所与映射策略应用到抽象类和接口，接口没有属性，但是有方法声明。
可以用<class>union-subclass,subclass,joined-subclass映射接口。并可以用<property>映射任何被声明或这被继承的属性。
hibernate不会试图实例化抽象类，即使你查询或加载了它。

jpa规范不在接口上支持任何映射注解，但将来的版本中会得到解决。

一些经验法则：
1 如果你不需要多态关联或者查询，就倾向于每个具体类一张表。换句话说，如果你从不或者很少查询BillingDetails，并且没有关联BillingDetails的类。基于union的显示映射是首选，因为随后(最优化的)多态查询和关联将成为可能。隐式多态对于利用非持久化相关的接口的查询最有用。
2 如果你一定要多态关联(对超类的关联，及由此在运行时通过具体类的动态解析对层次结构中所有类的关联)或者查询，并且子类相对地声明几种属性(尤其当子类之间的主要区别在于它们的行为中)时，则倾向与每个类层次结构一张表。你的目标是把可为空的列数减到最少，并让你自己确定反规范化的schema在长期运行中不会产生问题。
3 如果一定要多态关联或查询，并且子类声明多个属性(子类的主要不同在于它们所持有的数据)，则倾向于每个子类一张表。或者，更具继承层次结构的宽度和深度，以及相对于联合的可能联结成本，使用每个具体类一张表。


默认情况下，对简单问题选择每个类层次结构一张表，对于复杂问题或被要求严格遵循范式，考虑每个子类一张表。
但，这时需要问自己，对象模型中，重新把继承建模为委托是否更好？
对于无关持久化或orm的各种原因，通常最好避免复杂的继承。

开始考虑混合的继承策略时，记住：hibernate的隐式多态很聪明，足以处理更多异乎寻常的情况。

也可以在单个映射文件中使用<union-subclass>,<subclass>,<joined-subclass>映射元素(作为一级元素，而不是class子元素)然后必须声明被扩展的类，如<subclass name="CredirCard" extends="BillingDetails">,且必须在子类映射文件之前程序化地加载父类映射(在xml中，不必担心这个顺序)。这种技术允许扩展类层次结构，而不必修改超类的映射文件。
。。就是原先是<class>中<union-subclass>,现在可以直接<subclass>，只需要写好extends


5.2

实体是指其实例具有自己的持久化同一性的任何类。值类型是值没有定义某种持久化同一性的类。

实体实例可能处于3种持久化生命周期状态之一，瞬时transient,托管detached，持久化persistent。值类型实例没有这些生命周期状态。

hibernate..session.save()/update()应用到实体类的实例，不应用到值类型实例。
值类型实例的持久化生命周期完全由自己的实体实例的生命周期决定。如，保存用户时，用户名变成持久化，它从来不会独立于用户而变成持久化。

hibernate中，值类型可以定义关联，可能从一个值类型实例导航到一些其他实体，但是绝不可能从其他实体导航会值类型实例。关联始终指向实体。这意味着，从数据库中获取值类型实例时，它完全为一个实体所有，从不共享。

实体类利用class,union-subclass,subclass,joined-subclass.映射到数据库。
值类型，property，component.


hibernate内建的映射类型通常共享它们映射的java类型的名称。然而，一个特点的java类型可能有不止一个hibernate映射类型。

内建的类型不能用于执行任意的转换，例如，将varchar映射到Integer，这种转换需要自定义值类型。

映射类型        java        标准的sql内建类型(应该全大写)
integer       int或Integer   integer
long          long/Long      bigint
short         short/Short    smallint
float         float/Float    float
double        double/Double  double
big_decimal   BigDecimal     numeric
character     String         char(1)
string        String         varchar
byte          byte/Byte      tinyint
boolean       boolean/Boolean   bit
yes_no        同上            char(1) 'Y'/'N'
true_false    同上            char(1) 'T'/'F'

上面的sql类型是ansi标准数据类型。但是大部分数据库供应商忽略这部分sql标准，因为它们的遗留类型系统。
jdbc驱动提供特定于供应商的sql数据类型的部分抽象。允许hibernate在dml时使用ansi标准类型。
对于数据库专业ddl，hibernate利用对特定sql方言的内建支持，把ansi标准转为适当的特定于供应商的类型。

hibernate的类型系统很聪明，可以根据定义的长度转换sql数据类型。
如string，如果用length属性声明字符串属性映射，hibernate会根据方言选择正确的sql数据类型。如mysql，长度<=65535时，产生一个一般的varchar列，<=16777215时，使用mediumtext的数据类型。较大的字符串映射则使用longtext。
如果想知道映射类型的范围，检查sql方言,可以通过把方言作为子类，并覆盖这些设置来定制这种行为。

大部分方言也支持10进制的sql数据类型的比例和精度。如在big_decimal中设置precision,scale，给mysql创建一个numeric(precision,scale)的数据类型。

yes_no,true_false,是给遗留的schema和Oracle用户的。oracle dbms没有内建的布尔或者真值系统。(关系数据模型唯一真正需要内建的数据类型)



映射类型        java                标准sql内建类型
date         util.Date/sql.Date     date
time         util.Date/sql.time     time
timestamp    util.Date/sql.Timestamp    timestamp
calendar     Calendar                   timestamp
calendar_date Calendar              date

如果用timestamp映射util.Date，hibernate从数据库加载属性时返回sql.Timestamp。hibernate必须使用jdbc子类，因为它包括可能出现在数据库中的十亿分之1秒的信息。hibernate无法只切断这个信息。如果试图把util.Date属性使用equals()比较，会出现问题。因为它与sql.Timestamp子类的equals()方法不同步。比较2个util.Date对象的正确方法时a.getTime()>b.getTime()。可以编写一个切断数据库十亿分之一秒信息的定制映射类型，并在任何情况下都返回util.Date。



binary          byte[]          varbinary
text            String          clob
clob            sql.Clob        clob
blob            sql.Blob        blob
serializable    任何实现Serializable的java类      varbinary

varbinary真正的类型取决于方言，PostgreSQL中，sql类型时bytea, oracle中时raw

加载保存着属性变量的实体实例时，hibernate立即初始化属性，当你必须处理潜在的大值时，这很不方便。
一种解决方案是拦截字段访问，进行延迟加载。这种方法需要持久化类的字节码基础设施(BCI)的支持。
第二种是java类中一种不同的属性。jdbc直接支持定位器对象。如果你的java属性是sql.Clob,sql.Blob，就可以通过clob或blob映射类型映射它，以便不通过bci而获得大值的延迟加载。加载属性时，属性值是一个定位对象(指针)，访问时，才获取真正的值。这种按需加载需要开启数据库事务。

jpa，默认情况下String被映射到VARCHAR，如果想把String,char[],Character[],sql.Clob类映射到CLOB，需要@Lob注解

@Lob
@Column(name="item_desc")
private String desc;

@Lob
@Column(name="item_image")
private byte[] image;

byte[],Byte[],sql.Blob，也一样，需要@Lob

除了sql.Clob/Blob，其他类型的属性，都会被hibernate立即加载。

为了创建Clob,Blob，可以使用Hibernate.createBlob()/createClob()。。sql.Clob/Blob是接口。并没有实现类。所以hibernate实现了它们。。。5.2中。Hibernate.getLobCreator()。而不是直接create。

hib,jpa都对Serializable的任何属性类型提供序列回滚。这种映射类型把属性的值转换为字节流，然后保存到varbinary类型的列中。使用这种策略要非常谨慎(数据比代码更长久)，并且它可能只对临时数据(用户偏爱，登陆会话数据等)有用
。。而且，序列号一改就没办法反序列化了，还有增加的属性必须写后面(记得，反序列化时，从上往下挨个赋值的，顺序错了就完蛋，应该是的).
。。反序列化是，bit多了就抛弃，bit少了，那么属性就是默认值
。。Externalizable，强制实现序列化方法，反序列化方法。。继承Serialiable，也可以写2个private方法，来实现自定义序列化方法，反序列化方法。
。。transient属性不会被序列化。


其他jdk类型的hibernate类型，sql中是varchar

class       java.lang.Class         varchar
locale           util.Locale        varchar
timezone             .TimeZone      varchar
currency             .Currency      varchar


hib基础映射类型可能出现在,id,property,version,discriminator,index,element元素中。它们都有type属性

hib通常不需要显式指定内建类型。String属性，hibernate通过反射发现它，并默认选择string。
hib也理解 type="java.lang.String"

不适用于util.Date，hib默认认为util.Date是一个timestamp映射。如果不希望都持久化日期和时间，需要显式指定type="time",type="date"


jpa,对于util.Date,util.Calendar，要求@Temporal选择精度。
@Temporal(TemporalType.TIMESTAMP)
@Column(nullable=false,updatable=false)
private Date startDate;

hib annotation，默认TemporalType.TIEMSTAMP。
极少情况下，需要@org.hibernate.annotations.Type注解到一个属性。当编写自己的映射类型时，这就成了一个常见的扩展。

jpa.xml
<entity class="auction.model.Item" access="FIELD">
    <attributes>
        ...
        <basic name="startDate">
            <column nullable="false" updatable="false"/>
            <temporal>TIMESTAMP</temporal>
        </basic>
    </attributes>
</entity>

每个内建类型，都由org.hibernate.Hibernate定义常量。Hibernate.STRING。
。。。但是，5.2没了。Type里也没有。。好像常量变成了类了，org.hibernate.type包下各种类型的定义。对，每个xxxType都有INSTANCE。setParameter也接受TemporalType或者Type类型的变量。就是INSTANCE。

查询参数绑定：
session.createQuery("from Item i where i.desc like :desc").setParameter("desc", d, Hibernate.STRING).list()

5.2不接受String作为类型了。要么Type，要么TemporalType。///Hibernate.STRING应该是String吧。。或者是内部类Type？



5.3 自定义映射类型

<component name="homeAddress" class="Address">
    <property name="street" type="string" column="HOME_STREET"/>
    <...
</component>

这个值类型映射很简单，自定义的java类型的所有属性都被映射到内建的sql数据类型的列。
也可以选择利用一个定制的映射类型把它当作一个简单的属性来映射。
<property name="homeAddress" type="auction.persistence.CustomAddressType">
    <column name="home_streem"/>
    <column name="home_city"/>
</property>

把Address值类型和三个指定列之间转变和转换的任务转移给一个单独的类auction.persistence.CustomAddreeType。现在这个类负责加载和保存这个属性。

hib提供了定制映射类型会使用到的几个接口：
org.hibernate.usertype.UserType，基础扩展
.CompositeUserType，比UserType更多方法
.UserCollectionType，很少用，用来实现定制集合的接口。实现这个接口的定制映射类型不是在属性映射中声明，而是只对定制的集合映射有用。
.EnhanceUserType，扩展UserType，提供额外方法，这些方法用来将值类型和xml互相转换。或者启用一个定制的映射类型，在标识符和辨别标志映射中使用。
.UserVersionType,扩展UserType，额外方法用于实体版本映射的定制映射类型
.ParameterizedType,可以和其他接口合并，来提供配置设置，也就是元数据中定义的参数。例如，可以根据映射中的一个参数，编写一个知道如何把值转为欧元或美元的单个MoneyConverter。


案例
Bid定义了amount属性，Item定义了initialPrice属性，都是货币值，目前用BigDecimal来表示。通过big_decimal映射到numeric列。

现在拍卖要支持多种货币，就需要重构
一种方法是增加新属性到Bid,Item, amountCurrency,initialPriceCurrency，来表示货币类型(Currency)，使用hib的currency映射到sql的varchar。。。我们希望你永远不要用这种方法。

相反，应该创建一个封装了货币和金额的新类MonetaryAmount..这是一个领域模型类，不依赖任何Hib接口
public class MonetaryAmount implements Serializable {
    private final BigDecimal amount;
    private final Currency currency;
    public MonetaryAmount(BigDecimal amount, Currency currency) {
        this.=
        this.=
    }
    
    // getters,equals,hashCode
}

用这个新类替换Bid，Item中的BigDecimal

当前的数据库中保存了USD表示的金额。现在程序不再受限于单种货币。
。。但是，拍卖之类肯定是规定一种货币的吧，即使有其他货币，也是根据事先约定的汇率来兑换成指定货币的吧？查不到。
。。而且用Currency，怎么保存汇率？这个类完全没有用过。

当持久化MonetoryAmount时，需要把金额转为USD，从数据库加载时，把USD转为用户选择的货币。

public class MonetaryAmountUserType implements UserType {
    public int[] sqlTypes() {
        return new int[]{ Hibernate.BIG_DECIMAL.sqlType() };
    }
    public Class returnedClass() { return MonetaryAmount.class; }
    public boolean isMutable() { return false; }
    public Object deepCopy(Object value) { return value; }
    public Serializable disassemble(Object value) { return (Serializable) value; }
    public Object assemble(Serialiable cached, Object owner) { return cached; }
    public Object replace(Object original, Object target, Object owner) { return original;}
    public boolean equals(Objext x, Object y) {
        if (x==y) return true;
        if (x==null || y==null) return false;
        return x.equals(y);
    }
    public int hashCode(Object x) { return x.hashCode(); }
    public Object nullSafeGet(ResultSet resultSet, String[] names, Object owner) throws SQLException {
        BigDecimal valueUSD = resultSet.getBigDecimal(names[0]);
        if (resultSet.wasNull()) return null;
        Currency userCurrency = User.getPreferences().getCurrency();
        MonetaryAmount amount = new MonetaryAmount(valueUSD, "USD");
        return amount.convertTo(userCurrency);
。。。现时转换，，我还以为是保存货币类型到数据库。。而且哪有convertTo方法哦。
    }
    public Object nullSafeSet(PreparedStatement statement, Object value, int index) throws HibernateException, SQLException {
        if (value == null)
            statement.setNull(index, Hibernate.BIG_DECIMAL.sqlType());
...5.2  sqlType()返回的是 java.sql.Types中的 常量。所以能直接写Types.NUMERIC。
        else {
            MonetaryAmount anyCurrency = (MonetaryAmount)value;
            MonetaryAmount amountUSD = MonetaryAmount.convert(anyCurrency, Currency.getInstance("USD"));
            statement.setBigDecimal(index, amountUSD.getAmount());
        }
    }
}

sqlTypes()告诉hib要使用什么sql列类型。Hibernate.BIG_DECIMAL.sqlType()，或java.sql.Types.NUMREIC

hib对不可遍对象进行了微小的性能优化，如脏检查比较快照时，isMutable告诉hib这个类型不可变
由于不可遍，deepCopy返回实参。如果是可变对象，需要返回实参的一个副本，作为快照使用。

hib把MonetaryAmount放进二级高速缓存时，调用disassemble()方法，这是一种以序列化的形式保存信息的高速缓存
assemble是把高速缓存的数据转为MonetaryAmount，由于不可变，所以这2个方法很简单。

replace()来处理脱管对象状态的合并。

equals方法负责脏检查属性值。用当前属性和之前的快照进行对比。2个相等的值类型的hashCode必须相同。


现在Item的initialPrice属性映射如下：
<property name="initialPrice" column="initial_price" type="persistence.MonetaryAmountUserType"/>

定制的用户类型放入persistence包，这是程序的持久层的一部分，而不是领域模型或业务层的一部分

注解：
@org.hibernate.annotations.Type(
    type="persistence.MonetaryAmountUserType"
)
@Column(name="initial_price")
private MonetaryAmount initailPrice;

这是UserType的一种简单的转化。更复杂的：定制的映射类型可以执行验证；它可以把数据读取和写入到一个LDAP目录；它甚至可以从不同的数据库获取持久化对象。你主要受限于你的想象力。。。

现实应用中，更喜欢在数据库中表示货币金额和货币类型。特别是新建数据库，或可以快速转换的时候。
假设现在2个列可用，可以轻松保存MonetaryAmount。
第一种还是简单的<component>映射。
第二种，定制的映射类型。这里不是新编写定制类型，而是把前面例子中的一列转为2列。
简单的UserType实现的缺点在于，hib不知道有关MonetaryAmount内部单独属性的任何信息。查询引擎不知道如何查询amount或特定的currency。
如果需要hib查询的全部功能，就编写CompositeUserType,这个有点复杂的接口把MonetaryAmount的属性公开给hib查询。现在用这个更灵活的接口把它映射到2个列，实际上生成了组件映射的等价物。

public class MonetaryAmountCompositeUserType implements CompositeUserType {
    // public int[] sqlTypes()...
    public Class returnedClass...
    public boolean isMutable...
    public Object deepCopy...
    public Serializable disassemble...
    public Object assemble...
    public Object replace...
    public boolean equals...
    public int hashCode...

    public Object nullSafeGet(ResultSet resultSet, String[] names, SessionImplementor session, Object owner) throws SQLException {
        BigDecimal value = resultSet.getBigDecimal(names[0]);
        if (resultSet.wasNull) return null;
        Currency currency = Currency.getInstance(resultSet.getString(names[1]));
        return new MonetaryAmount(value, currency);
    }

    public void nullSafeSet(PreparedStatement statement, Object value, int index, SessionImplementor session) throws SQLException {
        if (value == null) {
            statement.setNull(index, Hibernate.BIG_DECIMAL.sqlType());
            statement.setNull(index+1, Hibernate.CURRENCY.sqlType());
        } else {
            MonetaryAmount amount = (MonetaryAmount) value;
            String currencyCode = amount.getCurrency().getCurrencyCode();
            statement.setBigDecimal(index, amount.getAmount());
            statement.setString(index+1, currencyCode);
        }
    }

    public String[] getPropertyNames() {
        return new String[] {"amount","currency"};
    }

    public Type[] getPropertyTypes() {
        return new Type[] {Hibernate.BIG_DECIMAL, Hibernate.CURRENCY};
    }

    public Objext getPropertyValue(Object component, int property) {
        MonetaryAmount ma = (MonetaryAmount) component;
        if (property == 0)
            return ma.getAmount();
        else
            return ma.getCurrency();
    }

    public void setPropertyValue(Object component, int property, Object value) {
        throw new UnsupportedOperationException("Immutable!");
    }
}

CompositeUserType不再需要sqlTypes()方法。
现在加载值很简单，把ResultSet中2个列转化为新MonetaryAmount实例中的2个属性值。
保存值涉及在预编译的语句中设置2个参数。
getPropertyNames公开值类型的属性。

iniitalPrice属性现在映射到2个列，因此在映射文件中要对2者都进行声明。第一列保存值，第二列保存货币类型。
<property name="initialPrice" type="persistence.MonetaryAmountCompositeUserType">
    <column name="initial_price"/>
    <column name="initial_price_currency"/>
</p

注解时，必须给这个属性声明几个列，无法多次使用@Column，需要一个hibernate的新注解。
@org.hibernate.annotations.Type(
    type="persistence.MonetaryAmountUserType"
)
@org.hibernate.annotations.Columns(columns = {
    @Column(name="initial_price")
    @Column(name="initial_price_currency", length=2)
})
private MonetaryAmount initialPrice;

在hibernate查询中，现在可以引用amount和currency,即使它们没有作为单独的属性出现在映射文件中。
from item i where i.initialPrice.amount>100.0 and i.initialPrice.currency='AUD'

..如果UserType的话，就没有办法这么用的，hibernate不知道类型里有什么。


一些表中存储美元，其他表中存储欧元。你仍然想给它编写单个定制的映射类型，使它可以进行任意的转换。这需要实现ParameterizedType接口。

public class MonetaryAmountConversionType implements UserType, ParameterizedType {
    private Currency convertTo;

    public void setParameterValues(Properties parameters) {
        this.convertTo = Currency.getInstance(parameters.getProperty("convertTo"));
    }

    public Object nullSafeGet(ResutleSet resultSet, String[] names, SessionImplementor session, Object owner) throws SQLException {
        BigDecimal value = resultSet.getBigDecimal(names[0]);
        if (resultSet.wasNull()) return null;
        Currency currency = Currency.getInstance(resultSet.getString(names[1]));
        return new MonetaryAmount(value, currency);
    }

    public void nullSafeSet(PreparedStatement statement, Object value, int index, SessionImplementor session) throws SQLException {
        if (value == null) {
            statement.setNull(index, Types.NUMERIC);
        } else {
            MonetaryAmount amount = (MonetaryAmount) value;
            MonetaryAmount dbAmount = MonetaryAmount.convert(amount, convertTo);
            statement.setBigDecimal(index, dbAmount.getAmount());
            statement.setString(index+1, dbAmount.getCurrencyCode());
        }
    }
}

hib在启动时用convertTo参数调用setParameterValues()来初始化这个类。

ParameterizedType需要参数来进行初始化，一种解决方案是type中嵌套属性
<property name="initialPrice">
    <column name="initial_price"/>
    <column name="initial_price_cur"/>
    <type name="persistence.MonetaryAmountConversionType">
        <param name="convertTo">USD</param>
    </t
</p

如果领域模型中有许多种货币时，这样很不方便，而且需要复制。更好的策略时使用类型的单个定义，用一个可以在所有映射种重用的唯一名称。通过<typedef>来完成。
<typedef class="persistence.MonetaryAmountConversionType" name="monetary_amount_usd">
    <param name="convertTo">USD</param>
</typedef>
<typedef class="persistence.MonetaryAmountConversionType" name="monetary_amount_eur">
    <param name="convertTo">EUR</param>
</typedef>

typedef是hibernate-mapping的一个子元素。

注解的typedef
@org.hibernate.annotations.TypeDefs({
    @org.hibernate.annotations.TypeDef(
        name="monetary_amount_usd",
        typeClass=persistence.MonetaryAmountConversionType.class,
        parameters = {@Parameter(name="convertTo", value="USD")}
    ),
    @org.hibernate.annotations.TypeDef(
        name="monetary_amount_eur",
        typeClass=persistence.MonetaryAmountConversionType.class,
        parameters = {@Parameter(name="convertTo" value="EUR")}
    )
})

这个注解元数据也是全局的。因此可以放在任何java类声明处，或者一个单独的package-info.java文件中。


使用
<property name="initialPrice" type="monetary_amount_usd">
    <column name="initial_price"/>
    <column name="initial_price_cur"/>
</property>

@org.hibernate.annotations.Type(type="monetary_amount_eur")
@org.hibernate.annotations.Columns({
    @Column(name="bid_amount"),
    @Column(name="bid_amount_cur")
})
private MonetaryAmount bidAmount;


映射枚举

public enum Rating {
    EXCELLENT, OK, BAD
}

public class Comment {
    ...
    private Rating rating;
    private Item auction;
}

Comment comm = new Comment(Rating.EXCELLENT, thisAuction);

现在必须持久化这个Comment实例和它的Rating。一种方法是使用枚举的实际名字，并把它保存到comments表中的一个varchar列。这个列将包含excellent，ok，bad。

编写UserType,让它可以加载和保存varchar支持的枚举。

现在使用EnhancedUserType接口，这个接口允许在xml表示模式中使用Comment实体，而不仅仅作为一个pojo。由于额外的ParametrizedType接口，你将要编写的实现可以支持任何varchar支持的枚举，而不仅仅是Rating

public class StringEnumUserType implements EnhancedUserType, ParameterizedType {
    private Class<Enum> enumClass;

    public void setParameterValues(Properties parameters) {
        String enumClassName = parameters.getProperty("enumClassname");
        try {
            enumClass = ReflectHelper.classForName(enumClassNames);
        } catch (ClassNotFoundException e) {
            throw new HibernateException("Enum class not found", e);
        }
    }

    public Class returnedClass() {
        return enumClass;
    }

    public int[] sqlTypes() {
        return new int[]{Hibernate.STRING.sqlType()};
    }

    public boolean isMutable
    + Object deepCopy
    + Serializable disassemble
    + Object replace
    + Object assemble
    + boolean equals
    + int hashCode

    public Object fromXMLString(String xmlValue) {
        return Enum.valueOf(enumClass, xmlValue);
    }

    public String objectToSQLString(Object value) {
        return '\'' + ((Enum)value).name() + '\'';
    }

    public String toXMLString(Object value) {
        return ((Enum)value).name();
    }

    public Object nullSafeGet(ResultSet rs, String[] names, Object owner) throws SQLException {
        String name = rs.getString(names[0]);
        return rs.wasNull() ? null : Enum.valueOf(enumClass, name);
    }

    public void nullSafeSet(PreparedStatement st, Object value, int index) throws SQLExceptiuon {
        if (value == null) {
            st.setNull(index, Hibernate.STRING.sqlType());
        } else {
            st.setString(index, ((Enum)value).name());
        }
    }
}

<typedef class="persistence.StringEnumUserType" name="ration">
    <param name="enumClassname">auction.model.Rating</param>
</typedef>

<property name="rating" column="rating" type="rating" not-null="true" update="false" access="field"/>

等级不可变，所以映射为update="false",并且直接字段访问(不可变属性没有setter)。


另一方面，可以依赖jpa提供程序持久化枚举。enum属性没有被标记为@Transient或者没有transient修饰，hib的jpa实现会保持这个属性的开箱即用，它有一个处理这个的内建类型。需要为这个内建类型指定enum在数据库中的表示法。有2种，最常见的是字符串表示法，有序表示法保存枚举选项的位置。例如1为excellent，2为ok，3为bad。数据库列也默认为一个数字列。通过@Enumerated注解改变枚举映射。

public class Comment {
    @Enumerated(EnumType.STRING)            // jpa的EnumType
    @Column(name="rating". nullable=false, updatable=false)
    private Rating rating;
    ...
}

<entity class="auction.model.Item" access="PROPERTY">
    <attributes>
        ...
        <basic name="rating">
            <column name="rating" nullable="false" updatable="false"/>
            <enumerated>STRING</enumerated>
        </basic>
    </attributes>
</e


hib查询种使用被枚举的类型
Query q = session.createQuery("from Comment c where c.rating=auction.model.Rating.BAD");

如果把枚举持久化为字符串，这个查询有效。如果选择了有序表示法，这个就无效了，必须使用一个参数绑定
Query q = session.createQuery("from Comment c where c.rating=:rating");
Properties params = new Properties();
params.put("enumClassname", "auction.model.Rating");
q.setParameter("rating", Rating.BAD, Hibernate.custom(StringEnumUserType.class, params));

Hibernate.custom()，把定制的映射类型转化为Hibernate Type，这是告诉Hibernate有关枚举映射，以及如何处理Rating.BAD值的一种简单办法。
。。5.2 没有这个方法了。

jpa并没有用于任意的和定制的查询参数的api，因此必须回退到Hibernate Session API，并创建一个Hibernate Query对象。


小结

4种基础的继承映射策略，把实体的继承层次结构映射到数据库，带有隐式多态的每个具体类一张表，带有联合的每个具体类一张表，每个类层次结构一张表和每个子类一张标准化表。



chapter 6 映射集合和实体关联

值类型的set,bag,list,map
值类型的对象不具备数据库同一性，它属于一个实体实例，其持久化状态被嵌入到所拥有实体的表行中。
如果实体类有一个值类型的集合，就需要一张额外的表，即所谓的集合表。
值类型没有标识符，它的生命期限由拥有它的实体实例的生命期限决定。值类型不支持共享的引用。

Item增加图片。图片只有通过货品才能访问，它不需要支持来自系统中任何其他实体的关联。程序通过Item来管理图片集合。

java领域模型中，集合属性的声明始终都是：private 集合接口 images = new 集合实现类();

我们不建议在构造函数或设置方法中延迟初始化集合。

hib支持重要的jdk集合接口。它知道如何持久化保存集合，映射，数组。每个接口都有一个Hibernate支持的匹配实现。
hib只包装已经在字段的声明中初始化的集合对象(或者如果是不正确的对象，有时就替换它)

<set>映射java.util.Set，使用util.HashSet初始化集合。无序，无重复，hib中最常见的持久化集合
可以使用<set>映射SortedSet接口，且<set>的sort属性可以设置成比较器或者用于内存排序的自然排序。使用TreeSet初始化集合。

<list>映射List,使用ArrayList初始化。
<bag>或<idbag>映射Collection，ArrayList初始化。
<map>映射Map，使用HashMap初始化属性
<map>可以映射SortedMap,标签的sort属性可以设置比较器或用于内存排序的自然排序。TreeMap实现。
<primitive-array>(对于java基础的值类型)和<array>(其他的一切)支持数组。但它们很少用在领域模型中，因为hib无法包装数组属性。没有字节码基础设施，就失去了延迟加载，以及为持久化集合优化过的脏检查，基本的便利和性能特性。

jpa没有列出所有这些选项，可能的标准集合属性类型是Set,List,Collection,Map。不考虑数组。
jpa仅指出集合属性持有对实体对象的引用，值类型的集合没有被标准化，未来版本将支持。

如果要映射Hibernate不直接支持的集合接口和实现，需要告诉hibernate定制集合的语义。
hibernate中的扩展点是PersistentCollection,通常扩展其中现有的PersistentSet，PersistentBag,PersistentList中的一个。定制持久化集合不太容易编写。


现在假设图片被保存在文件系统的某个地方，数据库中只保存了文件名。我们不讨论如何加载和保存图片，只关注映射。

映射Set
private Set images = new HashSet();

public Set getImages() { return this.images; }
public void setImages(Set images) { this.images = images; }

xml映射
<set name="images" table="item_image">
    <key column="item_id"/>
    <element type="string" column="filename" not-null="true"/>
</set>

集合无法包含重复元素，因此item_images集合表的主键是<set>声明中这2个列的复合：item_id和filename。


如果允许用户添加同一张图片呢？虽然这么做不太可能，但假设你允许这么做。
允许重复元素的无序集合被称为包(bag)，Collection直接有包的语义。有2种选择：
1 Collection接口编写集合属性。并用ArrayList初始化。hib中用<bag><idbag>元素映射集合。有一个内建的PersistentBag处理列表。但与包的约定一致，它忽略元素在ArrayList中的位置。
2 List接口编写集合属性，用ArrayList初始化。像前一个选项一样映射它，但是在领域模型类中公开一个不同的集合接口，这种方法有效，单不建议使用，因为使用这个集合属性，会导致客户端认为元素的顺序会始终被保存，但<bag><idbag>映射不保存顺序。

private Collection images = new ArrayList();
public Collection getImages() {}
public void setImages(Collection images) {}

还需要修改集合表以允许重复filename，表需要一个不同的主键。<idbag>映射添加了一个代理键列到集合表，很像用于实体类的合成标识符
<idbag name="images" table="item_image">
    <collection-id type="long" column="item_image_id">
        <generator class="sequence"/>
    </collection-id>
    <key column="item_id"/>
    <element type="string" column="filename" not-null="true"/>
</idbag>

主键是生成的item_image_id。
主键的native生成器不支持<idbag>映射，必须指定一种具体的策略。


映射list
更可能的场景是，你希望把添加图片到Item的顺序保存在那里。实现这个有许多种好方法，其中一种是使用真实的列表，而不是包。
private List images = new ArrayList();
getter
setter

<list>映射需要把一个索引列新增到集合表，索引列定义元素在集合种的位置。
<list name="images" table="item_image">
    <key column="item_id"/>
    <list-index column="position"/>
    <element type="string" column="filename" not-null="true"/>
</list>

xml dtd中也有index元素，用于和hibernate2兼容，建立使用这个新的list-index，作用相同，不容易混淆。

集合表的主键是item_id和position的复合。现在允许重复元素了。这和列表的语义一致。
持久化列表的索引从0开始，可以改变它，例如<list-index base="1" ... />
如果数据库中索引数字不连续，hib就会把空元素添加到java list中。

另一种方法，可以映射一个java数组，而不是列表。数组映射事实上和前面一个例子是等同的，除了使用不同的元素和属性名称之外(<array>,<array-index>)。但，hib很少用数组。


映射map
假设一件货品的图片除了文件名之外还有用户提供的名称。java中建模的一种方法是map，使用与键相同的名称以及与映射的值一样的文件名。

private Map image = new HashMap();
getter
setter

<map name="images" table="item_image">
    <key column="item_id"/>
    <map-key column="imagename" type="string"/>
    <element type="string" column="filename" not-null="true"/>
</map>

集合表的主键是item_id和imagename的复合。


排序集合和有序集合
上面的映射是无序的。如果像要按照图片的名称进行排序。

sorted,ordered对于hib持久化集合是指不同的东西。排序集合(sorted collection)是指用一个java比较器在内存中进行排序，有序集合(ordered collection)是指一个包含order by子句的sql查询在数据库级中排序。

private SortedMap images = new TreeMap();

<map name="images" table="item_image" sort="natural">
    <key column="item_id"/>
    <map-key column="imagename" type="string"/>
    <element type="string" column="filename" not-null="true"/>
</map>

通过指定sort="natural"，告诉hib使用SortedMap,并根据lang.String的compareTo()对图片名称进行排序。如果需要自定义的排序方法，可以在sort属性中指定实现java.util.Comparator的类名称。

<map name="images" table="item_image" sort="auction.util.comparator.ReverseStringComparator">
    <key column="item_id"/>
    <map-key column="imagename" type="string"/>
    <element type="string" column="filename" not-null="true"/>
</map>


下面映射util.SortedSet(包含一个util.TreeSet实现)：
<set name="images" table="item_image" sort="natural">
    <key column="item_id"/>
    <element type="string" column="filename" not-null="true"/>
</set>

包不可能被排序。list的顺序由列表索引决定。
。。sorted，ordered，这里是不能sorted。

另一种方法，不转换到Sorted*接口(和Tree*实现)，你或许想用一个链接Map，并在数据库端而不是内存中排序。
java中使用Map/HashMap. xml：
<map name="images" table="item_image" order-by="imagename asc"/>
    <key column="item_id"/>
    <map-key column="imagename" type="string"/>
    <element type="string" column="filename" not-null="true"/>
</map>

可以在order-by属性中包含sql函数
<map name="images" table="item_image" order-by="lower(filename) asc">

可以按集合表的任何列进行排序，hib内部使用LinkedHashMap,它是保存关键元素插入顺序的一个映射的变形。就是在集合加载期间，hib把元素添加到集合的顺序，就是你迭代的顺序。用Set也可以，hib使用LinkedHashSet。java中是一般的Set/HashSet，但hib内部使用LinkedHashSet的包装，通过order-by启用了排列。

<set name="images" table="item_image" order-by="filename asc">

。。就是order-by后，如果还是用HashMap的话，顺序会变得无序。所以得用LinkedHashMap，来保存order-by的顺序。

可以让hib在集合的加载期间为你排列包的元素。java的集合属性是Collection/ArrayList,或List/ArrayListt。hib内部使用ArrayList来实现一个保存了插入-迭代顺序的包
<idbag name="images" table="item_image" order-by="item_image_id desc">
    <collection-id type="long" column="item_image_id">
        <generator class="sequence"/>
    </collection-id>
    <key column="item_id"/>
    <element type="string" column="filename" not-null="trie"/>
</idbag>



6.2 组件的集合
可以把Image映射为实体类，并创建一个从Item到Image的1对多关系。但这没有必要，因为Image可以建模为一个值类型。
作为一个值类型，Image类定义了name,filename,sizeX,sizeY。

复合关联(UML中黑色菱形)。Image是Item的一个组件，Item负责Image实例的生命周期。
关联是多值的，即一个Item由0或1或多个Image实例。

Image是pojo，没有标识符属性，必须实现equals，hashCode，并比较name,filename,sizeX,sizeY属性，hib依赖这个等同性子程序检查实例中的修改。并非所有的组件都需要equals，hashCode，但我们建议所有都有。

映射集合
Item有保存了Image的Set。
组件的集合映射类似jdk类型的集合映射。唯一区别是<composite-element>代替<element>
有序图片集合(内部使用LinkedHashSet)可以这样映射：
<set name="images" table="item_image" order-by="imagename asc">
    <key column="item_id"/>
    <composite-element class="Image">
        <property name="name" column="imagename" not-null="true"/>
        ..
        <property name="sizeY" column="sizey" not-null="true"/>
    </composite-element>
</set>

这是一个值类型的集合，所以集合表的主键是所有元素列的一个复合。因为所有属性都出现在主键中，所以所有属性都not-null.复合主键任何列都不能为空，这可能是该映射的一个缺点。

启用双向导航
从Item到Image的关联是单向的。可以通过Item实例访问集合并迭代。
从一张图片导航会一件货品没有意义，但有时候访问后退指针就像访问anImage.getItem()一样-可能比较方便。。如果把parent元素添加到映射，hibernate就会为你填入这个属性
<set name="images" table="item_images" order-by="image_name asc">
    <key column="item_id"/>
    <composite-element class="Image">
        <parent name="item"/>
        <property name="name"...
        ..
    </c
</s

真正的双向导航是不可能的，你无法单独获取一个Image，然后导航回它的Item。
你可以通过查询它们(?item?image)来加载Image实例，但hql和criteira中，这些image对象都没有引用它们的所有者。
。。就是item和image是没有关联关系的。


如果任意属性列都是可为空的，image集合表就需要一个不同的主键。
类似<idbag>提供的那个额外的代理标识符属性，现在代理键列也要派上用场了。
如果存在<idset>，那么这个允许重复就和集的概念冲突了。

hib没有提供除了<idbag>以外的任何代理标识符集合。

因此要把java属性改为Collection
private Collection images = new ArrayList();

<idbag name="images" table="item_image" order-by="image_name asc">
    <collection-id type="long" column="item_image_id">
        <generator class="sequence"/>
    </collection-id>
    <key column="item_id"/>
    <composite-element class="Image">
        <property name="name" column="imagename"/>
        <property name="filename" column="filename" not-null="true"/>
        <...
    </c
</idbag>

..key是外键,id是主键。


转换到不同主键的另一种方法是map，可以从image类中移除name属性，并用图片名称作为map的键。
<map name="images" table="item_image" order-by="imagename asc">
    <key column="item_id"/>
    <map-key type="string" column="imagename"/>
    <composite-element class="Image">
        <property name="filename" column="filename" not-null="true"/>
        ..
    </c
</m

表的主键现在是item_id和imagename的复合。

<composite-element>中的属性不限于简单类型，它可以包含其他组件，通过<nested-composite-element>映射，甚至对实体的many-to-one关联。但是它无法拥有集合。包含多对一关联的复合元素很有用。


6.3 注解映射集合
本书编写时，jpa还没有这些。但hibernate有了。

hib annotations包对包含值类型元素的集合映射支持非标准的注解，主要是org.hibernate.annotations.CollectionOfElements。


@org.hibernate.annotations.CollectionOfElements(
    targetElement = java.lang.String.class
)
@JoinTable(
    name="item_image",
    joinColumns=@JoinColumn(name="item_id")
)
@Column(name="filename", nullable=false)
private Set<String> images = new HashSet<String>();

item_image有2个列，一起形成复合主键。hib自动侦测元素类型，所以如果没有使用泛型，就需要使用targetElement。


List，需要org.hibernate.annotations.IndexColumn，指明索引列。索引的基数默认0
@org.hibernate.annocations.CollectionOfElements
@JoinTable(name="item_image", joinColumns=@JoinColumn(name="item_id"))
@org.hibernate.annotations.IndexColumn(name="position", base=1)
@Column(name="filename")
private List<String> images = new ArrayList<String>();

如果忘记了索引列，这个列表就会被当作一个包集合处理，相当于<bag>


对于值类型的集合，通常用<idbag>在集合表中获得一个代理主键。值类型元素的<bag>没有真正起作用，java中允许重复，但数据库中不行。

映射持久化的map，需要org.hibernate.annotations.MapKey
@org.hibernate.annotations.CollectionOfElements
@JoinTable(name="item_image", joinColumns=@JoinColumn(name="item_id"))
@org.hibernate.annox.MapKey(columns=@Column(name="imagename"))
@Column(name="filename")
private Map<String, String> images = new HashMap<String, String>();

如果忘了映射键，这个映射的键就会自动映射到列MAPKEY。

map的key可以是嵌入的类，需要指定多个保存可嵌入组件的单独属性的映射键列。


排序，有序集合

@org.hib.anno.CollectionOfElements
@JoinTable(name="item_image",joinColumns=@JoinColumn(name="item_id"))
@Column(name="filename", nullable=false)
@org.hibernate.anno.Sort(type=org.hib.anno.SortType.NATURAL)
private SortedSet<String> images = new TreeSet<String>();

SortType.COMPARATOR


映射，集，包，都可以在加载时由数据库排序
@org.hib.anno.CollectionOfElements
@JoinTable(name="item_image", joinColumns=@JoinColumn(name="item_id"))
@Column(name="filename", nullable=false)
@org.hibernate.anno.OrderBy(clause="filename asc")
private Set<String> images = new HashSet<String>();

注解相当于xml映射。


映射嵌入式对象的集合

类上增加@Embeddable来启用嵌入

@Embeddable
public class Image {
    @org.hib.ann.Parent
    Item item;

    @Column(length=255, nullable=false)
    private String name;
    @Column(length=255, nullable=false)
    - String filename;
    @Column(nullable=false)
    - int sizeX;
    @Column(nullable=false)
    - int sizeY;

    // constructor,accessor,equals,hashCode
}

因为集合表中所有组件列都是复合主键，所以notnull很重要。
现在可以把这个组件嵌入到一个集合映射中，甚至覆盖列定义(下面的例子中，你覆盖了组件集合表的单个列的名称，其他列都是默认的策略)
@org.hib.anno.CollectionOfElements
@JoinTable(name="item_image", joinColumns=@JoinColumn(name="item_id"))
@AttributeOverride(name="element.name", column=@Column(name="imagename",length=255,nullable=false))
private Set<Image> images = new HashSet<Image>();


为了避免不可为空的组件列，集合表中需要一个代理主键，就像<idbag>。通过@CollectionId扩展

@org.hib.anno.CollectionOfElements
@JoinTable(
    name="item_image",
    joinColumns=@JoinColumn(name="item_id")
)
@CollectionId(
    columns = @Column(name="item_image_id"),
    type=@org.hibernate.anno.Type(type="long"),
    generator="sequence"
)
private Collection<Image> images = new ArrayList<Image>();



映射父/子关系

实体间的一值或多值关系。
。。一值是上面的element,多值是composite-element，不过实体间不太可能多值吧。。

实体中共享的引用，独立的生命周期使得这个关系映射复杂化了。

Item与Bid实体间的关系。

如果用过ejb cmp2.0，就会熟悉托管关联/托管关系的概念。cmp关联被称作容器托管的关系是有理由的。cmp中的关联天生就是双向的，对关联的一侧所作的改变，会立即影响另一侧。如，调用bid.setItem(item),容器会自动调用item.getBids().add(bid).

面向pojo的持久化引擎(如hib)不实现托管关联，且pojo标准(如ejb3.0，jpa)不需要托管关系。
与ejb2.0 cmr(container managed relationship)相反，hib和jpa关联天生都是单向的。
bid到item的关联与item到bid的关联，是不同的关联。这是好事，否则，你的实体类就不能在一个运行时容器之外使用。。。就是这个自动双向关联是容器的功劳，所以抛开容器，是无法自动双向关联的。


多样性
在描述关联和分类关联时，通常使用术语-多样性，在例子中，多样性是2小块信息：
一个item可以有不止一个bid吗？
一个bid可以有不止一个item吗？

看领域模型之后，就可以推断bid到item的关联是多对一的。关联有方向性，所以item到bid是1对多。


从Bid到Item的关联(反之亦然)是一种最简单的可能实体关联的例子。
。。？？1to1呢。。

2个类中有2个属性，一个是引用的集合，一个是单个引用。

public class Bid {
    private Item item;
    // ...
}

<class name="Bid" table="BID">
    ..
    <many-to-one name="item" column="item_id" class="Item" not-null="true"/>
</c


public class Bid {
    ...

    @ManyToOne(targetEntity = auction.model.Item.class)
    @JoinColumn(name="item_id", nullable=false)
    private Item item;
}

2个可选元素：
targetEntity,它对于字段类型来说是隐式的，显示的targetEntity在更复杂的领域模型中很有用，比如，在返回委托类时。
@JoinColumn,如果没有什么外键列的名字，hib默认使用目标实体名称和目标实体数据库标识符属性名称的一个组合。这里时item和id，中间一条下划线。
@ManyToOne中的optional="false"也会有一个not null约束。


把单向变成双向

public class Item {
    private Set bids = new HashSet();
    // accessor, addBid(bid){bid.setItem(),bids.add(bid)}
}

addBid实现托管关联。

<class name="Item" table="item">
    <set name="bids">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </set>
    ...
</class>

这里使用了<one-to-many>而不是之前的<element><composite-element。这表明集合没有包含值类型实例，而是包含了对实体实例的引用。
hib知道集合的表(。应该是指<set>的表)与目标实体类被映射到的表(。item的表)相同，所以不需要table属性。

<key>元素定义的列映射是bid表的外键列item_id。

not null="true" 没有了。

现在2个不同的单向关联映射到同一个外键列，哪一侧控制这个列呢？
运行时，同一个外键值有2种内存表示法：Bid的item属性，和Item中bids集合的一个元素。

bid.setItem(item);
bids.add(bid);
这段代码很好，但这种情况下，hib检查到内存持久化实例的2处变化。从数据库来看，只需要修改一个值就能体现这些变化。

需要告诉hib这个重复，它没有办法自动侦测到。

在关联映射中还需要做一件事情，就是使它成为真正的双向关联映射。inverse属性告诉hib，集合是<many-to-one>关联在另一侧的一个镜像：
<class name="Item" table="item">
    <set name="bids" inverse="true">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </>
</>

如果没有inverse属性，hib会试图执行2个不同的sql，更新同一个外键列。
通过inverse="true"，显式告诉hib，关联的哪一端不应该与数据库同步。，这个例子中，告诉hib把关联的Bid端发生的变化传播到数据库，忽略只对bids集合所作的变化。
现在，item.getBids().add(bid),没有使任何变化持久化。

<many-to-one>没有inverse，但可以用update="false",insert="false"来映射它，以忽略任何update，insert语句，然后set段是非反向的，这样，set段用于外键列的插入或更新。


jpa注解
public class Item {
    @OneToMany(mappedBy = "item")
    private Set<Bid> bids = new HashSet<Bid>();
}

mappedBy相当于inverse，但是它必须指定目标实体的反向属性。


父子的概念意味着一个照顾另一个。
Item item = new Item();
Bid bid = new Bid();
item.addBid(bid);
session.save(item);
session.save(bid);

session.save的第二次调用看起来是多余的。
但，由于2个类都是实体，所以它们的实例的生命周期是各自独立的，实体间的关系不影响它们的生命周期。如果Bid是值类型，那么Bid实例的状态和它的实体Item的状态相同。但这里Bid是一个单独的实体，有着它完全独立的状态，有3种选择:
1 自己负责独立的实例，必要时在Bid对象上执行save，delete
2 使Bid类变成值类型，用<composite-element>映射集合，获得隐式的生命周期，但失去了实体的其他方面，例如对实体的可能的共享引用。
3 hib提供传播性持久化。是一个可选的特性。

<class name="Item" table="">
    <set name="bids" inverse="true" cascade="save-update"/>
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </set>
</

cascade有方向性。

jpa
public class Item {
    @OneToMany(cascade={CascadeType.PERSIST, CascadeType.MERGE}, mappedBy="item")
    private Set<Bid> bids = new HashSet<Bid>();
}

Item item = new Item();
Bid bid = new Bid();
item.addBid(bid);
entityManager.persist(item);

cascade和inverse无关。
这2者都不会出现在值类型的集合或任何其他值类型映射种，这些规则隐含在值类型的特性中。


级联删除
<set name="bids" inverse="true" cascade="save-update,delete">

jpa
@OneToMany(cascade={CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE}, mappedBy="item")
private Set<Bid> bids = new HashSet<Bid>();


delete-orphan：孤儿删除，孤子删除




chapter 7 高级实体关联映射

单独一章讨论高级实体映射，原因之一是它们中大部分是少见的，或者至少是可选的。
只使用组件映射和多对一的实体关联是绝对有可能的。
有些怪异的映射特性大部分时候应该谨慎使用，尽量不用。


单值的实体关联
User，Address之间的关系最好用<component>映射来表示 ，这通常是表示1对1关系最简单的方法。

但如果像要Address的专用表，并把User和Address都映射为实体该怎么办？都是实体时，可以共享引用，比如Shipment类可以有一个Address的引用。

Address做为独立实体的映射：
<class name="Address" table="address">
    <id name="id" column="address_id">
        <generator ../>
    </id>
    <property name="street" column="street"/>
    <...city
    <property zipcode
</class>


创建从其他实体到这个列的关联映射，有几种选择，首要的是主键1对1关联。

共享的主键关联
由主键关联而相关的2张表中的行共享相同的主键值。这种方法的主要困难在于，确保被关联的实例在保存对象时分配到了相同的主键值。
把实体关联映射到共享主键实体的xml映射元素是<one-to-one>。
增加一个属性
public class User {
    private Address shippingAddress;
}

User的xml配置中增加
<one-to-one name="shippingAddress" class="Address" cascade="save-update" />

启用一个特殊的标识符生成器foreign
创建Address和User之间的这个标识符绑定，第一步是双向关联，添加user到Address
public class Address {
    private User user;
}
Address配置中增加：
<one-to-one name="user" class="User" constrained="true" />
这个映射不仅使关联变成双向，而且通过constrained="true"，添加了把Address表的主键链接到USERS表主键的外键约束。现在数据库保证了ADDRESS行的主键引用有效的USERS主键。(作为附带作用，现在hib可以在加载出货地址是启用用户的延迟加载，外键约束意味着用户必须对特定的出货地址而存在，因此代理可以不用命中数据库而开启。如果没有这项约束，hib就必须命中数据库去发现是否由对应于这个地址的用户，代理也将成为多余。)

现在可以给Address对象使用特殊的foreign标识符生成器了。
<class name="Address" table="">
    <id name="id" column="address_id">
        <generator class="foreign">
            <param name="paoperty">user</param>
        </g
    </id
    <one-to-one name="user" class="" constrained="true"/>
</

当Address被保存时，从user属性中提取主键。
USERS表中USER_ID是主键
ADDRESS表中ADDRESS_ID是主键和外键。

User u = new User();
Address a = new Address();
u.setShippingAddress(a);
a.setUser(u);
session.save(u);


注解的共享主键
jpa @OneToOne。支持1对1，要映射User类中的shippingAddress的关联为共享主键关联，还需要@PrimaryKeyJoinColumn

@OneToOne
@PrimaryKeyJoinColumn
private Address shippingAddress;

如果通过复合主键映射，就需要用@PrimaryKeyJoinColumns代替(复数多个s)

jpa xml
<entity-mappings>
    <entity class="auction.model.User" access="FIELD">
        <one-to-one name="shippingAddress">
            <primary-key-join-column/>
        </o
    </e
</

jpa规范没有包括处理共享主键生成问题的标注方法。这意味着在保存Address实例的标识符值(到被链接到User实例的标识符值)之前，你要负责正确地设置它。
hib由个扩展注解，用于可以通过Address实体使用的定制标识符生成器
@Entity
@Table(name="address")
public class Address {
    @Id @GeneratedValue(generator="myForeignGenerator")
    @org.hibernate.annotations.GenericGenerator(
        name="myForeignGenerator",
        strategy="foreign",
        parameters=@Parameter(name="property", value="user")
    )
    @Column(name="address_id")
    private Long id;

    private User user;
}


1对1的外键关联
共享的主键一对一并不稀奇，但相对少见。在许多模式中，对一(to-one)的关联都是用外键字段和唯一约束来表示。

改变从User到Address的映射，现在不用共享主键，而是在Users表中增加一个shipping_address_id列
<class name="User" table="">
    <many-to-one name="shippingAddress" class="Address" column="shipping_address_id" cascade="save-update" unique="true"/>
</c

shipping_address_id是唯一外键，保存Address的主键。
mony-to-one + unique 就是1对1。

从Address到User要使用one-to-one
<one-to-one name="user" class="User" property-ref="shippingAddress"/>

告诉hib，Address类的user属性是关联另一端的一个属性的反向。现在可以调用add.getUser()来访问出货地址的用户。没有额外的列或者外键约束，hib替你管理这个指针。


注解映射外键
和之前相比，主要是@JoinColumn代替了@PrimaryKeyJoinColumn

public class User {

    @OneToOne
    @JoinColumn(name="shipping_address_id")
    private Address shippingAddress;

}

如果要变成双向，Address还需要@OneToOne

public class Address {
    @OneToOne(mappedBy="shippingAddress")
    private User user;
}
mappedBy作用和property-ref一样：关联的一个简单的反向声明。

jpa xml
<entity-mappings>
    <entity class="auction.model.User" access="FIELD">
        ...
        <one-to-one name="shippingAddress">
            <join-column name="shipping_address_id"/>
        </
    </e
    <entity class="auction.model.Address" access="FIELD">
        <one-to-one name="user" mapped-by="shippingAddress"/>
    </e
</e


现在已经完成了2个基础的单端关联映射，一个带有共享主键，一个带有外键引用。
最后一个更怪异一些：在另一张表的帮助下映射一对一的关联。

场景：员工和桌子的关系。桌子可能被闲置，员工可能在加办公。Persona和Desk就是可选的一对一关联。

第一种：Person，Desk被映射到2张表，其中一张表(假设是PERSON)由一个外键列，引用另外一张带有额外唯一约束(以便2个人不会被分配到一张桌子)的表。如果外键列可为空，这个关系就是可选的。
第二种，意识到人员和桌子之间的分配需要另外一张表来表示分配。在这个设计中，这张表只有2列，Person_id,Desk_id.这些外键列的多样性通过unique约束--这样人或桌子只能被分配一次。


现在，Shipment要和Item进行关联，以便能查看状态。

表示从Shipment到Item关联的属性称作auction:
public class Shipment {
    private Item auction;
}

因为必须用一个外键列映射这个关联，因此在xml中你需要<many-to-one>映射元素。然而，外键列不在shipment表中，而是在item_shipment联结表中。通过join映射元素把它移到那里
<class name="Shipment" table="">
    <id name="id" column="shipment_id">...</>
    <join table="item_shipment" optional="true">
        <key column="shipment_id"/>
        <many-to-one name="auction" column="item_id" not-null="true" unique="true"/>
    </join>
</c

item_shipment有2个列，shipment_id和item_id，item_id列是唯一的，特定的货品正好可以被分配给一批出货。由于联结表的主键是shipment_id，它使得这个列也变成唯一，这样就保证了Shipment和Item之间一对一的多样性。

<join>中optional="true"，告诉hib它应该只有当这个映射分组的属性为非空时，才把行插入到联结表中。如果需要插入行，那么item_id的not null约束就得到应用。

可以在另一端使用相同的方法，把这个关联映射为双向。然而，可选的一对一关联大多数时候都是单向的。


jpa也对实体支持称为二级表的关联联结表
通过注解把可选的1对1关联映射到一个中间的联结表
public class Shipment {
    @OneToOne
    @JoinTable(
        name="item_shipment",
        joinColumns=@JoinColumn(name="shipment_id"),
        inverseJoinColumns=@JoinColumn(name="item_id")
    )
    private Item auction;
}
不必指定shipment_id列，因为它自动被认为是联结列，它是shipment表的主键列。
。。？就是joinColumns可以省略？在这个列的名字==另一张表主键列名字的情况下？..还是说Item端不需要任何配置？

另一种方法，可以把jpa实体的属性映射到不止一张表。
首先，需要给实体声明二级表
@Entity
@Table(name="shipment")
@SecondaryTable(name="item_shipment")
public class Shipment {
    @Id @GeneratedValue
    @Column(name="shipment_id")
    private Long id;

}

@SecondaryTable也支持用属性声明外键列名---相当于xml的<key column=..>和@JoinTable中的joinColumn(s).
如果没有指定，就使用实体的主键列名，这个例子中 是shipment_id

auction属性映射是一个@OneToOne，引用item表的外键列被移到中间的二级表
public class Shipment {
    @ManyToOne
    @JoinColumn(table="item_shipment", name="item_id")
    private Item auction;
}

如果不止一个属性必须被移到二级表的时候，给实体声明二级表就很有用。


7.2 多值的实体关联
一对多关联是涉及集合的一种最重要的实体关联。如果简单的双向多对一或一对多能够完成任务时，我们不鼓励使用更加怪异的关联方式。
多对多关联始终可以表示为对中间表的2个多对一关联。这个模型通常更易于扩展，因此我们趋于不再应用中使用多对多关联。
也要记住，如果不想的话，你不必映射实体的任何集合，你可以始终编写显示查询来代替通过迭代的直接访问。


一对多关联
前面的父/子关系时一个双向的关联，通过<one-to-many><many-to-one>映射。这个关联的多端在java中用Set实现。

考虑bag
对双向的一对多关联使用<bag>是可行的。
bag有着可以用于双向一对多实体关联的所有集合的最有效的性能特征(换句话说，如果集合端是inverse="true"的话)。默认情况下，hib中的集合只有在当它们被第一次访问时才加载。因为bag不必维护其元素的索引(如List)，或是检查重复的元素(如Set)，可以添加新元素给bag，而不触发加载。
。。。真的？
如果要映射一个可能很大的实体引用的集合，这就是一项重要的特性。
另一方面，无法同时即时抓取bag类型的两个集合(例如，Item的bids和images都是一对多的bag)
。。。？？？？？？？？？？？？？？？？？？？

一般来说，对于一对多的关联，我们认为bag是它最好的反向集合。
。。上面还有inverse，八成这里是说 inverse="true"情况下，bag是最好的集合？

为了使用bag来双向一对多，必须用Collection和ArrayList来替换Item中bids集合的类型

<class name="Bid" table="">
    <many-to-one name="item" column="item_id" class="Item" not-null="true"/>
</class>
<class name="Item" table="">
    <bag name="bids" inverse="true">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </
</

将<set>换成<bag>，其他不变。

jpa中，所有Collection和List属性都被认为都包语义，下面等同于上面的xml配置
public class Item {
    @OneToMany(mappedBy="item")
    private Collection<Bid> bids = new ArrayList<Bid>();

}

bag允许重复。但，重复是因为你将一个特定引用数次添加到bids中，不应该这么做。
而且，由于inverse="true"，hibernate建立关联的时候会忽略它。


单向和双线的列表
如果你需要真正的列表来保存元素在集合中的位置，就必须在另一列保存该位置。
对于一对多，应该把Item中bids属性改为List，通过ArrayList初始化。如果不想把这种行为公开给类的客户端，就保留之前的Collection接口。

<class name="Item" table="item">
    <list name="bids">
        <key column="item_id"/>
        <list-index column="bid_position"/>
        <one-to-many class="Bid"/>
    </
</
保存额外位置的列是bid_position

这个映射还没有完成。考虑item_id外键列，它是not null(出价必须引用货品)。第一个问题在于这个映射中没有指定这个约束，而且由于这个映射是单向的(集合端没有inverse)，所以只好假设没有对面端被映射到同一个外键列(可以在那里声明)。

<key column="item_id" not-null="true"/>

属性必须在key映射中，而不是一个可能嵌套的<column>元素中。每当有实体引用的非反向集合(大多数时候是包含list,map,array的一对多关联)，并且目标表中的外键联结列不可为空时，就需要让hibernate知道这些。

用Bid的item属性让这个变成双向。
hib会忽略反向集合的状态，但是这次，集合包含了更新数据库需要的信息：它的元素的位置。
如果只有每个Bid实例的状态被认为时同步的，集合又是反向的并且被忽略，那么hib就没有值给bid_position列了。

如果通过被索引的集合映射双向的一对多实体关联(映射和数组也是这样)，就必须转换反向端。不能使被索引的集合变成inverse="true"。集合负责同步状态。1端(Bid)必须变成反向。多对一映射没有inverse，所以需要模拟
。。Bid是多端吧。

<class name="Bid" table="">
    <many-to-one name="item" column="item_id" class="Item" not-null="true" insert="false" update="false"/>
</class>

insert，update2个属性一起使用，使得属性变成了只读，关联的这一端被忽略任何写操作。现在这一段不会同步任何状态。

从set/bag转到list(或任何其他被索引的集合)，这个是必要的条件。

jpa：
public class Item {
    @OneToMany
    @JoinColumn(name="item_id", nullable=false)
    @org.hibernate.annotations.IndexColumn(name="bid_position")
    private List<Bid> bids = new ArrayList<Bid>();

}

这个映射非反向的，因为没有mappedBy属性。
由于jpa不支持持久化的被索引列表(只能在加载时用@OrderBy进行排序)，需要给索引支持添加一个hib扩展注解。

public class Bid {
    @ManyToOne
    @JoinColumn(name="item_id", nullable=false, updatable=false, insertable=false)
    private Item item;

}


利用联结表的可选一对多关联。

Item类增加一个buyer属性(User类型)，保存出价胜出的用户。

从User类看来，这个关联是1对多的。uml中是0..*(1个User有[0,N]个物品)，表明引用是可选的，这不太影响java领域模型，但对底层表有影响。
你希望item有个buyer_id列，这个列可为空(只要拍卖仍在继续)。
外键列为null，并应用约束("仅当拍卖终止时间没到或还没有出价时才允许为null")。
我们总是努力在关系数据库中避免可为空的列。未知的信息降低了所保存数据的质量。
我们无法断言不知道的东西。
在实际应用中。许多开发人员和数据库管理员没有创建正确的约束，而是依赖(经常出现bug的)应用程序代码来提供数据的完整性。

可选的实体关联(1-1or1-多)，在sql数据库中用联结表表示得最好。

之前在1-1关联添加过一张联结表，为了确保1-1的多样性，在联结表的2个外键列上都应用了unique约束。目前情形中，你拥有一对多的多样性，因此只有item_buyer表的item_id列是唯一的。

User类的boughtItems集合
<set name="boughtItems" table="item_buyer">
    <key column="user_id"/>
    <many-to-many class="Item" column="item_id" unique="true"/>
</set>

table：
item：item_id<PK>,seller_id<FK>,name,desc,initial_price...
item_buyer: item_id<PK,FK,UNIQUE>,user_id<PK,FK>
Users: user_id<PK>,firstname,lastname...

Set作为集合类型。集合表是联结表item_buyer，主键是user_id,item_id的复合。

因为常规的<one-to-many>不知道任何有关联结表的信息，因此需要<many-to-many>，并且在引用目标实体表的外键列上加上unique约束，来强制1对多。

可以用Item的buyer属性把这个关联映射为双向的。如果没有联结表，就要在item中增加一个buyer_id外键列添加<many-to-one>，如果有联结表，则必须把这个外键列移到联结表里面。这可以通过<join>映射。
<join table="item_buyer" optional="true" inverse="true">
    <key column="item_id" unique="true" not-null="true"/>
    <many-to-one name="buyer" column="user_id"/>
</join>
这里有2个细节：
1 关联是可选的。你告诉hib如果被分组的属性为null，就不要把行插入到联结表。
2 这是个双向的实体关联。和往常一样，一端必须为反向的。你可以选择了join为反向的。现在hib利用集合状态更新数据库，忽略Item.buyer属性。只要集合不是被索引的变量(list,map,array)，就可以通过声明集合inverse="true"来反向。


jpa使用二级表来作为联结表进行一对多关联。

@Entity
public class Item {
    @ManyToOne
    @JoinTable {
        name="item_buyer",
        joinColumns={@JoinColumn(name="item_id")},
        inverseJoinColumns={@JoinColumn(name="user_id")}
    }
    private User buyer;

}
编写本书时，这个映射还有限制：不能把它设置为optional="true"，因而user_id列是可为空的。
如果试图在@JoinColumn上添加nullable="false"，hib就会认为你需要整个buyer属性永远不为null。
此外，联结表的主键现在只有item_id列。这样很好，因为你不想在这个表中有重复的货品。

。。那为什么上面的item_buyer是item_id,user_id2个列组成的主键？为什么不是单item_id组成的主键？

为了变成双向，需要User上添加一个集合，并使用mappedBy使它反向。
@OneToMany(mappedBy="buyer")
private Set<Item> boughtItems = new HashSet<Item>();


多对多关联
前面介绍了<many-to-many>元素，@JoinTable是注解中的等价物。
现在来一个真正的多对多

Category(种类)和Item之间的多对多关联。

单向多对多不比之前的更难。
Category有一组Items，你可以如下映射：
<set name="items" table="category_item" cascade="save-update">
    <key column="category_id"/>
    <many-to-many class="Item" column="item_id"/>
</set>

联结表有2列，category和item表的外键。主键是这2列的复合。

jpa，
@ManyToMany
@JoinTable(
    name="category_item",
    joinColumns={@JoinColumn(name="category_id")},
    inverseJoinColumns={@JoinColumn(name="item_id")}
)
private Set<Item> items = new HashSet<Item>();

hib xml中，也可以在联结表中通过一个单独的主键列切换到<idbag>
<idbag name="items" table="category_item" cascade="save-update">
    <collection-id type="long" column="category_item_id">
        <generator class="sequence"/>
    </collection-id>
    <key column="category_id"/>
    <many-to-many class="Item" column="item_id"/>
</idbag>

主键是一个代理键category_item_id,因此允许重复的联结。

hib @CollectionId
@ManyToMany
@CollectionId(
    columns=@Column(name="category_item_id"),
    type=@org.hibernate.annotations.Type(type="long"),
    generator="sequence"
)
@JoinTable(
    name="category_item",
    joinColumns={@JoinColumn(name="category_id")},
    inverseJoinColumns={@JoinColumn(name="item_id")}
)
private Collection<Item> items = new ArrayList<Item>();


jpa xml
<entity class="auction.model.Category" access="FIELD">
    <many-to-many name="items">
        <join-table name="category_item">
            <join-column name="category_id"/>
            <inverse-join-column name="item_id"/>
        </
    </
</

甚至可以在多对多中切换到一个被索引的集合(map或list)。下面在hib xml中映射一个list
<list name="items" table="category_item" cascade="save-update">
    <key column="category_id"/>
    <list-index column="display_position"/>
    <many-to-many class="Item" column="item_id"/>
</list>

联结表的主键是category_id，display_posistion列的复合。这个映射保证了每个item在category中的位置都是持久化的。

注解list：
@ManyToMany
@JoinTable(
    name="category_item",
    joinColumns={@JoinColumn(name="category_id")},
    inverseJoinColumns={@JoinColumn(name="item_id")}
)
@org.hibernate.annotations.IndexColumn(name="display_position")
private List<Item> items = new ArrayList<Item>();

jpa只持有有序集合(通过一个可选的@OrderBy注解或按主键排列)，因此需要使用hib扩展。
如果没有@IndexColumn，list会通过bag语义保存(不保证持久化顺序)



双向关联的一端必须被映射为反向，因为你已经对一个或多个外键列命名了2次。
。。。？是说外键只需要一个实体来管理就行？。不一定必须吧。不写也不错啊。只不过代码复杂一点。。
。一端 是 1端还是某一端？

双向多对多关联应用同样的原则，链接表的每一行都由2个集合元素组成，关联的两端各一个元素。

item和category之间的关联，在内存中由Category的items集合中的Item实例表示，而且还通过Item的categories集合中的Category实例表示。

如往常一样，双向关联要求两端都设置。
。。？inverse后，不是只需要多端设置吗？。。不过内存中的关联表示需要2端都设置。 sql中的只需要多端设置。

映射双向的多对多关系时，必须用inverse="true"声明关联的一端，来定义哪一端的状态用来更新联结表。

Category的items的映射,可以重用上面的单向多对多的映射：
<class name="Category" table="category">
    <set name="items" table="category_item" cascade="save-update">
        <key column="category_id"/>
        <many-to-many class="Item" column="item_id"/>
    </
</

另一端：
<class name="Item" table="">
    <set name="categories" table="category_item" inverse="true" cascade="sace-update">
        <key column="item_id"/>
        <many-to-many class="Category" column="category_id"/>
    </
</

inverse="true"，告诉hib忽略对categories集合所作的改变。

对集合2端都启用了cascade="save-update"，我们推想这是不切实际的。另一方面，级联选项all,delete,delete-orphans对于多对多的关联是没有意义的。
。。baidu不到。。双端save-update不切实际，估计是说递归save？但hib不会那么弱啊。还是说，现实中，不会双端都被save？。。。没有意义，应该是删除的问题，由于多对多，所以当你删除一条数据时，如果双端都有级联删除，估计会删除一大片的数据，都被级联删除了。如果单向级联，会导致 本类的其他对象 搜索对面时， 根据ID找不到对应数据。


jpa 非反向端
@ManyToMany
@JoinTable(
    name="category_item",
    joinColumns={@JoinColumn(name="category_id")},
    inverseJoinColumns={@JoinColumn(name="item_id")}
)
private Set<Item> items = new HashSet<Item>();

对面的反向端：
@ManyToMany(mappedBy="items")
private Set<Category> categories = new HashSet<>();


两端不一定要相同的集合类型。非反向端使用<list>,反向端使用<bag>是合理的
对于反向端，可以接受<set>,下列bag映射也一样
<class name="Item" table="">
    <bag name="categories" table="cate_item" inverse="true" cascade="save-update">
        <key column="item_id"/>
        <many-to-many class="Category" column="category_id"/>
    </
</

jpa中，bag是没有持久化索引的一个集合
@ManyToMany(mappedBy="items")
private Collection<Category> categories = new ArrayList<Category>();


没有其他映射可以用于多对多的反向端，被索引的集合(list,map)不行，因为如果集合是反向的，hibernate不会初始化或维持索引列。


把列添加到联结表
如果联结表由一些额外的列，而不只是2个外键列时，该怎么办？

在每次把item添加到category时都记录一些信息，例如日期，添加者的名字，这就需要在联结表中使用额外的列。

2种策略，把这种结构映射到java类。第一种策略需要一个用于联结表的中间实体类，并通过一对多的关联而被映射。
第二种时通过给联结表使用一个值类型的类来利用组件的集合。

1 把连接表映射到中间实体

@Entity
@Table(name="categorized_item")
public class CategorizedItem {
    @Embeddable
    public static class Id implements Serializable {
        @Column(name="category_id")
        private Long categoryId;
        
        @Column(name="item_id")
        private Long itemId;

        public Id() {}

        public Id(Long categoryId, Long itemId) {
            this.=
            this.=
        }

        public boolean equals(Object o) {

        }

        public int hashCode(){}

    }

    @EmbeddedId
    private Id id = new Id();

    @Column(name="added_by_user")
    private String username;

    @Column(name="added_on")
    private Date dateAdded = new Date();

    @ManyToOne
    @JoinColumn(name="item_id", insertable=false, updatable=false)
    private Item item;

    @ManyToOne
    @JoinColumn(name="category_id", insertable=false, updateble=false)
    private Catetory category;

    public CategorizedItem(){}

    public CategorizedItem(String username, Category caytegory, Item item) {
        this.username=
        this.cate
        this.item

        this.id.categotyid=
        this.id.itemid=

        category.getCategorizedItems().add(this);
        item.getCategorizedItems().add(this);
    }

    // getter setter
}

实体类需要一个标识符属性，连接表的主键是category_id,item_id的复合，所以实体类也有一个复合键。为了方便，把它封装在一个静态内部类种。

<class name="CategorizedItem" table="category_item" mutable="false">
    <composite-id name="id" class="CategorizedItem$Id">
        <key-property name="categoryId" access="field" column="category_id"/>
        <key-property name="itemId" access="f" column="item_id"/>
    </composite-id>

    <property name="dateAdded" column="added_on" type="timestamp" not-null="true"/>
    <property name="username" column="added_by_user" type="string" not-null="true"/>

    <many-to-one name="category" column="category_id" not-null="true" insert="false" update="false"/>
    <many-to-one name="item" ... 同上/>
</class>

实体类被映射为不可变，创建之后永远不用更新任何属性。
hib直接访问composite-id字段，这个内部类中不需要getter，setter。
2个many-to-one是只读的。因为列被映射2次，一次在复合键中(负责值的插入)，另一次用于多对一的关联。

Category,Item实体(可以)有对CategorizedItem实体的一对多关联。
Category中：
<set name="categorizedItems" inverse="true">
    <key column="category_id"/>
    <one-to-many class="CategorizedItem"/>
</set>

注解：
@OneToMany(mappedBy="category")
private Set<CategorizedItem> categorizedItems = new HashSet<>();


CategorizedItem newLink = new CategorizedItem(user.getUserName(), cate, ite);
ssession.save(newLink);


cate.getCategorizedItems().remove(link2);
ite.getCategorizedItems().remove(link2);
session.delete(link2);

这个策略的主要好处在于双向导航的可能性
确定是更复杂的代码管理CategorizedItem实体实例，创建，移除关联必须被独立地保存和删除，CategorizedItem需要一些基础结构，如复合标识符。但是可以在集合中的级联选项开启传播性持久化。


2 把连接表映射到组件的集合

简化CategorizedItem类，使它成为值类型，不用标识符或任何复杂的构造器
public class CategorizedItem {
    private String username;
    - Date dateAdded = new Date();
    - Item item;
    - Category category;

    public CategorizedItem(String username, Category category, Item item) {
        this.username=  this.category=  this.item=  ;
    }

    // getter setter equals hashcode

}

值类型必须为一个实体所拥有，这里的所有者是Category,它有这些组件的一个集合
<class name="Category" table="">
    <set name="categorizedItems" table="category_item">
        <key column="category_id"/>
        <composite-element class="CategorizedItem">
            <parent name="category"/>
            <many-to-one name="item" column="item_id" not-null="true" class="Item"/>
            <property name="username" column="added_by_user"/>
            <property name="dateAdded" column="added_on"/>
        </c
    </s
</c

这是联结表中包含额外列的多对多关联的完整映射。
数据库表只有一处变化，现在category_item表有一个主键，它是所有列的复合，而不仅仅是category_id,item_id。因此，这些属性永远不应为空。

可以通过对User而不有时用户名的引用来增强这个映射，这要求连接表中要有一个额外的user_id列，作为Users的一个外键。这是一个三重关联映射：
<set name="categorizedItems" table=">
    <key column="category_id"/>
    <composite-element class="CategorizedItem">
        <parent name="category"/>
        <many-to-one name="item" column="item_id" not-null="true" class="Item"/>
        <many-to-one name="user" column="user_id" not-null="true" class="User"/>
        <property name="dateAdded" column=added_on"/>
    </
</

组件的好处是链接对象的隐式生命周期。为了创建Category和Item之间的关联，就把CategorizedItem实例添加到集合，要解除关联，就从集合汇总移除该元素。不需要额外的级联，java代码也简化了
CategorizedItem alink = new CategorizedItem(auser.getUsername(), acate, aitem);
acate.getCategorizedItems().add(alink);

acate.getCategorizedItems().remove(alink);

缺点是无法启用双向导航，组件不可能有共享的引用，不能从Item导航到CategorizedItem。但是你可以编写一个查询来获取所需的对象。


注解：
@Embeddable
public class CategorizedItem {

    @org.hib.anno.Parent
    private Category category;

    @ManyToOne
    @JoinColumn(name="item_id", nullable=false, updatable=false)
    private Item item;

    @ManyToOne
    @JoinColumn(name="user_id", nullable=F, updatable=F)
    private User user;

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name="added_on", nullabe=F, updatable=F)
    private Date dateAdded;

    // constructor, getter, setter, equals, hashCode

}


@org.hib.anno.CollectionOfElements
@JoinTable(
    name="category_item"
    joinColumns=@JoinColumn(name="category_id")
    private Set<CategorizedItem> .... = new HashSet;
)


7.2.4 映射map

..2860行左右，有值类型-值类型的map
<map name="images" table="item_image" order-by="imagename asc">


值对实体的引用
假设，键是Long，值是对另一个实体的引用。想象Item实体有一个Bid实例的map。

映射的底层没有什么特别的，你有item，bid表，bid表中有item_id外键列。

Item类中的map：
@MapKey(name="id")
@OneToMany(mappedBy="item")
private Map<Long, Bid> bidsByIdentifier = new HashMap<Long, Bid>();

jpa的@MapKey，把目标实体的一个属性映射为该映射的键，默认是目标实体的标识符属性,因而这里的name是多余的。由于映射的多个键形成一个集，因此一个特定映射的值希望是唯一的(这是对于Bid主键，对于Bid其他属性则可能不是如此)。

hib xml
<map name="bidsById" inverse="true">
    <key column="item_id"/>
    <map-key type="long" formula="bid_id"/>
    <one-to-many class="Bid"/>
</map>

映射的formula键使得这个列变成了只读，因此当你修改该映射时它从不更新。


三重关联
一种更常见的情况是三重关联中间的映射。

这是最后一次介绍category,item之间关联的另一种方法了。

多对多关联：
可以利用2个集合在任意一端映射，也可以通过只有2个外键列的联结表映射。
。。？前半句是说1对多？多对多必然要联结表吧。

可以通过表示联结表的中间实体类和那里任何额外的列映射。一对多的关联在任意一端(category,item)映射，并且双向的多对一相当于在中间的实体类中映射。

可以被映射为单向，通过表示为值类型组件的联结表。category实体有组件的一个集合。每个组件都有一个对它自己Category的引用以及对Item的多对一实体关联。

之前把User添加到中间实体，把上面的场景变成一个三重关联。下面用map来完成同样的事。

Category有Item实例的一个map，每个映射项的键都是对Item的引用。每个映射项的值都是把Item添加到Category的User。如果连接表上没有额外的列，那么这个策略就很合适。

这个策略的好处在于不需要任何中间类，不需要实体或者值类型，就可以在java程序中表示联结表的added_by_user_id列。

Category中带有hib扩展注解的map属性。
@ManyToMany
@org.hib.anno.MapKeyManyToMany(
    joinColumns=@JoinColumn(name="item_id")
)
@JoinTable(
    name="category_item", joinColumns=@JoinColumn(name="category_idf"), inverseJoinColumns=@JoinColumn(name="user_id")
)
    private Map<Item, User> itemsAndUser = new HashMap<Item, User>();


hib,xml:
<map name="itemsAdnUser" table="category_item">
    <key column="category_id"/>
    <map-key-many-to-many column="item_id" class="Item"/>
    <many-to-many column="added_by_user_id" class="User"/>
</map>

可以试着通过Item中categories的一个集合，是这个映射变成双向的。
记住，这必须是一个反向的集合映射，因此它不支持被索引的集合。



7.3 多态关联

hib中多态非常容易使用。

多态的多对一关联
考虑User的defaultBillingDetails属性。它引用一个特定的BillingDetails对象，这个对象在运行时可以是该类的任何具体类型。

BillingDetails，有2个子类，CreditCard，BankAccount.

User.hbm.xml中：
<many-to-one name="defaultBillingDetails" class="BillingDetails" column="default_billing_details_id"/>

但是由于BillingDetails是抽象的，关联必须在运行时引用它其中一个子类的实例。

不必做任何特别的事情来启用hib的多态关联。在关联映射中指定任何被映射的持久化类的名称(或者让hib通过反射来发现它)，然后，如果该类声明了任何<union-subclass>,<subclass>,<joined-subclass>元素，该关联自然就成为多态。

有一件事需要小心，如果BillingDetails是lazy="true"(默认情况)，hib就会代理defaultBillingDetails关联目标，这种情况下，就不能在运行时执行类型装换到具体的类CredieCard,甚至instanceof操作符也表现得很奇怪。

。。直接bd instanceof CreditCard， 直接(CreditCard) bd;
..直接强转会异常，这个还是第一次知道。。现在估计不会吧。
。。get()立即去搜，会去缓存，然后数据库搜，没有就是null。
..load()返回一个代理，在需要的时候才初始化，所以load不能用于确认是否存在。


为了执行类型转换，需要load()
User user = (User) session.get(User.class, userId);
BillingDetails bd = user.getDefaultBillingDetails();

CreditCard cc = (CreditCard) session.load(CreditCard.class, bd.getId());
expiryDate = cc.getExpiryDate();

调用load()之后，bd和cc指向2个不同的代理实例，这两者都委托给同一个底层的CreditCard实例。然而，第二个代理有不同的接口，可以调用只应用给这个接口的方法(如getExpiryDate()).
。。getExpiryDate 是CreditCard的接口，不是父类的。

可以通过避免延迟抓取来避免这些问题。
User user = (User) session.createCriteria(User.class).add(Restrictions.eq("id", userId)).setFetchMode("defaultBillingDetails", FetchMode.JOIN).uniqueResult();
CreditCard cc = (CreditCard) user.getDefaultBillingDetails();
cc.getExpiryDate();


真正的oop不应该使用instanceof或众多的类型转换。如果你发现自己使用代理时遇到了问题，就应该质疑设计，问问是否有更多多态的方法。
hib也提供了BCI(ByteCode Instrumentation)，作为通过代理延迟加载的另一种选择。



多态集合

User可以有对多个BillingDetails的引用，而不只是单个。用一个双向的一对多关联映射它。

BillingDetails中有以下代码：
<many-to-one name="user" class="User" column="user_id"/>

Users映射有：
<set name="billingDetails" inverse="true">
    <key column="user_id"/>
    <one-to-many class="BillingDetails"/>
</s

已经是多态的了

for (BillingDetails bd : user.getBillingDetails()) {
    // invoke CreditCard.pay() or BankAccount.pay()
    bd.pay(payAmount);
}

到目前为止的例子中，假设BillingDetails是被显式映射的一个类，继承映射策略是每个类层次结构一张表，或者用每个子类一张表。

如果层次结构通过每个具体的类一张表映射(隐式多态)或显式地通过每个带有联合的具体类一张表映射，这个场景就需要更复杂的解决方案了。


对联合的多态关联
hib支持多态的多对一和1对多关联，即使类层次结构是每个具体类一张表的策略。

User的BillingDetails的集合：
<set name="billingDetails" inverse="true">
    <key column="user_id"/>
    <one-to-many class="BillingDetails"/>
</set>

如果要启用多态的联合特性，这个多态关联的必要条件是它为反向。在对面端必须有一个映射。
在BillingDetails的映射中，通过<union-subclass>,必须包括<many-to-one>关联：
<class name="BillingDetails" abstract="true">
    <id name="id" column="billing_details_id" .../>
    <property .../>
    <many-to-one name="user" column="user_id" class="User"/>

    <union-sublcass name="CreditCard" table="credit_card">
        <property .../>
    </

    <union-subclass name="BankAccount" table="bank_account">
        <
    </
</c

两张表用于层次结构的2个具体类，每张表都有user_id外键。


auser.getBillingDetails().iterator().next;
执行时，hib执行union查询：
select bd.* from (
select billing_details_id, user_id, owner, number, exp_month, exp_year, null as account, null as bankname, null as swift, 1 as clazz from credit_card
union
select billing_details_id, user_id ....
) bd where bd.user_id=?


多对一的关联defaultBillingDetails，在Users表中通过default_billing_details_id列映射，如果访问属性，hib就执行一个类似前一个查询的union查询来获取这个实例。然而，不是在where子句中限制用户，而是在特定的billing_details_id中进行限制。
。。？ billing_details_id 通过什么来限制？。。ok，users保存了default_billing_details_id，所以搜索的时候直接 select * from (select union select) where billing_details_id = default_billing_details_id。

hib不能也不会用这个策略为default_billing_details_id创建外键约束。这个引用的目标表可以是任何具体的表，它们不能被轻易地约束。你应该考虑通过一个数据库触发器来为这个列编写一个定制的完整性规则。


每个具体类一张多态表。
5.1.1节中，定义过每个具体类一张表的策略，并发现这种映射策略使得表示多态关联变得很难，因为无法把外键关系映射到抽象超类的表。使用这个策略时，没有超类表，只有具体类的表。也无法创建union，因为hib不知道什么东西在统一这些具体的类，该超类(接口)不会被随处映射。

如果把这个继承策略用于BillingDetails层次结构中，hib就不支持User中多态的billingDetails一对多集合。
如果你需要多态地多对一关联来使用这一策略，就必须求助于hack。

本书中介绍的这种方法是你最迫不得已的选择。先尝试转换到<union-subclass>映射。
假设，想要从User到BillingDetails的多态的多对一映射，其中BillingDetails类层次结构通过每个具体类一张表的策略和hib中的隐式多态行为进行映射。你有credit_card,bank_account表，但没有billing_details表，hib在users中需要2条信息，以便唯一地辨别被关联的是CreditCard还是BankAccount.
users表除了default_billing_details_id之外，还需要default_billing_defaults_type列。这个额外的列就像额外的辨别标志一样。并且在xml中还需要<any>映射
<any name="defaultBillingDetails" id-type="long" meta-type="string">
    <meta-value value="credit_card" class=""/>
    <meta-value value="bank_account" class=""/>
    <column name="default_billing_details_type"/>
    <column name="default_billing_details_id"/>
</

meta-type属性指定default_billing_defaults_type列的hib类型。id-type属性指定default_billing_details_id列的类型(CreditCard,BankAccount必须有相同的标识符类型)

<meta-value>元素告诉hib如何解释default_billing_details_type列的值。这里不需要完整的表名，可以用任何值。例如，可以把信息编码成2个字符
<meta-value value="CC" class="CreditCard"/>

第一个主要问题，你无法把外键约束添加到default_billing_details_id列，因为有些值引用bank_account，其他则引用credit_card表。。你需要找一些其他方法来确保完整性(如触发器)。这与你使用<union-subclass>策略时要面对的问题相同。

此外，很难给这个关联编写sql表联结。尤其是，hib查询工具不支持这种关联映射，这个关联也不能通过外部联结而被抓取。除非最特殊的情况，否则，我们不鼓励在任何情况下使用<any>关联。这种映射技术不能通过注解或在jpa中使用。

只要你不把关联创建到通过隐式多态映射的类层次结构，关联就很简单：通常不需要考虑它。

jpa或注解，也是一样，不需要额外的映射。




chapter 8 遗留数据库和定制sql
本章主题很广泛，可以把本章的大部分内容当作参考资料，遇到特定问题再回来。

8.1 整合遗留数据库
当程序继承现有的遗留数据库时，应尽可能对现有的Schema少做变动。对schema所做的每一处修改都可能破坏访问数据库的其他现有应用程序。
一般来说，构建一个新的应用程序不可能不对现有的数据模型做修改。新程序意味这额外的业务需求，自然需要数据库schema的演变。

2种类型的问题，与改变业务需求相关的问题(不改变schema一般无法解决)和只与你希望如何在新应用程序种表示相同业务问题相关的问题。

处理主键
自然主键使得业务需求改变时很难重构数据模型。极端情况下，它甚至可能影响性能。
hib支持自然键，如果自然键是一个复合键，支持就是通过<composite-id>映射。

遗留的users表，username可能是真正的主键。这种情况下，就没有自动生成的代理标识符了。
反之，你启用assigned标识符生成器策略，告诉hib标识符是在对象被保存之前，由应用分配的一个自然键
<class name="" table="">
    <id name="username" column="username" length="16">
        <generator class="assigned"/>
    </
</

hib如何知道saveOrUpdate时需要insert还是update呢？它不知道，所以会在users表中搜索指定的username，如果找到就更新，如果没有找到，就插入新行。这不是最好的解决方案。

几种策略避免select：
把<version>或<timestamp>映射和一个属性添加到实体。hib内部通过乐观并发控制来管理这2个值，作为一项附带作用，空的时间戳(0或null)版本表明实例时新的。
实现hib的Interceptor，并把它hook到Session中，这个扩展接口允许你实现方法isTransient()，它包含这你区分新旧对象时可能需要的任何定制过程。
。。public class EmptyInterceptor implements Interceptor, Serializable {

另一方面，如果你使用save或update，hib就不必区分瞬时对象和脱管对象了，这是不使用saveOrUpdate的唯一原因。


jpa映射自然主键很简单
@Id
private String username;

如果没有声明标识符生成器，hib就会假设它必须应用一般的select-to-determine-state-unless-versioned策略，并期待应用程序负责分配主键值。可以通过扩展拦截器，或添加版本控制属性(version/timstamp)来避免select。
。。unsaved-value=。。。这个也可以分辨时瞬时还是脱管。就是值是这个，那么就是瞬时的。默认是null。


映射复合自然键
users表的主键由username和department_nr组成。可以添加一个departmentNr属性到User类。并创建下列映射：
<class name="User" table="">
    <composite-id>
        <key-property name="username" column="username"/>
        <key-property name="departmentNr" column="department_nr"/>
    </
</

hib需要一个select来确定saveOrUpdate应该做什么--除非启用版本控制或定制的Interceptor。

load，get时，需要使用User对象作为查询的条件
User user = new User();
user.setUsername("johndoe");
user.setDepartmentNr(42);
session.load(User.class, user);

这个代码片段中，User表现得就像它自己的标识符类。
定义一个只声明键属性的单独复合标识符类则更为优雅。
public class UserId implements Serializable {
    private String username;
    private Integer departmentNr;

    public UserId(String un, Integer dn) {
        this.=;this.=;
    }
    // getter equals, hashCode

}
正确地实现equals和hashCode很重要，因为hib的高速缓存查找依赖这些方法。

现在从User属性中移除username和departmentNr.创建下列映射
<class name="User" table="">
    <composite-id name="userId" class="UserId">
        <key-property name="username" column="username"/>
        <key-property name="deparmentNr" column="department_nr"/>
    </
</

UserId id = new UserId("jogndoe", 42);
User user = new User();
user.setUserId(id);
user.setFirstName("");
session.saveOrUpdate(user);
session.flush();

要使saveOrUpdate起效，还是需要select。

UserId id = new UserId("johndoe", 42);
User user = (User) session.load(User.class, id);


复合主键中的外键
假设department_nr是一个引用department表的外键，并且你希望在java领域模型中把这个关联表示为多对一的关联。
建议你映射一个也是复合主键一部分的外键列，通过一般的<many-to-one>+insert=F+update=F，禁用该列的任何hib插入或更新
<class name="User" table="">
    <composite-id name="userId" class="">
        <key-property name="username" column=""/>
        <key-property name="departmentId" column="departmentId"/>
    </
    <many-to-one name="department" class="Department" column="department_id" inser="false" update="false"/>
</

现在hib更新或插入User时忽略department属性。但你当然可以通过user.getDepartment()来获取它。
User和Department之间的关系现在通过UserId复合键类的departmentId属性得到托管。

UserId id = new UserId("johndoe", department.getId());
User user = new User();
user.setUserId(id);
user.setFirstname("a");
user.setDepartment(department);
session.saveOrUpdate(user);
session.flush();

只有Department的标识符值对持久化状态有些影响，为了一致，调用setDepartment(department);否则，你必须在evict之后从数据库中重新获取来获得部门。(实际应用中，可以把所有这些细节移到复合标识符类的构造器中)
。。内部类？还是getDepartment从UserId中取？对啊，为什么要many-to-one，直接取。。不。key-property只知道是一个Integer，而不知道是一个对象的主键。但是应该能在composite-id中引用外键吧？
。。靠

另一种方法是<key-many-to-one>
<class name="User" table="">
    <composite-id name="userId" class="UserId">
        <key-property name="username" column=""/>
        <key-many-to-one name="department" class="Department" column="department_id">
    </
</
然而，在复合标识符类中存在关联，这通常并不方便，因此除非特殊情况，否则不推荐这种方法。
<key-many-to-one>构造在查询方面也由限制:你无法限制一个跨<key-many-to-one>联结的hql或criteira的查询结果(这些特性可能在以后的hib版本中得以实现)。


复合主键的外键
由于users由一个复合主键，所以任何引用外键也是复合的。
Item到User的关联映射，hib可以从java代码中隐藏这一细节：
<many-to-one name="seller" class="User">
    <column name="username"/>
    <column name="department_id"/>
</

User类所拥有的任何集合也都有复合外键，例如，反向关联的被这位用户出售的items：
<set name="itemsForAuction" inverse="true">
    <key>
        <column name="username"/>
        <column name="department_id"/>
    </key>
    <one-to-many class="Item"/>
</set>

列的排列顺序很重要，应该与它们在User主键映射的<composite-id>元素中出现的顺序一致。


利用注解的复合键
jpa涵盖了处理复合键的策略，你有3种选择：
1 把标识符属性封装在一个单独的类种，并把它标记为@Embeddable，就像一般组件那样。在实体类中包括这个组件类型的一个属性，并利用@Id给一个应用分配的策略映射它。
2 把标识符属性封装在一个没有任何注解的单独类中。在实体类中包含这个类型的一个属性，并用@EmbeddedId映射它。
3 把标识符属性封装在单个类中，复制实体类中的所有标识符属性，然后用@IdClass注解实体类，并指定被封装的标识符类的名称。


第一种选择很简单。需要使来自前一节的UserId类变成可嵌入的：
@Embeddable
public class UserId implements Serializable {
    private String username;
    private String departmentNr;
    ...
}

为了映射User的复合键，通过省略@GenerateValue注解而对分配的应用设置生成策略：
@Id
@AttributeOverride({
    @AttributeOverride(name="username", column=@Column(name="username")),
    @AttributeOverride(name="departmentNr", column=@Column(name="dep_nr"))
})
private UserId userId;


第二个复合键映射策略不要求你给UserId主键类做标记，因此这个类不需要@Embeddable和其他注解。
在自己的实体中，你通过@EmbeddableId映射复合的标识符属性：
@EmbeddedId
@AttributeOverrides({
    @AttributeOverride(name="username", column=@Column(name="username")),
    @AttributeOverride(name="departmentNr", column=@Column(name="dep_nr"))
})
private UserId userId;

jpa xml:
<embeddable class="auction.model.UserId" access="property">
    <attributes>
        <basic name="username">
            <column name="uname"/>
        </b
        <basic name="departmentNr">
            <column name="department_nr"/>
        </basic
    </
</

<entity class="auction.model.User" access="field">
    <attributes>
        <embedded-id name="userId">
            <attribute-override name="username">
                <column name="username"/>
            </
            <attorbute-override name="departmentNr">
                <column name="dep_nr"/>
            </
        </
    </
</


第三种复合键映射策略更难理解一点。首先，把所有标识符属性封装到一个单独类中，这个类不需要额外的注解。
复制实体类中的所有标识符属性：
@Entity
@Table(name="")
@IdClass(UserId.class)
public class User {
    @Id
    - String username;
    @Id
    - String departmentNr;

}

hib检查@IdClass,并挑出所有重复属性(通过名称和类型)，作为标识符属性和主键的一部分。
所有主键属性都通过@Id注解，并根据这些元素(字段或获取方法)的位置将实体默认为字段或属性访问。

hib也有最后一种策略，但是有点含糊：
<composite-id class="UserId" mapped="true">
    <key-property name="username" column="username"/>
    <key-property name="departmentNr" column="dep_nr"/>
</composite-id>
省略了实体的标识符属性名称(因为没有，(...这里说的是UserId这个属性没有))，因此hib内部处理标识符。利用mapped="true"，启用最后一种jpa映射策略。因此所有的键属性现在都要出现在User和UserId类中。


jpa xml：
<entity class="acution.model.User" access="field">
    <id-class class="xxx.UserId"/>
    <attributes>
        <id name="username"/>
        <id name="departmentNr"/>
    </
</


复合外键也可以使用注解。
先映射Item到User的关联：
@ManyToOne
@JoinColumns({
    @JoinColumn(name="username" referencedColumnName="username"),
    @JoinColumn(name="dep_nr" referencedColumnName="dep_nr")
})
private User seller;

一般的@ManyToOne和这个映射的差别主要在于涉及的列数--这个顺序还是很重要的，应该和主键列的顺序一致。然而，如果你对每个列声明referencedColumnName，顺序就不重要了，并且外键约束的源表和目标表可以有不同的列名称。

从User到带有Item集合的反向映射甚至更简单：
@OneToMany(mappedBy="seller")
private Set<Item> itemsForAuction = new HashSet<>();

这个反向端需要mappedBy属性，就像通常对于双向的关联一样。因为这是反向端，所以不需要任何列声明。


外键引用非主键
通常，外键约束引用主键，外键约束是一个完整性规则，它保证被引用的表有一行所包含的键值与引用表和给定行中的键值相必配。
外键约束可以自引用。

遗留的schema有时会有不遵循简单的"外键引用主键"规则的外键约束。有时，外键引用非主键:一个简单的唯一列，一个自然的非主键。
假设在CaveatEmptor中，你需要在users表中处理名为customer_nr的遗留自然键列：
<class name="User" table="">
    <id name="id" column="user_id">...</id>
    <property name="customerNr" column="customer_nr" not-null="true" unique="true"/>
</class>

unique属性是hib的一个sql定制选项，不在运行时使用它(hib不做唯一性验证)，而是通过hbm2ddl导出数据库schema时起作用。
如果你有个包含自然键的现有schema，就假设它是唯一的，为了完整起见，你可以并应该在映射元数据中重复如此重要的约束--或许有天，你会用它导出一个新的Schema。

jpa 注解 unique
@Column(name="customer_nr", nullable=false, unique=true)
private int customerNr;


遗留的schema中可能遇到的下一个问题是：item表有个外键列seller_nr。
理想情况下，你会期待用这个外键去引用users表的主键user_id，但是在遗留的schema中，它引用了自然的唯一键customer_nr。需要一个属性引用映射它：
<class name="Item" class="">
    <id name="id" column="item_id"> ,,, </
    <many-to-one name="seller" column="seller_nr" property-ref="customerNr"/>
</class>

在更怪异的hib映射中，你会看到property-ref属性。它用来告诉hib"这是具名属性的一个镜像"。
property-ref要求目标属性要唯一，因此，这个映射需要unique="true"


jpa:
@ManyToOne
@JoinColumn(name="seller_nr", referencedColumnName="customer_nr")
private User seller;

现在，hib知道被引用的目标列是一个自然键，并相应地管理外键关系。

为了完成这个例子，利用User类中的itemsForAuction集合的映射，使这2个类之间的关联映射变成双向，
<class name="User" tables="users">
    <id name="id" column="user_id">...</id>
    <property name="customerNr" column="customer_nr" unique="true"/>
    <set name="itemsForAuction" inverse="true">
        <key column="seller_nr" property-ref="customerNr"/>
        <one-to-many class="Item"/>
    </
</

item中的外键列再次通过一个对customerNr的属性引用而被映射。注解中，这更加容易映射为一个反向端：
@OneToMany(mappedBy = "seller")
private Set<Item> itemsForAuction = new HashSet<Item>();


复合外键引用非主键
外键可能是一个复合键，并且设计为引用一个复合的自然的非主键。

假设users有一个自然的复合键，包括firstname,lastname,birthday列。外键可以引用这个自然键。
为了映射这个，你需要按相同的名称给几个属性分组，否则无法在property-ref中给复合命名。应用<properties>元素来给映射分组
<class name="User" table="">
    <id name="id" column="user_id">...</id>
    <properties name="nameAndBirthday" unique="true" update="false">
        <property name="firstname" column="firstname"/>
        <property name="lastname" column=""/>
        <property name="birthday" column="birthday" type="date"/>
    </properties>
    <set name="itemsForAuction" inverse="true">
        <key property-ref="nameAndBitthday">
            <column name="seller_firstname"/>
            <column name="seller_lastname"/>
            <column name="seller_birthday"/>
        </key>
    </
</

<properties>给几个属性命名，并且定义了一个多列的unique约束，使几个属性变成不可变。
对于关联映射，列的顺序依然很重要：
<class name="Item" table="">
    <id name="id" column="item_id">...</id>
    <many-to-one name="seller" property-ref="nameAndBirthday"/>
        <column name="seller_firstname"/>
        <column name="seller_lastname"/>
        <column name="seller_birthday"/>
    </
</

可以通过重构外键来引用主键的方式清除这样一个schema。


有时，你无法对遗留数据库进行任何改变--甚至不能创建表或者试图，hib可以把类，属性，甚至关联的几个部分映射到一个简单的sql列语句或表达式。称为公式映射。


2个实体(Item,Bid)之间映射一个文字联结条件。
Item和Bid是一对多的关联，但它不是2个类之间的唯一关联，另一个一对一关联关联一个Bid作为胜出的出价。
第一个一对多关联，Bid表中有一个Item_id外键。
1对1的关联更为困难，可以有几种方式映射，最自然的是item表中一个被唯一约束的外键，它引用bid表中的一行--胜出的行。

遗留schema经常需要一个不是简单的外键关系的映射。

想象Bid表中每一个行都有一个标志列，给胜出的出价做上标记。一个Bid行把标记设置为true，那么这件拍卖品的其他行自然是false，在遗留schema中很可能找不到对这个关系的约束或者完整性规则，但暂时不管，我们关注java类的映射。

假设遗留schema没有使用sql boolean，而是使用char(1)的T/F。我们的目标是把这个标记列映射到Item的一个successfulBid属性。要把它映射为对象引用，就需要一个文字联结关系，因为hib没有可以用于联结的外键。换句话说，对于每个item行，你需要从把successful列表为T的Bid表中联结一个行。如果没有这样的行，item.getSuccessfulBid()就返回null

Bid类和一个successful布尔属性映射到successful数据库列：
<class name="Bid" table="">
    <id name="id" column="bid_id">...</id
    <property name="amount"...
    <properties name="successfulReference">
        <property name="successful" column="successful" type="true_false"/>
        <many-to-one name="item" class="Item" column="item_id"/>
    </priperties>
    <many-to-one name="bidder" class="User" column="Bidder_id"/>
</

type="true_false"是java boolean基本(或其包装)属性和包含文字T/F文字值的一个简单的char(1)列之间创建一个映射。
这里新出现的东西是，你可以组合<many-to-one>，而不只是那些基础属性。

。。MYSQL保存BOOLEAN值时用1代表TRUE,0代表FALSE，boolean在MySQL里的类型为tinyint(1),   

真正的技巧发生在另一端，对于Item类的successfulBid属性的映射：
<class name="Item" table="">
    <id name="id" column="item_id"...
    <property name="initialPrice"...
    <one-to-one name="successfulBid" property-ref="successfuleReference">
        <formula>'T'</formula>
        <formula>item_id</f>
    </
    <set name="bids" inverse="true">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </
</

通常，当2个实体表中的行有着相同的主键值时，<one-to-one>映射便是2个实体间的主键关系。
通过使用一个包含property-ref的formula，你可以把它应用到外键关系。
上面的例子中可以用<many-to-one>代替<one-to-one>。


查询一件拍卖品的获取和它的成功出价的sql：
select i.item_id,i.initial_price....b.bid_id,b.amount.b.successful,b.bidder_id...
from item i
left outer join Bid b on 'T'=b.successful and i.item_id=b.item_id
where i.item_id=?

2个formula转为了2个限制条件。

用或不用数据库约束，都无法只实现仅在item实例的一个私有字段上设置值的item.setSuccessfulBid方法，你需要在setter中实现额外逻辑，负责这个标记属性。
public class Item {
    private Bid successfulBid;
    private Set<Bid> bids = new HashSet<Bid>();
    public Bid getSuccessfulBid() {
        return this.successfulBid;
    }
    public void setSuccessfulBid(Bid successful) {
        if (successfulBid != null) {
            for(Bid bid : bids)
                bid.setSuccessful(false);
            successfulBid.setSuccessful(true);
            this.successfulBid = successfulBid;
        }
    }
}

对于这种文字联结条件映射要记住：它可以被应用到许多其他的情形中，而不仅仅对于成功的或默认的关系。每当需要把一些任意的联结条件附加到查询时，最好的选择是公式。

编写本书时，hib anno还不支持用公式表达的任意联结条件。在一个引用名称下分组属性也是不可能的。


遗留的schema中，可能的另一个问题是，它不能与类粒度很好的整合。
通常建议的类要比表更多可能不起作用，并且可能你必须反其道行之，把任意表联结到一个类里面。

<join>映射，把特定子类的属性分到一张单独的表中，处在主继承层次结构表之外。这项一般的功能有更多的用途，但<join>也可能是个馊主意。任何设计合适的系统都应该是类比表更多。
把单个类分离到几张单独的表中，是只有在你需要把遗留schema中的几张表合并到单个类中时才应该做的事情。

把属性移到二级表中
假设在CaveatEmptor中，你没有把包含用户主要信息的用户地址信息保存在映射为组件的Users表中，而是一张单独的表。
。。billing_address，主键是user_id,这也是外键指向了Users表，并且还有street，zipcode，city。

为了在xml中映射它，需要把Address的属性组合在<join>元素中：
<class name="User" table="">
    <id...
    <join table="billing_address" optional="true">
        <key column="user_id"/>
        <component name="billingAddress" class="Address">
            <property name="street" type="string" column="street" length="255"/>
            <p
            <p
        </c
    </j
</c

不一定要联结组件，也可以联结单独的属性甚至<many-to-one>，通过设置optional="true"，表明组件属性对于没有billingAddress的User也可能为null，并且没有行应该被插入到这张二级表中。
hib还执行一个外部联结(而不是内部联结)来从二级表中获取行。如果在<join>中声明了fetch="select"，二级表就可以用于这一目的。

jpa包含了二级表的概念,首先，你必须对一个特定的实体声明一张(或几张)二级表：
@Entity
@Table(name="users")
@SecondaryTable(
    name="billing_address",
    pkJoinColumns = {@PrimaryKeyJoinColumn(name="user_id")}
)
public class User {
}

每张二级表都需要一个名称和一个联结条件。这个例子中，外键列引用Users表的主键列，这是默认的联结条件，因此可以省略。

实际的组件属性billingAddress，被映射为一个常规的@Embedded类，就像常规的组件一样。然而，需要覆盖每个组件属性列，并把它分配到user类中的二级表：
@Embedded
@AttributeOverrides({
    @AttributeOverride(
        name="street", column=@Column(name="street", table="billing_address")
    ),
    @AttributeOverride(
        name="zipcode", column=@Column(name="zipcode", table="billing_address")
    ),
    @AttributeOverride(
        name="city", column=@Column(name="city", table="billing_address")
    )
})
private Address billingAddress;

jpa xml：
<entity class="auction.model.User" access="field">
    <table name="users"/>
    <secondary-table name="billing_address">
        <primary-key-join-column referenced-column-name="user_id"/>
    </
    <attributes>
        ...
        <embedded name="billingAddress">
            <attribute-override name="street">
                <column name="street" table="billing_address"/>
            </
            <...
            <...
        </e
    </a
</e


被反向联结的属性
另一种<join>元素甚至更为怪异的使用案例是 被反向联结的属性或组件。
假设在CaveatEmptor表中，有具名daily_billing的遗留表，这张表包括所有开放支付，对任何拍卖都以每夜批量的方式执行。表中有一个item的外键列。
。。daily_billing:billing_id<PK>,item_id<FK>,status,total

在CaveatEmptor中，如果能通过item.getBillingTotal()访问一次特定拍卖的价格，这样会很方便。

可以把这个列从daily_billing表映射到item类中，然而，永远不要从这一端插入或者更新它，它是只读的。基于这个原因，把它映射为反向的。
<class name="Item" table="item">
    <id>...
    <join table="daily_billing" optional="true" inverse="true">
        <key column="item_id"/>
        <property name="billingTotal" type="big_decimal" column="total"/>
    </join
</

另一种解决方案是，使用一个公式表达式和关联自查询的衍生属性
<property name="billingTotal" type="big_decimal" formula="(select db.total from daily_billing db where db.item_id=item_id)"/>

主要区别在于用来加载item的sql select，如果使用<join fetch="select">，第一种解决方案默认为一个外部联结，通过可选的另一个select。这个衍生属性在原始查询的选择子句中产生一个嵌入的子查询。在编写本书之时，注解还不支持反向的联结映射，但是可以给公式使用hib注解。


<join>在多种情况下有用，而且和公式结合，它们更强大，但我们不希望经常使用这种结合。

使用触发器
遗留数据的schema中经常出现的进一步问题是数据库触发器。
在全新的数据库中也有理由使用触发器。
使用ORM软件的触发器和对象状态管理通常是个问题，因为触发器可能在不合时机的时候运行，或者可能修改不与内存状态同步的数据。

在插入时运行的触发器
假设item表有一个created列，被映射为Date类型的created属性，它通过一个在插入中自动执行的触发器初始化，下列映射很恰当
<property name="created" type="timestamp" column="created" insert="false" update="false"/>

insert.update都是false，表明它不会被hib放到sql的insert，update中。

hib不知道这个列的值会被触发器修改，需要显式告诉hib使用select重新加载这个对象。
Item item = new Item();
Session session = getSessionFactory().openSession();
Transaction tx = session.beginTransaction();
session.save(item);
session.flush();

session.refresh(item);          // reload the object with a select

sysout(item.getCreated());
tx.commit();
session.close();

refresh()，更正式的定义是"利用数据库中的当前值，刷新处于持久化状态的内存实例"


还有一种更为简单的技术
<property name="created" type="timestamp" column="created" generated="insert" insert="false" update="false"/>

hib anno:
@Temporal(TemporalType.TIMESTAMP)
@org.hib.anno.Generated(
    org.hib.anno.GenerationTime.INSERT
)
@Column(name="created", insertable=false, updatable=false)
private Date created;

利用generated="insert"，hib在插入后自动执行select，来获取更新过的状态。
。。这种是获取一个列还是整个对象？


在更新时运行的触发器

另一项对generated属性的设置
<version name="version" column="obj_version" generated="always"/>
<timestamp name="lastModified" column="last_modified" generated="always"/>
<property name="lastModified" type="timestamp" column="last_modified" generated="always" insert="false" update="false"/>

注解版本是：
@Version
@org.hib.anno.Generated(org.hib.anno.GenerationTime.ALWAYS)
@Column(name="obj_version")
private int version;

@Version
@org.hib.anno.Generated(org.hib.anno.GenerationTime.ALWAYS)
@Column(name="last_modified")
private Date lastModified;

@Temporal(TemporalType.TIMESTAMP)
@org.hib.anno.Generated(org.hib.anno.GenerationTime.ALWAYS)
@Column(name="last_modified" insertable=false, updatable=false)
private Date lastModified;

利用always，启用hib的自动刷新，不仅针对行的插入还针对行的更新。换句话说，每当一个版本，时间戳，或者任何属性值在由update sql语句中运行的触发器生成/更新时，都需要启用这个选项。


拥有在更新中运行的触发器可能会遇到的第二个问题。
由于当托管对象被重附到新的session时(通过update/saveOrUpdate方法)，没有快照可用，hib可能执行不必要的sql update语句，确保数据库状态与持久化的上下文状态同步。这可能导致不合时宜地触发一个update触发器。通过在映射中为被持久化到带有触发器的表的类启用select-before-update,可以避免这种行为。
如果item表有一个触发器，就把下列属性添加到映射中：
<class name="Item" table="" select-before-update="true">
    。。
</cl

强制hib使用select来获取当前数据库状态的快照，如果内存Item的状态相同，则避免后面的update。用额外的select避免了不合时宜的update。

注解：
@Entity
@org.hib.anno.Entity(selectBeforeUpdate = true)
public class Item {...}


selectBeforeUpdate仅仅获得所述实体实例的状态。没有主动抓取任何集合或关联实例，也没有任何预抓取优化。

如果系统中多个实体启用selectBeforeUpdate，可能会发现通过未被优化的查询，会导致性能问题。

一种更好的策略是merge，而不是attach。hib可以在获取数据库快照时应用一些优化(外部联结)。后续会讨论attache和merge的区别。


8.2 定制SQL
sql标准的每一次更新都带来(许多有争议的)新特性，每个支持sql的dbms产品都以它自己独特的方式这么做着。
hib的内建查询机制，hql，criteria，根据所配置的数据库方言生成sql。所以其他自动生成的sql(例如，当集合必须按需获取时)也在方言的帮助下生成。利用一个简单的方言转换，可以在一个不同的dbms上运行应用。

为了支持这种可移植性，hib必须处理3种操作：
 每个数据获取操作导致正被执行的select语句。可能有多种变形，例如，数据库产品可能给联结操作使用一种不同的语法，或者结果如何被限制到特定数目的行。
 每个数据修改都需要执行DML语句，如update,insert,delete。dml不像select那么复杂，但仍然特定于DBMS。
 数据库schema必须在可以执行DML和数据获取之前创建或者改变。使用DDL在数据库目录上工作，它包括create,alter,drop这样的语句，DDL几乎完全特定于供应商的，但大部分产品至少有一个类似的语法结构。


hib基于org.hib.dialect.Dialect实现，为所有CRUD操作和模式定义生成sql。
鼓励你看看你正在只用的方言的源代码，它并不难阅读，一旦你对hib有更深了解后，你可能会想扩展一种方言，或编写自己的方言。

..。。org.hib.dialect.Dialect，这是个抽象类。具体实现看子类。

当你要在一个更低级的抽象上工作时，有时需要比hib api(或hql)提供的控制 更多的控制。通过hib，可以覆盖或完全替换所有将被执行的crud sql语句。如果依赖hib的自动schema导出工具，就可以定制和扩展所有定义schema的ddl语句。

hib运行通过session.connection()获取简单的jdbc connection。
。。5.1 这个方法的接口是 org.hibernate.engine.spi.SharedSessionContractImplementor。而不是Session了。。。3.X就已经在Session中Deprecated了。


8.2.1 编写定制CRUD语句

用定制sql加载实体和集合
<class name="User" table="">
    <id name="id" column="user_id"...
    <loader query-ref="loadUser"/>
</
loadUser查询可以被定义在映射元数据的任何地方，从它的用途中分离出来。
<sql-query name="loadUser">
    <return alias="u" class="User"/>
    select us.user_id as {u.id}, us.firstname as {u.firstname},... us.home_street as {u.homeAddress.street}, ... us.default_billing_details_id as {u.defaultBillingDetails}
    from Users us where us.user_id=?
</sql-query>

从列名到实体属性的映射使用了一个简单的别名。在具名的加载程序中查询实体，必须select以下列和属性：
 主键列和主键属性，包括复合主键，复合主键的属性、
 所有标量属性，必须从它们相应的列中被初始化
 所有必须被初始化的复合属性。可以利用下列别名语法处理单独的标量元素：{entityalias.componentProperty.scalarProperty}
 所有外键列，必须被获取并映射到相应的many-to-one属性。
 所有标量属性，复合属性，和<join>元素内部的多对一实体引用。如果所有被联结的属性永远不为null，就使用一个联结到二级表的内部联结，否则，用外部联结更恰当。
 如果通过字节码基础设施给标量属性启用了延迟加载，就不需要加载延迟属性。

别名并非必须，如果结果中的列名和被映射的列的名称相同，hib就自动绑定。
。。？应该是属性名称 和 列名吧？

可以在程序中使用session.getNamedQuery("loadUser")，按名称调用被映射的查询。
。。5.4是 session.getSessionFactory().getNamesQueryRepository().getgetNamedQueryDefinition
...getNamesQueryRepository 从6开始也会没有。现在是Deprecated了。
。。@deprecated (since 5.2) it will be replaced with the new QueryEngine concept introduced in 6.0
。。电脑上的是5.4了。


定制用来加载集合的sql,如，被一位User售出的items。
<set name="items" inverse="true">
    <key column="seller_id" not-null="true"/>
    <one-to-many class="Item"/>
    <loader query-ref="loadItemsForUser"/>
</set>

<sql-query name="loadItemsForUser">
    <load-collection alias="i" role="User.items"/>
    select {i.*} from item i where i.seller_id=:id
</sql-query>

有2个重要区别：一个是从别名映射到集合角色的<load-collection>，这个查询中新出现的东西是，从sql表别名item i到所有包含{i.*}的货品属性的自动映射。通过使用相同的别名(符号i)，创建了2者之间的一个联结。此外，你现在正在使用具名参数:id，而不是包含问号标记的简单的定位参数。

有时，通过外部联结，可以在单个查询中更好地加载实体实例和集合(实体可能有一个空的集合，因此无法使用内部联结)。如果想要应用这个主动抓取，就不要为集合声明装载程序引用。实体装载程序负责集合的获取：
<sql-query name="loadUser">
    <return alias="u" class="User"/>
    <return-join alias="i" property="u.items"/>
    select {u.*}, {i.*} from users u left outer join item i on u.user_id = i.seller_id where u.user_id=?
</

使用<return-join>把别名绑定到实体的集合属性，有效地把两个别名链接在一起。
如果想要在一个原始查询中主动抓取一对一和多对一关联的实体，这个方法也有效。这种情况下，如果被关联的实体是强制的(外键不能为null)，你可能想要用内部联结，如果目标是可选的，可能要用外部联结。
可以在查询中即时获取许多个单端的关联，然而，如果(外部)联结了不止一个集合，就会创建一个笛卡尔积，者可能导致产生比2个查询更慢的巨大结果。


定制插入，更新，删除
hib在启动时，生成所有琐碎的crud sql。
对于每个实体或集合，可以在<sql-insert><sql-delete><sql-update>内部相应地定义定制的cud sql
<class name="User" table="">
    <id name="id"...
    <join table="billing_address" optional="true">
        <key column="user_id"/>
        <component name="billingAddress" class="Address">
            <property...
        </c
        <sql-insert>
            insert into billing_address(street,zipcode,city,user_id) values (?,?,?,?)
        </sql-insert>
        <sql-update...
        <sql-delete...
    </join>
    <sql-insert>
        insert into users(firstname, lastname,..."password",email...) values (?,?...?)
    </sql-insert>
    <sql-update>...
    <sql-delete>..
</class>

单个映射中有2张表，主表用于实体users，二级表billing_address来自本章前面的遗留映射。

hib如何确定实参的顺序？从映射文件中移除定制sql，启动org.hib.persister.entity包的debug日志。查找类似下面的行：
AbstractEntityPersister - Inser 0: insert into users (firstname,lastname...user_id) values (?,?,...?)
AbstractEntityPersister - Update 0: update users set firstname=?, lastname=?...where user_id=?

现在可以复制这些语句，并进行必要的修改。


动态的sql并不是获取和操作数据的唯一方法。保存在数据库中预设的和编译好的过程也可以被映射到对实体和集合的crud操作。

一种观点是许多业务逻辑不应该被重复。这包括保证数据完整性的过程(如，复杂到难以声明式实现的约束)。你通常也会在具有过程完整性规则的数据库中发现触发器。

存储过程在大量数据上的所有处理中都有优势，例如生成报表和统计分析。你应该始终努力避免在网络上以及在数据库与应用程序服务器之间设置大数据，因此存储过程是大数据操作自然的选择，或者你可以实现一个复杂的数据获取操作，在它把最终的结果传递到应用程序客户端之前，通过几个查询把数据装配起来。


编写存储过程
本节中使用Oracle数据库和PL/SQL。
使用PL/SQL编写的存储过程必须在数据库目录中作为源代码创建，然后编译。
先编写一个可以加载所有符合特定标准的user实体的存储过程

<database-object>
    <create>
        create or replace procedure select_users_by_rank
        (
            out_result out sys_refcursor,
            in_rank in int
        ) as 
        begin    
            open out_result for
            select
                us.user_id as user_id,
                us.firstname as firstname,.......
                ba.home_street as home_street,
                ba.home_zipcode as home_zipcode...
            from users us
            left outer join billing_address ba on us.user_id=ba.user_id
            where us.ranking>=in_rank;
        end;
    </create>
    <drop>
        drop procedure select_user_by_rank
    </drop>
</

在数据库schema利用hbm2ddl工具被创建和更新时，hib就会自动创建和删除过程。


MS SQL Server中类似的过程如下：
create procedure select_users_by_rank
    @IN_RANK int
    as
    select
        us.user_id as user_id,
        ...
    from users us
    where us.ranking>=@IN_RANK


利用过程查询
用于查询的存储过程被映射为一般的具名查询，但有一些微小的区别：
<sql-query name="loadUsersByRank" callable="true">
    <return alias="u" class="User">
        <return-property name="id" column="user_id"/>
        <return-property name="firstname" column="firstname"/>
        ...
        <return-property name="homeAddress">
            <return-column name="home_street"/>
            <return-column name="home_zipcode"/>
            <return-column name="home_city"/>
        </return-property>
    </return>
    { call select_users_by_rank(?, :rank) }
</sql-query>

第一个区别是callable="true"
homeAddress属性通过3个属性映射为<component>，每个属性都映射到它自己的列。因此，存储过程映射包括绑定到homeAddress属性的三个列。

存储过程的call准备了out(问号标记)和具名的输入参数。如果你没有使用oracle驱动，就不需要保存第一个out参数。

下面是User类的常规类映射，这个例子中被过程返回的列名于你已经映射过的列名相同。可以省略每个属性的绑定，并让hib自动负责映射
<sql-query name="loadUsersByRank" callable="true">
    <return class="User"/>
    { call select_users_by_rank(?, :rank) }
</sql-query>

这里使用的语法{call PROCEDURE()}是sql标准的，可移植的。oracle有一种独有的语法begin PROCEDURE(); end; 是不可移植的。

在程序中利用这个存储过程的查询看起来就像任何其他具名查询一样：
Query q = session.getNamedQuery("loadUsersByRank");
q.setParameter("rank", 12);
List r = q.list();


大数据操作，在数据库层中执行，不应该在hib中映射它。而是应该通过最简单的jdbc：session.connection().prepareCallableStatement()等来执行它。
。。现在java.sql.connection中只有preapreCall，来准备调用存储过程。


把cud映射到过程
<class name="User">
    ..
    <sql-update callable="true" check="none">
        { call update_user(?,?,?,,,?) }
    </sql-update>
</class>

同样的问题：如何把值绑定到占位参数。同样的方法，打开日志，查看hib生成的sql的顺序，就是实参的顺序。

check="none"，为了正确地乐观锁，hib需要知道这个定制更新是否成功。通常，对于动态生成的sql，hib查看从操作中返回的被更新行的数量。如果操作没有/无法更新任何行，就出现乐观锁失败。如果你编写自己的定制sql操作，也可以定制这个行为。
利用check="none"，hib期待你的定制过程内部处理失败的更新(例如，通过给需要被更新的行做一个版本检查)，并期待过程在出错时抛出异常。oracle中这种存储过程如下：
<datebase-object>
    <create>
        create or replace procedure update_user
        (
            in_firstname in varchar,
            in_lastname in varchar,
            ....
        )
        as
            rowcount integer;
        begin
            update users set 
                firstname = in_firstname,
                lastname = in_lastname,
                ...
            where
                obj_version = ...;
            rowcount := SQL%ROWCOUNT;
            if rowcount != 1 then
                raise_application_error(-20001m 'version check failed');
            end if;
        end;
    </create>
    <drop>
        drop procedure update_user
    </drop>
</database-object>

sql错误被hib抓住,并转为一个可以在代码中处理的乐观锁异常。
检查属性的其他选项：
如果启用check="count"，hib使用简单jdbc检查被修改的行数。在你编写动态的sql而没有用存储过程时是默认这个选项。
如果启用check="param",hib会保存一个out参数，获取存储过程调用的返回值。你需要把一个额外的?添加到调用。并在存储结构中返回这个out参数中dml的行数，然后hib验证被修改的行数。

插入，删除的映射很类似，都必须声明乐观锁检查如何进行。可以从hib启动日志中复制一个模板，获得参数的正确顺序和数量。


映射存储函数
存储函数只有输入参数--没有输出参数。但它可以返回值。
例如，存储函数可以返回用户的等级：
<database-object>
    <create>
        create or replace function get_user_rank
        (in_user_id int)
        return int is
            rank int;
        begin
            select ranking into rank from users where user_id=in_user_id;
            return rank;
        end;
    </
    <drop>
        drop function get_user_rank
    </
</

这个函数返回一个标量数。返回标量的存储函数的主要用例是在常规的sql或hql查询中嵌入调用。例如，获取比指定等级更高的所有用户：
String q = "from User u where u.ranking>get_user_rank(:userId)";
List r = session.createQuery(q).setParameter("userId", 123).list();

。。hql直接写User，java类名，不带包。。不知道重名的话会怎么办。


8.3 改进Schema DDL
DDL定制分为2类
1 在映射元数据中现实命名自动生成的数据库对象，如列，表，约束。
2 在映射元数据中处理额外的数据库对象，如索引，约束，存储过程。

把属性和元素添加到Item类的映射中：
<class name="Item" table="items">
    <id name="id" type="string">
        <column name="item_id" sql-type="char(32)"/>
        <generator class="uuid"/>
    </id>
    <property name="initialPrice" type="big_decimal">
        <column name="init_price" not-null="true" precision="10" scale="2"/>
    </property>
    <property name="desc" type="string" column="item_desc" length="4000"/>
    <set name="categories" table="category_item" cascade="none">
        <key>
            <column name="item_id" sql-type="char(32)"/>
        </key>
        <many-to-many class="Category">
            <column name="category_id" sql-type="char(32)"/>
        </
    </
</

String默认对于varchar，这里使用char(32)，更精确。

@Entity
@Table(name="items")
public class Item {
    @Id
    @Column(name="item_id", columnDefinition="char(32)")
    @GeneratedValue(generator="hibernate-uuid.hex")
    @org.hib.anno.GenericGenerator(name="hibernate-uuid.hex", strategy="uuid=.hex")
    private String id;

    @Column(name="init_price", nullable=false, precision=10, scale=2)
    BigDecimal initialPrice;

    @Column(name="itm_desc", length=4000)
    private String desc;

    @ManyToMany
    @JoinTable(
        name="category_item",
        joinColumns={@JoinColumn(name="item_id",columnDefinition="char(32)")},
        inverseJoinColumns={@JoinColumn(name="category_id",columnDefinition="char(32)")}
    )
    private Set<Category> categories = new HashSet<Category>();

    ...

}


8.3.2 确保数据一致性
dbms允许你把完整性规则声明式地实现为数据库的一部分。声明规则的好处包括减少代码中的可能错误，以及dbms优化数据访问的机会。

4个级别的规则：
领域约束，领域是数据库中的一种数据类型。定义了一个特定的数据类型可以处理的值的范围。如，int可以用于整数值，char可以保存字符串。如果创建用户自定义的数据类型，你须定义它们的约束。如果它们得到你的数据库的支持，就可以使用对定制领域的支持，给特定的数据类型添加额外的约束。

列约束，限制了一个列保存特定领域的值，相当于增加一个列约束。如，ddl中init_price列，内部使用数据类型number(10,2)。大多数时候直接使用数据类型，而不用事先定义领域。sql中一个特殊的列约束是not null.

表约束，应用到单行或几行的完整性规则。典型的表约束是unique。只影响单行的一个规则是：拍卖的终止日期应该晚于开始日期。

数据库约束，如果一项规则应用给不止一张表，它就有数据库范围。如：外键


添加领域约束和列约束
create domain emailaddress as varchar
    constriant domain_emailadress
    check (IS_EMAILADDRESS(value));

创建表时，你现在可以把这个领域标识符用作列类型：
create table users (
    user_email emailaddress(255) not null,
    ...
);

sql中领域相对次要的好处是把一般的约束提取到一个单个位置，当插入或修改数据时，领域约束始终立即得到检查。
为了完成上面的例子，还需要编写存储函数is_emailaddress。

hib中映射新领域于sql-type一样简单：
<property name="email" type="string">
    <column name="user_email" length="255" not-null="true" sql-type="emailaddress"/>
</


@Column(name="user_email", length=255, columnDefinition="emailaddress(255) not null")
String email;

如果想要利用schema自动创建和删除领域声明，就把它放到<database-object>映射中。

sql支持额外的列约束。如，只允许字母和数字：
create table users (
    username varchar(16) not null check(regexp_like(username,'^[[:alpha:]]+$')),
    ...
)
可能你的dbms不支持这个表达式。
可以在hib的<column>中声明单列检查约束：
<property name="username" type="string">
    <column name="username" length="16" not-null="true" check="regexp_like(username,'^[[:alpha:]]+$')"/>
</property>

hib anno支持注解中检查约束
@Column(name="username", length=16, nullable=false, unique=true)
@org.hib.anno.Check(constraints="regexp_like(username,'^[[:alpha:]]+$')")
private String username;

有一个选择：创建和使用领域，或添加单个列的约束，作用都一样，长期而言，领域通常更易于维护，并且更可能避免重复。
。。领域就是自定义sql类型， 约束就是保存时检查。


单个行的表级约束
create table item (
    ...
    start_date timestamp not null,
    end_date timestamp not null,

    check(start_date<end_date)
);

约束表达式可以放在<class>
<class name="Item" table="" check="start_date &lt; end_date">

<这个字符必须用xml的&lt;转义。

注解：
@Entity
@org.hib.anno.Check(
    constraints="start_date<end_date"
)
public class Item {...}


多行的表约束需要更复杂的表达式。表达式中可能需要一个子查询。你的dbms可能不支持。
有一些一般的多行表约束，可以添加到在hib中.把User的注册名称标识为系统中唯一：
<property name="username" type="string">
    <column name="username" length="16" not-null="true" check="regexp_like(username,'^[[:alpha:]]+$')" unqiue="true"/>
</

注解中：
@Column(name="username" length=16, nullable=false, unique=true)
@org.hib.anno.Check(
    constraints = "regexp_like(username, '...')"
)
private String username;

jpa xml,这里没有检查约束
<entity class="auction.model.User" access="FIELD">
    <attributes>
        <basic name="username">
            <column name="username" length=16 nullable="false" unqiue="true"/>
        </
    </
</

唯一约束也可以跨列
如，CaveatEmptor支持嵌套的Category对象树。其中一个业务规则时，一个特定的分类不能于它的任何同胞同名。
<class name="Category" table="">
    <property name="name">
        <column name="cat_name" unique-keyu="unique_siblings"/>
    </
    <many-to-one name="parent" class="Category">
        <column name="parent_category_id" unique-key="unique_siblings"/>
    </
</

unique-key属性把一个标识符分配给约束，以便可以在一个类映射中多次引用它，并把相同的约束分组成列。
然而，导出的ddl中不用标识符命名约束：
creata teble category (
    cat_name varchar(255) not null,
    parent_category_id integer,
    ...    
    unique (cat_name, parent_category_id)
);

如果想用注解创建一个跨列的唯一约束，就需要在实体中声明，而非单个列
@Entity
@Table(name="category", uniqueConstraints={@UnqiueConstraint(columnNames={"cat_name". "parent_category_id"})})
public class Category {...}


jpa xml
<entity class="Category" access="FIELD"/>
    <table name="category">
        <unique-constraint>
            <column-name>cat_name</column-name>
            <column-name>parent_category_id</xx>
        </
    </
    ...
</


完全定制约束，包括一个可用于数据库目录的标识符，可以通过<database-object>元素添加到DDL：
<database-object>
    <create>
        alter table category add constraint unique_siblings unique(cat_name,parent_category_id);
    </
    <drop>
        drop constraint unqieu_siblings
    </
</


数据库约束
可以通过联结在任何check表达式的子查询中创建跨几张表的规则。
。。机翻。

创建适用于整个数据库的约束的另一种技术是使用定制触发器，它们在特定表中行的插入或更新中运行。

目前为止，大部分跨表的常用规则都是参照完整性规则，即外键，外键是2个东西的组合：一个从相关的行中复制出来的键值，和一个保证引用值存在的约束。
hib自动给关联映射中的所有外键创建外键约束。

可以利用foreign-key属性在Item类的<many-to-one>映射中定制约束的名称：
<many-to-one name="seller" class="User" column="seller_id" foreign-key="fk_seller_id"/>
。。定制约束的名称。。

注解
@ManyToOne
@JoinColumn(name="seller_id")
@org.h.a.ForeignKey(name="FK_SELLER_ID")
private User seller;

创建多对多中的外键需要一种特殊语法：
@ManyToMany
@JoinTable(...)
@org.h.a.ForeignKey(
    name="fk_category_id",
    inverseName="fk_item_id"
)
private Set<Category> categories;


不要立刻拒绝可能违背外键约束的数据修改，sql数据库可以把这个变化级联到引用行。如，如果父行被删除，父行主键上包含外键约束的所有子行也可能被删除。如果需要使用数据库级的级联关系，就在外键映射中启用它们
<class name="Item" table="">
    <set name="bids" cascade="save-update, delete">
        <key column="item_id" on-delete="cascade"/>
        <one-to-many class="Bid"/>
    </
</

hib现在创建和依赖外键约束的数据库级on cascade delete 选项，而不是item实例被删除且所有出价必须被移除时，执行多个单独的delete语句。
这个特性绕过了hib的乐观锁策略



创建索引
索引不是sql标准的一部分。

CaveatEmptor中许多查询都将涉及拍卖Item的endDate属性。可以对这个属性创建索引
<property name="endDate" column="end_date" type="timestamp" index="idx_end_date"/>

自动生成的ddl语句现在包含一条额外的：
create index idx_end_date on item (end_date);

注解：
@Column(name="end_date", nullable=false, updatable=false)
@org.hib.anno.Index(name="idx_end_date")
private Date endDate;

可以在多个属性映射中设置相同的标识符来创建一个多列的索引。

任何其他的索引选项，如unique index(创建一个额外的多行表级索引),索引方法(一般为btree,hash和binary)和任何存储字句(如，在单个表空间创建索引),可以通过<database-object>只在完整定制的ddl中设置。

创建注解的多列索引在实体级中定义，通过把额外的属性应用到表映射的定制hib注解：
@Entity
@Table(name="items")
@org.hib.anno.Table(
    appliesTo="items"， indexes = 
        @org.hib.anno.Index(
            name="idx_initial_price", columnNames={"initial_price","initial_price_currency"}
        )
)
public class Item {...}

org.hib.anno.Table不是javax.persistence.Table的替代物，因此，如果需要覆盖默认的表名，依然需要使用常规的@Table。




<database-object>
    <create>
        [...]
    </
    <drop>
        ...
    </
    <dialect-scope name="org.hib.dialect.Oracle9Dialect"/>
    <dialect-scope name="org.hib.dialect.OracleDialect"/>
</

<dialect-scope>把定制的create，drop语句限制为一个特定的被配置数据库方言组。

如果需要更多对于生成的ddl的可编程式的控制，就实现AuxiliaryDatabaseObject接口。
hib包含了一个可以子类化的便利实现：AbstractAuxiliaryDatabaseObject

可以通过编程来添加方言范围，甚至可以访问sqlCreateStirng，sqlDropString方法中的一些映射信息。
必须在映射元数据中启用这个定制类
<database-object>
    <definition class="auction.persistence.CustomDDLExtension"/>
    <dialect-scope name="org.hib.dialect.OracleDialect"/>
</
额外的方言范围是累积的，前面的例子全部应用两种方言。









part 3 会话对象处理

hibernate持久化管理器Session
ejb 3.0中jpa的接口是EntityManager.

持久化生命周期，指对象在它的生命期间经历的状态。
工作单元：把一组操作当作一个(通常是原子的)组。
把持久化上下文当作高速缓存，它记住你在一个特定的工作单元中给对象所作的所有修改和状态改变。


hib只定义4种状态。
瞬时，移除，持久化，托管。

自己new的是瞬时
hib，new的是持久化(在查询时，需要new来转换数据表达形式)

瞬时经过save,saveOrUpdate,persist,merge，变成持久化。
持久化经过evict,close,clear，变成托管。
脱管经过，update,saveOrUpdate,merge变成持久化
持久化经过delete，remove，变成移除状态。

merge，合并并返回一个持久化实例，原始实例没有改变状态。
close，clear，影响持久化上下文中的所有实例。


瞬时对象
jpa没有瞬时这种术语，而是 新的 这个术语。

hib，jpa认为所有的瞬时实例都要变成非事务的。持久化上下文不知道瞬时实例的任何修改，这意味者hib不给瞬时对象提供任何回滚功能。

只被其他瞬时实例引用的对象也默认是瞬时的。
要从瞬时变成持久化，需要调用持久化管理器，或从已经持久化的实例中创建一个引用。


持久化对象
持久化对象是一个包含数据库同一性的实体实例。这意味者持久化且被托管的实例具有设置成为其数据库标识符的主键值。

持久化对象始终与持久化上下文关联，hib高速缓存它们。并且可以侦测到它们是否已经被程序修改。


移除对象
几种方式删除实体实例。如：用持久化管理器的一个显示操作把它移除。如果移除所有对它的引用，它可能变成可以删除的了，这个特性只在包含hib扩展设置(实体的孤儿删除)的hib或jpa中才可用。
如果一个对象已经被计划在一个工作单元结束时删除，它就处于移除状态，但仍然由持久化上下文托管，直到工作单元完成。换句话说，移除对象不应该被重用，因为一旦工作单元完成，它就立即从数据库中被删除。你也应该放弃在程序中保存着的任何对它的引用。


脱管(detached)对象
要理解脱管对象，你需要考虑实例的一种典型的转变：它先是瞬时的，因为它刚刚在应用程序中创建。现在通过在持久化管理器中调用一个操作使它变成持久化。所有这些都发生在单个工作单元中，并且这个工作单元的持久化上下文在某个时间点(当产生一个sql的insert时)与数据库同步。
现在工作单元完成了，持久化上下文也关闭了。但是在应用程序中仍然有一个句柄---对被保存实例的一个引用。只要持久化上下文是活动的。这个实例的状态就是持久化的。在工作单元结束时，持久化上下文关闭。你现在保存着对其引用的是什么对象状态，以及如何处理呢？
我们把这些对象当作脱管(detached)，表示它们的状态不再保证与数据库状态同步，不再被附加到持久化上下文中，并仍然包含持久化数据(可能很快会实效)。
可以继续使用脱管对象并修改它。
有时，你需要将那些变化持久化---换句话说，把脱管实例变回到持久化状态。
hib提供重附(reattachment)和合并(merging)两种操作来处理这种情况。
jpa只对合并标准化了。

这些特性对于如何设计多层应用程序有着深刻的影响。从一个持久化上下文返回对象到表现层，并随后在一个新的持久化上下文中重用它们的能力是hib和jpa的主要卖点。它让你能够创建跨越用户思考时间的长工作单元。我们称这种长期运行的工作单元为对话(conversation)。



hiberante中，假设一个Session有一个内部的持久化上下文。
jpa中，EntityManager具有持久化上下文。

一个工作单元中所有处于持久化状态和脱管状态的实体都被高速缓存在这个上下文中。
持久化上下文之所以有用，基于以下几个原因：
hib可以进行自动的脏检查和事务迟写
hib可以用持久化上下文作为一级高速缓存
hib可以保证java对象同一性的范围
hib可以把持久化上下文扩展到跨整个对话。


自动脏检查
持久化实例托管在一个持久化上下文中--它们的状态在工作单元结束时与数据库同步。当一个工作单元结束时，保存在内存中的状态通过sql insert，update，delete语句(dml)的执行被传播到数据库。
这个过程也可能发生在其他时间点。如，hib可能在查询执行之前与数据库同步。这样确保了查询知道在工作单元期间之前所作的改变。

hib不会在工作单元结束时，将内存中每个单独持久化对象的状态更新到数据库行。ORM软件必须有一个策略，用来侦测哪个持久化对象已经被应用程序修改。我们称之为自动脏检查。一个修改过的对象在还没有被传播到数据库时被认为是脏的。这种状态对于应用程序不可见。利用透明的事务级迟写，hib尽可能迟地把状态变化传播到数据库，但是从应用程序中隐藏这个细节。通过尽可能迟地执行dml(趋向于数据库事务的结束)，hib试图保证数据库中的锁时间尽可能短。(DML通常在数据库中创建一直被保存到事务结束的锁)

hib能准确地侦测哪些属性已经被修改。以便有可能只包含需要在sql update语句中更新的列。这可能带来一些性能上的收获。但差别通常不明显，理论上来说，这样在某些环境下会损害性能。
默认情况下，hib的update语句包含被映射表的所有列(因而，hib可以在启动时而不是在运行时生成这个基础的sql)。
可以通过在类映射中设置dynamic-update="true"启用动态的sql生成。
dynamic-insert="true"启用insert语句的运行时生成。
当一张表中有特别多的列(如，超过50列)时，我们建议考虑这种设置，有时候，无变化的字段所引起的网络流量也是不容忽视的。

自定义脏检查算法。hib默认把一个对象的旧快照与同步时的快照进行对比，侦测任何需要更新数据库状态的修改。可以通过org.hibernate.Intercepter给Session提供一个定制的findDirty()方法来实现自己的子程序。
。。hib自己的脏检查代码在哪里。。？


持久化上下文高速缓存
持久化上下文是持久化实体实例的一个高速缓存，这意味着它记住了你已经在特定的工作单元中处理过的所有持久化实体实例。
自动脏检查是这个高速缓存的好处之一。另一个好处是对实体的可重复读，以及工作范围高速缓存单元的性能优势。

如果hib被告知通过主键加载对象，它就可以先在当前的工作单元的持久化上下文中检查。如果在那里找到了实体，就不会去数据库搜索。
如果查询通过hib/jpa的某个接口执行也一样。hib读取查询的结果集，并封送(？指将sql结果转为对象？)随后返回给应用程序的实体对象。在这个过程中，hib也与当前的持久化上下文交互。它试图解析这个高速缓存中的每个实体实例(通过标识符)，只有在当前的持久化上下文中无法找到该实体时，hib才会从结果集中读取剩下的数据。
。。1条sql，select *,先读取主键，如果缓存中有，那么就不new了，如果cache中没有，就new对象，并且读取ResultSet中剩下的字段，赋值到对象的属性。
。。那我按主键+某个属性去搜索，hib会不会发出sql？毕竟主键对象是存在的，但是某个属性可能导致sql搜不到数据。

持久化上下文高速cache带来重大的性能好处，并改进工作单元中的孤立保证(免费得到了实体实例的可重复读取)。由于这个高速缓存只有工作单元的范围，它没有真正的缺点，例如，对并发访问的锁控制---工作单元是在单个线程中处理的。

持久化上下文高速缓存有时避免了不必要的数据库流量，但更重要的是，它确保了：
持久层在对象图中出现循环引用时，不会出现堆栈溢出的影响
工作单元结束时永远不能有相同数据库行的冲突的表示方法/对象。在持久化上下文中，最多一个对象表示任意一个数据库行，对该对象进行的任何改变都可以被安全地写入到数据库中。
。。2个对象指向同一个数据库行，后update会把前update的数据更新掉。
同样地，在特定持久化上下文中进行的改变，也始终立即对在持久化上下文和它的工作单元内部(对实体保证的可重复读取)执行的所有其他代码可见。


持久化上下文高速缓存，始终开启，不能关闭。


对象的同一性和等同性

一个基础的hib客户端/服务端应用程序可能通过跨单个客户端请求的服务器端的工作单元进行设计。当来自应用程序用户的一个请求需求数据访问时，就启动一个新的工作单元。这个工作单元在处理结束时终止，并为客户准备好了响应。这也被称为每次请求一个会话策略。

在web应用程序中，通常不维护跨用户交互的数据库事务。用户花很长时间思考修改，但由于可伸缩性的原因，必须保持数据库事务简短，并尽快释放数据库资源。当需要引导用户通过几个屏幕完成一个工作单元时，可能面对这个问题。例如--填写一张在线的表格。在这个一般的场景中，拥有持久化服务的支持非常有用，因此可以用最少的代码和最佳的可伸缩性实现这样一个对话。

有2种策略可以在hib/jpa应用程序中实现对话：利用脱管对象，或通过扩展一个持久化上下文。这2者均各有利弊。

脱管对象状态和已经提到过的重附或合并的特性 是实现对话的方法。
用户在思考时对象以脱管状态保存，并且这些对象的任何修改都通过重附或合并被手工变成持久化。这一策略也被称为利用脱管对象每次请求一个会话。
持久化上下文只跨一个特定请求的处理，对话期间应用程序手工重附和合并(且有时脱管)实体实例。

另一种方法不需要手工重复或合并，利用每次对话一个会话的模式，把一个持久化上下文扩展到跨整个工作单元。

。。web-flow不知道是怎么弄的。，好像和它无关？session和线程绑定了，所以应该是web-flow开始时开启事务，结束时commit吧。就是第二种？。。但是好像出过问题，就是因为Agent在传递过程中脱管了。。


java同一性a==b和数据库同一性x.getId().equals(y.getId())，有时它们是相等的，有时不等。
我们把java同一性等价于数据库同一性的条件称作对象同一性的范围。
对这一范围，有3种常见选择：
 没有同一性范围的基本持久层不保证一个行是否被访问2次，以及是否会把相同对象实例返回给应用程序。如果应用程序修改了都在单个工作单元中表示同一行的2个不同的实例，就会有问题。
 持久层利用持久化上下文范围的同一性。保证在单个持久化上下文的范围中，只有一个对象实例表示一个特定的数据库行。这样避免了前一个问题，还允许在上下文级的一些高速缓存。
 过程范围的同一性，更进一步，保证整个过程(jvm)中只有一个对象实例表示该行。
。。第二种：session中唯一，2个session中可能重复。

对于典型web或企业应用程序，持久化上下文范围的同一性是首选。
过程范围的同一性，对跨多个工作单元的实例重用，在高速缓存利用率和编程模型方面提供了一些潜在的优势。但是，在一个遍布多线程的应用程序中，始终在全局的同一性映射中同步对持久化对象的共享访问成本太高，难以支付。
更简单且更可伸缩些的方法是：让每个线程在持久化上下文中使用一组独特的持久化实例。


hibernate中受保护的对象同一性范围
Session session1 = sessionFactory.openSession();
Transaction tx1 = session1.beginTransaction();

Object a = session1.get(Item.class, new Long(1234));
Object b = session1.get(Item.class, new Long(1234));

(a == b)        // True, persistent a and b are identical

tx1.commit();
session1.close();

Session session2 = sessionFactory.openSession();
Transaction tx2 = session2.beginTransaction();

Object c = session2.get(Item.class, new Long(1234));

(a == c)        // False

tx2.commit();
session2.close();


a和b不仅数据库同一，还具有java同一性，因为它们是在相同的Session中获得的。它们引用那个工作单元的持久化上下文中所知道的同一个持久化实例。一旦出了这个范围，hib就不保证java同一性了，因此a和c不相等。当然，测试数据库同一性的a.getId().equals(c.getId())，将仍返回true。


脱管对象的同一性
如果对象引用离开了受保护的同一性范围，那就就称它为脱管对象引用。
在上面的代码中，a,b,c都是数据库同一的。然而，它们不是相等的内存对象实例。
如果在脱管状态下把它们作为相等处理，就会产生问题。
考虑代码的下列扩展，在session2已经终止之后：
session2.close();
Set all = new HashSet();
all.add(a);
all.add(b);
all.add(c);

添加元素到Set时，equals方法被调用。所有java类都默认继承Object,的equals方法，这个实现使用了双等号(==)比较。
现在all中有2个元素，在真实应用程序中，你不可能知道a,b由同一个session加载。
此外，你显然希望这个集合正好只有一个元素。

。。所以需要重写 equals，hashCode。。话说native的主键策略，是怎么equals的？毕竟可能一个是父类的123，一个是子类的123，应该会对比2个类是否在继承树上吧？

每当使用脱管状态下的对象时，特别在给同一性进行测试时(通常在一个基于散列的集合中)，就需要为持久化类提供你自己的equals，hashCode方法。

如果要使用脱管对象，就必须用自己的程序测试它们的等同性。可以通过几种方式实现equals和hashCode，记住在覆盖equals时，也必须要覆盖hashCode，以便这2种方法保持一致。如果2个对象相等，它们就必须由相同的散列码。

一个方法是，equals方法中只比较标识符属性(通常是个代理主键)值：
public class User {
    
    public boolean equals(Object other) {
        if (this == other) return true;
        if (id == null) return false;
        if (!(other instanceof User)) return false;
        final User that = (User) other;
        return this.id.equals(that.getId());
    }

    public int hashCode() {
        return id == null ? System.identityHashCode(this) : id.hashCode();
    }
}
。。equals是在bmfobject中的，所以所有的可能相等的对象都是instanceof bmfobject的。

equals的第二行if (id == null) 是有道理的，因为它们不可能等于脱管实例，这个脱管实例有一个标识符值。
。。就是，第一行不相等，且id为null，说明 this 和 other 肯定是2个不同的java对象(第一行不相等就决定了)，也肯定不会将是2个相同行(2个不同游离对象，saveOrUpdate,后，肯定是2个行，不可能是一个行的(如果other是持久态，this是游离态，这2个也肯定不会相等的。)。)。。
。。对，游离态保存以后的id，肯定不会和that相等。


这种方案有一个大问题：标识符直到对象变成持久化时才由hib分配。如果瞬时对象在保存前被添加到Set，它的散列值就可能在它被Set包含时改变，与java.util.Set的约束相悖。特别是，这个问题使得级联保存对于集来说变得毫无用处。
我们强烈反对这种方案(数据库标识符等同性)。
。。。bmfobject，中会缓存hashCode，所以加入到set后，调用hashCode，那么这个值就确定了，

一种更好的方法是包括持久化类的所有持久化属性在equals()比较中，远离任何数据库标识符属性。这就是大多数人知道的equals的含义，我们称它为按值等同性。
当我们说所有属性时，并不想包括集合。集合状态与不同的表关联，因此把它包括在内似乎错了。更重要的是，你并不想强制获取整个对象图来执行equals。对于User而言，这意味者你不应该把boughtItems集合包含在比较式内。
public class User {
    public boolean equals(Object other) {
        if (this == other) return true;
        if (!(other instanceof User)) return false;
        final User that = (User) other;
        if (!this.getUsername().equals(that.getUsername()))
            return false;
        if (!this.getPassword().equals(that.getPassword()))
            return false;
        return true;
    }

    public int hashCode() {
        int result = 14;
        retult = 29 * result + getUsername().hashCode();
        return = 29 * result + getPassword().hashCode();
        return result;
    }

}

这种方法还有2个问题，第一，如果修改了其中一个(如，用户修改了密码)，那么来自不同Session的实例便不再相等。
第二，包含不同数据库同一性的实例(表示数据库表不同行的实例)可以被认为相等，除非属性的有些组合保证唯一(数据库列有一个唯一约束)。
对于这个案例中的用户而言，有一个唯一的属性：username。
这样就把我们引到了等同性检查的首选实现。你需要一个业务键

利用业务键实现等同性
业务键是一种属性，或者一些属性的组合，它对于每个包含相同的数据库同一性的实例来说是唯一的。本质上，它就是你的自然键。业务键并不是永远不变的---只要它很少变化，就足够了。

业务键是用户作为唯一辨别一个特定记录的东西，代理键是程序和数据库使用的东西。

业务键等同性意味着equals方法只比较构成业务键的属性。这是个完美的解决方案，避免了之前的所有问题。唯一的缺点是它需要特别记着：先辨别正确的业务键。

对于User类，username是一个很好的备用业务键。它永远不为空，通过数据库约束而唯一，并且即使改变也很少。

public class User {
    public boolean equals(Object other) {
        if (this == other) return true;
        if (!(other instanceof User)) return false;
        final User that = (User) other;
        return this.username.equals(that.getUsername());
    }

    public int hashCode() {
        return username.hashCode();
    }
}
。。前提是username在构造器中初始化吧。不然这个会空指针啊。


对于其他的类，业务键可能更复杂，下面是一些提示，帮助辨别业务键
考虑当应用程序的用户必须辨别一个对象时，他会使用什么属性。
每个不可变的属性都可能是一个好的备选业务键。如果可变属性很少更新，或当它们更新时，你能控制局势的话，可变属性也可能是一个好的备选对象。
每个包含unique数据库约束的属性都是好的备选业务键。
任何基于日期或者时间的属性，如记录的创建时间，通常都是业务键的一个好组件。syscurrentTimeMillis的准确性则取决于虚拟机和操作系统。我们建议的安全缓冲区是50ms，如果基于时间的属性是业务键的单个属性时，它可能还不够精确。
可以用数据库标识符作为业务键的一部分。例如，Bid类的一个备选业务键时Item的标识符，它与出价金额一起产生。

在一个子类上覆盖equals并在比较中使用另一个属性，这种做法通常是错误的。
equals和hashCode始终通过获取方法访问其他对象的属性。这非常重要，因为other可能是一个代理对象。


如果使用脱管对象时，同一性范围问题非常棘手，那么第二种对话实现策略可能就是你需要的。
hib,jpa通过一个被扩展的持久化上下文---每个对话一个会话策略--支持对话的实现。

扩展持久化上下文
一个特定的对话 是 所有交互重用相同的 持久化上下文。对话期间所有的请求都由相同的持久化上下文管理。
当来自用户的请求被处理之后，持久化上下文没有关闭。在用户思考时间内，它断开与数据库的连接，并保持这种状态。当用户在对话中继续时，持久化上下文被重新连接到数据库，就可以处理下一个请求了。对话结束时，持久化上下文与数据库同步并关闭。
这里消除了脱管这个状态。所有实例要么是瞬时的(不为持久化上下文所知)，要么是持久化的(附加到一个特定的持久化上下文)。
hib中，这个策略为对话的持续使用单个的Session，jpa对被扩展的持久化上下文有着内建的支持，甚至可以为你自动保存请求之间断开连接的上下文(在一个有状态的EJB会话bean中)


9.3 hibernate接口
任何透明的持久化工具都包括一个持久化管理器API。这个持久化管理器通常为以下内容提供服务：
基础的CRUD(创建，获取，更新，删除)操作
查询执行
事务的控制
持久化上下文的管理

持久化管理器可能通过几个不同的接口而被公开，对hib而言，它们是Session,Query,Criteria,Transaction。
。。就是 持久化管理器 并不是一个单独的类，而是多个类的集合。 会话，查询，查询，事务。

jpa中，主要接口是EntityManager,它扮演着和hib的Session一样的角色。其他的jpa接口是Query，EntityTransaction。

现在介绍hib和jpa加载和保存对象。有时，这2者有着完全相同的语义和api，甚至方法名称也相同。

hib中，通过实质上改变它们的状态来保存和加载对象。你在工作单元中进行这项工作。单个工作单元是一组被认为是原子团的操作。

1 开始工作单元
Session sesion = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

你永远不应该创建一个新的SessionFactory用来只服务一个特定的请求。SessionFactory的创建非常昂贵。
第二行通过hib的另一个接口开始一个Transaction。这是可选的。

2 使对象变成持久化
你要用Session做的第一件事就是通过save方法使一个新的瞬时对象变成持久化

Item item = new Item();
item.setName("player1");
item.setEndDate(...);
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

Seriablizable itemId = session.save(item);

tx.commit();
session.close();

tx.commit()时。我们说发生了清除(你也可以手工调用flush())。为了使持久化上下文同步，hib获得一个jdbc连接，并发出单个sql insert语句。
注意，对于插入来说，并非总是这样：hib保证item对象在保存之后有一个被分配的数据库标识符，因此可能需要更早的insert，取决于你在映射中启用的标识符生成器。
。。对啊。hilo，是由hib分配的，所以不需要insert就有主键了，但是其他的标识符生成器，可能就需要insert后才知道主键值。


在Session管理Item实例之前完全初始化它更好(但并非必要)。sql insert语句包含调用save()时对象保存者的值。
可以在save之后修改对象，这种变化会被作为一个(额外的)sql update传播到数据库。

session.beginTransaction()和tx.commit()之间的一切都在一个事务中发生。
在事务范围中的所有数据库操作要么完全成功，要么完全失败。
如果flush()时，有一条insert或update语句失败，那么这个事务中对持久化对象所作的所有变化便在数据库级回滚。
然而，hib不会把内存回滚到持久化对象。这是有道理的，因为事务的失败一般是不可恢复的，你必须立即放弃失败的Session。


3 获取持久化对象
Session也用于查询数据库，并获取现有的持久化对象。
hib给最简单的查询提供了2种特殊的通过标识符获取的方法，get，load

Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

Item item = (Item) session.load(Item.class, new Long(1234));
// Item item = (Item) session.get(Item.class, new Long(1234));

tx.commit();
session.close();

获取到的对象item处于持久化状态，并且一旦持久化上下文关闭，它就立即处于脱管状态。

get,load之间的一个区别在于它们如何表明实例无法被找到。如果数据库中不存在包含给定标识符值的行，get就返回null。load方法则抛出一个ObjectNotFoundException.

更重要的是，load可能返回一个代理，一个占位符，而不命中数据库。一旦你试图访问返回的占位符，就立即强制它初始化，你可能会得到一个ObjectNotFoundException。
load方法始终试图返回一个代理，如果它已经由当前的持久化上下文管理，则仅返回一个已被初始化的对象实例。
在上面的例子中，根本没有发生数据库命中。
。。get被注释掉了。所以单独load不会命中数据库。

另一方面，get方法从不返回代理，它始终命中数据库。

load是为了：获得一个持久化实例，并把它作为对另一个实例的引用进行分配。例如，获取item只是为了一个目的：aComment.setForAuction(item)设置一个关联。那么代理会做得很好，不需要命中数据库。



4 修改持久化对象
由get,load返回的任何持久化对象，或者任何被查询的实体，都已经与当前的session和持久化上下文关联。它可以被修改，并且其状态与数据库同步。
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
Item item = (Item) session.get(Item.class, new Long(1234));
item.setDesc("new");
tx.commit();
session.close();

当tx.commit被调用时，这些修改在清除期间被传播到数据库。这种机制被称为自动脏检查，hib追踪并保存在持久化状态中对一个对象所作的改变。一旦关闭session，这个实例就被认为是脱管了


5 使持久化对象变成瞬时
session.delete(item)方法。

调用delete之后，item对象处于移除状态，你不应该继续使用它。大多数情况下，应该确保应用程序中对它的任何引用都被移除了。
只有当Session的持久化上下文在工作单元结束时与数据库同步，才执行sql delete。
session关闭后，item是一个普通的瞬时实例。

。。delete之后，再开一个Session，save，这会报什么错？主要是item的id是有值的，但是id作为主键，在数据库中没有行对应。

删除前，对象必须被加载。实例必须处于要被移除的持久化状态(代理就够了)。

如果启用了hibernate.use_identifier_rollback配置。hib也可以回滚已经被删除的任何实体的标识符。
前一个例子中，如果配置了这个选项。hib就会在删除和清除之后，设置被删除item的数据库标识符属性为null。item就是一个干净的瞬时实例了，可以在未来的工作单元中重用。


6 复制对象
hib可以使用一些特殊的案例。如，当你需要从一个数据库获取对象并把它保存到另一个数据库中的是后。这称为对象的复制。

Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
Item item = (Item) session.get(Item.class, new Long(1234));
tx.commit();
session.close();

Session session2 = sessionFactory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(item, ReplicationMode.LATEST_VERSION);
tx2.commit()
session2.close();

ReplicationMode控制复制过程的细节：
ReplicationMode.IGNORE：现有的数据库行包含与目标数据库中相同的标识符时忽略对象
ReplicationMode.OVERWRITE：覆盖任何包含与目标数据库中相同标识符的现有数据库行。
ReplicationMode.EXCEPTION：如果现有数据库行包含与目标数据库中相同的标识符时抛出异常。
ReplicationMode.LATEST_VERSION：如果目标数据库的版本比对象的版本更早，则覆盖它里面的行，否则忽略对象。你需要启用hib乐观并发性控制。

。。现有应该值session2,目标应该是指session。

当你在产品升级期间升级系统配置信息时，或当你需要回滚非acid事务期间所作的改变时，都可能需要复制。



使用脱管对象
Session关闭之后修改item，不会影响数据库中的行。
持久化上下文一关闭，item就成了一个脱管实例。
如果需要保存对脱管对象所做的修改，必须重附或合并它。

1 重附被修改的脱管实例
脱管实例可以通过在托管对象上调用update()，被重附到新的Session(并由新的持久化上下文托管)。
update方法在数据库中强制更新对象的持久化状态，始终计划一个sql update。

item.setDesc("asdf");
Session session2 = sessionFactroy.openSession();
Transaction tx = session2.beginTransaction();
session2.update(item);
item.setEndDate(...);
tx.commit();
session2.close();

item对象在传递到update之前还是之后被修改都没有关系。这里重要的是，update的调用把脱管实例重附到这个新的Session(和持久化上下文)。hib始终把这个对象当作脏对象来处理。
。。对，始终是脏对象，所以update时的快照就应该无意义了。毕竟快照是在加入到上下文时进行的，之前的修改并不知道。所以只能默认为脏对象。

避免这个update的方法是：通过select-before-update="true"属性配置Item的类映射。然后hib通过执行一个select语句，把对象的当前状态与数据库中的状态进行比较，确定是否为脏对象。


如果确定没有修改脱管实例，你可能会更喜欢另一种重附方法，它不会总是计划一个sql update。

2 重附未被修改的脱管实例
lock()的调用把对象与Session关联起来，不强制更新
Session s2 = sf.openSession();
Transaction tx = s2.beginTransaction();

s2.lock(item, LockMode.NONE);

item.setDesc("zxcv");
item.setEndDate(...);

tx.commit();
s2.close();

这里，变化是在重附之前还是之后，是很重要的。在lock()之前进行的修改不会被传播到数据库。

这里通过LockMode.NONE，告诉hib不要执行版本检查或在使对象与session关联时重新获得任何数据库级锁。
如果指定了LockMode.READ,LockMode.UPGRADE。hib就会执行select语句，以便执行版本检查(并锁定数据库中的行进行更新)


3 使脱管对象变成瞬时
delete()删除数据库中的的持久化状态。

这意味着你不一定要重附(update/lock)脱管实例来把它从数据库中删除。
delete具有2重功能，重附对象到session，计划删除对象(在commit中执行)。delete调用之后，对象的状态为移除。


4 合并脱管对象的状态
脱管对象的合并是另一种可以选择的方法。它可以是重附的补充，也可以取代重附。
合并最初引入到hib中，是用来处理重附无法满足的特殊案例(merge，在hib2.X中叫saveOrUpdateCopy)

item.getId();       // 1234
item.setDesc("...");
Session s = sf.openSession();
Transaction tx = s.beginTransaction();
Item item2 = (Item) s.get(Item.class, new Long(1234));
session.update(item);       // throws exception
tx.commit();
s.close();

新session，get以后，update旧item。
抛出NonUniqueObjectException。hib无法确定哪个对象表示当前状态。

可以先重附item解决这一问题。由于重附后，item处于持久化状态，get返回的是同一个对象。
但这很难在更为复杂的应用程序中进行重构。

hib自动合并item和item2。
item.getId();       // 1234
item.setDesc("zxc")

Session
Transaction tx = s.beginT

Item item2 = session.get(Item.class, new Long(1234));

Item item3 = ()session.merge(item);

item == item2   // F
item == item3   // F
item2 == item3  // T


merge导致了几个动作。第一，hib检查持久化上下文中的持久化实例是否具有与正在合并的脱管实例相同的数据库标识符。
如果有相等的持久化实例，hib把脱管实例的状态复制到持久化实例中。即item中desc被设置到了item2上。
如果没有，hib从数据库加载它，然后把脱管状态与被获取的状态合并。
如果上下文中没有，数据库里也没有，就会创建新的持久化实例，并且把被合并的实例的状态复制到新实例中。然后就计划把这个新对象插入到数据库中，并通过merge操作返回。

如果传到merge的是一个瞬时实例，而不是脱管对象时，也会发生插入。



管理持久化上下文

1 控制持久化上下文高速缓存
持久化上下文时持久化对象的一个高速缓存。持久化状态中的每个对象都为持久化上下文所知，并且每个持久化实例的复制，快照都保存在高速缓存中。这个快照内部用于进行脏检查，侦测对持久化对象所做的任何修改。
忽略这个简单事实的许多hib用户都会遇到OutOfMemoryException。

持久化上下文高速缓存从不自动收缩。为了减少或者重新获得被持久化上下文在特定工作单元中消耗掉的内存，必须做下列事情：
保持持久化上下文的大小为必需的最小尺寸。Session中许多持久化实例经常意外出现---例如，你只需要几个却查询了许多个。只有当这个状态绝对需要它们时才使对象变成持久化。非常大的图表可能严重影响性能，并需要大量的内存用于状态快照。检查你的查询是否只返回需要的对象。也可以在hib中执行一个查询，返回只读状态的对象，而不用创建持久化上下文快照。
调用session.evict(object)，从持久化上下文高速缓存中手工脱管一个持久化实例。
调用session.clear()，从持久化上下文中脱管所有持久化对象。脱管对象不需要检查脏状态。
session.setReadOnly(object, true)，可以禁用对特定实例的脏检查。如果它是只读的，持久化上下文将不再维持快照。session.setReadOnly(object, false)，可以给一个实例重新启用脏检查，并强制重新创建快照。注意这些操作并不改变对象的状态。


2 清除持久化上下文
工作单元结束时，任何修改都必须通过sql dml语句与数据库同步。
hib的session实现了迟写。在持久化上下文范围中对持久化对象所作的改变并没有立即传播到数据库。这样允许，hib把许多改变接合到最少的数据库请求中，降低网络延迟的影响。尽可能迟地执行dml有一个很棒的副作用，在于缩短了数据库内部锁的持续时间。

如，如果对象的单个属性在同一个持久化上下文中被改变2次，hib就只需要执行一个sql update。迟写的另一个例子时：当执行多个update，insert或delete语句时，hib能利用jdbc批量api。

持久化上下文于数据库的同步被称为清除。hib清除发生在以下几个时间点：
hib的transaction被提交时。
执行查询前
显式session.flush()


hib不会在每个查询之前flush。如果变化保存在会影响查询结果的内存中，hib会默认先同步。

session.setFlushMode。默认时FlushMode.AUTO。
如果是COMMIT，在执行查询之前，持久化上下文不会被清除，只有tx.commit,session.flush，才会被清除。可能导致内存中脱管对象所作的修改，和查询的结果冲突。
MANUAL，只有flush()才同步。

持久化上下文的重复清除经常成为性能问题的根源，因为持久化上下文中所有的脏对象都必须在清除时被发现。
一种常见的原因在于，特定的工作单元模式多次重复查询-修改-查询-修改的顺序，每次修改都导致每个查询之前进行一次清除和所有持久化对象的脏检查。这种情况下，FlushMode.COMMIT可能比较恰当。

清除过程的性能部分取决于持久化上下文的大小---它管理的持久化对象的数量。



9.4 JPA

jap提供hib原生api功能集合的一个子集。

EntityManager相当于hib的Session。

可以用托管和非托管的工作单元编写jpa应用程序。

非托管是指用jpa创建持久层的可能性，它不用任何特殊的运行时环境(如，应用程序服务器提供的运行时容器)就可以运行和工作。可以在简单的java se应用程序中使用jpa。


1 java se中启动工作单元
EntityManagerFactory == SessionFactory

EntityManagerFactory emf = Persistence.createEntityManagerFactory("caveatemptorDatabase");
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();


2 使实体实例变成持久化
Item item = new Item();
item.setName("zxc");
item.setEndDate(..);

EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();     // ... EmtityManager 没有 beginTransaction();

em.persist(item);       // persist不会返回实体实例的数据库标识符值

tx.commit();
em.close();


hib的Session也有persist()，有着和jpa的persist()操作相同的语义。
然而关于清除，这2个操作之间有着重要的差别。在同步期间，即使用这个选项映射了一个关联，hib的session也不会把persist操作级联到被关联的实体和集合。它只是被级联到调用persist时可以达到的实体。如果使用session api，则只有save(),update()在清除时被级联。在jpa应用程序中则相反：只有persist在清除时被级联。


3 获取实体实例
jpa支持复杂的查询特性。最基础的部分和往常一样，是通过标识符获取：
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

Item item = em.find(Item.class, new Long(1234));
tx.commit();
em.close();

这里不需要转换find的返回值。

如果找不到，find返回null，find始终命中数据库(或特定于供应商的透明高速缓存)，因此实体实例始终在加载期间被初始化。

如果不想命中数据库，因为你不确定是否需要完全初始化实例。可以告诉EntityManager尝试获取一个占位符：

EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

Item item = em.getReference(Item.class, new Long(1234));
tx.commit();
em.close();

这个操作返回被完全初始化的item(例如，如果当前的持久化上下文中已经有实例)或者一个代理(空的占位符)。
一旦你试图访问非数据库标识符属性时，就立即执行一个select来完全初始化这个代理。这也意味者这时候(或者更早，在执行getReference时)应该会有一个EntityNotFouneException。
托管并不会触发 完全初始化item。



4 修改持久化的实体实例
修改非 @Transient注解或transient关键字的属性。
这里也会提供自动脏检查特性。


5 使持久化实体实例变成瞬时
em.remove(item);

不能对脱管状态调用remove，会抛出异常。
必须先合并脱管实例，然后移除被合并的对象。或者利用相同的标识符获得一个引用，然后移除。

6 清除持久化上下文
清除：对持久化实体实例所做的所有修改都在某个时间点与数据库同步。
EntityTransaction中的commit()被调用时，就清除EntityManager的持久化上下文。
hibernate作为jpa的实现，在下列时间点同步：
EntityTransaction.commit()时
执行查询之前
显式em.flush()时。


可以通过FlushModeType控制flush。
em.setFlushModeType(FlushModeType.COMMIT);
COMMIT：查询之前禁用自动同步，只在commit或手动flush时才flush。
默认AUTO：查询，commit，flush().


使用脱管的实体实例
1 jpa持久化上下文范围

默认情况下，如果你创建了EntityManager,持久化上下文就会被界定到这个EntityManager实例的生命周期。
。。一个EntityManager可以有多个EntityTransaction。持久化上下文跟随EntityManager.

持久化上下文，始于createEntityManager(),止于close()。

关闭持久化上下文不是脱管实体实例的唯一途径

2 实体实例的手工脱管
em.clear();清除持久化上下文，并脱管所有持久化实例。

hib的session有evict方法，但是jpa没有这个能力。原因只有一些专家组成员才知道。。。


3 合并脱管的实体实例
hib的session提供update，lock和merge，2种策略使脱管对象的任何变化与数据库同步。
。。update是重附前/后的修改都会更新到数据库，lock只更新重附后的修改。

jpa只提供后者。(上面的原文是hib提供重附和合并)。

Item mergedItem = (Item) em2.merge(item);

merge完成几件事情：
jpa检查持久化上下文中是否存在与正在合并的脱管实例有着相同数据库标识符的实例。如果没有，通过标识符从数据库中进行获取。然后，脱管的实体实例被复制到持久化实例。
如果持久化上下文中没有，数据库中也没有。那么被合并的实例就被复制到一个新的持久化实例，当第二个持久化上下文与数据库同步时插入到数据库。


341
9.5 EJB组件中使用Java Persistence

@Stateless
@PersistenceContext
@TransactionAttribute(TransactionAttributeType.REQUIRED)
JNDI
JTA
@PersistenctUnit(name="emf/auction", unitName="auctionDB")




chapter 10 事务和并发

事务/整个工作单元 具有原子性。

事务允许多个用户同时使用相同的数据，而不破坏数据的完整性和正确性。特定的事务不应对其他同时运行的事务可见。

事务具有其他重要属性，如一致性，持久性。一致性意味着事务始终工作在同一组数据上：从其他同时运行的事务中隐藏起来的，并在事务完成后留在一个清洁的和一致的状态中的一组数据。数据库完整性规则保证一致性。
持久性意味着一旦事务完成，所有的变化都在该事务变成持久化期间进行，即使系统后来失败了，这些变化也不会丢失。

数据库事务必须简短。单个的事务通常只涉及单批数据库操作。
在实践中，还需要一个概念，允许你有长期运行的对话，在这里一个原子组合的数据库操作不是在一批而是几批中发生。对话允许应用程序的用户有思考时间，而仍然保证原子，隔离，且一致的行为。


启动和终止事务的事务范围可以在应用程序代码中编程式地设置，或者声明式地设置。
1 编程式的事务划分
在非托管环境中，jdbc api被用来给事务范围做标记。通过jdbc Connection中调用setAutoCommit(false)启动事务，并通过调用commit()终止它。可以在任何时候通过rollback()强制立即回滚。

在一个 在多个数据库中操作数据的系统中，特定的工作单元涉及对不止一个资源的访问。此时，你无法单独通过jdbc实现原子性。你需要可以在系统事务中处理几个资源的事务管理器。这样的事务处理系统公开了与开发人员进行交互的java transaction api(JTA).jta中主api是UserTransaction接口，包含begin，commit,rollback等方法。

hibernate应用程序中的编程式事务管理通过hibernate的 Transaction接口公开给应用程序开发人员。你并没有被强制使用这个api---hib也让你直接启动和终止jdbc事务，但不鼓励这种用法，因为它把代码绑定到了直接的jdbc。
在java ee环境中(或者如果你把它和java se应用程序一起安装了)，就可以使用jta兼容的事务管理器，因此你应该调用jta UserTransaction接口来编程式地启动和终止事务。hibernate的Transaction接口在jta的顶层也有效。

jpa的编程式事务划分，还需要区分是否是java ee应用程序服务器。非javaEE，利用简单的javaSE处理本地资源事务，这是EntityTransaction接口的作用。在javaEE服务器，调用jta UserTransaction接口来启动，终止事务

概括接口，以及什么使用时候它们：
java.sql.Connection，利用setAutoCommit(false),commit(),rollback()进行简单的jdbc事务划分。它可以但不应该被用在hibernate应用程序中，因为它把应用程序绑定到一个简单的jdbc环境。

org.hibernate.Transaction，hibernate应用程序中统一的事务划分。适用于非托管的简单jdbc环境，也适用于以jta为底层系统事务服务的应用程序服务器。但，它主要的好处在于与持久化上下文管理的紧密整合---例如，你提交时Session被自动清除。持久化上下文也可以拥有这个事务的范围。如果你无法具备jta兼容的事务服务，就使用java se中的这个api。

javax.transaction.UserTransaction，java中编程式事务控制的标准接口，是jta的一部分。每当你具备jta兼容的事务服务，并想编程式地控制事务时，它就应该成为你的首选。

javax.persistence.EntityTransaction，在使用jpa的java se应用程序中，编程式事务控制的标准接口。


2 声明式事务划分
声明式事务划分不需要额外的代码。且从定义上来说，它解决了可移植性的问题。
在应用程序中，当你希望在一个事务内部进行工作的时候要进行声明(例如，在方法中使用注解)。然后处理这个关注点就是应用部署程序和运行时环境的责任了。java提供声明式事务服务的标准容器是ejb容器，这项服务也称为容器托管事务。



简单java中运行的hibernate应用程序,没有容器，没有托管的数据库资源可以使用。

1 java se的编程式事务
配置hibernate创建一个jdbc连接池。如果你正在使用Transaction API编写java se hibernate应用程序，除了连接池之外，不需要其他的配置设置：
hibernate.transaction.factory_class选项默认为org.hibernate.transaction.JDBCTransactionFactory,这是java se中Transaction API以及直接的jdbc的正确工厂。
可以使用自己的TransactionFactory实例扩展和定制Transaction接口。这几乎没有必要，但有一些值得关注的使用案例。例如，每当启动事务时，如果你必须编写审计日志，就可以把这个日志添加到一个定制的Transaction实现。

hib为你正要使用的每个Session获得一个jdbc连接
Session session = null;
Transaction tx = null;
try {
    session = sessionFactory.openSession();
    tx = session.beginTransaction();
    
    concludeAuction(session);
    tx.commit();
} catch (RuntimeException ex) {
    tx.rollback();
} finally {
    session.close();
}

session是延迟的，这是好事，意味着它不消费任何资源，除非绝对需要。
只有当数据库事务启动时，才从连接池中获得jdbc Connection。
对beginTransaction()的调用在新的jdbc Connection中转变为setAutoCommit(false);
。。org.hibernate.resource.jdbc.internal.AbstractLogicalConnectionImplementor.begin()中有setAutoCommit(false);


回滚只读事务更快吗？如果事务中的代码读取数据但没有修改它，你应该回滚事务而不是提交它吗？这样更快吗？
有些开发人员发现在某些特殊环境下会更快。
我们用更为普及的数据库系统进行过测试，发现并没有区别。
始终提交事务，如果提交失败就回滚。话虽这么说，但sql标准还是包括一个SET TRANSACTION READ ONLY的语句。hib不支持启用这个设置的api，虽然你可以自定义Transaction和TransactionFactory来添加这个操作。我们建议你先查一下数据库是否支持这一点，以及可能的收益是什么。


2 处理异常

Session session = null;
Transaction tx = null;

try {
    session = sessionFactory.openSession();
    tx = session.beginTransaction();
    tx.setTimeout(5);
    concludeAuction(session);
    tx.commit();
} catch (RuntimeException ex) {
    try {
        tx.rollback();
    } catch (RuntimeException rbEx) {
        log.error("....", rbEx);
    }
    throw ex;
} finally {
    session.close();
}


hibernate抛出的异常：
HibernateException是一个一般的错误，必须检查异常，或调用getCause()找到更多原因
JDBCException，是被hib的内部jdbc层抛出的任何异常。这种异常总是由一个特定的sql语句产生，可以用getSQL()获得这个引起麻烦的语句。jdbc连接抛出的内部异常可以通过getSQLException()或getCause()获得，并通过getErrorCode()可以得到特定于数据库和特定于供应商的错误代码。
Hibernate包括JDBCException的子类型和一个内部转换器，该转换器试图将数据库驱动抛出的特定于供应商的错误代码变成一些更有意义的东西。内建的转换器可以给hib支持的最重要的数据库方言生成jdbcconnectionexception,sqlgrammerexception,lockaquisitionexception,dataexception,constraintviolationexception.
可以对数据库操作或者增强方言，或者插入SQLExceptionConverterFactory定制这种变换。
Hibernate抛出的其他RuntimeException也应该终止事务。

抛出异常的session不能再使用。

不要将异常用于验证。


3 使用JTA的编程式事务
能与java ee兼容的托管运行时环境，能够为你整理资源。大多数情况下，被管理的资源都是数据库连接，但是任何带有适配器的资源都可以和java ee系统整合。在那些资源上的编程式事务划分，如果它们是事务的，就被统一并公开给使用jta的开发人员，javax.transaction.UserTransaction是启动和终止事务的主要接口。

下列是使用jta的托管资源的好处，以及使用java ee服务的理由：
事务管理服务可以同一所有资源，并用单个标准的api把事务控制公开给你。这意味着你可以替换hibernate的Transaction API，并直接在任何地方使用jta。然后，在jta兼容的运行时环境中安装应用程序就是应用程序部署人员的责任了。这个策略把可移植性关注点归属的位置转移了：应用程序依赖标准的java ee接口，并且运行时环境必须提供实现。
javaEE事务管理器可以在单个事务中获取多个资源。如果你使用几个数据库，就可以想要一个两阶段提交协议来保证跨资源范围的事务原子性。这种场景中，hib通过配置多个sessionFactory,它们的session获得所有参与同一个系统事务的托管数据库连接。
与简单jdbc相比，jta实现的质量通常更高。
jta提供程序在运行时不增加不必要的过载。简单案例的处理和使用简单jdbc事务一样有效。

把hibernate配置转换到jta：
hibernate.transaction.factory_class必须设置为org.hibernate.transaction.JTATransactionFactory.
出于2个原因，hib需要知道你在哪个jta实现中部署，第一，不同的实现可能都公开jta UserTransaction，hibernate现在必须以不同的名称内部调用它。第二，hib必须钩进jta事务管理器的同步过程来处理它的高速缓存。你必须配置hibernate.transaction.manager_lookup_class选项来配置这2项：例如，配置为org.hibernate.transaction.JBossTransactionMaangerLookup.
hib不再负责管理jdbc连接池，它从运行时容器获得托管的数据库连接。这些连接被jta提供程序通过jndi这个全局注册而被公开。你必须在jndi上使用正确的名称对数据库资源配置hibernate。

354

hib Transaction API用hibernate配置一个简单的变化来保证可移植性。如果你想把这个责任移到应用部署程序上，就应该针对标准的jta接口编写代码。
下面的代码在一个系统事务内部使用2个数据库(2个sessionfactory):

UserTransaction utx = (UserTransaction) new InitialContext().lookup("java:comp/UserTransaction");
Session s1 = null;
Session s2 = null;
try {
    utx.begin();
    s1 = auctionDatabase.openSession();
    s2 = billingDatabase.openSession();
    concludeAuction(s1);
    billAcution(s2);
    s1.flush();
    s2.flush();
    utx.commit();
} catch (RuntimeException ex) {
    try { utx.rollback() } catch () {}
} finally {
    s1.close,s2.close
}
这里可以抛出一些其他checked exception，就像从jndi查找中抛出的NamingException，需要处理一下。

首先，必须从jndi注册上获得jta UserTransaction上的句柄。然后开启，关闭事务，并且，所有的hib session所用的(容器提供)数据库连接都在这个事务中被自动获取。即使你没有使用TransactionAPI，也仍应该给jta和环境配置hibernate.transaction.factory_class和hibernate.transaction.manager_lookup_class，以便hibernate可以与事务系统内部进行交互。

默认设置中，需要手动flush()。hibernate tranansaction API以前自动为你完成。你还必须手动关闭session。
另一方面，可以启用hibernate.transaction.flush_before_completion和/或hibernate.transaction.auto_close_session配置选项，再次让hibernate替你负责这项工作，然后，flush和commit就成为事务管理器内部同步过程的一部分，并且发生在jta事务终止之前(相应地，或者之后)。

上面的例子删除2个flush，finally块。
s1,s2持久化上下文现在在UserTransaction的提交期间被自动清除，并且两者都在事务完成之后关闭。


4 容器托管事务
编程式的事务划分需要针对事务划分接口而编写的应用程序代码。避免任何不可移植的代码传播到整个应用程序的一种更好的方法是，声明式事务划分。

声明式事务划分，意味着容器替你负责这个关注点。
CMT是javaEE尤其EJB的标准特性。

@Stateless
public class ManageAuctionBean implements MaangeAuction {
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void endAuction(Item item) {
        Session s1 = auctionDatabase.openSession();
        Session s2 = billingDatabase.openSession();
        concludeAuction(s1, item);
        billAuction(s2, item);
    }
}

@TransactionAttribute,如果调用方法没有系统事务在运行，就会启动一个新事务(REQUIRED)。一旦方法返回，并且如果调用这个方法时(不是调用其他方法时。。外层有事务的话，这个方法就不会启动事务。)启动了事务，这个事务就提交。如果方法内部的代码抛出RuntimeException，系统事务就自动回滚。

hib需要设置一些属性来启用CMT
hibernate.transaction.factory_class选项必须被设置为org.hibernate.transaction.CMTTransactionFacotry
需要给应用程序服务器设置hibernate.transaction.manager_lookup_class为正确的查找类。

所有ejb会话bean都默认cmt，如果你想禁用cmt并在任何会话bean方法中直接调用jta UserTransaction，就用@TransactionManagement(TransactionManagementType.BEAN)注解ejb类。然后你就是在使用bean托管事务了。即使它可能适用于大多数的应用程序服务器，但是javaEE规范还是不允许在单个bean中混合cmt，bmt



使用java persistence 的事务
使用jpa也要进行设计抉择：是在应用程序代码中编程式地事务划分，还是由运行时容器自动处理声明式事务划分。

描述本地资源的事务应该用到由应用程序(编程式地)控制的，且不参与全局系统事务的所有事务。

jpa中本地资源的事务通过EntityTransaction控制。这个接口不是为了可移植性而存在的，而是用来启用java persistence的特定特性---如，当提交事务时，底层持久化上下文的清除。

jpa抛出的异常是RuntimeException的子类型。任何异常都使得当前的持久化上下文无效，并且一旦抛出异常，就不允许你继续使用EntityManager。
hib异常处理策略也适用于jpa异常处理策略：
由EntityManager接口的任何方法抛出的异常，都会触发当前事务的自动回滚。
由javax.persistence.Query接口的任何方法抛出的异常，都会触发当前事务的回滚，除了NoResultException，NonUniqueResultException。

jpa不提供细粒度的sql异常类型。最常见的异常是javax.persistence.PersistenceException。被抛出的所有异常都是PersistenceException的子类型。你应该把它们都当作是致命的，除了NoResultException，NonUniqueResultException。
可以在jpa抛出的任何异常中调用getCause()，并找出被包装的hib异常，包括细粒度的sql异常类型。

如果你在应用程序服务器内部或者至少提供了jta的环境中使用jpa，就对编程式的事务划分调用jta接口。EntityTransaction接口只对本地资源的事务可用。

1 使用java persistence的 jta事务
如果jpa代码是在一个可用的jta环境中部署，并且你想要使用jta系统事务，就需要调用jta UserTransaction接口来编程式地控制事务范围。
UserTransaction utx = (UserTransaction) new InitialContext().lookup("java:comp/UserTransaction");
EntityManager em = null;
try {
    utx.begin();
    em = emf.createEntityManager();
    concludeAuction(em);
    utx.commit();
} catch (RuntimeException ex) {
    try { utx.rollback() } catch (RuntimeException) {}
} finally { em.close(); }

如果在ejb中使用jta，别忘了在类上设置@TransactionManagement(TransactionManagement.BEAN)来启用bmt。


2 jpa 与 cmt

@Stateless
public class ManagerAuctionBean implements ManageAuction {
    @PersistenceContext(unitName="auctionDB")
    private EntityManager auctionEM;
    @PersistenceContext(unitName="billingDB")
    private EntityManager billingEM;

    @TransactionAttributes(TransactionAttributeType.REQUIRED)
    public void endAuction(Item item) throws AuctionNotValidException {
        concludeAuction(auctionEM, item);
        billAuction(billingEM, item);
    }
}

endAuction被调用时，如果没有事务，就会启动一个事务。

AuctionNotValidException，是受检异常，继承自java.lang.Exception。ejb容器把它当成应用程序异常处理，如果ejb方法抛出这个异常，则不会触发任何动作。然而，容器认识系统异常，它默认是所有可能被ejb方法抛出的未检查RuntimeException。由ejb方法抛出的系统异常强制系统事务的自动回滚。
你不需要从jpa中捕捉和重新抛出任何系统异常---让容器来处理它们。
如果抛出应用程序异常，那么对于如何回滚事务，你有2种选择，第一，可以捕捉它，并手工调用jta UserTransaction,设置它回滚。或者把@ApplicationException(rollback=true)注解添加到AuctionNotValidException的类---然后容器知道，你希望每当ejb方法抛出这个应用程序异常时就自动回滚。



10.2 控制并发访问
数据库(和其他的事务系统)试图确保事务隔离性。从每个事务的观点来看，似乎没有其他的事务正在运行。
传统上，这已经通过锁实现了。事务可以在数据库中一个特点的数据项目上放置一把锁，暂时防止通过其他事务访问这个项目。一些现代的数据库通过多版本并发控制(MVCC)实现事务隔离性。mvcc被认为更具可伸缩性。
数据库如何实现并发控制，这在hib，jpa中至关重要。应用程序继承由数据库管理系统提供的隔离性保证。例如，hib从不锁上内存中的任何东西。


理解数据库级并发
完全隔离性的代码太高，由几个隔离级别，它们一般削弱完全的隔离性，但提升系统的性能和可伸缩性。

1 事务隔离性问题
首先，来看下削弱完全事务隔离性时可能出现的几种现象。ansi sql标准根据数据库管理系统允许的现象定义了标准的事务隔离性级别：
如果2个事务都更新一个行，然后第二个事务异常终止，就会发生丢失更新。导致两处变化都丢失。这发生在没有实现锁的系统中。此时没有隔离并发事务。
。。由于没有隔离并发事务，所以全部都回滚了。没有隔离并发事务，估计就是2个事务在dbms层面是一个事务？

如果一个事务读取了另一个还没有被提交的事务进行的修改，就发生脏读取。这很危险，因为由其他事务进行的改变随后可能回滚，并且第一个事务可能编写无效的数据。

如果一个事务读取一个行两次，并且每次读取不同的状态，就会发生不可重复读取。如，另一个事务可能在其2次读取之间写到数据库并提交。

不可重复读的一个特殊案例是二次丢失更新问题。2个并发事务都读取了一个行，一个写到行并提交，然后第二个也写到行并提交。由第一个事务所做的改变丢失了。

幻读发生在一个事务执行一个查询2次，并且第二个结果集包括第一个结果集中不可见的行，或者包括已经删除的行时。(不需要完全相同的查询)。这种情形时由另一个事务在2次查询执行之间插入或这删除行造成的。


ANSI事务隔离性级别
标准的隔离性级别由ANSI SQL标准定义。

隔离性级别的增加带来了更高成本以及严重的性能退化和可伸缩性：
允许脏读取但不允许丢失更新的系统，据说要在读取未提交的隔离性中操作。如果一个未提交事务已经写到一个行，另一个事务就不能再写到这个行。但任何事务都可以读取任何行。这个隔离性级别可以在dbms中通过专门的写锁来实现。
允许不可重复读取但不允许脏读取的系统，据说要实现读取提交的事务隔离性。这可以用共享的读锁和专门的写锁来实现。读取事务不会阻塞其他事务访问行。但是未提交的写事务阻塞了所有其他的事务访问该行。
在可重复读取隔离性模式中操作的系统即不允许不可重复读，也不允许脏读取。幻读可能发生。读取事务阻塞写事务(但不阻塞其他的读取事务)，并且写事务阻塞所有其他的事务。
可序列化提供最严格的事务隔离性。这个隔离性级别模拟连续的事务执行，好像事务是连续的一个个执行，而不是并发执行。序列化不可能只用低级锁实现。一定由一些其他的机制，防止新插入的行变成对于已经执行并返回过行的查询的事务可见。


锁系统在dbms中具体实现取决于供应商。需要查询dbms文档。了解：如何逐步加强锁(如从低级别到页面，到整张表)，以及每个隔离性级别对于系统性能的可伸缩性有什么影响。


3 选择隔离性级别
在数据库的事务语义方面，hib努力尽可能地透明。不过高速缓存和乐观锁影响着这些语义。hib中如何选择呢？
消除读取未提交隔离性级别。在不同事务中使用一个未提交的事务变化是很危险的。一个事务的回滚或者失败将影响其他的并发事务。第一个事务的回滚可能战胜其他的事务，或者甚至可能导致它们使数据库处于一种错误的状态中。甚至由一个终止回滚的事务所作的改变也可能在任何地方被提交，因为它们可以读取，然后由另一个成功的事务传播
大多数应用程序不需要可序列化隔离性(幻读通常不成问题)，并且这个隔离性级别往往难以伸缩。现有的应用程序很少在产品中使用序列化隔离性，但在某些情况下，有效地强制一个操作序列化地执行相当依赖于悲观锁。

选择读取提交还是可重复读取留给你来决定。
我们首先考虑可重复读取。如果所有的数据访问都在单个原子的数据库事务中执行，这个隔离性级别就消除了一个事务可能覆盖由另一个并发事务所做变化(第二个丢失更新问题)的可能性。事务持有的读锁防止了并发事务可能希望获得的任何写锁。这是一个重要的问题，但是启用可重复读取并不是唯一的解决方法。
假设你正使用版本化的数据，这是hib可以自动完成的东西。持久化上下文高速缓存和版本控制的组合已经提供了可重复读取隔离性的大部分优良特性。特别是，版本控制防止了二次丢失更新问题，并且持久化上下文高速缓存也确保了由一个事务加载的持久化实例状态与由其他事务所作的变化隔离开来。因此，如果你使用版本化的数据，那么对于所有数据库事务来说，读取提交的隔离性是可以接受的。
可重复读取给查询结果集(只针对数据库事务的持续期间)提供了更多的可复制性。但是因为幻读仍然可能，这似乎没有多大的价值。可以在hib中给一个特定的事务和数据块显式地获得可重复读取的保证(通过悲观锁)。



4 设置隔离性级别
与数据库的每个jdbc连接都处于dbms的默认隔离性级别---通常是读取提交或可重复读取。
可以在dbms配置中修改这个默认。
还可以在程序中给jdbc连接设置事务隔离性，通过一个hib配置选项：
hibernate.connection.isolation = 4

hib在启动事务之前，给每个从连接池获得的jdbc连接设置这个隔离性级别，它们也是java.sql.Connection中的常量(如：TRANSACTION_READ_COMMITTED)
1 ： 读取未提交隔离性
2 ： 读取提交隔离性
3 ： 可重复读取隔离性
4 ： 可序列化隔离性
。。但是java.sql.Connection中对于的是0，1，2，4，8。0是NONE。

hib永远不会改变在托管环境中从应用程序服务器提供的数据库连接中获得的连接隔离性级别。可以利用应用程序服务器的配置改变默认的隔离性级别。(如果使用独立的jta实现也一样)


设置隔离性级别是影响所有连接和事务的一个全局选项。给特定的事务指定一个更加限制的锁经常很有用。hib和jpa依赖乐观的并发控制，并且两者都允许你通过版本检查和悲观锁，获得额外的锁保证。


乐观并发控制
乐观并发控制只在工作单元结束时才出现错误。多用户的应用程序通常默认为使用读取提交隔离性级别的乐观并发控制和数据库连接。
只有适当的时候(如，需要可重复读取的时候)才获得额外的隔离性保证。这种方法保证了最佳的性能和可伸缩性。

2个用户同时选择一块代码，对话A中的用户先提交变化，并且对话终止于第二个事务的成功提交。过了一会儿，对话B中的用户提交了变化，第二个事务也成功提交。在对话A中所作的改变已经丢失，并且(可能更糟的是)对话B中提交的数据修改可能基于已经失效的信息。

有3种方法处理第二个事务中的丢失更新：
最晚提交生效，2个事务都成功，且第二个覆盖第一个。没有错误
最先提交生效，对话A的事务被提交，对话B中提交事务的用户的到一条错误消息。用户必须重新对话。
合并冲突更新，第一个修改被提交，并且对话B中的事务在提交时终止，带有一条错误消息。但是失败的对话B用户可以选择性地应用变化，而不是再次重新对话。

如果没有启用乐观并发控制(默认为未启用)，应用程序就使用最晚提交生效策略。

很显然，最先提交生效，更有吸引力。hib，jpa用自动乐观锁协助你。

合并冲突的变化，是最先提交生效的一种变形。不显示始终强制用户返回的错误消息，而是提供一个对话框，允许用户手工合并冲突的变化。这是最好的策略。


乐观并发控制有多种实现方法。hib使用自动的版本控制。每个实体实例都有一个版本，它可以是数字或者时间戳。当对象被修改时，hib就增加它的版本号，自动比较版本，如果侦测到冲突就抛出异常。
public class Item {
    private int version;

}

也可以添加getter，但不许程序修改版本号。
xml的<version>必须放在标识符属性映射之后：
<class name="Item" table="item">
    <id .../>
    <version name="version" assess="field" column="obj_version"/>
    ...
</class>

所有访问相同数据库的其他应用程序也可以(并且或许应该)实现乐观版本控制，并利用相同的版本列。
有时，时间戳时首选(或者已经存在)：
public class Item {
    private Date lastUpdated;
}

<class name="" table="">
    <id .../>
    <timestamp name="lastUpdated" access="field" column="last_updated"/>
</

理论上来说，时间戳更不安全一点，因为2个并发的事务可能都在同一个毫秒点上加载和更新。但实践中不会发生这种情况，因为jvm通常没有精确到毫秒(你应该查阅jvm和os文档所确保的精确度)。

此外，从jvm获取当前时间在集群环境下并不一定安全，该环境中的节点可能不与时间同步。
可以在<timestamp>中增加source="db"属性从数据库机器中获取当前时间。并非所有的hib sql方言都支持这个属性，每一次增加版本都始终会有命中数据库的过载。

我们建议新项目依赖包含版本号的版本，而不是时间戳。



版本控制的自动管理
假设一个工作单元中，你从版本1的数据库中加载一个item，然后修改属性。当持久化上下文被清除时，hib侦测到修改，并把item的版本增加到2。然后执行sql update：
update item set initial_price="12.99", obj_version=2 where item_id=123 and obj_version=1

如果另一个并发的工作单元更新和提交了同一个行，obj_version列就不再是1，行也不会被更新。hib检查jdbc返回这个语句所更新的行数，此时被更新的行数为0，并抛出StaleObjectStateException。

每当实体实例脏时，hib就增加版本号或时间戳。这包括实体的所有脏的值类型属性，无论它们是单值，组件还是集合。考虑User和BillingDetails之间的关系，这是个一对多的关联，如果CreditCard修改了，User的版本并不会增加，如果你从BillingDetails中添加或删除CreditCard，User的版本就增加了。

如果你想禁用对特定值类型属性或集合的自动增加，就用optimistic-lock="false"属性映射它。inverse属性在这里没有什么区别。


没有版本号或时间戳的版本控制
没有版本，时间戳，hib依然能执行自动的版本控制，但是只对在同一个持久化上下文中获取和修改的对象。如果你需要乐观锁用于通过托管对象实现的对话，则必须使用通过托管对象传输的版本号或者时间戳。
。。但是同一个持久化上下文，怎么进行多线程呢？多线程获得的item是同一个吧。

这种可以选择的版本控制实现方法：在获得对象(或最后一次清除持久化上下文)时，把当前的数据库状态与没有被修改时的持久化属性值进行核对。
。。。就是快照和数据库对比。bu，看下面sql。。

类映射中设置optimistic-lock="all"来启用：
<class name="Item" table="" optimistic-lock="all">
    <id.../>
</

sql：
update item set item_price='12.99'
where item_id=123 and item_price='9.99' and item_desc="an item" ... and seller_id=45

where子句中，列举了所有非实效值，如果jdbc返回的被更新行数为0，就抛出一个StaleObjectStateException.

另一种方法是，如果设置optimistic-lock="dirty"，hib只包括限制中被修改的属性(这个例子中只有item_price)。这意味这2个工作单元可以同时修改一个对象，只有当2者修改同一个值类型属性(或外键值)时才会侦测到冲突。
。。就是where后面只有主键+where前面被修改的属性的限制条件。

对于业务实体来说，不是一种好策略，想象2个人同时修改一个拍卖品，一个改变价格，一个改变描述。即使这些修改在最低级别(数据库行)没有冲突，但从业务逻辑观点看它们也可能发生冲突。如果货品的描述完全变了，还可以改它的价格吗？
如果你想启用这个策略，还必须在实体类映射上启用dynamic-update="true"，hib无法在启动时给这些动态的update语句生成sql。

不建议在新应用程序中定义没有版本或时间戳列的版本控制，它更慢，更复杂，如果你正在使用托管对象，它不会生效。



jpa的版本控制

@Entity
public class Item {
    @Version
    @Column(name="obj_version")
    private int version;

}

可以有getter，但不允许程序修改版本值。
hib中，实体的版本属性可以时任何数字类型，包括基本类型，或Date，Calendar。
jpa只把int,Integer,short,Short,Long,long,java.sql.Timestamp当作可移植的版本控制。

jpa没有涵盖无版本属性的乐观版本控制，所以需要hib扩展，通过新旧状态来启用版本控制：
@Entity
@org.hib.anno.Entity(
    optimisticLock = org.hib.ann.OptimisticLockType.ALL
)
public class Item {...}

如果只希望检查被修改的属性，也可以转到OptimisticLockType.DIRTY.然后还需要设置dynamicUpdate属性未true。

jpa还没有对 哪个实体实例修改应该触发版本增加 标准化。
如果你使用hib作为jpa提供程序，则默认和hib一样：每个值类型的修改(包括集合元素的添加和删除)都触发版本控制。
本书编写时，还没有在特定的属性和集合上禁用版本增加的hib注解，但已经存在一项对@OptimisticLock(excluded=true)的特性请求。你的hib anno或许包含这个选项。


Hibernate EntityManager 和其他jpa提供程序一样，当侦测到冲突版本时，就抛出javax.persistence.OptimisticLockException.



获得额外的隔离性保证
有几种方式防止不可重复读取，并升级到一个更高的隔离性级别。

1 显式的悲观锁
持久化上下文高速缓存为处于持久化状态的实体实例提供可重复读取。然后，这并非永远是足够的。

如，对标量查询可能需要可重复读取：
Session s = sf.openS
Transaction tx = s.beginT

Item i = s.get(Item.class, 123);

String desc = s.createQuery("select i.desc from item i where i.id=:itemid").setParameter("itemid", i.getId()).uniqueResult();

tx.commit
s.close


如果在第一次get和第二次query之间有并发事务修改了货品描述。那么会导致desc和i.getDesc()不一致。

这个例子说明：如果数据库事务隔离性级别是读取提交，那么混有 实体和标量 的工作单元很容易受到 非可重复读的影响。

不是把所有的数据库事务转换为一个更高的，不可伸缩的隔离性级别。
而是在必要时，在hib session中使用lock()方法获得更强的隔离性保证：

Item i = session.get(Item.class, 123);
session.lock(i, LockMode.UPGRADE);
String desc = session.createQuery....;

LockMode.UPGRADE，给表示Item实例的(多)行，促成了在数据库中保存的悲观锁。现在没有并发事务可以在相同数据中获得锁---即，没有并发事务可以在你的2次读取之间修改数据。
也可以缩短为：
Item i = session.get(Item.class, 123, LockMode.UPGRADE);

LockMode.UPGRADE导致一个sql  select...for update或类似的东西(取决于数据库方言)。
一种变形是LockMode.UPGRADE_NOWAIT,添加了一个允许查询立即失败的子句。如果没有这个子句，当无法获得锁时，数据库通常会等待。等待的持续时间取决于数据库。

jpa出于同样的目的定义了LockModeType.READ,且EntityManager也有一个lock方法。规范没有要求未被版本控制的实体支持这种锁模式；但hib在所有实体中都支持它，因为它在数据库中默认为悲观锁。


hib支持下列其他LockMode
LockMode.NONE   别到数据库中去，除非对象不处于任何高速缓存中。
READ            绕过所有的高速缓存，并执行版本检查，来验证内存中的对象是否与当前数据库中存在的版本相同。
UPGRADE         绕过所有高速缓存，做一个版本检查(如果适用)，如果支持的化，就获得数据库级的悲观升级锁。相当于jpa的LockModeType.READ.。如果数据库方言不支持select ...for update，这个模式就透明地退回到LockMode.READ.
UPGRADE_NOWAIT  与UPGRADE相同，如果支持的化，就使用select...for update nowait。它禁用了等待并发锁释放，因而如果无法得到锁，就立即抛出锁异常。如果sql 方言不支持nowait，就退回到LockMode.UPGRADE.
FORCE       在数据库中强制增加对象的版本，来表明它已经被当前事务修改，相当于jpa的LockModeType.WRITE.
WRITE       当hib已经在当前事务中写到一个行时，就自动获得它。(这是一种内部模式，你不能在应用程序中指定它)


默认情况下，load,get使用LockMode.NONE。
LockMode.READ对session.lock()和脱管对象最有用。

Item item = ...;
Bid bid = new Bid();
item.addBid(bid);

Transaction tx = session.beginTransaction();
session.lock(item, LockMode.READ);
tx.commit();

这段代码通过级联(假设从Item到Bid的关联启用了级联)保存新Bid之前，在托管的Item实例上执行版本检查，验证该数据库行在获取之后没有被另一个事务更新。
注意，EntityManager.lock()不重附指定的实体实例，它只对已经处于托管持久化状态的实例有效。



强制增加版本
有时你需要手工增加实体实例的版本，因为hib不会把你的改变当成一个应该触发版本增加的修改。
修改CreditCard所有者的名字：
User u = session.get(User.class, 123);
u.getDefaultBillingDetails().setOwner("Jone");
tx.commit. session.close();

当这个session flush时，被修改的billingDetails实例的版本通过hibernate自动增加了。但User的版本没有。
用LockMode.FORCE调用lock(),增加一个实体实例的版本：
Session session = 
Transaction tx = 
User u = session.get(User.class, 123);
session.lock(u, LockMode.FORCE);
u.getDefault.setOwner("xx");
tx.commit. session.close

jpa中等同的调用是em.lock(o, LockModeType.WRITE);


非事务数据访问
许多dba在新的数据库连接上默认启用所谓的自动提交模式。自动提交模式对于sql的特殊执行很有用。
在sql控制台连接到数据库，运行查询，甚至更新删除。此时，你不会考虑工作单元的计划或者一系列语句。数据库连接中的默认自动提交模式对这种数据访问是完美的---毕竟，你不会想给所编写和执行的每个sql都输入begin a trnasaction和end a transaction。
在自动提交模式中，一个(短)数据库事务给对于发送到数据库的每个sql语句进行启动和终止。
你正在有效地进行非事务地工作，因为对于使用sql控制台的会话来说，没有原子性和隔离性保证。


许多开发人员用一些含糊的理由，仍然喜欢使用自动提交模式。下面来列举一些：
许多开发人员认为，他们可以在事务外与数据库对话。这显然是不可能的。没有任何sql可以被发送到数据库事务外部的数据库。术语非事务的数据访问意味着没有显式的事务范围，没有系统事务，并且数据访问的行为处于自动提交模式。这并不意味这没有涉及实质性的数据库事务。
如果你的目标是利用自动提交模式改进应用程序的性能，就应该重新考虑许多小事务的含义。给每个sql语句启动和终止数据库事务涉及了重大的过载，它可能降低应用程序的性能。
如果你的目标是利用自动提交模式改进应用程序的可伸缩型，就重新考虑：对于每个sql语句来说，用更长运行的数据库事务代替许多小事务，可以保持更长时间的数据库锁，也可能不进行伸缩。但是由于hib的持久化上下文和dml的迟写，数据库中所有写锁已经持续了很短的时间。根据你启用的隔离性级别，读锁的成本可能可以忽略。或者，你可以使用一个不需要读锁的包含多版本并发控制的dbms，因为默认情况下，读取操作永远不会被阻塞。
因为你正在进行非事务地工作，不仅真的放弃了一组sql语句的任何事务原子性，而且如果数据被同步修改，还减弱了隔离性保证。基于读锁不可能有自动提交模式的可重复读取。


在应用程序中引入非事务的数据访问时，要考虑更多的问题。
我们已经注意到，引入一种新的事务类型，称作只读事务，可以明显使应用程序的任何未来修改变得复杂起来。如果你引入非事务的操作也一样。
然后你在应用程序中就有3种不同的数据访问了：普通事务，只读事务，非事务。

我们的建议是不在程序中使用自动提交模式，并且只在有明显的性能好处，或者很可能要在未来改变代码时，才应用只读事务。始终更喜欢一般的acid事务，把数据访问操作组合起来，无论是读还是写数据。

话虽如此，hib，jpa还是允许非事务的数据访问。事实上，如果你想实现原子的长运行对象，ejb3.0规范强制你非事务地访问数据。


使用hib非事务地工作：
Sesssion s = sf.openS;
s.get(Item.class, 1231);
s.close();

这里访问没有事务范围的数据库。

默认情况下，在包含jdbc配置的javaSE环境中，如果执行这个片段，将发生：
打开新session，此时还没有获得数据库连接。
调用get触发一个sql select，现在session从连接池获得jdbc Connection。hib立刻默认在这个连接中用setAutoCommit(false)关闭自动提交的模式。这样有效地启动了一个jdbc事务。
select在这个jdbc事务内部执行，session关闭，连接返回池中，由hib释放。
对于没有被提交的事务，发生了什么事？
答案是：不一定。jdbc规范没有提到在一个连接上调用close()时任何未处理的事务的内容。会发生什么取决于供应商。如，oracle jdbc调用close提交了事务。大多数其他jdbc供应商会选择回滚未处理的事务。
显然，这对于你以执行的select来说不成问题。但是：
Long generatedid = session.save(item);
session.close();
现在这个insert是否生效取决于数据库。


如果你仍认为不用事务划分进行工作是个好主意，并且想要一般的自动提交行为。必须在hib配置中告诉hib允许自动提交的jdbc连接：
<property name="connection.autocommit">true</property>
根据这个设置，当从连接池获得jdbc连接时，hib不再关闭自动提交--如果连接还没有处于该状态，就启用自动提交。


使用jta的可选事务
前面着重讨论了自动提交模式，以及利用非托管的jdbc连接的应用程序中的非事务数据访问。
现在你可能需要在javaEE环境中使用hibernate，包含jta，可能也有cmt。connection.autocommit在这个环境中不起作用。是否使用自动提交，取决于你的事务程序集。

想象你有一个ejb会话bean，它把特定的方法标记为非事务：
@Stateless
public class ItemFinder {
    @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
    public Item findItemById(Long id) {
        Session s = getSessionFactory().openSession();
        Item i = s.get(Item.class, id);
        s.close();
        return i;
    }
}

方法被标记为不支持事务上下文，所以没有为这个操作启动任何事务，并且任何现有的事务上下文在这个方法的持续时间内被暂停。select在自动提交模式中被有效地执行。

最后，你需要知道，在没有事务时，session的默认FlushMode改变了。默认的行为是AUTO,导致在每个hql，sql，criteria查询之前同步。当然，这样不好，因为除了为查询执行select外，dml update,delete,insert也执行。因为你正在自动提交模式下工作，这些修改是永久的。当你在事务外使用session时，hib通过禁用自动清除防止这一点。然后你不得不期待查询可以返回失效数据或者与当前session中数据状态冲突的数据--当选择FlushMode.MANUAL时，必须有效地处理相同问题。
。。机翻。。




chapter 11 实现对话

持久化上下文传播。
对话实现的策略


11.1 传播Hibernate Session
触发拍卖终止的事件必须得到处理，你需要执行一系列操作：为拍卖检查胜出的出价，收取拍卖费用，通知卖主和买家，等。
可以编写一个大过程的单个类。更好的设计是，把这些步骤中的每一步的责任都转移到可重用的更小组件上，并按关注点把它们分开。

Session传播的用例
public class ManageAuction {
    ItemDAO itemDAO = new ItemDAO();
    PaymentDAO paymentDAO = new PaymentDAO();

    public void endAuction(Item) {
        itemDAO.makePersistent(item);       // reattach item
        
        // set winning bid
        Bid winningBid = itemDAO.getMaxBid(item.getId());
        item.setSuccessfulBid(winningBid);
        item.setBuyer(winningBid.getBidder());

        // charge seller
        Payment payment = new Payment(item);
        paymentDAO.makePersistent(payment);

        // notify seller and winner
        ...
    }
}

ManageAuction类被称作控制器。它的任务是协调所有必须的步骤来处理一个特定的事件。

上面的代码不能正常工作，首先，没有事务划分，endAuction中的所有代码应当被视为一个原子的工作单元。
更难的问题是持久化上下文。ItemDAO，PaymentDAO在每一个(无状态的)方法中使用不同的持久化上下文(在它们的每个方法中都打开，清除，关闭它们自己的持久化上下文)。这是一种应该永远避免的反模式。


通过线程局部传播
hib为简单javaSE的独立java应用程序以及任何使用了jta(不管是否包含ejb)的应用程序，提供了自动的持久化上下文传播。
hib中，可以访问当前的session来访问数据库。例如，考虑hib的ItemDAO实现：
public class ItemDAO {
    public Bid getMaxBid(Long itemId) {
        Session s = getSessionFactory().getCurrentSession();
        return (Bid) s.createQuery("asdf").uniqueResult();
    }
}

getSessionFactory()返回全局的SessionFactory。如果做到取决于你，可以从jndi注册中查找，或者实例化ItemDAO时，手工注入一个静态变量。这种依赖管理很复杂；SessionFactory是线程安全的对象。

getCurrentSession是我们要讨论的话题。当前的Session是什么，当前指的是什么？

让我们把事务划分添加到控制器中。
public class ManageAuction {
    ItemDAO itemdao = new ;
    PaymentDAO paymentdao = new ;
    
    public void endAuction(Item item) {
        try {
            sf.getCurrentSession().beginTransaction();
            itemdao.makePersistent(item);
            Bid winningBid = itemdao.getMaxBid(item.getId());
            ...
            paymentdao.makePersistent(payment);

            // notify seller and winner

            sf.getCurrentSession().getTransaction().commit();
        } catch (RuntimeException ex) {
            try {sf.getCurrentS.getTransac.rollback()} catch () {}
            throw ex;
        }
    }
}

当前java线程第一次调用sf.getCurrentSession()时，会打开和返回一个新的Session。
在全局共享的SessionFactory中调用getCurrentSession，都访问相同的session---如果它在相同的线程中被调用的话。
当Transaction被提交或回滚时，工作单元结束。如果提交或回滚事务，hib也清除和关闭当前的session以及它的持久化上下文。这意味着，提交或回滚事务后，getCurrentSession()会生成一个新的session和新的持久化上下文。

你有效地把相同的范围应用到了数据库事务和持久化上下文。你通常会想改善这段代码，通过把事务和异常处理移到方法实现之外。一种简单的解决方案时事务拦截器。16章将编写一个。

hib内部把当前的session绑定到当前正在运行的java线程。必须在hib配置中把hibernate.current_session_context_class属性设置为thread来启用这个绑定。


利用jta传播
用jta部署程序，可以直接把持久化上下文 界定和绑定 到系统事务。

我们始终推荐用jta服务来处理事务。
jta提供了用hibernate接口避免代码污染的标准事务划分接口。

public class ManageAuction {
    UserTransaction utx = null;
    ItemDao itemdao = new ;
    PaymentDao paymentdao = new;
    
    public ManageAuction() throws NamingException {
        utx = (UserTransaction) new InitialContext().lookup("UserTransaction");
    }

    public void endAuction(Item item) throws Exception {
        try {
            utx.begin();
            itemdao.makePersistent(item);
            Bid winningBid = itemdao.getMaxBid(item.getId());

            Payment payment = new Payment(item);
            paymentdao.makePersistent(payment);

            // notify seller and winner

            utx.commit();
        } catch (Exception e) {
            try { utx.rollback(); } catch (Exception e2) {}
            throw e;
        }
    }
}

这段代码没有任何hibernate导入，更重要的是，内部使用getCurrentSession()的ItemDao，PaymentDao类不变。
当第一次在其中一个dao类中调用getCurrentSession()时，新的持久化上下文开始了。当前的session被自动绑定到当前的jta系统事务上。事务结束时，通过提交或回滚，持久化上下文被清除，且内部绑定的当前session也关闭了。
。。？感觉。。dao中getCurrentSession，怎么绑定到已经启动的jta事务中？。。应该是utx.begin()会新建session？

如果你给jta配置hib应用程序，就不必启用这个jta绑定的持久化上下文，getCurrentSession始终返回一个被界定和绑定到当前jta系统事务的session

注意，不能把hib的Transaction接口与getCurrentSession()特性和jta一起使用。你需要session来调用beginTransaction，但session必须被绑定到当前的jta事务上。尽可能使用jta。


利用ejb传播

@Stateless
public class ManageAuctionBean implements ManageAuction {
    ItemDao itemdao = new ItemDao();
    PaymentDao paymentdao = new PaymentDao();

    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void endAcution(Item item) {
        itemDao.makePersistent(item);
        Bid winningBid = itemdao.getMaxId(item.getId());
        
        Payment payment = new Payment(item);
        paymentdao.makePersistent(payment);

        // notify seller and winner
    }
}

当前session被绑定到为endAuction()方法启动的事务，当这个方法返回时，它被清除和关闭。在这个方法内部运行和调用sf.getCurrentSession()的所有代码都获得相同的持久化上下文。


hib内部使用当前的线程或当前的jta系统事务，来绑定当前的session和持久化上下文。


利用hibernate的对话

提供对话保证

实践中，短对话很常见。几乎所有应用都有更复杂的对话。如，触发endAcution的员工这么做，是因为他确信这场拍卖应该结束，信息是如何传递给员工的，怎么展现的，怎么触发的。在用户看来，触发拍卖加载，显示到屏幕，到员工结束拍卖，这个流程是同一个工作单元的一部分。

利用脱管对象的对话
我们用hib原生接口和脱管对象策略来创建对话。对话有2个步骤，1加载对象，2持久化被加载对象所作的变化。
第一部需要hib session来按其标识符获取实例：
public class ManageAuction {
    public Item getAuction(Long itemId) {
        Session s = sf.getCurrentSession();
        s.beginTransaction();
        Item item = s.get(Item.class, itemId);
        s.getTransaction().commit();
        return item;
    }
}

这段代码省略了异常处理。

调用getAuction()时，一个新的session，持久化上下文，数据库事务开始了，对象从数据库中加载，事务提交，并且持久化上下文关闭。现在item处于脱管状态，并返回到调用这个方法的客户端。客户端利用脱管对象，显示它，甚至可以运行用户修改它。

会话中的第二步是完成拍卖：
public class ManageAuction {
    public Item getAuction(Long itemId) ...

    public void endAuction(Item item) {
        Session s = sf.getCurrentSession();
        s.beginTransaction();
        s.update(item);         // reattach item
        // set winning bid, charge seller, notify seller winner

        s.getTransaction().commit();
    }
}
这里也简化了方法。

hib必须假设客户端在对象被脱管时对它进行了修改。(否则，如果你确定没有修改，lock就足够了)。
对话中的第二个事务提交时，持久化上下文自动被清除，并且对曾经脱管而现在持久化的对象所作的任何修改都与数据库同步。

实践中，saveOrUpdate比save,update,lock更有用。复杂的对话中，你不知道item是否处于脱管状态，或者它是否为新的，瞬时的，必须保存的。当你不仅在单个实例上工作，还想要重附或持久化被连接的对象图并应用级联选项时，saveOrUpdate提供的自动状态侦测变得更有用。

目前为止，你只解决了其中一个对话实现问题：用很少的代码实现对话。用户期待工作单元不仅要与并发修改隔离，还要有原子性。

你用乐观锁把并发的对话隔离开来。
如何使对话变成原子化呢？对话跨越几个持久化上下文和几个数据库事务。在当前的对话中，这不成问题，因为你只在第二步中修改和持久化数据。任何只读数据，并把被修改对象的重附延迟到最后一步的对话，都自动成为原子化，可以随时终止。如果对话在一个中间步骤中把修改重附和提交到数据库，它就不再是原子的。

一种解决方案是不在提交时清除持久化上下文---也就是说，在一个假定不持久化修改的session中设置FlushMode.MANUAL。另一种方法是使用补偿动作，撤销任何进行永久改变的步骤。
。。。？ commit难道也不会触发flush？
。。好像还真有可能，现在一般认为flush生成sql，commit发出commit的sql。如果没有flush，自然就没有中间的sql，commit了个空气


给对话扩展Session
hib session有一个内部的持久化上下文。通过扩展持久化上下文来跨整个对话，你可以实现一个不涉及脱管对象的对话。这就是大家所知的每个对话一个会话策略。

在对话开始时打开新的session和持久化上下文。第一步，Item对象的加载在第一个数据库事务中实现。一旦提交数据库事务，session就立即自动地从底层的jdbc Connection中断开。现在你可以在用户思考时保持这个断开连接的session和它内部的持久化上下文。一旦用户继续，你就立即通过启动第二个数据库事务把session重新连接到新的jdnc connection。已经在这个对话中加载的任何对象都处于持久化状态，永远不会脱管。因而，一旦你在session中调用flush，对任何持久化对象所做的修改就立刻被清除到数据库。必须通过设置FlushMode.MANUAL来禁用session的自动清除。
在清除期间，由乐观锁和hib的自动版本检查，保证并发对话中所作修改被隔离。如果你直到最后一步即对话结束时才清除session，对话的原子性就得到了保证。
这种行为的一个例外：新实体实例的插入时间。这在本例中不成问题，但它是在更复杂的对话中必须处理的东西。

延迟到清除时插入
session中save方法要求必须返回被保存的实例的新数据库标识符。因此，标识符值必须在调用save时生成。对于大多数标识符生成策略来说，这不成问题。如hib可以调用sequence，在内存中进行累加，或者向hilo生成器要一个新值。hib不一定要化执行sql insert来在save上返回标识符值，并把它分配到目前持久化的实例。
例外的是insert发生之后触发的标识符生成策略，如identity，select；两者都要求先插入一个行。通过这些标识符生成器映射持久化类时，调用save时就立即执行insert。因为你正在对话期间提交数据库事务，这个插入可能有永久的效果。

下面的代码示范了这种效果：
Session s = getsessionfactory().opensession();
s.setflushmode(xxx.manual);

s.beginTransaction();
Item item = s.get(Item.class, 123);
s.gettransaction().commit();

s.begintrasnaction;
Item newitem = new Item();
Long newId = session.save(newItem);         // triggers insert
s.gettransaction.commit;
// roll back the conversation
s.close();

。。。transaction.commit无效么？。。。好吧，没有flush。

你可以期待整个对话(2个步骤)可以通过关闭未flush的持久化上下文进行回滚。newItem的插入应该被延迟到flush()时。这是在没有选择identity或select作为标识符生成器时才会发生的情况。

除了关闭未被清除的持久化上下文之外，一种解决方案时使用补偿动作，执行它们用来撤销在被终止的对话期间所作的任何可能的插入。你必须手工删除插入的行。另一种解决方案是用不同的标识符生成器，如sequence，支持新标识符值的生成而不用插入。

persist操作让你面临了相同的问题。然而，它还提供了另一种更好的解决方案，它可以延迟插入，如果在事务之外调用它，甚至可以用事后插入(post-insert)标识符生成：
Session s = getsf.opensession;
s.setflushmode(xxx.manual);

s.beginTransaction();
Item item = s.get(item.class, 1);
s.gettransaction.commit;

Item newItem = new Item();
session.persist(newItem);

session.close();

persist方法可以延迟插入，因为它不必返回标识符值。newItem在调用persist之后处于持久化状态，但如果你用identity或者select生成器策略映射持久类，它就没有分配到标识符值。flush时生成insert，标识符值被分配到实例。在事务之外调用persist时，没有执行任何insert，newItem对象只是在队列中等待插入。


管理当前session
前面讨论过的当前session支持是一种可转换的机制。你已经见过两种可能的内部策略：一种是线程绑定，另一种是把当前session绑定到jta事务。这两者都在事务结束时关闭session。
第三种内建的选项正是你使用"每个对话一个会话"策略需要的东西。通过把hibernate.current_session_context_class选项设置为managed来启用它。
之前的2种内建是thread,jta,如果你给jta部署配置hibernate，后者就会被隐式启用。

所有这些内建的选项都是org.hibernate.context.CurrentSessionContext接口的实现。可以编写自己的实现，但是内置的一般够用了。

managed启动的hibernate内建实现被称为托管，因为它把管理范围(启动和终止当前session)委托给你。
有3个静态方法来管理session的范围：
public static Session bind(Session session) {...}
+ static Session unbind(SessionFactory sf) {...}
+ static boolean hasBind(SessionFactory sf) {...}

对话启动时，用ManageSessionContext.bind()打开和绑定一个新的session，来服务对话中的第一个请求。你还必须在这个新的session中设置FlushMode.MANUAL，因为你不想在背后发生任何持久化上下文的同步。
现在调用SessionFactory.getCurrentSession，将返回你所绑定的session。
对话完成时，需要调用ManagedSessionContext.unbind()，并在某处保存现在断开的session，直到对话中有下一个请求，或者，如果这是对话中的最后一个请求，你需要flush和close。

所有这些步骤都可以在拦截器中实现。

创建对话拦截器

当对话中的第一个请求命中服务器，拦截器运行并打开新的session，这个session的自动flush立刻被禁用。这个session被绑定到hib的ManagedSessionContext。在拦截器让控制器处理事件之前启动事务。在这个控制器内部运行的所有代码都可以调用sf.getcurrentsession，并使用session。当控制器完成工作时，拦截器再次运行，并解绑当前session，事务提交后，session自动断开连接，在用户思考期间内保存。
现在服务器等待对话中的第二个请求。
第二个请求命中服务器，拦截器就立刻运行，侦测到有被保存的断开连接的session，并把它绑定到ManagedSessionContext中，控制器在事务被拦截器启动之后处理事件。当控制器完成它的工作时，拦截器再次运行，并从hib中解绑当前session。不再是断开连接并保存，而是拦截器侦测到这是对话的终点，且session需要在提交事务之前被flush，最后对话结束，拦截器关闭session。

下面是拦截器的一个伪实现：
public class ConversationInterceptor {
    public Object invoke(Method method) {
        Session currentsession = nulll;
        if (disconnectedSession == null) {
            currentsession = sf.opensession();
            currentsession.setflushmode(manual);
        } else {
            currentsession = disconnectedsession;
        }

        ManagedSessionContext.bind(currentsession);
        currentsession.beginTransaction();

        Object returnvalue = method.invoke();
        currentsession = ManagedSessionContext.unbind(sf);

        if (returnvalue.containsEndOfConversationToken()) {
            currentsession.flush. getTrsnaction.commit. close
            disconnectionsession = null;
        } else {
            currentsession.gettransaction.commit;
            disconnectedsession = currentsession;
        }
        return returnvalue;
    }
}

你可能有如下疑问：
当应用程序等待用户发送对话的下一个请求时，disconnectionSession保存在哪里？
它可以保存在HttpSession中甚至有状态的EJB中。如果没有使用ejb，这个责任就交给应用程序的代码。如果使用ejb和jpa，你可以把持久化上下文的范围(session的一个等价物)绑定到一个有状态的ejb中。
标志对话结束的特殊标记来自哪里？
在例子中，这个标记出现在invoke方法的返回值中。把这样的特殊型号实现到拦截器有多种方法。


11.3 使用JPA的对话
现在看使用JPA和ejb3.0进行的持久化上下文传播和对话实现。
就像使用原生hib一样，要使用jpa实现对话时，必须考虑3点：
你想传播持久化上下文，以便持久化上下文可以在特定的请求中用于所有数据访问。在hib中，这项功能内建在getCurrentSession()特性中。如果jpa在javase中独立部署，它就没有这项特性。另一方面，由于ejb3编程模型和预设好的范围，以及事务与托管组件的生命周期，与ebj结合的jpa比原生hib更强大。
如果你决定使用脱管的对象方法作为你的对话实现策略，就要使得对脱管对象的改变成为持久化。hib提供重附和合并，jpa只支持合并。
如果决定用"每个对话一个会话"作为实现对话的策略，就要扩展持久化上下文来跨整个对话。

必须再次在2个不同环境中处理jpa，简单javaSE，javaEE+EJB。


java SE中持久化上下文传播
这里再次出现了这种包含hib api的数据访问对象的实现
public class ItemDAO {
    public Bid getMaxBid(Long itemId) {
        Session s = getSessionFactory().getCurrentSession();
        return a.createQuery("xxx").uniqueResult();
    }
}

如果是土通过jpa重构，唯一的选择似乎只能是：
public class ItemDAO {
    public Bid getMaxBid(Long itemId) {
        Bid maxBid;
        EntityManager em = null;
        EntityTransaction tx = null;
        try {
            em = getEntityManagerFactory().createEntityManager();
            tx = em.getTransaction();
            tx.begin();
            maxBid = em.createQuery("...").uniqueResult();
            tx.commit();
        } finally { em.close(); }
        return maxBid;
    }
}

使用EntityManager，jpa中就没有定义任何持久化上下文传播。因为没有hib的sf.getCurrentSession的等价方法。

java se中，获得EntityManager的唯一方法是工厂中利用createEntityManager()方法。即，数据访问的所有方法使用它们自己的EntityManager实例，这是前面指出的反模式。更糟糕的是，对于跨几个数据访问操作的事务划分，并没有明显的位置。
有3种解决方案
可以在创建DAO时给整个DAO实例化EntityManager.它还不是每个请求一个持久化上下文，但是比每个操作一个持久化上下文好一点。但，事务划分仍然是问题，所有DAO中所有dao操作无法组合成一个原子的，隔离的工作单元。
可以在控制器中实例化单个EntityManager，并在创建DAO时，通过构造器传入到DAO中。这样就解决了问题。处理EntityManager的代码可以与单个位置中的事务划分代码(即控制器)配对。
可以在拦截器中实例化单个EntityManager，并把它绑定到辅助类的ThreadLocal变量。dao从ThreadLocal获得当前EntityManager，这种策略模拟hibernate的getCurrentSession功能。拦截器也可以包括事务划分，并且可以把控制器方法包装在拦截器中。


在对话中合并脱管对象
jpa只提供了merge。

public class ManageAuction {
    public Item getAuction(Long itemId) {
        EntityManager em = emf.createEntityMaanger();
        EntityTransaction tx = em.getTransaction();
        tx,begin();
        Item item = em.find(Item.class, itemId);
        tx.commit();
        em.close()
        return item;
    }

    public Item endAuction(Item item) {
        EntityManager em = emf.create;
        EntityTransaction tx = em.getT
        tx.begin();
        
        // merge item
        Item mergedItem = em.merge(item);

        // set wining bid, charge seller, notify seller and winner， use mergedItem!

        tx.commit();
        em.close();
        return mergedItem;
    }

}

item,mergedItem是不同java对象。item需要丢弃。


在java se中扩展持久化上下文

默认的持久化上下文范围
在没有ejb的jpa中，持久化上下文被绑定到EntityManager实例的生命周期和范围。为了在对话中给所有的事件重用相同的持久化上下文，只需要重用同一个EntityManager去处理所有事件。

一种简单方法是把这个责任委托给对话控制器的客户端：
public static class ManageAuctionExtended {
    EntityManager em;
    public ManageAuctionExtended(EntityManager em) {
        this.em = em;
    }
    public Item getAuction(Long itemId) {
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        Item item = em.find(Item.class, itemId);
        tx.commit();
        return item;
    }

    public Item endAuction(Item item) {
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        Item mergedItem = em.merge(item);

        // set winning bid, charge seller, notify seller and winner, use mergedItem!

        tx.commit();
        return mergedItem;
    }
}
。。静态类只能是内部类。

控制器期待在它的构造器中给整个对话设置持久化上下文。客户端现在创建和关闭EntityManager：
EntityManager em = emf.createEntityManager();
ManageAuctionExtended controller = new ManageAuctionExtended(em);
Item item = controller.getAuction(1234L);
item.setDesc("xxx");
controller.endAuction(item);
em.close();

..这里没有禁用 Flush().

防止自动清除
jpa默认FlushMode是AUTO,在执行查询之前和提交事务时启用同步。

Hibernate,有MANUAL，它从同步中解耦事务划分。JSR-220专家组成员意见不一，javax.persistence.FlushModeType只有AUTO，COMMIT。

下面的代码回退到hib，来获得MANUAL：

Map params = new HashMap();
params.put("org,hibernate,flushMode", "MANUAL");
EntityManager em = emf.createEntityManager(params);

// 上面三行或这行，都可以修改FlushMode.
((org.hib.Session) em.getDelegate()).setFlushMode(org.hib.FlushMode.MANUAL);

ManageAuction controller = new ManageAuction(em);
Item item = controller.getAuction(1234);
item.setDesc("zzz");
if (!controller.sellerHasEnoughMoney(seller))
    throw new RuntimeException("mai bu qi");

controller.endAcution(item);
em.close();

em.flush必须在endActuion中被手工调用，否则没有任何修改会变成持久化。
。。这里的没有tx.commit()。所以没有办法。。。不能长事务，！


正式的架构解决方案依赖非事务的行为。不是简单的FlushMode设置，而是需要给数据访问操作编写没有事务范围的代码。
专家组成员对于漏掉MUNUAL的一个原因就是：事务提交应该使所有修改永久化。
因此，你只能通过移除事务划分，给对话中的第二步禁用清除：
public class ManageAuction {
    public boolean sellerHashEnoughMoney(User seller) {
        boolean sellerCanAffordIt = (Boolean) em.createQuery("select ... ").getSingleResult();
        return sellerCanAffordIt;
    }
}

这段代码没有触发持久化上下文的清除，因为EntityManager是在任何事务范围之外使用的。
执行这个查询的EntityManager现在正在自动提交模式下工作。
你失去了拥有可重复读取的能力。

如果使用jpa的话，强烈建议你考虑MANUAL。(几乎)所有jpa供应商都包含一个专有的FlushMode,功能和MANUAL一样。


399
11.4 使用ejb3.0的对话

使用ejb的上下文传播

404 required,not_supported,supports,requires_new,mandatory,never



chapter 12 有效修改对象

12.1 传播性持久化
真正的应用程序中不仅使用单独的对象，还使用对象网络。持久化时，可能需要持久化一张由已持久化的，脱管的，瞬时的实例组成的对象图。传播性持久化是允许你吧持久化自动传播到瞬时,脱管的子图的方法。

传播性持久化不止一个模型。最著名的是 按可到达性持久化。

按可到达性持久化
每当应用程序从已经持久化的实例中创建对其中一个实例的引用是，如果任何实例变成了持久化，对象持久层便是在实现按可到达性持久化
。。机翻。。估计是，持久化对象和瞬时对象有关联，建立这个关联的时候，瞬时对象就变成了持久化对象。

所有对象的可达性很难实现。

hib和其他orm都没有实现这一点。

可达性只能使瞬时变成持久化，无法从持久化变成瞬时。


把级联应用到关联
hib的传播性持久化模型使用与按可到达性持久化相同的基本概念：检查对象关联来确定传播性状态。
hib允许你给每个关联映射指定一种级联样式，它为所有的状态转变提供更多灵活性和更细粒度的控制。

默认情况下，搜索瞬时或脱管对象时，hib并不导航关联，因此，保存，删除，重附，合并等，Category对于被父类别的childCategories集合引用的任何子类别都没有影响。这和按可达性持久化的默认行为相反。
对于特定关联而言，如果你希望启用传播性持久化，就必须在映射元数据中覆盖这个默认。

这些设置被称为级联。
xml中，cascade="..."属性放在<one-to-one>,<many-to-one>映射元素中，来启用传播性状态变化。
所有集合映射(<set,bag,list,map>)都支持cascade属性。
delete-orphan设置只适用于集合。


none        默认，hib忽略关联
save-update org.hib.anno.CascadeType.SAVA_UPDATE。当session被清除时，且对象被传递到save/update时，hib就导航关联，并保存刚刚被实例化的瞬时实例和把变化持久化到脱管状态的实例
persist     javax.persistence.CascadeType.PERSIST。当对象传递到persist()时，hib使任何被关联的瞬时实例都变成持久化。如果使用原生hib，级联只在调用时发生，如果使用EntityManager，则在持久化上下文清除时被级联
merge       javax.per.CascadeType.MERGE。hib导航关联，并在对象传递到merge时，通过相当的持久化实例合并被关联的脱管实例。可达到的瞬时实例被变成持久化
delete      org.hib.anno.CT.DELETE。当对象被传递到delete或remove时，hib就导航关联，并删除被关联的持久化实例。
remove      javax.per.CT.REMOVE。当对象被传递到remove或delete时，这个选项就把级联删除启用到被关联的持久化实例。
lock        org.hib.ann.CT.LOCK。把lock操作级联到被关联的实例，如果对象是脱管的，就把它们重附到持久化上下文。注意LockMode没有被级联。hib假设你在被关联对象上不想要悲观锁---因为根对象上的悲观锁已经足以比避免并发修改。
replicate   org.hib.ann.CT.REPLICATE。hib导航该关联，并把replicate操作级联到被关联的对象。
evict       org.xxxx.EVICT。当对象被传递到hib session的evict()时，hib从持久化上下文清除被关联的对象。
refresh     javax....REFRESH。当对象被传递到refresh()时，hib从数据库中重新读取被关联对象的状态。
all         javax...All 这里包括前面列出的所有级联选项。
delete-orphan   org.xxxDELETE_ORPHAN。当被关联的对象从关联(即集合中)被移除时，这项额外的设置启用了它们的删除。如果你在一个实体集合中启用这项设置，就等于告诉hib，被关联的对象没有共享的引用，且当引用从集合中被移除时，它可以被安全地删除。

all不包含delete-orphan

几个单独的例子：
<many-to-one name="parent" column="parent_category_id" class="Category" cascade="save-update, persist, merge"/>

<one-to-one name="shippingAddress" class="Address" cascade="save-update, lock"/>

<set name="bids" cascade="all, delete-orphan" inverse="true">
    <key column="item_id"/>
    <one-to-many class="Bid"/>
</set>


级联选项通过注解以2种可能的方式进行声明。
第一，所有的关联映射注解(@ManyToOne, @OneToOne, @OneToMany, @ManyToMany)都支持cascade属性。这项属性的值时单个或一列javax.persistence.CascadeType值。
@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
@JoinColumn(name="parent_category_id", nullable=true)
private Category parent;

@OneToMany(cascade = CascadeType.ALL)
private Set<Bid> bids = new HashSet<>();

只有与EntityManager操作相关的级联选项，如persist(),merge()。

@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
@org.hib.anno.Cascade(
    org.hib.anno.CascadeType.SAVE_UPDATE
)
@JoinColumn(name="parent_category_id", nullable=true)
private Category parent;


@OneToOne
@org.hib.ann.Cascade({
    org.hi.a.CascadeType.SAVE_UPDATE,
    org.....Lock
})
@PrimaryKeyJoinColumn
private Address shippingAddress;


@OneToMany(cascade = CascadeType.ALL)
@org.h.a.Cascade(
    org.hi.a.C.DELETE_ORPHAN
)
private Set<Bid> bids = new HashSet<Bid>();


使用传播性状态
<class name="Category" table="category">
    ...
    <property name="name" column="cate_name"/>
    <many-to-one name="parentCategory" class="Category" column="parent_category_id" cascade="none"/>
    <set name="childCategories" table="category" cascade="save-update" inverse="true">
        <key column="parent_category_id"/>
        <one-to-many class="Category"/>
    </set>
</class>

这是一个递归的双向一对多关联。


Session s = sf.openSession();
Transaction tx = s.beginTransaction();

Category computer = session.load(Category.class, computerId);
Category laptops = new Category("Laptops");
computer.getChildCategories().add(laptops);
laptops.setParentCategory(computer);

tx.commit()
s.close();

computer时持久化的(注意如何将load()与代理共用，并避免数据库命中)，且childCategories关联启用了级联保存。因为，这段代码在tx.commit()被调用时导致新的laptops变成持久化的。

。。AUTO，所以commit包含flush。
。。getChildCategories()的时候不会发出select？..会的！，下面就说了，会懒加载。不过可能是load 和get的区别？  区别应该没有这么大吧？


以脱管的方式创建新类别
在持久化上下文范围之外创建computer和laptops之间的连接：

Category computer = session.get()       // loaded in previous session

Category laptops = new Category("laptops");
computer.getChildCategories().add(laptops);
laptops.setParentCategory(computer);

你现在有了脱管的，完全实例话(没有代理)的computer对象，它在前一个session中加载。并与新的瞬时laptops对象关联。你通过把这个新对象保存在第二个session中---一个新的持久化上下文，使得对象上所作的变化持久化：
Session s2 = sf.openSession();
Transaction tx = s2.beginT
session.save(laptops);
tx.commit s2.close()

hib检查laptops.parentCategory对象的数据库标识符，并在数据库中，把computer的标识符插入到新行laptops的外键字段。

这个例子中，你无法给computer获得脱管的代理，因为computer.getChildCategories()将触发代理的初始化。你会看到LazyInitialzationException.session已关闭。

由于你给parentCategory关联定义了cascade="none",hib忽略computer中任何其他类所作的修改。它不把save级联到这个关联引用的实体。


用传播性持久化保存几个新实例

为什么要有级联操作？
考虑下面的例子:
Category computer = .. // loaded in a previous session

Category lap1 = new Category("");
Category lap2 = new Category("");
Category lap3 = new Category("");

lap1.adChildCategory(lap2);
lap1.adChildCategory(lap3);

computer.addChildCategory(lap1);

addChildCategory 中对两端都设置了关联指向对面

由于cascade="save-update"映射了childCategories集合。所以只需要保存lap1,就能保存这3个新对象。

Session s = sf.openS
Transaction tx = s.beginT

s.save(lap1);
tx.commit s.close


在前面的基础上，修改数据，并再新建一个
lap1.setName("a");
lap3.setName("b");
lap2.setName("c");

Category lap4 = new Category("");
lap1.addChildCategory(lap4);

Session s2 = sf.
tx = 
s2.saveOrUpdate(lap1);
tx.commit s2.close()

发出三条update，1条insert。


更有经验的用户专门使用saveOrUpdate。它更容易让hib决定什么是新的，什么是旧的，尤其在混合状态的复杂对象图中。
saveOrUpdate唯一的缺点再与，它在数据库中没有触发select的情况下，有时无法猜测一个实例是旧的还是新的---如，当类用一个自然的复合键映射，并且没有版本或时间戳属性的时候。
。。一般都是hib设置主键的，所以hib查看主键就能分辨。现在自然键，并且没有乐观锁，所以它不知道是新是旧

hib如何区别新旧？有很多选项可用，hib假设实例是瞬时的，如果：
标识符属性为null
版本或时间戳属性为null
同一个持久化类的新实例有着与指定实例相同的数据库标识符值。。。？意思：不同对象，相同标识符，说明是瞬时？
你在映射文档中提供了unsaved-value，并且该值与标识符属性的值匹配。unsaved-value对于版本和时间戳也有用。
包含相同标识符值的实体数据不在二级高速缓存中。
你提供org.hib.Interceptor的一个实现，从isUnsaved中返回true。


merge级联选项实际上有着和save-update一样的效果。


考虑传播性删除
删除一行后，其他持有对被删除行的引用，就会得到一个外键约束违例。
你需要在删除实体之前，删除对Category的所有链接。
有时，你想要通过从集合中移除引用来删除实体实例。换句话说，你可以保证，一旦从集合中删除这个对实体的引用，就不会存在其他引用。
hib假设没有引用的孤儿实体应该被删除。
<set name="bids" cascade="all, delete-orphan" inverse="true">
    <key column="item_id"/>
    <one-to-many class="Bid"/>
</set>

现在可以通过从这个集合移除，来删除bid对象，在脱管状态下：
Item item = ..   // loaded in previous session

item.getBids().remove(aBid);
item.getBids().remove(bBid);

Session s = sf.openS
tx = s.begin

s.saveOrUpdate(item);
tx.commit. s.close()

如果没有启用delete-orphan，就必须从集合中移除引用后，显式地删除Bid实例
Item item = ...     // loaded in previous session

item.getBids().remove(abid);
item.getBids().remove(bbid);

Session s = sf.open
tx = s.begin

s.delete(abid);
s.delete(bbid);
s.saveOrUpdate(item);
tx.commit s.close

如果映射一个组件的集合，孤儿删除就是隐式的。额外的选项只与实体引用的集合相关(通常是<one-to-many>)


利用jpa的传播性关联

@Entity
public class Category {
    private String name;
    @ManyToOne
    public Category parentCategory;

    @OneToMany(mappedBy="parentCategory", cascade={CascadeType.PERSIST, CascadeType.MERGE})
    public Set<Category> childCategories = new HashSet<>();

}

你给persist(),merge()操作启用了级联。现在可以在持久化和脱管状态下创建和修改Category实例
Category computer =         // load in previous session

Category lap1 = new Category("");
Category lap2 = new 
Category lap3 = 

lap1.addChildCategory(lap2);
lap1.addxxxxx(lap3);

computer.setName("d")
computer.addChildCategory(lap1);

EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

computer = em.merge(computer);
tx.commit  em.close

对merge的调用，使得所有修改和新增都变成持久化。
merge和重附不同，merge之后返回一个新值。



12.2 大批量和批量操作
需要大量数据的操作最好不要在应用层中执行，你应该把操作移近数据的位置，而不是其他地方。
上千行的数据，update，delete直接执行已经足够。
更复杂的操作需要更复杂的过程在数据库内部运行，因此，你应该把存储过程当作一种可能的策略。


使用hql，jap ql 的大批量语句
hql类似sql，区别：hql使用类名，属性名。hql也理解继承。
jpa是hql的子集。

直接在数据库中更新对象
执行直接在数据库中的行上操作的sql，所作的任何修改都不会影响内存。即，任何直接的dml都绕过了持久化上下文和所有高速cache。
避免这一问题的方案是一个简单的会话：首先在一个新的持久化上下文中执行任何直接的dml操作。然后用hib的session或EntityManager加载和保存对象。
另一种方法，如果你知道它已经在持久化上下文的背后被修改了的话，可以选择性地使用refresh()从数据库中重载持久化对象的状态。

hib和jpa提供dml操作，比简单sql更强大一些。
Query q = session.createQuery("update Item i set i.isActive=:isActive");
q.setBoolean("isActive", true);
int updatedItems = q.executeUpdate();

类似sql，但使用类名，属性名。它也被整合到hib的参数绑定api中。
返回被更新实体对象的数目---而不是被更新行的数目。。。。？？这2个数目会有区别？内存中已经改成true的话，这里数目会-1？
另一个好处是hql(jpa ql) update语句适用于继承：
Query q = session.createQuery("update CreditCard set stolenOn <= :now where type='Visa'");
q.setTimestamp("now", new Date());
int updated = q.executeUpdate();

持久化引擎知道如何执行这项更新，即使必须生成几条sql。
别名是可选的，但是如果你使用了别名，所有属性都必须加上别名前缀。
hql和jpa ql update语句只引用单个类，例如，你无法编写单个语句来同时更新Item和CreditCard对象。
where子句允许子查询，只有在这些子查询中才允许任何联结。

默认情况下，直接dml不会影响实体的任何版本或时间戳值。
通过hql，你可以增加 直接被修改的实体实例的版本号：
Query q = session.createQuery("update versioned Item i set i.isActive=:isActive");
q.setBoolean("isActive", true);
int updated = q.executeUpdate();
。。类名前面增加了 versioned

如果你的版本或时间戳属性依赖定制的org.hib.usertype.UserVersionType，则不允许使用versioned关键字。


第二个大批量操作是delete
Query q = session.createQuery("delete CreditCard c where c.stolenOn is not null");
int updated = q.executeUpdate();

规则和update相同：没有联结，只有单个实体类，可选的别名，where中允许子查询。

和sql大批量操作一样，hql jpa ql 大批量操作不影响持久化上下文，它们然过任何高速cache。不会更新内存。


在数据库中直接创建新对象
假设所有客户的visa卡都被偷了，你需要把所有的卡都删除，删除之前，需要复制下这些卡。为被偷的卡编写一个类：
public class StolenCreditCard {
    private Long id;
    private String type;
    - String number,expMonth,expYear,ownerFirstname,ownerLastname,ownerLogin,ownerEmailAddress;
    private Address ownerHomeAddress;

}

把这个类映射到stolen_credit_card表中。
获取所有安全受危及的卡，并创建新的StolenCreditCard对象：
Query q = session.createQuery("insert into StolenCreditCatd(type,number,expMonth,expYear....ownerHomeAddress) select c.type,c.number,...u.firstname,u.lastname...u.homeAddress from CreditCard c join c.user u where c.stolenOn is not null");
int created = q.executeUpdate();

insert...select的目标属性(本例中，是StolenCreditCard属性)必须针对一个特定子类，而不是(抽象的)超类。
select返回的类型必须和insert要求的类型相匹配。
用于每个StolenCreditCard对象的数据库标识符，将通过标识符生成器自动生成。另一种方法是，你可以把标识符属性添加到一个被插入的属性的清单中，并提供通过选择的值。标识符值的自动生成仅适用于直接在数据库内部操作的标识符生成器，如序列或者同一性字段。
如果生成的对象具有版本控制，也会生成新的版本(0或当时的时间戳)。另一种方法是，可以选择一个版本(或时间戳)值，并把版本(或时间戳)属性添加到被插入的属性列表中。

insert...select 只可用于hql， jpa ql没有标准化这种语句。


利用批量处理

利用批量更新编写过程
下列代码同时加载100个Item对象用于处理：
Session s = sf.openS;
tx = 

ScrollableResults itemCursor = s.createQuery("from Item").scroll();
int count = 0;
while (itemCursor.next()) {
    Item item = itemCursor.get(0);
    modifyItem(item);
    if (++count % 100 == 0) {
        s.flush();
        s.clear();
    }
}

tx.commit
s.close

为了最好的性能，应该把hib(和jdbc)配置属性hibernamte.jdbc.batch_size大小设置为与过程批量的大小相同：100。然后在flush期间执行的所有update语句也都在jdbc级被批量话。
注意，你应该给任何批量操作禁用二级高速缓存，否则，批量过程期间对象的每一次修改都必须为这个持久化类传播到二级高速缓存，这是一项没有必要的过载。13章介绍如何控制二级高速缓存。

jpa不支持游标。只能调用org.hib.Session..org.hib.Query来访问这个特性。


批量插入许多对象

Session s = sf.openS
tx = 
for (int i = 0; i < 100000; i++) {
    Item item = new Item(...);
    s.save(item);
    if (i % 100 == 0) {
        s.flush();
        s.clear();
    }
}
tx.commit s.close

要记住hibernate.jdbc.batch_size配置设置一个相同的值。并给持久化类禁用二级缓存

如果你的实体通过identity标识符生成器被映射。hib就会悄悄禁用jdbc批量插入。许多jdbc驱动程序在这种情况下都不支持批量。


使用无状态的会话
org.hibernate.StatelessSession。没有持久化上下文。感觉和表现都像简单的jdbc，不过你可以从被映射的持久化类，数据库可移植性收益。

Session s = sf.openStatelessSession();
tx = 

ScrollableResults cursor = s.createQuery("from Item").scroll();

while (cursor.next()) {
    Item item = cursor.get(0);
    modifyItem(item);
    s.update(item);
}
tx.commit s.close

StatelessSession，不再在持久化状态下使用对象，从数据库返回的一切都处于脱管状态。因此，修改item后，需要手动update。这个update不会重附。item依然是脱管的。
。。很容易就 懒加载？

禁用持久化上下文及使用StatelessSession接口有一些其他严重后果和概念上的限制：
StatelessSession没有持久化上下文高速cache，没有与任何其他二级高速cache交互。你进行的每一件事都导致立即的sql操作。
没有脏检查，没有迟写。
没有级联
对于被映射为实体关联(1对多，多对多)的集合的任何修改都被忽略。只考虑值类型的集合。
StatelessSession绕过任何被启用的org.hib.Interceptor，并且无法通过事件系统被拦截。
你没有受保护的对象的同一性范围。同一个查询生成2个不同的内存脱管实例。需要小心equals


数据拦截和过滤
场景：当前用户应无权看到所有内容；只展现一周内的数据；如何限制到集合；
可能的解决方案是使用数据库视图，sql没有标准化动态的视图(可能被限制，并在运行时通过一些参数(当前登陆的用户，时间周期等))移动的试图。很少有数据库提供更加灵活的视图选项，即是可用也是很贵很复杂的。

hib给动态的数据库视图提供了另一种可选方法：运行时通过动态参数化的数据过滤器。

数据库应用程序中另一个常见的问题是，需要了解被保护或被加载的数据的横切关注点。例如，给应用程序的每一个数据修改编写一个日志。hib提供org.hib.Interceptor接口，允许你钩入hib内部处理。

hib内核基于一个事件/监听器模型。例如，如果对象必须被加载，就触发LoadEvent。hib内核被实现为这些事件默认的监听器。你可以插入你自己的监听器的公共接口。事件系统提供发生在hib内部的任何可想象操作的完整定制，应该被当作拦截的另一种更强大的方法。


动态数据过滤
CaveatEmptor中的User有一个ranking属性。现在假设用户只能对等级<=他的用户的货品出价。

定义数据过滤器
动态数据过滤器用一个全局唯一的名称在映射元数据中定义。只要在<hibernate-mapping>元素内部即可。
<filter-def name="limitItemsByUserRank">
    <filter-param name="currentUserRank" type="int"/>
</

注解，你可以把相同功能的@org.hib.anno.FilterDef放在你喜欢的任何类中(或者包元数据中)，它对该类的行为没有影响。
@org.hibernate.anno.FilterDef(
    name="limitItemsByUserRank",
    parameters = {
        @org.hib.ann.ParamDef(
            name="currentUserRank", type="int"        
        )
    }
)

过滤器现在没有激活，没有东西表明它应该用到Item对象。

应用和实现过滤器
在Item类中应用定义好的过滤器
<class name="Item" table="">
    
    <filter name="limitItemsByUserRank" condition=":currentUserRank>=(select u.rank from user u where u.user_id=seller_id)"/>
</

<filter>元素可以对类映射设置。它把一个具名的过滤器应用到该类的实例。condition是一个sql表达式，直接被传递到数据库系统，因此你可以使用任何sql操作符或者函数。如果一条记录应该通过过滤器，它的值就必须是true。

@Entity
@Table(name="item")
@org.hib.anno.Filter(
    name="limitItemsByUserRank",
    condition=":currentUserRank>=(select u.rank from user u where u.user_id=seller_id)"
)
public class Item {...}

通过@org.hib.anno.Filters,可以应用几个过滤器。

启用过滤器
需要在session中参数化(EntityManager不支持这个api，所以你需要回退到hib的接口)
Filter filter = session.enableFilter("limitItemsByUserRank");
filter.setParameter("currentUserRank", loggedUser.getRanking());

通过名称启用过滤器，返回一个Filter实例。其他有用的Filter方法是,getFilterDefinition，它允许遍历参数名称和类型，validate如果忘记设置参数，会抛出HibernateException。setParameterList()设置一系列参数。如果你的sql中有个带有量词操作符(如in)的表达式，它最有用。

现在被过滤的session中执行每个hql或criteira查询都限制了返回的Item实例：
List<Item> filteredItems = session.createQuery("from Item").list();
List<Item> f2 = session.createCriteria(Item.class).list();

2种检索对象的方法没有被过滤：通过标识符检索，通过对Item实例的导航访问(如通过aCategory.getItems())。

过滤集合
目前为止，aCategory.getItems()返回被该category引用的所有Item实例。
可以通过应用到集合的一个过滤器进行限制：
<class name="Category" table="">

    <set name="items" table="category_item">
        <key column="category_id"/>
        <many-to-many class="Item" column="item_id">
            <filter name="limitItemsByUserRank" condition=":currentUserRank>=(select u.rank from users u where u.user_id=seller_id)"/>
        </m
    </s
</c

这里过滤器应用到了<many-to-many>而不是<set>.现在，子查询中的非限定seller_id列引用关联的目标item表，而不是关联的category_item联结表。

注解，在@ManyToMany字段或获取方法中使用@org.hib.anno.FilterJoinTable(s).

如果Category和Item是一多对关联，你就已经创建了下列映射：
<class name="Category" table="">
    
    <set name="items">
        <key column="category_id"/>
        <one-to-many class="Item"/>
        <filter name="limitItemsByUserRank" condition=":currentUserRank>=(select u.rank from users u where u.user_id=seller_id)"/>
    </
</

通过注解，你只是把@org.hib.anno.Filter(s)放在正确的字段或获取方法中，与@OneToMany和@ManyToMany注解并排一起。

如果现在在session中启用过滤器，对Category的items集合的所有遍历都会被过滤。

如果有一个默认的过滤条件应用到多个实体，就用过滤器定义对它进行声明：
<filter-def name="limitByRegion" condition="region>=:showRegion">
    <filter-param name="showRegion" type="int"/>
</


动态数据过滤的用例
很多情况下都有用，受限于你的想象力和使用sql的能力，典型用例如下：
安全性限制，常见问题是对被给定的一些任意的安全性相关条件的数据访问的限制。可以是一个用户的等级，是用户必须属于一个特定的组，或者是用户已经被分配到的一个角色。
区域数据，数据经常通过一个区域代码进行保存(如，一个销售团队的所有业务合同。)每个销售人员都只在覆盖他们区域的一个数据集上工作。
临时数据，许多企业应用程序需要在数据上应用基于时间的视图(如，看上周的一个数据集)。


拦截hib事件
审计日志，将 对其他数据所做的改动 保存在数据库中。记录的信息：用户，事件的日期和时间，什么类型的事件，被改变的货品。
审计日志经常利用数据库触发器处理，另一方面，应用程序承担责任有时更好，尤其当不同的数据库之间需要可移植性的时候。

审计日志，需要几个元素，第一，必须给你想对其启用日志的持久化类做上标记。第二，定义什么信息应该被记入日志。第三，用自动创建审计轨迹的Interceptor把所有东西连在一起。

创建标记接口
package auction.model;
public interface Auditable {
    public Long getId();
}
这个接口要求持久化实体类用一个获取方法公开它的标识符。
public class Item implements Auditable {...}

创建和映射日志记录
public class AuditLogRecord {
    + String message;
    + Long entityId;
    + Class entityClass;
    + Long userId;
    + Date created;

    AuditLogRecord() {}
    public AuditLogRecord(String message, Long entityId, Class entityClass, Long userId) {...}
}

这个类不是领域模型的一部分。因此，你公开所有的属性作为公有的，你不可能需要重构应用程序的这个部分。AuditLogRecord是持久层的一部分，并可能与其他持久化相关的类共用相同的包，如HibernateUtil,定制的UserType扩展。

将这个类映射到audit_log:
<hibernate-mapping default-access="field">

<class name="persistence.audit.AuditLogRecord" table="audit_log" mutable="false">
    <id type="long" column="audit_log_id">
        <generator class="native"/>
    </id>

    <property name="message" type="string" column="message" length="255" not-null="true"/>
    ...
    <property name="entityClass" type="class" column="entity_class" not-null="true"/>
    <proeprty name="created" type="java.util.Date" column="created" update="false" not-null="true"/>

</class>

</hibernate-mapping>

。。type="class"

field访问策略。
由于不会更新AuditLogRecord对象，所以mutable="false"
这里没有声明标识符属性，因此hib内部管理AuditLogRecord的代理键。你不准备以脱管方式使用AuditLogRecord，因此它不必包含标识符属性。
如果用注解映射这个类为jpa实体，就需要标识符属性。

编写拦截器
当调用save()时，应该自动调用logEvent()方法。完成这件事最好的方法是实现Interceptor接口
public class AuditLogInterceptor extends EmptyInterceptor {
    private Session session;
    - Long userId;
    - Set inserts = new HashSet();
    - Set updates = new HashSet();

    public void setSession(Session s) {
        this.session = s;
    }

    public void setUserId(Long userId) { .. }

    public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) throws CallbackException {
        if (entity instanceof Auditable)
            inserts.add(entity);
        return false;
    }

    public boolean onFlushDirty(...) {
        if (entity instanceof Auditable)
            updates.add(entity);
        return false;
    }

    public void postFlush(Iterator iterator) {
        try {
            for (Iterator it = inserts.iterator(); it.hashNext();) {
                Auditable entity = (Auditable) it.next;
                AuditLog.logEvent("create", entity, userId, session.connection());
            }
            for (Interator it = updates.iterator; ;) {
                Auditable entity = it.next();
                AuditLog.logEvent("update", entity, userId, session.connection());
            }
        } finally { inserts.clear(), updates.clear()}
    }
}

当hib保存实体时，就调用onSave()拦截器，侦测到脏对象时，就调用onFlushDirty方法。
hib在执行完同步数据库的sql之后调用postFlush。

你无法在onSave中把事件记入日志，因为瞬时实体的标识符此时不可知。


启用拦截器
AuditLogInterceptor interceptor = new AuditLogInterceptor();
Session s = sf.openSession(interceptor);
Transaction tx = 

interceptor.setSession(s);
interceptor.setUserId(currentUser.getId());

session.save(newItem);
tx.commit. s.close();

如果使用getCurrentSession，就不要控制session的打开，它由CurrentSessionContext的其中一个hib内建的实现透明地处理。可以扩展/编写自己的CurrentSessionContext，为打开当前的session并分配给它一个拦截器。

另一种启用拦截器的方法是，在创建SessionFactory之前，通过setInterceptor()在Configuration上全局地设置它。然而，在Configuration中设置的并且所有session都可以启用的任何拦截器都必须是线程安全的。单个Interceptor实例被并发运行的Session共享。AuditLogInterceptor实现不是线程安全的，它使用了成员变量(inserts，updates)

也可以在persistence.xml中配置下列选项，设置一个共享的线程安全的拦截器，该拦截器有一个无参构造器，用于jpa所有EntityManager实例：
<persistence-unit name="...">
    <properties>
        <property name="hibernate.ejb.interceptor" value="my.ThreadSafeInterceptorImpl"/>
        ...
    </properties>
</


使用临时会话
从Interceptor回调Session是非法的。session在拦截器调用期间处于易碎状态。在其他对象的保存期间，无法save新对象。避免这一问题的方法是，只为保存单个AuditLogRecord对象打开新的session，从原始的session中复用jdbc连接。
public class AuditLog {
    public static void logEvent(String msg, Auditable entity, Long userId, Connection connection) {
        Session temps = getSessionFactory().openSession(connection);
        try {
            AuditLogRecord record = new AuditLogRecord(msg, entity.getId(), entity.getClass(), userId);
            temps.save(record);
            temps.flush();
        } finally {
            temps.close();
        }
    }
}

在同一个jdbc连接使用了新的session，但它不启动或提交任何数据库事务。
session只是持久化上下文和高速缓存，以及使这个高速缓存与数据库同步的一系列sql操作。



内核事件系统
内核引擎基于一个事件/监听器的模型。
可以给hib事件编写和启用自己的监听器。
session接口的所有方法都会和一个事件关联。load方法触发LoadEvent，这个事件通过默认的DefaultLoadEventListener处理。

监听器实际上应该被认为是单例的，在请求间共享，所以不应该把任何事务相关的状态保存为实例变量。

原生hib中所有的事件和监听器接口的清单，请见org.hibernate.event包的api javadoc。

一个监听器的实现，可以实现多个监听器接口。

定制监听器可以通过hib Configuration对象被编程式地注册，或者在hib配置xml中指定(不支持通过属性文件的声明性配置)。你还需要一个配置入口，告诉hib除了默认的监听器外还需要使用这个监听器：
<session-factory>
    <event type="load">
        <listener class="auction.persistence.MyLoadListener"/>
    </
</

监听器按照它们在你的配置文件中排列的相同顺序进行注册。
本例中，由于你正在扩展内建的DefaultLoadEventListener，因此只有一个监听器。如果没有扩展它，就需要把内建的它指定为第一个监听器，否则要在hib中禁用加载。
。。。？？那DefaultDeleteEventListener，这种需要注册进去？
。。结合下面的 如果替换内建的监听器，就像MyLoadListener那样，就需要扩展正确的默认监听器。 这里是：加载所有default的，以及这里的，然后如果某2个类之间有父子类关系，就把父类剔除掉？
。。不，上面也写了 如果没有扩展它，就需要把内建的它指定为第一个监听器。就是 优先配置的，如果配置的某个事件没有，那么加载default，如果有了，那就不加载了。？

编程式地注册监听器堆栈：
Configuration cfg = new Configuration();
LoadEventListener[] stack = {new MyLoadListener(), ...};
cfg.getEventListeners().setLoadEventListeners(stack);

声明注册的监听器无法共享实例。如果同一个类名被用在多个<listener>中，每个引用都会new一个监听器。
如果需要在监听器之间共享数据，就必须使用编程式的注册方法。


EntityManager也支持监听器的定制，在persistence.xml中配置。
<persistence-unit name="...">
    <properties>
        <property name="hibernate.ejb.event.load" value="auction.persistence.MyLoadListener, ..."/>
    </
</

配置选项中属性名称 和 想监听的事件类型 一致， 这里是load。

如果替换内建的监听器，就像MyLoadListener那样，就需要扩展正确的默认监听器。

EntityManager没有绑定它自己的LoadEventListener，所以扩展org.hib.event.DefaultLoadEventListener的监听器仍然运行得很好。

几乎不必去扩展hib内核事件系统。大多数时候，Interceptor足够灵活了。


实体监听器和回调
ejb3实体监听器是拦截实体回调事件的类。这类似于原生hib拦截器，可以编写定制监听器，并通过注解或xml，把它们附加到实体
简单监听器：
public class MailNotifyListener {
    @PostPersist
    @PostLoad
    public void notifyAdmin(Object eneity)  {mail.send("save or load : "+entity);}
}

实体监听器不实现任何接口，它需要一个无参构造器。
你可以把回调注解引用到特定事件中需要被通知的任何方法，可以在单个方法中合并几个回调。不允许在几个方法中重复相同的回调
监听器类通过注解绑定到一个特定的实体类
@Entity
@EntityListeners(MailNotfyListener.class)       // 可以多个
public class Item {
    @PreRemove
    private void cleanup() {...}
}

也可以为整个层次结构把监听器应用到超类，并在orm.xml配置文件中定义默认的监听器。
最后可以通过@ExcludeSuperclassListeners,和@ExcludeDefaultListeners注解，给特定的实体排除超类监听器或者默认的监听器。

所有回调方法都可以有任意的可见性，必须返回void，不允许抛出任何受检异常。如果抛出未检异常，且有一个jta事务在处理，这个事务就会回滚。

回调注解
@PostLoad               find(),getReference()加载实体实例之后，或执行jpa查询时，或调用refresh()后
@PrePersist,@PostPersist    persist()调用时，且在数据库插入发生后，立即发生
@PreUpdate,@PostUpdate      持久化上下文和数据库同步之前，之后，触发，即在flush之前之后触发。且实体状态是需要同步，才触发
@PreRemove,@PostRemove      remove()，或通过级联删除实体实例时，并且在数据库删除之后触发。



chapter 13 优化抓取和高速缓存

定义全局抓取计划

对象获取选项
hib提供以下方法从数据库中获取对象：
导航对象图，从一个已经加载的对象开始。如auser.getAddress().getCity(),如果持久化上下文仍是打开的，当调用访问方法时，hib就会自动加载对象图中的节点。
通过标识符获取。
hql，jpa ql
Criteria
原始sql，包括存储过程的调用。

默认抓取计划，抓取策略是应用到特定的实体关联或集合的计划和策略。它定义了当加载自己的实体对象时，以及访问一个被关联的对象或集合时，被关联的对象或者集合是否以及如何被加载。

你的目标是为每个用例找到最好的获取方法和抓取策略，最小化sql查询次数，获得最好的性能。


hql 和 jpa ql
hql是sql的一种面向对象的方言。

hql常用于对象获取。
如果需要大量数据操作，hql，jpa ql都支持直接的大批量操作，用于更新，删除，插入。

大多数情况下，只需要获得特定类的对象，并通过该类的属性进行限制，如，下面查询通过名字获取用户
Query q = session.createQuery("from User as u where u.firstname=:fname");
q.setString("fname", "John");
List result = q.list();

hql支持：
对 按引用相关或者处于集合中的被关联对象的属性，应用限制的能力(用查询语言导航对象图)
只获取一个或多个实体的属性的能力，没有加载实体本身到持久化上下文的系统开销。有时这被称为报告查询，更准确的称呼是投影
对查询结果进行排序的能力
对查询结果进行分页的能力
与group by，having,聚集函数(sum,min,max)联合使用
当每一行获取多个对象时使用外部联结。
调用标准的和用户定义的sql函数的能力
子查询(嵌套查询)


按条件查询
hibernate的按条件查询(query by criteira) api允许 查询 在运行时通过criteria对象的操作进行创建。
这样让你可以动态地指定约束，而无需直接的字符串操作，但是会失去少量的hql灵活性或功能性。另一方面，用条件表达的查询通常比用hql表达的查询更不具备可读性

Criteria好的一面是，Criterion框架允许用户进行扩展。


按示例查询
作为Criteria的一部分。hib支持按示例查询(query by example).
Criteria criteria = session.createCriteria(User.class);
User example = new User();
example.setFirstname(""John);
criteria.add(Example.create(example));
criteria.add(Restrictions.isNotNull("homeAddress.city"));
List r = c.lsit();

典型用例是搜索屏，允许用户指定一系列不同的属性值 要与返回的结果集相匹配。


延迟的默认抓取计划
hib给所有实体和集合默认一个延迟的抓取策略。这意味着hib在默认情况下，只加载你正在查询的对象。


理解代理
代理是运行时生成的占位符。每当hib返回实体类的实例时，它就检查是否可以返回一个代理来代替，并避免命中数据库。
代理时 当真实对象第一次被访问时触发其加载的占位符。
Item i = session.load(Item.class, 123);
i.getId()
i.getDesc()         // initialize the proxy

如果通过直接的字段访问映射标识符属性，就不是这样了，hib不知道getId的存在，所以hib在调用getId时就初始化。

如果需要Item只是用来创建一个引用，代理就很有用。
。。而且，你得确保 这个主键是存在的吧。。。如果主键不存在，save的时候会保存吗？不知道发出什么样的sql来确认是否存在这个主键。
。。。上面也没说，如果缓存中有，load也是返回实例的，如果缓存中没有，才会返回代理。

get始终命中数据库(如果一级，二级缓存中没有)，不返回代理。

jpa中，find == get， getReference == load


hib代理是实体类运行时生成的子类的实例，你无法通过一般的操作符得到一个对象的类。需要辅助方法：HibernateProxyHelper.getClassWithoutInitializingProxy(o)。
。。返回值是 Class。


集合也没有立即加载，我们用术语集合包装器描述这种占位符。

hib有一组智能的集合，可以按需要初始化它们自己。hib用这些集合代替你的集合。这就是为什么领域模型应该使用集合接口。

默认情况下，hib给所有的关联和集合都创建占位符，并且仅仅立即获取值类型的属性和组件。不幸的是，这不是jpa默认的抓取计划。


如果你通过集合的元素启用迭代，或调用任何集合管理操作，如size，contains，集合就被初始化。

hib提供了一项对大集合最有用的额外设置，它们可以被映射为extra延迟，
<class name="Item" table="">
    
    <set name="bids" lazy="extra" inverse="true">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </
</
集合包装将更智能，现在调用size,contains,isEmpty，集合将不会被初始化，而是查询数据库来获取必要的信息。
如果它是一个Map或List，containsKey,get操作也将直接查询数据库。

注解：
@OneToMany
@org.hib.anno.LazyCollection(
    org.hib.anno.LazyCollectionOption.EXTRA
)
private Set<Bid> bids = new HashSet<Bid>();


禁用代理生成
lazy="false"
<class name="User" table="users" lazy="false">
    ...
</

jpa标准不要求通过代理实现。"代理"甚至没有出现在规范中。所以要禁用代理，需要hib的注解：
@Entity
@Table(name="users")
@org.hib.anno.Proxy(lazy=false)
public class User {...}


关联和集合的即时加载
hib默认lazy
始终加载：
<class name="Item" table="item">
    <many-to-one name="seller" class="User" column="seller_id" update="false" not-null="true" lazy="false"/>
</

<class name="Item" table="">
    <set name="bids" lazy="false" inverse="true">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </
</

注解：
@Entity
public class Item {

    @ManyToOne(fetch=FetchType.EAGER)
    private User seller;

    @OneToMany(fetch=FetchType.EAGER)
    private Set<Bid> bids = new HashSet<>();
}

hib中，FetchType.EAGER 和 lazy="false"相同。

jpa中，@ManyToOne,@OneToOne默认FetchType.EAGER.


通过拦截延迟加载
hib提供的运行时代理生成，是透明的延迟加载的一种极好的选择。这个实现公开的唯一必要条件是一个包，或者是必须被代理的类中公有可见的无参构造器，以及非final方法和类声明。在运行时，hib生成一个充当代理类的子类，这是私有构造器或者final类无法实现的。

另一方面，很多其他持久化工具没有使用运行时代理，它们使用拦截。
有2种情况，你可能不想使用代理：
运行时代理不完全透明的唯一情况时通过instanceof测试的多态关联。7.3.1介绍过如何避免这个问题，如何处理这个问题。用拦截代替代理也可以解决这些问题
代理和集合包装器只能被用于延迟加载实体关联和集合。它们无法用来延迟加载单独的标量属性或者组件。我们认为这种有化将没有什么用。如果没有使用 非常大量的可选列，或者没有使用 包含了必须按需获取的大值的可选列， 就没有必要在sql种被选中的单独列的级别上进行有化。大值最好用定位器对象。

。。7.3.1。。自己在load一次。。critera.setFetchMode("xxx", FetchMode.JOIN)。主动抓取。

想象你不想使用User实体类的代理，但仍想延迟加载。用no-proxy映射：
<class name="Item" table="">
    <many-to-one name="seller" class="User" column="seller_id" update="false" not-null="true" lazy="no-proxy"/>
</

lazy属性默认是proxy，通过no-proxy，告诉hib对这个关联应用拦截：

代理可以比拦截更延迟：item.getSeller().getId，不强制代理的初始化。

也可以延迟加载<property>,<component>的属性。xml中启用lazy="true"
注解@Basic(fetch=FetchType.LAZY)是给hib的一个提示，有一个属性或组件应该通过拦截被延迟加载。

用注解给关联禁用代理并启用拦截：
@ManyToOne
@JoinColumn(name="seller_id", nullable=false, updatable=false)
@org.hib.anno.LazyToOne(
    org.hib.ann.LazyToOneOption.NO_PROXY
)
private User seller;


为了启用拦截，类的字节码必须在编译之后，运行时之前被使用。hib提供一个Ant任务用于这一目的：
...

适合拦截的用例很少。


选择抓取策略

默认情况下，每当访问被关联对象和集合时(如果使用jpa，假设所有"对一"关联为FetchType.LAZY)，hib就延迟抓取它们.
Item i = s.get(Item.class, 123);
没有配置任何的非延迟，也没有配置可以为所有关联生成的代理，因此，发出sql：
select item.* from item item where item.item_id=?


批量预抓取数据
如果每一个实体关联和集合都按需抓取，完成一个特定的过程可能就需要许多额外的sql select。
List all = s.createQuery("from Item").list();
processSeller(all.get(0));
processSeller(all.get(1));
processSeller(all.get(2));

你会看到一个sql select获取所有的Item对象，并且你每处理Item的每一个seller时立刻就有另一个select。所有被关联的User对象都是代理。
n+1查询。sql看起来就像这样：
select items ...
select u.* from users u where u.user_id = ?
select u.* from users u where u.user_id = ?
select u.* from users u where u.user_id = ?

hib提供一些算法，可以预抓取User对象。我们现在讨论第一个优化：批量抓取。它像这样进行：如果User的一个代理必须被初始化，就在相同的select中初始化几个代理。换句话说，如果你已经知道持久化上下文中有3个Item，并且它们已经把一个代理应用到了它们的seller关联，那么你可以也初始化所有代理而不只是1个。

批量抓取经常被称为瞎猜优化，因为你不知道在一个特定的持久化上下文中，有多少个未被初始化的User代理。
前一个例子中，这个数量取决于返回的Item对象的数量。你猜测并把批量大小(batch-size)抓取策略应用到User类映射：
<class name="User" table="users" batch-size="10">
</class>

告诉hib：如果必须初始化一个代理，就在单个sql select中最多预抓取10个未被初始化的代理。

之前的查询所产生的sql现在看起来：
select items ...
select u.* from users u where u.user_id in (?,?,?)

all.get(0).getSeller()触发第二条sql，3个是因为，这是初始查询要返回的项目数量，以及当前的持久化上下文中未被初始化的代理数量。你定义了batch-size为最多10个。如果返回的货品超过10个，你就会看到第二个查询如何在一批中获取10个卖主。

批量抓取也可用于集合
<class name="Item" table="">
    <set name="bids" inverse="true" batch-size="10">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </
</

如果现在强制初始化一个bids集合，则立即加载相同类型的集合元素最多10个。
select items ...
select b.* from bid b where b.item_id in (?,?,?)

注解：
@Entity
@Table(name="USERS")
@org.hib.anno.BatchSize(size=10)
public class User {...}

@Entity
public class Item {
    @OneToMany
    @org.hib.anno.BatchSize(size=10)
    private Set<Bid> bids = new HashSet<Bid>();
}

预抓取的唯一缺点是，可能抓取了最终不需要的数据，用更少的sql的代码可能是更高的内存消耗。但，内存很便宜，可伸缩的数据库服务器则不便宜。


通过子查询预抓取集合
一个示例，并应用一种(或许)更好的预抓取优化：
List all = s.createQuery("from Item").list()
processBids(all.get(0))
processBids(all.get(1))
processBids(all.get(2))

更好的优化是这个集合映射的子查询抓取：
<class name="Item" table="">
    <set name="bids" inverse="true" fetch="subselect">
        <key column="Item_id"/>
        <one-to-many class="Bid"/>
    </
</

一旦你强制初始化一个bids集合，hib现在就立即给所有被加载的Item对象初始化所有的bids集合。
。。所有item  的 所有 bids 集合。

现在的sql：
select i.* from item i
select b.* from bid b where b.item_id in (select i.item_id from item i)

。。所有item 怎么弄？ 是多条select b.* ？还是 一条sql，但最后加上where item_id in (???)

@OneToMany
@org.hib.anno.Fetch(
    org.hib.anno.FetchMode.SUBSELECT
)
private Set<Bid> bids = new HashSet<Bid>();

利用子查询预抓取是一种更强大的优化。稍后介绍更详细的内容。


通过联结即时抓取
延迟加载是一种极好的默认策略。
但，你可能："每次我需要item的时候，也需要该item的seller".此时可以用即时抓取，并利用sql联结：
<class name="Item" table="">
    <many-to-one name="seller" class="User" column="seller_id" update="false" fetch="join"/>
</c

Item i = s.get(Item.class, 123);
发出sql：
select i.*, u.* from item i left outer join users u on i.seller_id = u.user_id where i.item_id = ?

fetch="join"禁用了延迟加载。如果你只用lazy=""join，启用即时抓取，会立即看到第二个select。通过fetch="join"在同一个select中加载seller。

如果你使用<many-to-one not-null="true"/>，hib就会执行内联结，而不是外部联结。

集合上设置即时联结抓取策略：
<class name="Item" table="">
    <set name="bids" inverse="true" fetch="join">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </
</
如果现在加载许多个Item对象，例如createCriteria(Item.class).list()。.sql：
select i.*, b.* from item i left outer join bid b on i.item_id=b.item_id

jpa，FetchType
@Entity
public class Item {
    @ManyToOne(fetch=FetchType.EAGER)
    private User seller;

    @OneToMany(fetch=FetchType.EAGER)
    private Set<Bid> bids = new HashSet<>();
}
前面用它来禁用关联和集合的延迟加载。hib把它默认当作一个不应该通过立即的第二个select(而是通过初始查询中的一个join)执行的即时抓取。

可以保留FetchType.EAGER，显式添加一个hib注解，从联结抓取转换到一个立即的第二个查询：
@Entity
public class Item {
    @ManyToOne(fetch=FetchType.EAGER)
    @org.hib.anno.Fetch(
        org.hib.anno.FetchMode.SELECT
    )
    private User seller;
}


一个全局的，可以用来控制被联结的实体关联(不是集合)最大数量的hib配置。
假如，你已经在映射元数据中设置所有多对一和一对多关联映射为fetch="join"(或FetchType.EAGER)。假设item有一个successfulBid关联，Bid有一个bidder，且这个User有一个shippingAddress。如果所有这些关联都通过fetch="join"映射，当你加载item时，要联结多少张表，要获取多少数据？
这种情况下，被联结的表的数量取决于全局的hibernate.max_fetch_depth配置属性。默认情况下，没有设置限制。
合理的设置很小，通常在1-5之间。你甚至可以设置0，给多对一和一对多的关联禁用联结抓取。
有些数据库方言可能预设这项属性，如MySQLDialect把它设置为2。



给二级表优化抓取
如果你查询的对象属于继承层次结构一部分的类，sql语句就变得更加复杂了
List r = s.createQuery("from BillingDetails").list();

获取所有的BillingDetails实例。sql select现在取决于你已经给BillingDetails和它的子类CreditCard,BankAccount选择的继承映射策略。
假设你已经把它们全部映射到一张表(每个层次结构一张表)。这个查询与前一节介绍过的没有什么区别。
如果你已经利用隐式多态映射了它们，这个简单的sql就可能根据个子类的每张表产生几个sql select

每个子类一张表 层次结构的外部联结
select b1.billing_detials_id,b1.owner....b2.number,b2.exp_month..b3.account,b3.bankname..
case
    where b2.credit_card_id is not null then 1
    where b3.bank_account_id is not null then 2
    where b1.billing_details_id is not null then 0
end as clazz
from billing_details b1 left outer join credit_card b2 on b1.billing_details_id = b2.credit_card_id left outer join bank_account b3 on b1.billing_details_id = b3.bank_account_id

许多数据库管理系统限制可以与out join合并的表的最大数目。如果你用标准的策略映射了一个很宽很深的继承层次结构，就可能碰到这一限制。


转换到额外的选择
你可以告诉hib转换到一种不同的抓取策略。你想要继承层次结构的一些部分通过立即的额外的select抓取，而不是初始查询中的out join。
启用这种抓取策略的唯一方式是稍微重构映射，作为使用了辨别标志列的每个层次结构一张表和使用了<join>映射每个子类一张表的混合：
<class name="BillingDetails" table="billing_Details" abstract="true">
    <id name="id" column="billing_details_id" ..../>
    <discriminator column="billing_details_type" type="string"/>

    <subclass name="CreditCard" disctiminator-value="CC">
        <join table="credit_card" fetch="select">
            <key column="credit_card_id"/>
            。。。
        </join>
    </subclass>

    <subclass name="BankAccount" discriminator-value="BA">
        <join table="bank_account" fetch="join">
            <key column="bank_account_id"/>
            。。。
        </
    </
</

这个映射把CreditCard 和 BankAccount类分开到它们各自的表中，但是在超类表中保存辨别标志列。
CreditCard对象的抓取策略是select，BankAccount的策略是默认的join。

现在如果查询所有的BillingDetails，的sql：
select b1.billing_details_id...b2.account,b2.bankname,..b1.billing_details_type as clazz
from billing_details b1 left outer join bank_account b2 on b1.billing_Details_id = b2.bank_account_id

select cc.number,cc.exp_month...from credit_card cc where cc.credit_card_id=?
select cc.number,cc....from credit_card cc where cc.credit_card_id=?

第一个sql从超类表和bank_account表获取所有的行。它也给每一行返回辨别标志值作为clazz列。
hib现在根据credit_card表给的第一个结果(这个结果有着CreditCard的正确辨别标志)的每一行执行一个额外的sql。这里执行了2条sql，意味着billing_Details超类表中有2个行表示一个CreditCard对象(的一部分)。

这种优化几乎没有必要。


优化指导方针
默认情况下，hib从不加载你没有请求的数据，这样减少了持久化上下文的内存消耗。然而，它也会让你面临所谓的n+1查询问题。
如果默认的策略转换到通过联结即时抓取数据的查询，就可以遇到另一个问题，笛卡尔积问题。

需要自己找到一个平衡点。

n+1查询问题
假设你没有在映射元数据中配置任何抓取计划或者抓取策略，所有的东西都是延迟的，且按需加载。
下面的代码试图找到每个Item中最高的Bid。(当然，有许多其他的方法可以更轻松地实现这一点)
List<Item> all = s.createQuery("from Item").list();
// List<Item> all = s.createCriteria(Item.clas).list();

Map<Item, Bid> highest = new HashMap<Item, Bid>();

for (Item item : all) {
    Bid high = null;
    for (Bid bid : item.getBids()) {
        if (high == null)
            high = bid;
        if (bid.getAmount() > high.getAmount())
            high = bid;
    }
    highest.put(item, high);
}

首先，获取所有Item实例，hql和criteria没有区别。这个查询触发一个sql select，获取item表的所有行，并返回n个持久化对象。接下来，你遍历这个结果，并访问每个Item对象。

每件货品的Bid对象都必须通过一个额外的查询来加载，这整个代码片段因此产生了n+1查询。

第一种方法是给集合改变你的全局映射元数据，启用批量预抓取：
<set name="bids" inverse="true" batch-size="10">
    <key column="item_id"/>
    <one-to-many class="Bid"/>
</set>

现在不是n+1，而是n/10 + 1查询。

利用一个基于子查询的预抓取，可以把选择的数量减到正好2个：
<set name="bids" inverse="true" fetch="subselect">
    <key column="item_id"/>
    <one-to-many class="Bid"/>
</set>

过程中的第一个查询现在执行单个sql select，获取所有item实例。hib记住这个语句，并当你命中第一个未被初始化的集合时，再次应用它。所有的集合都通过第二个查询被初始化。

可以设置fetch="join"，但会导致严重的笛卡尔积。


List<Item> all = s.createQuery("from Item i left join fetch i.bids").list();

all = s.createCriteria(Item.class).setFetchMode("bids", FetchMode.JOIN).list();

这2个查询通过一个outer join，为所有Item实例都生成了获取bids的单个select。


笛卡尔积问题
与n+1查询问题相反的是抓取过多的数据的select。

<class name="Item">
    
    <set name="bids" inverse="true" fetch="join">
        <key column="item_id"/>
        <one-to-many class="Bid"/>
    </
    <set name="images" fetch="join">
        <key column="item_id"/>
        <composite-element class="Images">
    </
</

sql：
select item.*, bid.*, image.* from item item left outer join bid bid on item.item_id=bid.item_id left outer join item_image image on item.item_id = image.item_id

如果你有1000件货品，每个货品20个出价和5张图片，你会得到100000行的结果集。

如果使用fetch="subselect"映射集合。就会得到3个查询，这就是对并行集合所建议的优化。

hib允许你通过fetch="join"在多个并行的集合中创建笛卡尔积，但如果你试图在并向的<bag>集合上启用fetch="join"，它就会抛出异常。乘积的结果集无法被转化为包集合。因为hib不知道哪些行包含有效的重复(包允许重复)以及哪些行不包含。
如果使用包集合(它们是jpa @OneToMany的默认集合)，就不启用导致乘积的抓取策略。给包集合的并行即时抓取使用子查询或立即的二级查询抓取。


强制初始化代理和集合
代理或者集合包装器，每当调用它的任何方法是都被自动初始化(除了标识符属性获取方法之外)。
预抓取和即时联结抓取都是获取你需要的所有数据的可能的解决方案。

有时，你需要在脱管状态下使用对象网络，获取所有应该脱管的对象和集合，然后关闭持久化上下文。
此时，在关闭持久化上下文之前显式地初始化一个对象，而不用求助于改变全局的抓取策略或者不同的查询。
可以使用Hibernate.initialize()给代理进行手工初始化：

Session s = sf.openS
tx

Item item = s.get(Item.class, 1234);
Hibernate.initialize(item.getSeller());

tx.commit s.close;

Hibernate.initialize()可以传递一个集合包装器或代理。如果你把一个集合包装器传递到initialize()，它不会初始化这个集合所引用的目的实体对象。

几乎没有必要用这个静态的辅助方法来显式地初始化，你应该始终首选使用hql或criteira的动态抓取。


逐步优化
首先，启用hibernate sql日志。你也应该准备针对特定的数据库schema而阅读，理解和评估的sql查询及其性能特征。
单个外部联结比2个查询更好吗？所有索引都使用得当吗？什么是数据库内部的高速缓存命中率？
开启配置属性：hibernate.format_sql, hibernate.use_sql_comments，使得在日志文件中阅读和分类sql语句变得容易多了。

逐个执行你应用程序的用例，并注意hib执行了多少个以及哪些sql语句。
你的目的是通过调优元数据中的默认抓取计划和抓取策略，把每个用例的sql数量和复杂性降下来。

默认情况下，一切都是延迟加载的。考虑转换到多对一，一对一和(有时)集合映射中的lazy="false"(或者FetchType.EAGER)。全局的抓取计划定义了始终被即时加载的对象。优化你的查询，如果你需要即时(不是全局)地加载对象，就启用即时抓取，但要在特定的过程(仅有的一个用例)中。

一旦定义了抓取计划，并且知道一个特定的用例所需要的数据量，就优化这个数据获取的方式。你可能遇到2个常见的问题：
sql使用太复杂且太慢的联结操作，先和dba一起优化sql执行计划。如果还没有解决，就移除集合映射中的fetch="join"(或先不设置它)。通过考虑它们是否真的需要fetch="join"策略，还是被关联的对象应该通过二级查询进行加载，来优化多对一和一对一关联。也可以通过全局的hibernate.max_fetch_depth配置选项来尝试调优，但是记住这个值最好保存在1-5之间。
可能执行过多的sql语句，在多对一和一对一关联映射中设置fetch="join"。在极少数情况下，如果你绝对确定，就启用fetch="join"，禁用对特定集合的延迟加载。记住，每个持久化类都有不止一个被即时抓取的集合会导致乘积。利用批量或者子查询，来评估你的用例是否能从集合的预抓取中受益。使用3-15之间的批量大小。



高速缓存基本原理
我们之所以认为使用对象/关系持久层 远胜于 用直接的jdbc创建的应用程序，一个重要的理由在于：高速缓存的潜能。
虽然我们对大多数的应用程序在不使用高速缓存的情况下应该可能实现满意的性能有严重的分歧，但对于某些类型的应用程序，尤其对于主要用于读取的应用程序或者在数据库中保存重大元数据的应用程序来说，高速缓存会对性能有巨大的提升。

不同的高速缓存和同一性范围，高速缓存在事务隔离性中的影响。如何启用，调优，管理一级，二级hib高速cache。

高速缓存是一种优化，因此它不是jpa或ejb3的一部分。每个供应商都对优化提供不同的解决方案，尤其是任何二级高速缓存。

高速缓存是数据的一个本地副本，处于应用程序和数据库之间，可以用来避免数据库命中，每当：
应用程序通过标识符执行查询的时候
持久层延迟解析一个关联或集合的时候

也可能高速缓存查询的结果，15章中你会见到，但高速缓存查询结果的性能收益十分微小，因此这项功能很少使用。

高速缓存策略和范围
有3种主要的高速缓存类型：
事务范围高速缓存，添加到当前的工作单元，它可能是一个数据库事务，甚至是一个对话。它只有在工作单元运行时才是有效的，才能被使用。每一个工作单元都有自己的高速缓存，这个高速缓存中的数据不会被并发访问。
过程范围高速缓存，在许多(可能并发的)工作单元或者事务之间共享。这意味着过程范围高速缓存中的数据被并发运行的线程访问，显然隐含着事务隔离性。
集群范围高速缓存，在同一台机器的多个过程之间或者一个集群中的多态机器上共享。

过程范围高速缓存可以把持久实例本身保存在高速缓存中，或者可以用分解的格式只保存它们的持久化状态。然后，每个访问共享高速缓存的工作单元都从被高速缓存的数据中重新组合一个持久化实例。

集群范围高速缓存需要某种远程过程通信来维持一致性。
对于许多应用程序来说，集群范围高速缓存的价值并不太确定，因为读取和更新高速缓存可能只比直接到数据库快一点点。

持久层可以提供多级高速缓存，如，事务范围中的高速缓存丢失，可能接着在过程范围内查找，数据库请求是最后的办法。


高速缓存和对象同一性
考虑事务范围的高速cache，这个高速cache似乎很自然地也被用作对象的同一性范围。这意味着高速cache实现同一性处理:对于使用相同数据库标识符的对象的2个查找返回实际上相同的java实例。因此，如果持久化机制也提供工作单元范围的对象同一性，事务范围高速缓存就是理想的。

利用过程范围高速缓存的持久化即值可能选择实现过程范围的同一性。这种情况下，对象同一性就相当于整个过程的数据库同一性。在2个并发运行的工作单元中，使用相同的数据库标识符的2个查找产生了相同的java实例。
另一种方法是，从过程范围的高速缓存中获取的对象可能按值被返回，此时，每个工作单元获取它自己的状态副本，并且生成的持久化实例也不相同。cache的范围和对象同一性的范围就不再相同。

集群范围cache需要远程通信，并且在面向pojo的持久化解决方案的案例中，对象始终按值被远程传递，因此，集群范围的cache无法保证跨越集群的同一性。

对于典型的web或企业应用程序的架构来说，对象同一性的范围被限制为单个工作单元最方便。换句话说，在2个并发的线程中有相同的对象即不必要也不理想。
在其他种类的应用程序中(如桌面型的或者胖客户端的架构)，使用过程范围的对象哦太唔易行可能很恰当。这在内存极端受限的应用程序中尤其合适---工作单元范围cache的内存消耗与并发线程的数量成正比。
过程范围同一性的真正缺点再与，需要同步对cache中持久化实例的访问，这很可能导致思索，以及由于锁竞争而减少可伸缩性。

cache和并发
任何运行多个工作单元共享相同持久化实例的orm实现，都必须提供某些对象级锁定，以确保并发访问的同步。这通常结合使用读/写锁(保存在内存中)与死锁侦测共同实现。hib的实现：给每个工作单元(工作单元范围的同一性)维护一个独特的实例组，很大程度避免了这些问题。
应该避免在内存中保存锁。
如果你也使用工作单元范围的对象同一性，并且如果对于高并发的多用户系统来说它是最佳策略，那么事务/工作单元范围的cache就是首选。这个一级cache是强制的。
对于有些数据，二级高速缓存被界定到按值返回数据的过程(或者集群)中可能会有好处。


cache与事务隔离性
过程，集群范围的cache使得从一个工作单元中的数据库获取的数据对另一个工作单元可见。
如果应用程序有对数据库的非专有访问，就不因该使用过程范围的cache，除了对很少改变且可以被cache期限安全地刷新的数据之外。
对于非专有的访问，小心2个主要的场景：
被集群的应用程序
共享的遗留数据

任何被设计为可伸缩的应用程序，都必须支持集群的操作。过程范围的cache不维持集群中不同机器上不同cache之间的一致性。此时，应该使用集群范围(分布式的)二级cache而不是过程范围的cache。


完全的orm解决方案让你单独地给每个类配置二级cache，cache的好的备选类是：
很少改变的数据
不重要的数据
应用程序固有的而非共享的数据。

不好的备选类：
经常被更新的数据
财务数据
通过遗留应用程序共享的数据。

通常应用规则不是唯一的，许多应用程序都有大量包含下列属性的类：
少量的实例
被另一个类或几个类的许多实例引用的每一个实例
很少/从不更新的实例
这种数据有时称为引用数据，引用数据的例子是邮政编码，参考地址，办公地点，静态文本信息等。、
引用数据对于利用过程或集群范围的高速cache而言都是极好的备选对象，并且如果这个数据被cache，任何大量使用引用数据的应用程序都将受益匪浅。


hibernate cache

一级cache是持久化上下文cache，一个hib session的寿命相当于单个请求(通常用一个数据库事务实现)或者单个对话。这是个强制的一个cache，它保证对象的范围和数据库同一性(StatelessSession是例外，它没有持久化上下文。。。无所谓，StatelessSession没有继承Session)。

二级cache是可插拔的，并且可以被界定到过程或集群。这是一个状态的cache(按值返回)，而不是实际的持久化实例的cache。cache并发策略给特定的数据项目定义了事务隔离细节，而cache提供程序表示了物理cache实现。二级cache是可选的，可以在按类和按集合的基础上配置---每个这样的cache都利用它自己的物理cache区域。

hib也给与二级cache密切整合的查询结果集实现cache，这是可选特性。它需要2个额外的物理cache区域，当表最后一次被更新时保存被高速缓存的查询结果和时间戳。


hib 二级cache
二级cache有过程或者集群范围：已经从特定SessionFactory开始的(或与特定持久化单元的EntityManager关联的)所有持久化上下文共享一个二级cache。
持久化实例以分解的形式保存在二级cache中，把分解当作一个过程，有点像序列化(但这个算法比序列化快很多)。
过程/集群范围cache的内部实现没有什么值得关注的。更为重要的是cache策略的正确使用---cache策略和物理cache提供程序。

不同种类的数据需要不同的cache策略，cache策略涉及如下设置：
二级cache是否被启用
hib并发策略
cache过期策略(超时，lru，内存敏感性)
cache的物理格式(内存，被索引的文件，集群复制)

cache通常只对主要用来读取的类有用。如果你有更新比读取更频繁的数据，就不要启用二级cache。
二级cache存在与其他的写入应用程序共享数据库的系统中可能很危险。

hib 二级cache的创建分为2步，首先，决定使用那种并发策略，第二，利用高速缓存提供程序 配置cache过期和物理cache属性。

内建的并发策略
并发策略是一个媒介：它负责在cache中保存数据的项目，并从高速缓存中获取它们。它也为特定的项目定义了事务隔离语义。
如果要启用二级cache，就必须给每个持久化类和集合决定使用哪种并发策略
4个内建的并发策略，表示递减的事务隔离方面的严格性：
事务，只用于托管环境，如有必要，它还保证完整的事务隔离直到可重复读取。给主要用于读取的数据使用这种策略，因为对于这种数据，防止并发事务中的废弃数据最为关键，极少数情况下用于更新
读/写，利用时间戳，维护读取提交隔离，只能在非集群环境中使用。还是主要用于读取的数据，因为对于这种数据，防止并发事务中的废弃数据最为关键，极少数情况下用于更新。
非严格读/写，不提供cache与数据库之间的一致性保证。如果有可能并发访问相同的实体，你应该配置一个足够短的超时期限。否则，可能从cache中读取废弃的数据。如果数据几乎不变，并且废弃的数据不可能是关键的关注点，那就使用这种策略。
只读，并发策略适用于从不修改的数据，它只用于引用数据。

递减的严格性带来了性能的递增。在许多情况下，如果绝不考虑废弃的数据，可能最好给特定的类禁用二级cache。

首先以禁用了二级cache的程序为基准。为好的备选类开启二级cache，一次一个，同时继续测试系统的可伸缩性，并评估并发策略。

通过实现org.hib.cache.CacheConcurrencyStrategy,可以定义自己的并发策略，但这是一个非常困难的任务，并且只适合于少数的优化案例。


选择高速缓存提供程序
现在，hib强制你给整个程序选择单个的cache提供程序，hib内建了如下开源产品：
EHCache，特意用于单个jvm中简单的过程范围高速缓存的高速缓存提供程序。它可以高速缓存在内存或磁盘中，并支持可选的hib查询结果高速缓存。(ehcache最新版支持被集群的cache，但还没有测试)。
OpenSymphony OSCache，一项服务，通过一组丰富的过期策略和查询高速缓存支持，支持单个jvm高速缓存到内存和磁盘。
SwarmCache，基于JGroups的集群cache，使用集群的实效，但不支持hib查询cache。
JBoss Cache，完全事务复制的集群cache，也基于JGroups多播库。支持复制或者失效，同步或者不同步的通信，以及乐观锁，悲观锁。支持hib查询cache，假设时钟在集群中同步。


通过实现org.hib.cache.CacheProvider给其他产品编写一个适配器很容易。许多商业高速cache都可以通过这个接口插入到hibernate。
。。5.2没有这个接口了。找不到是什么接口。 CachedDomainDataAccess ？

并非每个cache提供程序都可以和每一种并发策略兼容！

            只读      非严格读/写      读/写     事务
ehcache     x           x           x     
OSCache     x           x           x              
SwarmCache  x           x
JBoss Cache x                                 x

创建cache有2个步骤：1，在映射元数据中看看持久化类和集合，并决定要给每个类和每个集合使用哪种cache并发策略。
2，在全局的hib配置中启用首选的cache提供程序，并定制提供程序特定的设置和物理高速缓存区域。


高速缓存实践
给CaveatEmptor的Category,Item,Bid类启用高速缓存

选择并发控制策略
Category只有少量实例且很少更新，且实例在许多用户之间共享。它适合开启二级cache。

<class name="auction.model.Category" table="category">
    <cache usage="read-write"/>
    <id ...
</

usage="read-write"属性告诉hib，给Category高速缓存使用一个 读/写并发策略。

注解：
@Entity
@Table(name="category")
@org.hib.anno.Cache(
    usage = org.hib.anno.CacheConcurrencyStrategy.READ_WRITE
)
public class Category {...}

用read-write代替nonstrict-read-write，因为category是一个高并发的类，在许多并发事务中共享。(很显然，读提交隔离级别就够了)。nonstrict-read-write只依赖cache过期，但你更喜欢让对类别所做的改变立刻可见。

类高速缓存始终对持久化类的整个层次结构而被启用。你无法只cache一个特定子类的实例。
。。直接写子类上就ok了吧？。被<cache>的应该是 cache的根吧？


上面的例子只高速hib缓存category的简单属性值，而不是被关联的实体或集合的状态。
集合需要它们自己的<cache>:
<class name="auction....Category" table="">
    <cache usage="read-write"/>
    <id...>
    <set name="items">
        <cache usage="read-write"/>
        <key..
    </s
</c

集合cache的区域名称是完全匹配的类名+集合属性的名称：auction.model.Category.items.
。。这个 全限定类名，是 java的还是 <class>的？

@org.hib.anno.Cache 也可以在集合字段或获取方法中进行声明

调用acategory.getItems()时，这个cache设置生效---换句话说，集合cache是一个包含"哪些项目处在哪些类别中"的区域，它是只有标识符的cache，在该区域没有实际的Category或Item数据。
。。靠，只是一个关联关系。只是一个关系，或者说 一组id映射，没有其他数据。。

如果你需要Item实例本身被cache，就必须启用Item类的cache。读/写尤其合适，用户可不想更具可能实效的Item数据做出决定。
考虑bids，bids集合中特定bid是不变的，但bids集合可变，并且并发的工作单元需要立刻看到集合元素的添加或移除：
<class name="Item" table="">
    <cache usage="read-write"/>
    <id...
    <set name="bids">
        <cache usage="read-write"/>
        <key...
    </set>
</class>

<class name="Bid" table="Bid" mutable="false">
    <cache usage="read-only"/>
    <id..
</class>

因此，bid数据在cache永不过期，因为它只能被创建而从不更新。如果bid实例被删除，hib也从cache中移除数据，但不对这种做法提供任何事务的保证。

User是可以通过nonstrict-read-write策略而被cache的一个类。但我们不确定它对于cache 用户是否有意义。


理解高速缓存区域(cache region)
hib在不同的高速缓存区域中保存不同的类/集合。区域是一个具名的cache：这个句柄使你可以通过它在cache提供的程序配置中引用类和集合，并设置适合于该区域的过期策略。一种更图形化的描述是：区域是一桶桶的数据，它们有2种类型：一种区域类型包含实体实例的分解数据，另一种类型只包含通过集合而被链接的实体标识符。

对于类cache而言，区域名称是类名，对于集合cache而言，是类名+属性名。
Category实例被高速缓存在具名auction.model.Category区域种，而items集合被cache在具名auction.model.Categoty.items的区域中。

hib配置属性hibernate.cache.region_prefix用来给特定的SessionFactory或持久化单元指定区域名前缀，例如，如果前缀设置为dbl，Category就被cache在具名dbl.auction.model.Category的区域中。
如果程序使用多个sessionfactory或持久化单元，这项设置就是必须的。没有它，不同持久化单元的cache区域名称就可能冲突。

设置本地的cache提供程序
hibernate.cache.provider_class=org.hibernate.cache.EhCacheProvider
选择EHCache作为二级cache

现在需要指定cache区域的属性，EHCache有自己的配置文件ehcache.xml，在应用程序的类路径中。
hib发行包中为所有绑定的cache提供程序 捆绑了示例配置文件。

ehcache.xml中用于Category类的cache配置可能如下：
<cache name="auction.mode.Category" maxElementsInMemory="500" eternal="true" timeToIdleSeconds="0" timeToLiveSeconds="0" overflowToDisk="false" />

有少量的Category实例，所以，你选择一个大于系统中实例数量的cache大小限制，并设置etrnal="true"，禁用超时清除。没有必要通过超时终止被cache的数据，因为category的cache的并发策略是读/写，且没有其他应用会修改数据库中数据。禁用了基于磁盘的cache溢出，因为你知道category的实例很少，因此内存消耗不会有问题。

Bid很小，且不可变，但是有很多，因此你必须配置EHCache来小心管理cache内存消耗。你把过期超时和最大cache大小限制都用上了：
<cache name="auction.model.Bid" maxElementsInMemnory="50000" eternal="false" timeToIdleSeconds="1800" timeToLiveSeconds="100000" overflowToDisk="false" />

timeToIdleSeconds定义了以秒为单位的从一个元素最后一次在cache中被访问开始的过期时间。必须要设置，因为不想让无用的Bid始终消耗内存。
timeToLiveSeconds定义了以秒为单位的从元素被添加到cache中开始的最大过期时间，由于出价是不可变的，因此如果它们正被正常访问，你就不需要把它们从cache中移除。因此timeToLiveSeconds被设置成一个很大的数值。

现在，当cache总数达到50000个元素，那么最近30分钟内没有被使用或者最近使用频率最小的被cache的出价就会从cache中被移除。

这里，你禁用了基于磁盘的高速缓存，因为你预计应用程序服务器和数据库在同一台机器上。如果不是这种物理架构，那么可能需要启用基于磁盘的cache来减少网络通信量。

最佳的cache清除策略是特定于数据和应用程序的。
需要考虑很多：应用程序服务器的可用内存，是否和数据库机器在一起，网络延迟，遗留应用程序的存在，等。有些因素不可能在开发时得知，因此经常需要在生产环境或模拟环境中反复调试。我们考虑通过二级cache优化一些在开发期间你不会去做的事情，开发时没有实际数据集，没有实际并发情况。


设置重复的cache
单个jvm，ehcache是极好的cache。
对于企业程序，需要上千并发，可伸缩的应用程序对于项目的成功非常重要。hib天生是可伸缩的。hib不会限制应用程序需要部署在哪些节点上。稍微修改cache配置，就能得到一个可用于集群的cache。

我们推荐JBoss cache，一个基于TreeCache,JGroups多播库的集群安全的cache系统。
。。maven上，jboss cache最后一次更新是2008。。。baidu不到hibernate 集群 缓存 cache。。maven有 JBossCache Core，2011年的。。


首先，必须检查所有使用 只读 或者 事务 作为cache并发策略的所有映射文件。这些是jboss cache提供程序唯一支持的策略。有一种很好的技巧有助于避免这种搜索，并在未来替换问题。不要在映射文件中放置<cache>元素，而是集中在hibernate.cfg.xml中：
<hibernate-configuration>
<session-factory>
    <property .../>
    <mapping .../>
    
    <class-cache class="org.hibernate.auction.model.Item" usage="transactional"/>
    <collection-cache collection="org.hibernate.auction.model.Item.bids" usage="transactional"/>
</s
</h

如果Item映射文件中也有<cache>元素，hib就会遇到冲突。
建议一开始就使用集中的cache配置。

启用JBoss cache:
hibernate.cfg.xml:
<property name="cache.provider_class">
    org.hibernate.cache.TreeCacheProvider
</property>

jboss cache的配置文件 treecache.xml,在应用程序类路径中。
有些场景中，集群的每个节点都需要不同的配置，并且你必须确保部署时把正确的文件复制到类路径中去。
下面是一个典型的配置，在一个2节点的集群(具名MyCluster)中，这个文件在节点A上：
<server>
    <classpath codebase="./lib" archives="jboss-cache.jar, jgroups.jar"/>
    <mbean code="org.jboss.cache.TreeCache" name="jboss.cache:service=TreeCache">
        <depends>jboss:service=Naming</
        <depends>jboss:service=TransactionMaanger</
        <attribute name="TransactionManagerLookupClass">org.jboss.cache.GenericTransactionManagerLookup</
        <attribute name="ClusterName">MyCluster</
        <attribute name="NodeLockingSchema">PESSIMISTIC</
        <attribute name="CacheMode">REPL_SYNC</
        <attribute name="IsolationLevel">REPEATABLE_READ</
        <attribute name="FetchInMemoryState">false</
        <attribute name="InitialStateRetrieveTimeout">20000</
        <attribute name="SyncReplTimeout">20000</
        <attribute name="LockAcquisitionTimeout">15000</
        <attribute name="Clusterconfig">
            <config>
                <UDP loopback="false"/>
                <PING timeout="2000" num_initial_members="3" up_thread="false" down_thread="false"/>
                <FD_SOCK/>
                <pbcast.NAKACK gc_log="50" retransmit_timeout="600,1200,2400,4800" max_xmit_size="8192" up_thread="false" down_thread="false"/>
                <UNICAST timeout="600,1200,2400" window_size="100" min_threadhold="10" down_thread="false"/>
                <pbcast.STABLE desired_avg_gossip="20000" up_thread="false" down_thread="false"/>
                <FRAG frag_size="8192" down_thread="false" up_thead="false"/>
                <pbcast.GMS join_timeout="5000" join_retry_timeout="2000" shun="true" print_local_addr="true"/>
                <pbcast.STATE_TRANSFER up_thread="true" down_thread="true"/>
            </config>
        </att'
    </m
</s

这个配置不仅仅是jboss cache的一个配置文件，它还集多种角色于一身：jboss as部署的jmx服务配置，treecache的配置，jgroups的细粒度配置和通信库。

第一个属性TransactionMaangerLookupClass，GenericTransactionManagerLoopup试图在最流行的应用服务器中找到事务管理器。
接下来，是使用同步通信的被复制高速缓存的配置属性。
jboss cache也可以清除元素
也支持失效，但不支持集群中被修改数据的复制。可以转到OPTIMISTIC锁，需要另一种hib高速cache提供程序插件org.hib.cache.OptimisticTreeCacheProvider。
最后，jgroups集群通信配置。<UDP>

其他jgroups属性更复杂，需要查看文档。它们处理发现算法，用于在群组中侦测新节点，失败侦测，以及群组通信的管理。

对于集群cache提供程序而言，把hib配置选项hibernate.cache.use_minimal_puts设置为true可能更好。当启用这项设置时，hib只在检查以确保该项目还没有被cache之后才把它添加到cache中。如果cache写入比cache读取更贵，那么这种策略执行得很好。


控制二级cache
hib有一些有用的方法，可以帮助你测试和调优cache，给二级cahe，hibernate.cache.use_second_level_cache考虑全局的配置转换。默认情况下，映射文件中的任何<cache>都触发二级cache，并在启动时加载cache提供程序。如果想禁用二级cache，而不移除cache映射元素或注解，那么就把这个属性设置为false。

session/entityManager提供编程方法来控制持久化上下文，
sessionfactory对二级缓存也一样。jpa中，必须访问底层的内部sessionfactory.

SessionFactory.evict(Category.class, 123);
通过指定类和对象标识符值，从二级cache中移除元素。

SessionFactory.evict("auction.model.Category");
通过区域名称，消除一个特定类的所有元素，或清除一个特定集合的角色。

。。但是SessionFactoryImpl中找不到这些方法了。父类也没， 不知道去哪里了。

很少用到这些方法。
注意二级cache的清除时非事务的，即，cache区域在清除期间没有被锁定。

hib还提供CacheMode选项。可以由特定的session启用。想象你需要在session中把许多对象批量插入到数据库中，每个对象都被添加到一级cache。如果实体类启用了二级cache，也会添加到二级cache：
Session s = sf.open
tx = 
s.setCacheMode(CacheMode.IGNORE);
for (int i = 0; i < 100000; i++) {
    Item item = new
    session.save(item);
    if (i % 100 == 0) {
        s.flush.  s.clear()    
    }
}
tx.commit
s.close

IGNORE告知hib不要在这个session中与二级cache交互

NORMAL  默认行为，从二级读，也会写到二级
IGNORE  从不与二级交互，除了更新发生时使被cache的项目失效
GET     从二级读，但不添加，除了更新发生时使项目失效之外。
PUT     不读，但当它从数据库中读取项目时，会把项目添加到cache
REFRESH 不读，但从db读取时，会添加。此时，hibernate.cache.use_minimal_puts的作用被忽略，以便在一个复制的集群cache中强制cache刷新。

除了NORMAL，IGNORE之外的选项，好的用例很少。


你的程序在不使用二级cache时也应该执行得令人满意。二级cache治标不治本！。抓取计划和抓取策略的定制始终是你的第一个优化步骤。



chapter 14 使用hql 和 jap ql 查询

前面提到了hib的3中表达查询的方法：
hql jap ql
s.createQuery("from Category c where c.name like 'Laptop%'");
entityManager.createQuery("from Category c where c.name like 'Laptop%'");

criteira 的 qbc qbe
s.createCriteria(Category.class).add(Restrictions.like("name", "Lap%"));

sql
s.createQuery("select {c.*} from category {c} where name like 'Lap%'").addEntity("c", Category.class);
。。。！

查询涉及几个独特的步骤：
创建查询，通过任何任意的限制或你想要获取的数据的投影
把运行时参数绑定到查询参数，该查询通过改变设置被重用
执行针对数据库的预编译查询和数据获取，你可以控制查询如何执行，如何把数据获取到内存(一次获取全部，还是逐个获取)


准备查询
org.hib.Query,org.hib.Criteria这2个接口都定义了几种控制查询执行的方法。
jpa使用javax.persistence.Query接口。

创建查询对象
在session上调用createQuery(),createSQLQuery()
2个方法中，hib都返回一个刚刚被实例化的Query对象。

createCriteria()

jpa
em.createQuery(),em.createNativeQuery()


对结果进行分页
query.setMaxResults(10);
查询结果集限制为前10个对象(行)。

从结果集的中间开始：
crit.setFirstResult(40);
crit.setMaxResults(20);
从第40个对象开始，获取接下来的20个。
。。应该是41，42，43。。。60。

sql的分页没有标准的方法，依赖于各个方言。
sqlQ.setFirstResult(40);
sqlQ.setMaxResults(20);

Query,Criteria，都可以使用方法链。。包括jpa的，所有的sqlQuery.


考虑参数绑定。
如果没有运行时参数绑定，你只能编写很糟糕的代码：
String hql = "from Item i where i.desc like '" + search + "'";
List r = s.createQuery(hql).list();

应用永远不要这样写，因为恶意的用户可能搜索下面的项目描述，即search是：
foo' and callSomeStoredProcedure() and 'bar'='bar

不再是一个简单的查询，还会在数据库中执行一个存储过程。
sql注入的安全性问题

jdbc驱动包括将值安全绑定到sql参数的功能。它准确地知道参数中哪些字符需要转码，因此不会出现sql注入问题。如，对前面的search中的引号字符进行转码，不再作为控制符号处理，而是作为搜索符号的一部分。此外，使用参数的时候，数据库能有效地高速缓存预编译的语句，显著改善性能。

参数绑定有2种方法，利用定位或利用具名参数。hib，jpa都支持这2项。但无法在一个特定查询中同时使用这2个选项.

使用具名参数：
String hql = "from Item item where item.desc like :search";
Query q = s.createQuery(hql).setString("search", searchStr);
。。searhStr带不带 % ？？hib应该不会自动添加吧。

searchStr是用户提供的字符串变量，调用setString方法，把它绑定到具名参数(:search).这个代码更规则，更安全，执行得更好，因为如果只是绑定参数的变化，单独编译的sql语句就可以被重用。

经常需要多个参数：
String hql = "from Item item where item.desc like :search and imte.date>:minDate";
Query q = s.createQuery(hql).setString("search", str).setDate("minDate", mDate);

在jpa中稍有不同：
Query q = em.createQuery(hql).setParameter("search", searchStr).setParameter("minDate", mDate, TemporalType.DATE);

setParameter方法是一般的操作，它可以绑定所有类型的实参，对于时间类型需要额外的参数来表明是日期，时间，时间戳。
jpa只支持这种方法，用于参数绑定。hib也支持这种方法。


利用hib的参数绑定
前面使用了setString,setDate。原生的hib query提供了其他类似的方法，来绑定大多数hib内建类型的参数，从setInteger到setTimestamp,setLocale。它们中大多数是可选的，可以依赖setParameter()方法自动找出正确的类型(除了时间类型)。

特别有用的一种方法是setEntity()，它让你绑定一个持久化实例。(setParameter足够聪明，能理解这一点)
s.createQuery("from Item item where item.seller=:seller").setEntity("seller", theSeller);

还有一种允许绑定任何hib实参的一般方法：
s.createQuery(hql).setParameter("seller", theSeller, Hibernate.entity(User.class)).setParameter("desc", desc, Hibernate.STRING);

。。Hibernate中entity，STRING,都不知道哪里去了。

甚至可以用于定制的用户自定义的类型，如MonetaryAmount:
Query q = session.createQuery("from Bid where amount>:amount");
q.setParameter("amount", givenAmount, Hibernate.custom(MonetaryAmountUserType.class));


如果你有包含seller，desc属性的java对象，就可以调用setProperties来绑定参数：
Item item = new item();
item.setSeller(seller);
item.setDesc(desc);
String hql = "from Item item where item.seller=:seller and item.desc like :desc";
session.createQuery(hql).setProperties(item);

setProperties绑定使得java对象中名称与查询字符串中具名参数一致，内部调用setParameter来猜测hib类型并绑定值。
实际上，结果表明它并没有听起来这么有用，因为有些常用的hib类型是不可猜测的(尤其是时间的类型)。
。。setProperties还可以接受Map。

Query的参数绑定方法可以是空的。因此下列代码有效：
query.setString("name", null);

然后这段代码的结果不是你想要的，生成的sql将包含一个比较式(username=null,它在sql三重逻辑中始终取值未空)。反之，你必须使用is null：
s.createQuery("from User as u where u.username is null");


利用定位参数
hql = "from Item item where item.desc like ? and item.date>?";
s.createQuery(hql).setString(0, searchStr).setDate(1, minDate);

jpa也支持定位参数：
hql = "from Item item where item.desc like ?1 and item.date>?2";
em.createQuery(hql).setParameter(1, searchStr).setParameter(2, minDate, TemporalType.DATE);
。。真是 ?1 ?2 ???,不是 注释？必须有数字。。。这个数字必须1，2，3？还是随意的？随意的话，可以当具名用。

比具名参数更难懂，而且如果改变查询字符串中条件的顺序，需要改变方法的顺序。
建议避免使用定位参数。如果你通过编程构建复杂的查询，它可能更加方便，但是此时 criteria是更好的选择

记住hib从0开始，jpa从1开始。必须给jpa ql查询字符串中每个?添加数字。它们有着不同的遗留根：hib的根是jdbc，jpa的根是更早版本的ebj ql
。。估计说的是 来源吧。


设置查询提示。。。md这个机翻，估计这里是：一些查询优化的提示
假设你在执行查询之前修改了持久化对象，这些修改只出现在内存中，因此hib在执行查询之前，把持久化上下文和所有变化flush到数据库，这样保证查询时，查询结果和内存之间不会有冲突。

有时，你执行一系列查询-修改-查询-修改的操作，并且每次查询的结果都是不同的数据集，这样就不需要在查询之前把修改flush到数据库，因为不会有冲突的结果。注意，持久化上下文给实体对象提供可重复读取，因此只有查询的标量结果才是问题。
可以在session/entityManager中，利用setFlushMode禁用持久化上下文的flush。或者如果你只想在特定的查询之前禁用flush，可以在Query中设置FlushMode:
s.createQuery(hql).setFlushMode(FlushMode.COMMIT);
em.createQuery(ql).setFlushMode(FlushModeType.COMMIT);

hib不会在执行这些查询之前清除持久化上下文
。。执行前flush。。


另一种优化是对特定查询结果的一个细粒度的org.hib.CacheMode。13.4.5节中用了一种cache模式，控制hib如何与二级cache交互。
如果hib通过标识符获取对象，它现在一级cache中搜索，没找到且开启了二级cache，那么它还会去二级cache中搜索这个实体。执行一个返回实体实例的查询时，也发生同样的事情，在查询结果的封送期间，hib试图先从持久化上下文cache中找到它们，如果找到，那么hib就忽略结果的实体数据。如果，不存在cache中，hib在查询之后会把它放入cache中，可以在查询中通过CacheMode控制这个行为：
Query q = session.createQuery("from Item").setCacheMode(CacheMode.IGNORE);
s.createCriteria(Item.class).setCacheMode(CacheMode.IGNORE);
em.createQuery(ql).setHint("org.hibernate.cacheMode", org.hib.CacheMode.IGNORE);

IGNORE告诉hib不要这个查询返回的任何实体而与二级cache交互。
。。一级应该是永远起效的。

给特定持久化对象禁用脏检查的一种方法是设置session.setReadOnly(object, true),entityManager不支持这个。

你可以告诉hib：查询返回的所有实体对象都应该被当作只读的：
s.createQuery("from Item").setReadOnly(true);
em.createQuery("select i from Item i").setHint("org.hibnerante.readOnly", true);

由这个查询返回的所有item都处于持久化状态，但在持久化上下文中，没有给自动脏检查启用任何快照。hib不会自动持久化任何修改，除非用session.setReadOnly(object, false)禁用只读模式。


设置超时，控制允许一个查询运行多久
s.createQuery("from Item").setTimeout(60);      // 1fenzhong
s.createCriteria(Item.class).setTimeout(60);
em.createQuery("select i from Item i").setHint("org.hibernate.timeout", 60);

这种方法和jdbc statement的setQueryTimeout有相同的语义和结果。

还和底层jdbc有关的是抓取大小(fetch size):
s.createQuery("from Item").setFetchSize(50);
s.createCriteria(Item.class).setFetchSize(50);
em.createQuery("select i from Item i").setHint("org.hib.fetchSize", 50);
jdbc抓取大小是对数据库驱动程序的一个优化提示；如果驱动程序没有实现这个功能，它不会有任何的性能改善。
如果它实现了，当客户端在一个ResultSet中操作时，通过在一个批量中获取许多个行，可以改善jdbc客户端和数据库之间的通信。


优化程序时，需要阅读复杂的sql日志，强烈建议启用hibernate.use_sql_comments。然后hib就会为它写到日志中的每条sql增加一条注释，可以通过setComment给特定的查询设置定制的注释：
s.createQuery("from Item").setComment("My comment ... ");
s.createCriteria(Item.class).setComment("xxx");
em.createQuery("select i from Item i").setHint("org.hibernate.comment", "asd");

其他场景中，可以通过org.hibernate.Interceptor,在onPrepareStatement(sql)方法中操作sql

使用悲观锁，这是一直持续到数据库事务结束的锁：
s.createQuery("from Item item").setLockMode("item", LockMode.UPGRADE);
s.createCriteria(Item.class).setLockMode(LockMode.UPGRADE);

悲观锁在jpa中不可用。


执行查询
迭代iterating和滚动scrolling 差不多，90%的查询依赖list，getResultList方法。

列出所有结果
List r = myQuery.list();
r = myCriteria.list();

jpa:
List r = myJPAQuery.getResultList();

如果你只想要最高出价，可以r.get(0);
或者setMaxResult(1).uniqueResult()返回单个对象。


uniqueResult()如果返回不止一个对象，就抛出异常，如果没有，就返回null。
。。可以多个对象而不报错，前提：多个对象中任意2个，使用==操作符，都返回为true。

jpa中getSingleResult()，不过这个方法，如果结果是空，也会抛错。


循环访问结果
hibernate Query接口提供了iterator()方法来执行查询。它返回和list()一样的数据，但是依赖不同的策略来获取结果。
调用iterator()执行查询时，hib在第一个sql select只获取实体对象的主键(标识符)值，然后试图在持久化上下文cache和二级cache中查找对象的其他状态。
Query q = s.createQuery("from Category c where c.name like :name");
q.setString("name", namePattern);
List r = q.list();
这个查询导致至少一条sql select。category表的所有列都包含在该select子句中：
select category_id, name, parent_id from category where name like ?

List r = q.iteraor();
发出sql：
select category_id from category where name like ?

初始的查询只获取Category主键值。然后你循环访问结果，hib在一级和二级cache中搜索Category，如果cache中没有找到，就发出sql select 通过主键 去获取。
大多数情况下，这是很小的优化。把行读取减到最少通常比把列读取减到最少更为重要。
如果你对象中有很大的字符串字段，这种方法也可以降低网络中的数据包，减小延迟。
只有当被迭代实体的二级cache被启用时，这种方法才真正有效，否则，它就会产生n+1问题。

hib保持迭代器开着，直到你循环访问了所有的结果，或者直到session关闭。也可以通过Hibernate.close(iterator)显示关闭它


利用数据库游标滚动
jdbc提供 可滚动的结果集(scrollable resultset)。
使用的一种情形时结果集太大而无法载入内存。通过可以尝试通过增加查询中的条件进一步限制结果。

12.2.2介绍了滚动，也讲解了如何实现处理批量数据的过程。
下面展示了ScrollableResults接口中其他值得关注的选项：
ScrollableResults cursor = s.createQuery("from Item").scroll();
cursor.first()
cursor.last()
cursor.get()
cursor.next()
cursor.scroll(3)
cursor.getRowNumber();
cursor.getRowNumber(5);
cursor.previous()
cursor.scroll(-3);
cursor.close();

可以把游标设置到结果集中的第一个和最后一个对象，
使用游标获得当前指向的Item
通过setRowNumber()跳到一个位置
previous,next前后滚动。
scroll设置偏移前后滚动。

criteria也可以使用滚动。

在终止数据库事务之前，用完游标后必须关闭它。

ScrollableResults c = s.createCriteria(Item.class).scroll(ScrollMode.FORWARD_ONLY);
hib中ScrollMode常量相当于jdbc的ScrollMode常量。这里是必须的，因为有些jdbc驱动器不支持向后滚动。
SCROLL_INSENSITIVE，不会把你公开给被修改的数据(有效地保证没有脏读取，不可重复读取，幻读)
SCROLL_SENSITIVE，灵敏的游标会把刚刚被提交的数据和修改公开给你。hib的cache依然给实体实例提供可重复读取，因此，只有你在结果集中投影的被修改的标量值会受到这项设置的影响。


使用具名查询
我们不想在java代码中看到随处分散着hql，jpa ql。
hib让你把查询字符串具体化到映射元数据，这项技术称作具名查询(named query)。它让你把与特定的持久化类或一组类相关的所有查询都保存在一个xml映射文件中。如果使用注解，可以创建具名查询作为特定实体类的元数据，或者把它们放在一个xml部署描述副中。

调用具名查询
hib中，getNamedQuery() 给具名的查询获得Query实例：
s.getNamedQuery("findItemsByDesc").setString("desc", desc);

jpa:
em.createNamedQuery("findItemsByDesc").setParameter("desc", desc);

具名查询是全局的，即 查询的名称被当作是特定sessionfactory或持久化单元的唯一标识符。


xml元数据中定义具名查询
可以把一个具名查询放在xml元数据中任何<hibernate-mapping>元素内部。在更大的应用程序中，建议把所有的具名查询隔离并分离到它们自己的文件中去。
<query>定义具名的hql或者jpa ql查询：
<query name="findItemsByDesc"><![CDATA[
    from Item item where item.desc like :desc
]]></query>

应该把查询文本包装在一个CDATA指令中，以便xml解析器不会被 查询字符串中 可能被当作xml的字符 的字符而混淆。

之前利用api设置的所有查询提示也可以通过声明设置：
<query name="findItemsByDesc" cache-mode="ignore" comment="my comment..." fetch-size="50" read-only="true" timeout="60"><![CDATA[
    from Item item where item.desc like :desc
]]></query>

具名查询不一定是hql或者jpa ql字符串，它们甚至可以是原生的sql查询---并且你的java代码也不需要知道这种差别。
<sql-query name="findItemsByDesc">
    <return alias="item" class="Item"/>
    <![CDATA[
        select {item.*} from item where desc like :desc
    ]]>
</sql-query>


利用注解定义具名查询
jpa， @NamedQuery,@NamedNativeQuery。
可以放进特定类的元数据内，也可以放进jpa xml描述符文件内。
查询名称在任何情况下都必须是全局唯一的。不会自动加上任何类或者包名作为前缀。

package auction.model;
import ...;

@NamedQueries({
    @NamedQuery(
        name="findItemsByDesc",
        quert = "select i from Item i where i.desc like :desc"
    ),...
})
@Entity
@Table(name="item")
public class Item {....}

更常见的解决方案是把查询封装在orm.xml部署描述符中：
<entity-mappings ...>
    ...
    <named-query name="findAllItems">
        <query>select i from Item i</query>
    </named-query>
    <entity class="Item">
        。。。
        <named-query name="findItemsByDesc">
            <query>
                select i from Item i where i.desc like :desc
            </query>
            <hint name="org.hibernate.comment" value="My comment"/>
            <hint name="org.hibernate.fetchSize" value="50"/>
            <hint name="org.hibernate.readOnly" value="true"/>
            <hint name="org.hibernate.timeout" value="60"/>
        </named-query>
    </entity>
</entity-mappings>

原生的sql查询,也可以在一个实体映射的内部或外部定义它们：
<named-native-query name="findItemsByDesc" result-set-mapping="myItemResult">
    <query>select i.name from item i where i.desc=:desc</query>
    <hint name="org.hibernate.timeout" value="200"/>
</named-native-query>


14.2 基本的HQL 和 JAP QL 查询

我们用 选择 来指定数据源，用 限制 来使记录与条件相匹配，并用 投影 选择想要从查询中返回的数据。

试一试：用eclipse的hibernate tools支持 Hibernate Console视图，可以在控制台窗口测试查询，并立即看到生成的sql和结果。

选择
hql最简单的查询是单个持久化类的一个选择：
from Item
生成的sql：
select i.item_id,i.name,i.desc ... from item i

利用别名
通常，使用hql，jpa ql选择一个类进行查询时，你需要分配一个别名给被查询的类，用作查询其他部分的一个引用：
from Item as item
as关键字是可选的，所以相当于 from Item item

对关键字不区分大小写。

多态查询
from BillingDetails
返回所有类型为BillingDetails的对象，它是一个抽象类。这个例子中，具体的对象属于CreditCard,BankAccount类型。

from子句中具名的类型甚至不需要一定是被映射的持久化类，任何类都可以，下面的查询返回所有的持久化对象：
from java.lang.Object

也适用于接口，下面返回所有可序列化的持久化对象：
from java.io.Seriablizable

jpa没有标准化 利用未被映射的接口的多态查询。


限制
where子句。

from User u where u.email='foo@hibernate.org'

可以在语句和提交中用单引号包括文字，hql中常见的其他文字是 true，false
from Item i where i.isActive=true
限制利用三重逻辑进行表达。where子句是一个逻辑表达式，结果是true，false，null，利用内建的比较操作符，通过把对象的属性与其他属性或者文字值进行对比，来构建逻辑表达式。

什么是三重逻辑？当且仅当where子句取值未true时，行才被包括在结果集中。java中，notnullobject==null返回false，null==null返回true。sql中，notnullcolumn=null和null=null都返回null，而不是true。这样，sql就需要一个特定的操作符is null来测试一个值是否为null。这个三重逻辑是处理表达式的一种方法，可以应用到空的列值。不要把null当作特殊的标记，而是作为普通的值处理，这是对关系模型中常见的二重逻辑的sql扩展。hql jpaql必须利用三重操作符支持这个三重逻辑。


比较表达式
hql和jpa ql支持 与sql相同的基本比较操作符。
from Bid bid where bid.amount between 1 and 10
from Bid bid where bid.amount > 10
from User u where u.email in ('foo@bar', 'bar@foo')

测试null值需要谨慎。
hql jpaql 提供了 sql风格的 is [not] null
from User u where u.email is null
from Item i where i.successfulBid is not null

like操作符允许通配符% _
from User u where u.firstname like 'G%'

也可以 否定like 操作
from User u where u.firstname not like '%Foo B%'

如果想要百分比或下划线，需要转义字符：
from User u where u.firstname like '\%Foo%' escape='\'
这个查询返回带有名字的以%Foo开头的所有用户。

hql jpa ql支持算术表达式：
from Bid bid where (bid.amount/0.71)-100.0>0.0

逻辑操作符(和用于分组的圆括号)用于组合表达式：
from User user where user.firstname like 'G%' and user.lastname like 'k%'
from User u where (u.firstname like 'G%' and u.lastname like 'k%') or u.email in ('foo@', bar@)

操作符优先级，从高到低
.       导航路径表达式操作符
+ -     正号，负号
* /     数值的一般乘除
+ -     数值的一般+-
= <> < > >= <=, [not] between, [not] like, [not] in, is [not] null      sql语义的二元比较
is [not] empty, [not] member [or]   hql，jpaql 用于集合的二元操作符
not,and,or  组合表达式


包含集合的表达式

from Item i where i.bids is not empty
返回bids集合中有元素的所有Item实例

from Item i, Category c where i.id='123' and i member of c.items
这个查询返回Item和Category实例--通常添加select子句，并只投影这2个实体类型的其中之一。它返回包含主键123的Item实例，以及与这个item实例关联的所有Category实例。

这里使用的一个技巧：.id路径，这个字段始终指向一个实体的数据库标识符，无论标识符属性名称是什么。


调用函数
hql中一项强大的特性就是where子句中调用sql函数。
如果数据库支持用户自定义函数，hql中也可以调用。

from User u where lower(u.email)='foo@'

hql jpaql支持可移植的concat函数
from User user where concat(user.firstname, user.lastname) like '%G K%'

集合大小：
from Item i where size(i.bids)>3

jpa ql标准化了常用的函数：
upper(s),lower(s)
concat(s1,s2)
substring(s,offset,length)
trim([[both|leading|trailing] char [from]] s)
length(s)
locate(search, s, offset)
abs（n）,sqrt(n),mod(dividend, divisor)
size(c)

所有标准的jpa ql函数都可以用在查询的where和having子句中。
原生的hql更灵活一点，hql的其他函数：
bit_length(s)
current_date(),current_time(),current_timestamp()
second(d),minute(d),hour(d),day(d),month(d),year(d)
cast(t as Type)
index(joinedCollection)
minelement(c),maxelement(c),minindex(c),maxindex(c),elements(c),indices(c)

。。以上的 函数 全是大写的，不清楚大小写是否区分。

这些hql函数中的大多数，转变成了你之前用过的sql配对。这个转换表可以通过org.hibernate.Dialect定制和扩展。
你可以在那里发现许多已经注册的其他sql函数，可以在hql中立即使用。但是注意：非Dislect中的函数是不可移植的。

另一种增加sql函数到hql的方法是Configuration.addSqlFunction()
Configuration cfg = new Configuration();
cfg.addSqlFunction("lpad", new StandardSQLFunction("lpad", Hibernate.String));
cfg.buildSessionFactory();

。。现在是 StandardBasicTypes.STRING 了
添加sql函数lpad到hql。


排序查询结果
hql，jpa ql 提供 order by, asc, desc

from User u order by u.username
from User u order by u.username desc
from User u order by u.lastname asc, u.firstname asc


投影
select子句在hql japql中执行投影。它允许你准确指定需要查询结果中的哪些对象或对象的哪些属性。

实体和标量值的简单投影
from Item i, Bid b
这是有效的hql，无效的jpa ql，jpa需要select。

Query q = s.createQuery("from Item i, Bid b");
// Query q = em.createQuery("select i, b from Item i, Bid b");

Iterator pairs = q.list().iterator();
// = q.getResultList().iterator();

while (pairs.hashNext()) {
    Object[] pair = (Object[]) pairs.next();
    Item item = pair[0];
    Bid bid = pair[1];
}

下列sql也返回一个Object[]的集合.0:Long, 1:String, 2:BigDecimal或MonetaryAmount,这些都是标量值，而不是实体实例，因此，它们不处于任何持久化状态，它们不是事务的，不会自动对脏状态进行检查。
select i.id, i.desc, i.initialPrice from Item i where i.endDate>current_date()


获取独特的结果
使用select时，结果的元素不再保证唯一。可以使用distinct关键字
select distinct item.desc from Item item


调用函数
对于某些sql方言来说，可以在select子句中调用sql函数。
select item.startDate, current_date() from Item item

select item.startDate, item.endDate, upper(item.name) from Item item
这个返回Object[]，包含拍卖的起始，终止日期，货品的名称全部大写。


联结，报表查询，子查询

联结关系和关联

右外联结很少使用，开发人员始终考虑从左到右，并且先放置驱动表。

hql和jpa ql联结选项
hib中，通常不显式指定联结条件，而是指定被映射的java类关联的名称。

hql,jpaql提供了4种表达联结的方式：
隐式关联联结
from子句中的普通联结
from子句中的抓取联结
where子句中的theta类型的联结

隐式关联联结
.表示2种不同的目的：
查询组件
表达隐式关联联结

第一种用法：
from User u where u.homeAddress.city='Bangkok'
这个查询种没有联结任何表，homeAddress组件属性和User数据保存在一张表中。

select中也可以编写一个路径表达式
select distince u.homeAddress.city from User u

第二种用法：
from Bid bid where bid.item.desc like 'Foo%'
从Bid到Item的多对一关联产生了一个隐式联结。hib知道Bid表中的item_id外键映射了这个关联。
隐式联结始终采用多对一或一对一关联，从来不通过集合值进行关联(无法编写item.bids.amount)。

单个路径表达式可能存在多个联结。如果Item到Category时多对一：
from Bid bid where bid.item.category.name like 'Lap%'

我们反对给复杂的查询使用这种语法糖。sql联结很重要，尤其当优化时，你需要能一眼看出有多少个联结：
from Bid bid where bid.item.category.name like 'Lap%' and bid.item.successfulBid.amount > 100
这里有多少个联结？答案是3个，sql类似：
select ... from Bid b 
inner join item i on b.item_id=i.item_id
inner join category c on i.category_id=c.category_id
inner join bid sb on i.successful_bid_id=sb.bid_id
where c.name like 'Lap%' and sb.amount>100


在from子句中表达的联结
hib需要区分 联结 的目的：
1. 你可能想要以应用到货品Bid的一些条件为基础，来限制返回的货品。如，你需要所有出价超过100的item，因而你需要一个内部联结。目前你不关注没有出价的货品
2. 你可能主要关注Item，但可能想要执行一个外部联结，只是因为想给在同一个sql语句中查询的item获取所有bid。默认情况下，延迟映射所有关联，因此，即时的外部联结抓取查询用于在运行时给特定的用例覆盖默认的抓取策略

内联结进行限制的查询：
from Item i join i.bids b where i.desc like 'Foo%' and b.amount>100

生成的sql：
select i.desc, i.initial_price ... b.bid_id, b.amount,...
from Item i
inner join Bid b on i.item_id=b.item_id
where i.desc like 'Foo%' and b.amount>100

查询以有序的配对形式返回被关联的Bid Item的所有组合
Query q = s.createQuery("from Item i join i.bids b");
Iterator pairs = q.list().iterator();
while (pairs.hasNext()) {
    Object[] pair = pairs.next();
    Item item = pair[]0;
    Bid bid = pair[]1;
}
一个特定的Item可能出现多次，每个被关联的Bid只出现一次。这些重复的货品是重复的内存引用，而不是重复的实例。

如果不想要Bids，可以在hql中指定一个select子句中使用别名
select i from Item i join i.bids b where ..
查询结果只包含Item，所以返回的是List<Item>

hql,jap ql提供另一种语法，用于在from子句中联结集合，并给它一个别名，in()操作符在更早版本的ejb ql中就出现了。它的语义和普通集合联结一样，可以化从写最后一个查询如下：
select i from Item i in(i.bids) b where i.desc like '%Foo' and b.amount>100

from Item i in(i.bids) b 生成了与之前的from Item i join i.bids b 一样的内部联结。

下面是第一种查询的变形：
from Item i left join i.bids b with b.amount>100 where i.desc like 'F%'

left join. with.
amount>100放在where之后，限制了 有价格 且 >100。
使用with的话， 没有价格的item也会返回。

jpa ql 不支持 with


利用联结的动态抓取策略
之前Item的bids是懒加载的。要修改这种情况：
1 映射元数据改称lazy="false"，会产生n+1
2 hql jpaql 动态抓取策略

hql,jap ql中可以指定被关联的实体实例或集合应该在from子句中通过fetch关键字即时抓取：
from Item i left join fetch i.bids where i.desc like 'F%'

这个查询返回所有Item，和前面的有序对不同。
抓取联结的目的再与性能优化，你使用这个语法，只是因为想要在单个sql操作中即时初始化bids集合：
select i.desc, i.initial_price... b.bid_id, b.amount...
from Item i left outer join Bid b on i.item_id=b.item_id
where i.desc like 'Foo%'

额外的with语句在这里没有意义。这里所有的Bids都要初始化。

也可以利用相同的语法预抓取多对一或一对一关联
from Bid bid left join fetch bid.item left join fetch bid.bidder where bid.amount>100
执行下列sql：
select b.bid_id,b.amount,b.item_id... i.desc,i.initial_price... u.username,u,firstname..
from Bid b
left outer join Item i on i.item_id=b.item_id
left outer join User u on u.user_id=b.bidder_id
where b.amount>100

如果你写join fetch,没有left，那么就通过一个内部联结获得了即时加载。内部联结不会返回没有出价的Item。

hql,jpaql 动态抓取很简单，但是你应该牢记下列警告：
永远不要为任何被抓取联结的关联或集合分配别名，来用于进一步限制或投影。因此left join fetch i.bids b where b=...是无效的，left join fetch i.bids b join fetch b.bidder是有效的。
。。。！！！
不应该并行抓取一个以上的集合，否则就会产生笛卡尔积。
hql，jpaql忽略你已经在映射元数据中定义的任何抓取策略。xml中fetch="join"映射bids集合，对hql jpaql不会有任何影响。动态抓取策略忽略全局的抓取策略，不会忽略全局的抓取计划---保证加载每一个非延迟的关联或集合，即使需要多个sql。
如果即时抓取一个集合，则可能返回重复。select i from Item i join fetch i.bids.如果一个item关联有多个bid，那么会返回多个item，这些item是相同的对象的不同引用。可以利用set去重。或者使用distinct，select distinct i from Item i join fetch i.bids，这个distinct不作用于sql，而是在把结果封送到对象时，过滤重复。
基于sql结果行的查询执行选项(如setMaxResults,setFirstResult的分页)，如果集合被即时抓取，那么它在语义上就是错的。如果查询中有即时抓取的集合，在编写本书时，hib会退回到内存中限制结果，而不是使用sql。这样会降低效率，所以不建议join fetch 和 setMaxResults,setFirstResult共用。如果共用，未来hib可能退回到一个不同的sql查询策略(例如2个查询和子查询抓取)


Theta类型的联结
乘积让你获取2个或多个类的实例的所有可能的组合。下面返回所有有序的User和Category对象对：
from User, Category
这通常没用，它常用于一个案例：theta类型的联结

传统sql中，theta类型的联结是一个笛卡尔积和where子句中的一个联结条件，在乘积上应用它用来限制结果。

hql,jpa ql中，当联结条件不是一个被映射到类关联的外键关系时，theta类型的语法就很有用。
如，假设在日志记录中保存了User的姓名，而不是映射一个从LogRecord到User的关联。2个类相互不知道对方的信息。可以通过下列theta类型的联结，找到所有User和他们的日志：
from User user, LogRecord log where user.username=log.username

此处的联结条件是usernamne的一个比较，在两个类中都以属性出现。
这个查询结果由有序的对组成：
Iterator i = s.createQuery("..").ist().iterator();
while (i.hasNext()) {
    Object[] pair = i.next();
    User u = pair[0];
    LogRecord log = pair[1];
}

在hql jpaql中对2张没有映射关联的表使用外部联结(theta类型的联结是内部联结)目前是不可能的。


比较标识符
如果以更面向对象的方式来考虑标识符比较，实际上就是正在比较对象引用。hql jpaql支持下列查询：
from Item i, User u where i.seller=u and u.usernaem='steve'
这个查询中，i.seller指向item表中user表的外键(seller_id)，并且user指向user表的主键(user_id)。
这个查询使用一个theta类型的联结，相当于下面的首选：
from Item i join i.seller u where u.username='steve'

另一方面，下列theta类型的联结无法被重新表达为from子句联结：
from Item i, Bid b where i.seller=b.bidder
。。这里少了User这张中间表。

你可能想把外键值和查询参数进行比较，以便从User找出所有Comment：
User u = ...
Query q = s.createQuery("from Comment c where c.fromUser = :user");
q.setEntity("user", u)'
List r = q.list();

另一种偶尔使用的方法是，你喜欢根据标识符值而不是对象引用来表达这类查询。标识符值可能被标识符属性名或特殊的属性名id引用。(只有hql保证id始终引用任何被任意命名的标识符属性，jpaql不保证)
这些查询相当于之前的查询：
from Item i, User u where i.seller.id=u.id and u.username='steve'
from Item i, Bid b where i.seller.id=b.bidder.id

可以把标识符值作为查询参数：
Long userid = ..
Query q = s.createQuery("from Comment c where c.fromUser.id=:userid");
q.setLong("userId", userId);
List r = q.list();

考虑标识符属性，在下列查询之间由很大区别：
from Bid b where b.item.id=1
from Bid b where b.item.desc like '%F'
第二个查询使用了隐式的表联结，第一个根本没有联结。



报表查询

hql，jpa ql允许你使用几个最常用于报表的sql特性。

利用统计函数投影
hql,jpaql都能用的统计函数：count(),min,max,sum,avg

查询Item条数
Long cnt = (Long) s.createQuery("select count(i) from Item i").uniqueResult();

查询所有具有successfulBid(排除空值)的Item的条数
select count(i.successfulBid) from Item i

select sum(i.successfulBid.amount) from Item i
返回BigDecimal。因为amount是BigDecimal类型。
sum()也识别BigInteger。其他属性返回Long

查询给定Item的最低，最高出价：
select min(bid.amount), max(bid.amount) from Bid bid where bid.item.id=1
返回一个BigDecimal对(保存在Object[]中)

select count(distinct i.desc) from Item i


给统计结果分组
hql,jpa ql允许group by。
select u.lastname,count(u) from User u group by u.lastname

生成的sql：
select u.last_name,count(u.user_id) from user u group by u.last_name

如果使用一个已经在from中设置的别名，生成的sql就会自动利用主键。
。。指count(u)。

平均出价金额：
select bid.item.id, avg(bid.amount) from Bid bid group by bid.item.id

统计还未出售货品的平均价格，
select bid.item.id,count(bid),avg(bid.amount)
from Bid bid
where bid.item.successfulBid is null
group by bid.item.id
这里使用了隐式的关联联结。对于from子句中的显示普通联结(不是抓取联结)，可以把它重新表达如下：
select bidItem.id,count(bid),avg(bid.amount)
from Bid bid join bid.item bidItem
where bidItem.successfulBid is null
group by bidItem.id


用having限制分组
where子句在行上执行限制，having子句在分组上执行限制。

下面统计每个以A开头的用户：
select user.lastname, count(user)
from User user
group by user.lastname having user.lastname like 'A%'
。。这种和 select lastname, count(user_id) from User where user.lastname like 'A' 哪个快？

查询未售出 且 出价超过10个 的货品
select item.id, count(bid), avg(bid.amount)
from Item item join item.bids bid
where item.successfulBid is null
group by item.id having count(bid)>10


利用动态的实例化
hql jpaql 提供了select new构造器调用。动态创建新对象，可以和聚集和分组组合起来。
如果用含有Long,Long,BigDecimal的构造器，定义个ItemBidSummary类，就可以用到如下查询：
select new ItemBidSummary(bid.item.id,count(bid),avg(bid.amount))
from Bid bid
where bid.item.successfulBid is null
group by bid.item.id

这里必须使用完全限定类名，除非类已经被导入到hql命名空间(4.3.3)。

返回的实例都是瞬时状态，无论 类是否被hbm映射。

。。没见到 select new map.


利用报表查询提升性能
对于报表查询，不是选择返回托管状态下的实体，而是选择属性或者统计值：
select user.lastname,count(user) from User user group by user.lastname
这个查询不返回持久化的实体实例，因此hib不会添加任何对象到持久化上下文，也不会关注脏对象，内存也会更快被释放。
通常情况下，这些考虑是次要的。



利用子查询
子查询是内嵌在另一个查询中的查询，一般在select，from，where子句中。

hql，jpaql支持where中的子查询。
不支持from子句中的子查询(未来可能扩展)，因为这2种ql都没有传递闭包。查询的结果可能不是表格，所以不能在from子句中重新用于选择。
select子句中的子查询也不受ql的支持，但是可以通过公式映射到属性。如8.1.3

相关的和不相关的嵌套
子查询的结果可能是单行或多行，典型的：返回单行的子查询执行聚集。下列子查询返回被一位用户出售的货品的总数量，外部查询返回出售超过10件货品的所有用户：
from User u where 10 < (
    select count(i) from u.item i where i.successfulBid is not null
)
这是一个相关子查询--从外部查询引用一个别名，下面的子查询是不相关子查询：
from Bid bid where bid.amount + 1 >= (
    select max(b.amount) from Bid b
)
这个示例中的子查询返回整个系统中最高出价，外部是返回最高出价相差一美元内的所有出价

不相关的子查询没有害处。
你应该更慎重地考虑相关子查询对性能的影响。在一个成熟的数据库中，一个简单的相关子查询的性能成本类似于一个联结的成本。


量词
如果一个子查询返回多行，它就是与量词组合了。标准sql，hql，jpa ql定义了下列量词：
all，如果对子查询的结果中所有值的比较为真，表达式就取值为true。否则false
any，如果对子查询的结果中存在值比较为真，就是true，否则false
in，针对一个子查询的结果比较一系列值，如果在结果中找到所有的值，就是true
。。翻译的什么？？？

返回所有出价都小于100的货品
from Item i where 100>all(select b.amount from i.bids b)

返回存在出价>=100的货品
from Item i where 100<=(select b.amount from i.bids b)

返回出价正好为100的货品
from Item i where 100=some(select b.amount from i.bids b)

这个也是：
from Item i where 100 in (select b.amount from i.bids b)

hql对在元素或者集合的索引上操作的子查询支持快捷语法。下列查询使用特殊的hql elements函数
List r = s.createQuery("from Category c where :item2 in elements(c.items)")
.setEntity("item2", item).list();

相当于下列hql，jpaql
List r = s.createQuery("from Category c where :item2 in (select i from c.items i)")
.setEntity("item2", item).list();

除了elements外，还提供了indices,maxelement,minelement,maxindex,minindex,size.

子查询是一种高级的技术。你应该质疑子查询的频繁使用，因为带有子查询的查询经常可以只用联结和统计来重写。但它们有时很强大并且有用。



chapter15 高级查询选项

利用条件和示例查询
Criteria, Example

critera支持多态： s.createCriteria(BillingDetails.class), 这个返回BillingDetails及其子类。
s.createCriteria(java.lang.Object.class) 返回所有持久化对象。

addOrder(Order.desc("firstname"))   排序

DetachedCriteria，不需要session就创建Criteria。之后附加到session用于执行，或者附加到另一个criteria作为子查询：
DetachedCriteria dc = DetachedCriteria.forClass(User.class).addOrder(Order.desc("lastname"));
List r = dc.getExecutebaleCriteria(session).list();


应用限制
Restrictions类给内建的Criterion类提供工厂方法。

User u = s.createCriteria(User.class).add(Restrictions.eq("email", "foo@xx")).uniqueResult();

静态导入 import static org.hib.anno.criterion.Restrictions.*;

获得Criterion的另一种方法是Property对象，这个更有用：
s.createCriteria(User.class).add(Property.forName("email").eq("f00@xx"));

可以使用. 命名一个组件的属性：
s.createCriteria(User.class).add(Restrictions.eq("homeAddress.street", "F00"));

所有一般的sql(和hql，jpa ql)比较操作符也可以通过Restrictions类使用：
Criterion restriction = Restrictions.between("amount", new BigDecimal(100), new BigDecimal(200));
s.createCriteria(Bid.class).add(restriction);

三重逻辑操作符也可用，下面返回没有电子邮件地址的所有用户：
session.createCriteria(User.class).add(Restrictions.isNotNull("email"));

使用isEmpty,isNotEmpty或者它实际大小测试集合：
s.createCriteria(Item.class).add(Restrictions.isEmpty("bids"));
s.createCriteria(Item.class).add(Restrictions.sizeGt("bids", 3));

比较2个属性：
s.createCriteria(User.class).add(Restrictions.eqProperty("firstname", "username"))

通配符可以使用% _ 或者指定MatchMode
下面的查询是一样的：
s.createCriteria(User.class).add(Restrictions.like("username","G%"));
s....add(Restrictions.like("username", "G", MatchMode.START));

MatchMode支持：START，END，ANYWHERE，EXACT

不区分大小写：Restrictions.like("username", "foo").ignoreCase()
。。只有SimpleExpression 有这个ignoreCase方法。


组合表达式和逻辑操作符

and or
disjunction, conjunction
。。disjunction可以AorBorCorD...   or只能2个，所以多个or的话，or的深度会很深。

s.createCriteria(User.class).add(Restrictions.or(Restrictions.and(Restrictions.like("firstname", "G%"), Restrictions.like("lastname", "K%")), Restrictions.in("email", emails)));

s.createCriteria().add(Restrictions.disjunction().add(Restrictions.conjunction().add( Restrictions.like("firstname", "G%")).add(Restrictions.like("lastname", "K%"))).add(Restrictions.in("email", emails)));

很难懂，jdk5的静态导入能改善可读性，但是，除非你正在凭空构建查询，否则，hql jpaql 更容易理解。


CriteriaAPI中，漏了某些操作符，如任何算术操作符都没有直接的支持。

另一个问题是函数调用，criteria只给最常见的案例(如字符串区分大小写)匹配内建函数。hql允许你在where子句中调用任意的sql函数。

criteria没有sql,hql,jpaql中的length()函数。但是可以把一个简单sql表达式添加到你的criteria
s.createCriteria(x).add(Restrictions.sqlRestriction("length({alias}.PASSWORD)<?", 5, Hibernate.INTEGER));

sql中任何表别名都要加上{alias}占位符作为前缀，它总是指向根实体所映射到的表。
这里使用了位置参数(api不支持具名参数)，并指定它的类型是Hibernate.INTEGER。

添加量词到sql where子句中：
.add(Restrictions.sqlRestriction("'100'>all(select b.amount from Bid b where b.item_id={alias}.item_id)"));

hib条件查询是可扩展的，可以把Length函数包装在自己的Criterion接口的实现中。

编写子查询
条件查询中的子查询是一个where子句查询.
下面，子查询返回用户出售货品总数，外部查询返回出售货品超过10件的所有用户：
DetachedCriteria subq = DetachedCriteria.forClass(Item.class, "i");
subq.add(Restriction.eqProperty("i.seller.id", "u.id")).add(Restrictions.isNotNull("i.successfulBid")). setProjection(Property.forName("i.id").count());

Criteria c = s.createCriteria(User.class, "u").add(Subqueries.lt(10, subq));


联结和动态抓取
hql,jpaql中的fetch == criteria 中的 FetchMode

criteria api 表达联结有2种方法，因此你有2种给限制使用别名的方法。
第一种是 Critria接口的createCriteria 方法。
List r = s.createCriteria(Item.class).add(Restrictions.like("desc", "Foo", MatchMode.ANYWHERE)).createCriteria("bids").add(Restrictions.gt("amount", new BigDecimal(99))).list();

为Item的bids创建Criteria，导致2个类的表之间的内部联结。
可以在任意一个criteria实例中调用list()而不改变查询结果。

List r = s.createCriteria(Item.class).createCriteria("seller").add(Restrictions.like("email", "%@hib.org")).list();

第二种是为被联结的实体分配一个别名：
s.createCriteria(Item.class).createAlias("bids", "b").add(Restrictions.like("desc", "%F00%")).add(Restrictions.gt("b.amount", new BigDecimal(99)));

s.createCriteria(Item.class).createAlias("seller", "s").add(Restrictions.like("s.email", %hib.org));

根实体的属性可以直接被应用，不必别名，或者利用别名this。
s.createCriteria(Item.class).createAlias("bids", "b").add(Restrictions.like("this.desc", "%Foo")).add(Restrictions.gt("b.amount", new BigDecimal(99)));
。。org.hibernate.criterion.CriteriaSpecification.ROOT_ALIAS。。这个是this，，可以新建Criteira的时候指定 根 的别名。默认就是ROOT_ALIAS.

编写本书时，只有包含了对实体的引用的被关联实体或者集合的联结(1对多和多对多),在hib中通过Criteria得到支持。
如果视图联结组件的一个集合，hib会失败，并有异常告诉你：你想要使用别名的那个属性不表示一个实体关联。我们认为在你读到本书时，这个特性已经实现了：
s.createCriteria(Item.class).createAlias("images", "img").add(Restrictions.gt("img.sizeX", 320));

另一种语法也是无效的，但你可能有兴趣尝试，它是包含点号的单值关联的一个隐式联结：
s.createCriteria(Item.class).add(Restrictions.like("seller.email", "%hib.org"));

"seller.email"字符串不是一个属性或组件的属性路径。创建一个别名或嵌套的criteria对象来联结这个实体关联。
。。。感觉是可以的啊。。


通过条件查询动态抓取
在hql，jpaql中，用join fetch操作即时填入一个集合，或者初始化一个被映射为延迟否则将被代理的对象。criteria也可以：
s.createCriteria(Item.class).setFetchMode("bids", FetchMode.JOIN).add(Restrictions.like("desc", "%Foo"));
查询Item实例，并给每个Item即时加载bids集合。

FetchMode.JOIN通过sql外部联结启用即时抓取。如果想要使用内部联结，可以强制它：
s.createCriteria(Item.class).createAlias("bids", "b", CriteriaSepcification.INNER_JOIN).setFetchMode("b", FetchMode.JOIN).add(Restrictions.like("desc", "%F00"));
。。5.2默认 JoinType.INNER_JOIN 。之前应该也是默认 内联结的。

也可以预抓取多对一和一对一关联：
s.createCriteria(Item.class).setFetchMode("bids", FetchMode.JOIN).setFetchMode("seller", FetchMode.JOIN).add(Rstrictions.like("desc", "%Foo"));

并行即时抓取不止一个集合(如bids,images)，会造成一个sql笛卡尔积，它或许比2个单独的查询更慢。
如果你给集合使用即时抓取，那么限制分页结果集也在内存中完成。

criteria的FetchMode的动态抓取 和 hql jpaql稍有不同，Criteria查询不会忽略在映射元数据中定义的全局抓取策略。如，如果利用fetch="join"或者FetchType.EAGER映射集合bids，下面查询会造成item和bid表的一个外部联结：
s.createCriteria(Item.class).add(Restrictions.like("desc", "%Foo"));

返回的Item实例初始化了它们的bids集合，并完全加载。
因而，条件查询可能返回对根实体的独特实例的重复引用，即使你没有在查询中给集合应用FetchMode.JOIN。

去重可以通过set， hql japql可以通过distinct。 criteria中需要使用ResutlTransformer。

默认情况下，所有的条件查询都只返回根实体的实例：
List r = s.createCriteria(Item.class).setFetchMode("bids", FetchMode.JOIN).setResultTransformer(Criteria.ROOT_ENTITY).list();
Set distinct = new LinkedHashSet(r);

ROOT_ENTITY是默认设置。上面的criteria无论是否使用setResultTransformer(Criteria.ROOT_ENTITY)，都返回相同的结果，返回所有的Item实例并初始化它们的bids集合，可能包含重复Item的引用。

可以换一种转换器
List distinct = s.createCriteria(Item.class).setFetchMode("bids", FetchMode.JOIN),setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY).list();
现在hib返回结果之前，过滤掉重复的根实体引用。

如果想在联结查询中获取有别名的实体，结果转换器也很有用：
Criteria c = s.createCriteria(Item.class).createAlias("bids", "b").createAlias("seller", "s").setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
List r = c.list();
for (Object re : result) {
    Map map = re;
    Item item = map.get(Criteria.ROOT_ALIAS);
    Bid bid = map.get("b");
    User u = map.get("s");
}

hql和 原生sql查询也支持ResultTransformer:
Query q = s.createQuery("select iid as itemid, i.desc as desc, i.initialPrice as price from Item i");
q.setResultTransformer(Transformers.aliasToBean(ItemDTO.class));
这个查询现在会返回ItemDTO的一个集合。


投影和报表查询

简单的投影列表
下面查询只返回正在拍卖中的item的标识符值：
s.createCriteria(Item.class).add(Restrictions.gt("endDate", new Date())).setProjection(Projections.id());

setProjection()方法，接受任何单个的被投影的属性，或者接受要包括在结果中的几个属性的一个列表：
s.createCriteria(Item.class).setProjection(Projections.projectionList().add(Projection.id()). add(Projrctions.property("desc")).add(Projections.property("initialPrice")));
返回一个List<Object[]>，

另一种给投影指定属性的方法是Property类：
s.createC(Item.class).setProjection(Projections.projectionList().add(Property.forName("id")). add(Property.forName("desc")).add(Property.forName("initialPrice")));


hql，jpaql 可以通过select new 动态实例化。 criteria通过ResultTransformer完成相同的工作(事实上，它更灵活)：
s.createC(Item.class).setProjection(Projextions.projextionList().add(Projections.id().as("itemId")). add(Projections.property("desc").as("itemDesc")).add(Projections.property("initialPrice"). as("itemPrice"))).setResultTransformer(new AliasToBeanResultTransformer(ItemPriceSummary.class));

ItemPriceSummary是简单java bean，包含itemId，itemDesc,itemPrice 公共字段。
它不一定是被映射的持久化类。
as()，和sql 的as 一样，是起别名。


统计和分组
计算行数：
s.createC(Item).setProjection(Projections.rowCount());

另一种获得总数的方法是：scroll()，然后cursor调用last和getRowNumber来跳到并得到最后一行的行数，这个值+1就是对象数量。


更复杂的统计则使用统计函数，下面查询查找出价的数量，并且平均每位用户所进行的出价总金额：
s.createC(Bid.class).createAlias("bidder", "u").setProjection(Projections.projectionList(). add(Property.forName("u.id").group()). add(Property.forName("u.username").group()).add(Property.forName("id").couint()). add(Property.forName("amount").avg()));

这个查询返回包含4个字段的Object[]的一个集合：用户id，登录名，出价数，平均出价金额。现在可以再次给动态的实例化使用结果转换器，并返回数据转换器对象，而不是object[]
产生相同结果的另一种方法如下：
s.createC(Bid.class).createAlias("bidder", "u").setProjection(Projections.projectionList(). add(Projections.groupProperty("u.id")). add(Projections.groupProperty("u.username")).add(Projections.count("id")). add(Projections.avg("amount")));

更复杂的示例，把别名应用到被统计，被分组的属性，用于给结果排序：
s.createC(Bid.class).createAlias("bidder", "u").setProjections(Projections.projectionList().add(Projections.groupProperty("u.id")). add(Projections.groupProperty("u.username").as("uname")).add(Projections.count("id")). add(Projections.avg("amount"))).addOrder(Order.asc("uname"));

编写时，暂时没有 对having的支持 和 对被统计结果的限制，未来或许会添加。
。。好像没有。


利用sql 投影

sql投影是被添加到生成的sql select子句的一个任意片段，下列查询产生统计和分组，并增加一个货品的数量到结果中
String sqlFragment = "(select count(*) from item i where i.item_id=item_id) as numOfItems";
s.createC(Bid.class).createAlias("bidder", "u").setProjection(Projections.projectionList(). add(Projections.groupProperty("u.id")). add(Projections.groupProperty("u.username")).add(Projections.count("id")). add(Projections.avg("amount")).add(Projections.sqlProjection(sqlFragment, new String[] {"numOfItems"}, new Type[] {Hibernate.LONG})));

生成的sql如下：
select u.user_id,u.username,count(bid_id),avg(bid_amount),(select count(*) from item i where i.item_id=item_id) as numOfItems from Bid inner join Users u on bidder_id=u.user_id group by u.user_id, u.username


按示例查询

Restrictions.ilike("firstname", firstname, MatchMode.ANYWHERE)
ilike不区分大小写。

Example exUser = Example.create(u).ignoreCase().enableLike(MatchMode.ANYWHERE). excludeProperty("password");
return getSession().createCriteria(User.class).add(exUser).list();

ignoreCase()为所有字符串值属性把实例查询放进一个不区分大小写的模式中。
enableLike,指定sql like操作符应该用于所有字符串属性，并指定MatchMode。
excludeProperty() 从搜索中排除特定的属性。默认情况下，所有属性，除了标识符属性，都在比较式中。

Example查询最好的方面是，Example只是一个一般的Criterion，可以混合和匹配按实例查询和按条件查询

下面限制搜索结果为包含未出售Items的用户。
public List findUserByEx(User u) {
    Example ex = Example.create(u).ignoreCase().enableLike(MatchMode.ANYWHERE);
    return getSession().createCriteria(User.class).add(ex).createCriteria("items"). add(Restrictions.isNull("successfulBid")).list();
}

更好的是，可以在同一个搜索中组合User属性和Item属性：
public List findByxxx(User u, Item i) {
    Example exu = Example.create(u).ignoreCase().enableLike(MatchMode.ANYWHERE);
    Example exi = Example.create(i).ignoreCase.enableLike(anywhere);

    return getS().createCriteria(User.class).add(exu).createCriteria("items").add(exi).list();
}


利用原生的sql查询
如果需要使用原始的sql提示，就需要回退到 手工sql。
或者你扩展内建的查询机制，但hql,jpaql更难实现，criteria比较容易扩展(Criterion)。

自动的结果集处理
利用hib执行 sql的最大好处在于，自动把表格式的结果集封送到业务对象中。
List r = s.createSQLQuery("select * from category").addEntity(Category.class).list();
。。addEntity。。。这个能 add一个 非持久化的类吗？

更复杂的查询需要显式投影，而不是select * ：
s.createSQLQ("select {i.*} from ITEM i join users u on i.seller_id=u.user_id where u.username=:user").addEntity("i", Item.class).setParameter("uname", "john");

即时抓取被关联的对象和集合：
s.createSQLQ("select {i.*}, {u.*} from ITEM i join users u on i.seller_id=u.user_id where u.username=:uname").addEntity("i", Item.class).addJoin("u", "i.seller").setParameter("uname", "john");

addJoin()告诉hib，别名u是指可以用来立即填充每个item的seller的列。


获取标量值

List r = s.createSQLQuery("select * from ITEM").list();
r是Object[]组成的List。
hib的一个好处是它抛出 非受检异常，因此不需要try catch。

如果没有使用 * 投影每件东西，就需要告诉hib你想要从结果中返回哪些标量值：
s.createSQLQuery("select u.firstname as fname from users u").addScalar("fname");
。。不知道大小写fname是否需要一致，不过sql应该大小写无关吧。不加addScalar是不是返回全部？还是报错？

显示指定类型，返回Rating对象的集合
Properties params = new Properties();
params.put("enumClassname", "auction.model.Rating");
s.createSQLQuery("select c.rating as rating from comments c where c.from_user_id=:uid"). addScalar("rating", Hibernate.custom(StringEnumUserType.class, params)). setParameter("uid", 123);

可以在一个原生sql中混合标量结果和实体对象：
s.createSQLQ("select {i.*},u.firstname as fname from item i join users u on i.seller_id=u.user_id where u.username=:uname").addEntity("i", Item.class).addScalar("fname").setParameter("uname", "john");
这个查询结果是List<Object[]>，每个数组有2个元素，Item实例和字符串。


jpa中的原生sql
EntityManager.createNativeQuery()。原生的sql查询可以返回实体，标量值，或者2者混合。
不同于hib，jpa中api利用映射元数据来定义结果集处理：
简单sql查询不需要显示的结果集映射：
em.createNativeQuery("select * from category", Category.class);
结果集被自动封送到Category实例的一个集合。
列在结果集中 按名称搜索。你可能必须在sql中使用别名，返回与定义在实体映射元数据中相同的列名。

如果返回多个实体类型或标量类型，就需要应用显式的结果集映射。
下面的查询返回Object[]集合，数组的第0个元素是Item实例，第1个元素是User实例。
em.createNativeQuery("select i.item_id, i.item_price, u.username, u.email form item i join users u where i.seller_id=u.user_id", "ItemSellerResult");
最后一个参数ItemSellerResult，是定义在元数据中的一个结果映射的名称(在类或全局jpa xml中):
@SqlResultSetMappings({
    @SqlResultSetMapping(
        name="ItemSellerResult",
        entities = {
            @EntityResult(entityClass=auction.xxx.Item.class),
            @EntityResult(entityClass=acu...User.class)
        }
    )
})
这个结果集映射可能对于介绍的例子不起作用---自动映射需要：实例化Item和User对象所需的所有列都必须在sql查询中返回，这个容易解决。
真正的问题是，结果集中的列名，它们与被映射列的名称不匹配，首先，把别名添加到sql：
em.createNativeQ("select i.item_id as item_id, i.item_price as item_price, u.username as user_name, u.email as user_email from item i join users u on i.seller_id=u.user_ud", "ItemSellerResult");

接下来，在结果集映射中使用@FieldResult,来把别名映射到实体实例的字段：
@SqlResultSetMappings({
    @SqlResultSetMapping(
        name="ItemSellerResult",
        entities = {
            @EntityResult(entityClass=auction.xxx.Item.class,
                fields={@FieldResult(name="id",column="item_id"),
                        @FieldResult(name="initialPrice", column="item_price")}),
            @EntityResult(entityClass=acu...User.class,
                fields={@FieldResult(name="username", column="user_name"),
                        @FieldResult(name="email", column="user_email")})
        }
    )
})

也可以返回标量类型结果，下面查询返回拍卖货品标识符和每件货品的出价数量：
em.createNativeQuery("select i.item_id as item_id, count(b.*) as num_of_bids from Item i join bids b on i.item_id=b.item_id group by item_id", "ItemBidResult");

@SqlResultSetMapping(
name="ItemBidResult",
columns = {
    @ColumnResult(name="Item_ID"),
    @ColumnResult(name="NUM_OF_BIDS")
})

返回List<Object[]>，一个数组2个元素，都是数字类型(最可能long)。
如果要混合实体和标量类型，就需要在@SqlResultSetMapping中组合entities和columns属性。

jpa不要求原生sql支持具名参数绑定。


过滤集合

你有一个Item，希望按创建时间查询处该货品的所有出价：
s.createQuery("from Bid b where b.item=:givenItem + order by b.created asc"). setEntity("givenItem", item);
出价和货品是双向关联的，这个查询有效，也没有任何联结，b.item指向bid表的item_id列。

想象这个关联是单向的，Item有bids集合。但bid没有item属性。下面的查询：
select b from Item join i.bids b where i=:givenItem order by b.amount asc
这个查询效率很低，它使用了一个完全没有必要的联结。
更好的解决方案是使用集合过滤器---可以应用到持久化集合(或数组)的一种特殊查询。它常用于进一步限制或排序 结果。

List filterCol = s.createFilter(item.getBids(), "order by this.created asc").list();
在一个 已经加载的Item 和 它的bids中应用它。
这个过滤器相当于上上个查询。
session.createFilter()用了2个参数：一个持久化的集合(不一定要被初始化)和一个hql查询字符串。集合过滤器查询有一个隐式的from子句和一个隐式的where条件。别名this暗指bids集合的元素。

hib集合过滤器不是在内存中执行的。bids可能没有被初始化，调用后createFilter后还是不会初始化。
不要把过滤器应用到瞬时的集合或者查询结果。它们只能应用到当前被添加到hib持久化上下文的一个实体实例引用的持久化集合。

hql查询唯一需要的子句是from子句。集合过滤器隐含了一个from子句，所以它能执行：
List r = s.createFilter(item.getBids(), "").list();

这个过滤器很有用，它可以用来给集合元素进行分页：
List r = s.createFilter(item.getBids(), "").setFirstResult(50).setMaxResult(100).list();

不过，分页查询通常都会使用order by.

集合过滤器不需要from子句。但如果你喜欢，你也可以放一个。集合过滤器甚至不需要返回正被过滤的集合的元素，下面查询返回任何与指定集合中的一个类别同名的Category：
String filterstr = "select other from Category other where this.name=other.name";
List r = s.createFilter(cate.getChildCategories(), filterstr).list();

下面查询返回对货品有出价的Users的一个集合：
List r = s.createFilter(item.getBids(), "select this.bidder").list();
。。会自动判断 string应该在前面还是后面。。

返回这些用户的所有出价：
List r = s.createFilter(item.getBids(), "select elements(this.bidder.bids)").list();

elements函数的hql的，用来投影一个集合的所有元素。

集合过滤器存在的最重要的原因是：允许应用程序获取集合的一些元素，而不需要初始化整个集合。
下面查询获取一位用户在过去一周所做的所有出价：
List r = s.createFilter(user.getBids(), "where this.created>:timeago").setTimestamp("timeago", oneweakago).list();
这里没有初始化User的bids集合。


高速缓存查询结果
查询结果在默认情况下没有被高速缓存。
hql，jpaql,sql,criteria 查询都先命中数据库。

启用查询结果高速缓存
hibernate.cache.use_query_cache = true
还不够，默认情况下，所有查询都始终忽略cache，下面启用cache：
Query q = s.createQuery("from Category c where c.name=:name");
q.setString("name", name2);
q.setCachable(true);

setCacheable()启用结果高速缓存。criteria也有这个方法。

如果要给javax.persistence.Query启用结果cache，就使用setHint("org.hibernate.cachable", true);

理解查询高速缓存
当查询被第一次执行时，它的结果被cache在cache区域，这个区域不同于你可能已经配置的任何其他实体或集合的cache区域。这个区域的默认名称是org.hibernate.cache.QueryCache。
setCacheRegion()可以给一个特定查询改变cache区域：
Query q = s.createQuery("from Category c where c.name=:name");
q.setString("name", categoryName);
q.setCachable(true);
q.setCacheRegion("my.region");
这几乎没有必要，你只在需要一个不同的区域配置时，才会给某些查询使用不同的cache区域---如，在一个更细粒度的级别上限制查询高速缓存的内存消耗。

标准的查询结果cache区域保存着sql语句(包括绑定的参数)和每个sql语句的结果集。但，这不是完整的sql结果集。如果结果集包含实体实例，那么只有标识符值被保存在结果高速缓存中。当结果集被放入cache区域时，每个实体的数据列就被丢弃了。因此，命中查询结果cache意味着，hib找到一些Category标识符值。

cache实体的状态，是二级cache区域auction.model.Category的责任。这类似于iterator()的查询策略。
换句话说，如果你查询实体，并决定启用cache，你就要确保这些实体启用了二级cache。如果没有，可能在启用查询cache之后，导致更多的数据库命中。

如果cache了不返回实体实例而只返回相同标量值(如货品名称和价格)的查询结果，这些值就被直接保存在查询结果cache中。

如果查询结果cache在hib中被启用，另一个始终需要的cache区域也出现了：org.hibernate.cache.UpdateTimestampsCache。这是hib内部使用的一个cache区域。

用时间戳区域来决定被cache的查询结果集是否有效。当你重新执行一个启用了cache的查询时，hib就在时间戳cache中寻找对被查询的(几张)表所做的最近的插入，更新，删除的时间戳。如果找到的时间戳万余cache查询结果的时间戳，cache结果就被丢弃，并产生一个新的查询。
为了得到最佳结果，你应该配置时间戳区域，以便表的更新时间戳不会超出高速缓存期。最容易的方法是在二级cache提供程序的配置中，关闭时间戳高速cache区域的过期时限。


什么时候使用查询高速缓存
大多数查询都没有从结果cache中受益。有2个原因：
1. 短时间内重复执行同一个查询的情况很罕见
2. 对于执行许多查询，少量插入，删除，更新的应用程序来说，cache查询可以提升性能和可伸缩性。如果程序执行许多写入操作，查询cache就没有得到有效的利用。

对于许多查询来说，查询结果cache的好处是没有的。
有一种特殊的查询可以从结果cache中获得巨大受益。

自然标识符高速缓存查找
假设你有一个包含自然键的实体。不讨论自然主键，而是讨论应用到你实体的单个或复合属性的业务键。如，如果用户的登录名称不可变，那么它可以是唯一的业务键。这是我们已经隔离作为好的equals对象等同性子程序实现的最好的键。
通常要把构成自然键的属性映射为hib中的常规属性。可以在数据库级启用一个unique约束来表示这个键。

User类，考虑username和emailAddress构成实体的业务键：
<class name="User">
    <id name="id".../>
    <property name="username" unique-key="unq_userkey"/>
    <property name="emailAddress" unique-key="unq_userkey"/>
</class>
这个映射在2列的数据库级别上启用了一个唯一键约束。也假设业务键属性是不可变的(虽然，你可能会允许用户更新email)
但，现在介绍的这项功能只有当你处理不可变得分业务键时才有意义，映射不可变性如下：
<class name="User">
    <id name="id".../>
    <property name="username" unique-key="unq_userkey" update="false"/>
    <property name="emailAddress" unique-key="unq_userkey" update="false"/>
</class>
或通过业务键利用高速缓存查找，可以用<natural-id>映射它：
<class name="User">
    <id name="id".../>
    <cache usage="read-write"/>
    <natural-id mutable="false">
        <property name="username"/>
        <property name="emailAddress"/>
    </natural-id>
</class>
这个分组自动启用跨越所有被组合属性的唯一键sql约束的生成。mutable="false"也防止了被映射列的更新。

现在可以给cache查找 使用这个业务键：
Criteria c = s.createCriteria(User.class);
c.add(Restrictions.naturalId().set("username","john").set("emailAddress","jj@hib.org"));
c.setCachable(true);
User u = c.uniqueResult();

这个条件查询更具业务键找到一个特定的用户对象。它通过业务键导致一个二级cache查找---这通常是一个通过主键的查找，并且可能只用于按主标识符的获取。业务键映射和criteria允许你通过业务键表达这个特殊的二级cache查找。

编写本书时，没有自然标识符的映射的注解，hql也不支持通过业务键查找。

二级擦车是一项重要的特性，但它不是优化性能时的首选方案。
查询设计中的错误，或者对象模型中没有必要的复杂部分，都无法通过一个"全部cache"的方法得到改进。
如果应用只用一个热cache(即几小时或几天的运行时值后的完整cache)就能获得可接受的运行速度，那么就应该查找出严重的设计错误，损害性能的查询，n+1查询等问题



chapter 16 创建和测试分层的应用程序


548
泛型DAO。
interface                       --      class
GenericDAO<T, ID>               --      GenericDAOHibernate
ItemDAO<Item, Long>             --      ItemDAOHibernate
CategoryDAO<Category, Long>     --      CategoryDAOHibernate

553
DAOFactory
但不是单例的。使用clazz.newInstance();。由于它只需要SessionFactory，所以内部没有属性的。sf靠Util类的单例提供。

556-558
命令模式 BidForItemCommand
Command需要DAO，所以顶层保存DAOFactory变量，setDAOFactory方法。子类通过DAOFactory获得dao，进行处理。
Handler,保存DAOFactory，如果类 instanceof xx，调用setDAOFactory()。然后execute


566
TestNG, cenqua clover
。。现在覆盖率好像jacoco很强


575
性能：基于程序的请求/响应的反应时间
可伸缩性：系统在更高的负载下合理执行的能力。系统可伸缩性越好，就可以在它上面绑定越多的并发用户，而不会降低性能。


chapter 17 JBoss Seam
应该已经放弃了，最后更新是2015年。

JSF java server face

。。jsf类似于struts，spring mvc..所以 ...


610，616 hibernate Validator

@Length,@Pattern

@Entity
@Table(name="USERS")
public class User implements Serializable {
    @Id @GeneratedValue
    @Column(name="USER_ID")
    private Long id = null;

    @Column(name="USERNAME", nullable=false, unique=true)
    @org.hib.validator.Length(
        min=3,max=16,message="Minimun {min}, maximum {max} characters."
    )
    @org.hibernate.vali.Pattern(
        regex="^\\w*$",message="Invalid username!"
    )
    private String username;

    @Column(name="`PASSWORD`", length=12, nullable=false)
    private String password;
    
    ...
}







633 笛卡尔积,2张表所有可能的组合。。不是外联结，外联结有限制的。。有限制的笛卡尔积
select * from Item i, Bid b

联结经常改为以theta风格来表示，from的乘积和where中的联结条件。
select * from item i, bid b where i.item_id=b.item_id


group by   having   order by


















