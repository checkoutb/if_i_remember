Linux_CPP
2023年4月12日
20:55

linux programmer's manual

===============

===============

https://blog.csdn.net/m0_68931081/article/details/128557825
进程地址空间

C++动态内存空间，习惯把地址分为几个区域：

|     |     |
| --- | --- |
| 内核空间， | 用户代码无法读写 |
| 栈区， | 向下增长 |
| 。中间 | 保存  内存映射(文件映射，动态库) |
| 堆区， | 向上增长 |
| 静态区/常量区， | 静态数据，全局变量 |
| 代码区， | 可执行代码/只读常量 |

但这并不是真正的地址空间

。代码  ctmf/AAAtest

``` C++
int global_val = 100;

void create_sub_process()
{
	pid_t id = fork();    // 新建子进程。

	if (id < 0)
	{
		printf("fork error\n");
		return 1;
	}
	else if (id == 0)
	{
		int cnt = 0;
		while (1)
		{
			printf("I am sub-process, pid: %d, ppid: %d | global_val: %d, &global_val: %p\n",
					getpid(), getppid(), global_val, &global_val);
			sleep(1);
			++cnt;
			if (cnt == 10)
			{
				global_val = 300;
				print("sub-process has changed gloval_val");
			}
		}
	}
	else
	{
		while (1)
		{
			print("I am parent-process, pid: %d, ppid: %d | global_val: %d, &global_val: %p\n",
					getpid(), getppid(), global_val, &global_val);
			sleep(2);
		}
	}
}
```

可以看到，子进程把全局变量修改后，子进程和父进程的值是不同的。
这是合理的，因为<font color="#dddd00">**进程之间具有独立性**</font>。
但是这里，global_val  的地址是相同的。  多进程  在读取  同一个地址的时候  怎么会出现  不同的结果呢？
地址相同说明这里的地址  绝对不是  对应的物理地址，也就是说指针，不是对应物理地址。
这里的地址是  虚拟地址(线性地址)，也可以称为  逻辑地址。
$\color{yellow}{物理地址，由OS管理，OS负责将虚拟地址转化为物理地址}$

。。fork()  是新建进程吗？
。。确实，百度了下，应该是  逻辑地址，逻辑地址和真正的物理地址  是OS进行映射的。
。"windows的32位系统对每一个用户进程都管理着一个寻址范围为4GB的地址空间,  各个进程的地址空间是相互独立的,很显然这是一个逻辑的地址空间"

。。我一直认为，32位  超过4g浪费  是因为  物理地址。  那这么说的话5g内存也可以啊。1g用来给  OS。  就是  这4g  是4g全部归我管(即，内存条可能要5g，1g是给OS的)，不是   要切分给OS的那种。

进程会认为自己是独占系统资源的，实际上并不是。

实际上，OS会给每个  进程  创建一个  独立的虚拟地址空间，然后通过页表将虚拟地址空间与物理内存一一对应(映射)，我们用户只能得到  虚拟地址空间中的虚拟地址，当我们修改虚拟地址中的数据时，OS  会先通过  页表找到对应的物理内存，然后修改物理内存中的数据。

父进程  和子进程  都有自己独立的  进程地址空间，且都有自己的页表结构，子进程由父进程创建，所以  <mark>子进程的地址空间是  从父进程拷贝而来</mark>，  刚开始时，2个global_val  是指向同一个  物理内存。  子进程修改  自己  地址空间中的  global_val时，OS  通过页表映射发现  global_val  的值是共享的，  由于  进程具有独立性，所以  OS  为了保证  进程的独立性，当  子进程  或  父进程  任意一方  尝试对  共享数据进行写入，那么OS  会在物理内存上  重新开辟一块  新的内存空间，拷贝数据，然后修改  映射关系，不再指向老的变量，在整个修改的过程中，和父子进程的虚拟地址没有任何关系，只是底层经过页表映射到不同的区域，所以我们看到地址一样，但是值不一样。

写时拷贝：指父子进程在上述情况下任何一方尝试写入，操作系统先进行数据拷贝，更改页表映射，然后再让进程进行修改的过程称为写时拷贝。

进程地址空间上的地址从全0到全1按照正常的方式排列，所以是连续的地址，所以这个地址空间也被称为线性地址；对于磁盘程序内部的地址称为逻辑地址，在Linux下，虚拟地址到线性地址、逻辑地址是一样的，但在其他地方，区分比较明确。

进程地址空间的管理
OS如何管理进程地址空间

OS会为系统中的每一个进程都创建一个地址空间，但是OS中同时存在很多个许多进程，那么就需要创建很多给地址空间，所以为了保证各个进程正常运行，OS  需要对每个进程的地址空间进行管理。

而管理的本质是先描述，在组织，所以和管理进程一样，操作系统会使用一种内核数据结构来对地址空间进行管理，Linux中用于  管理地址空间的内核数据结构叫做  mm_struct，操作系统会为每个进程创建一个  mm_struct  对象，然后通过管理结构体对象来间接管理进程地址空间。

图。linux-2.6.32.26/include/linux/sched.h  的  task_struct  中有  mm_struct  结构体的  指针。

图。linux-2.6.32.26/include/linux/mm_types.h  中定义了  mm_structs  结构体

所以进程地址空间也是进程的属性，我们可以通过进程的  task_struct  来找到/管理进程对应的地址空间。

区域划分和调整

进程地址空间被划分为很多个区域，例如栈区、堆区、数据区、代码段。那进程地址空间是如何进行区域划分和区域调整的：把一个区域的end和start进行调整和维护内存区域

struct mm_struct{
//uint32_t:32位系统下的无符号整型
    uint32_t code_start,code_end;
    uint32_t data_start,data_end;
    uint32_t heap_start,heap_end;
    uint32_t stack_start,stack_end;
}

所谓的区域调整，本质就是修改各个区域的end或start.
。。不知道这个  code_start  是  大约意思一下，还是真的这名字。感觉是意思一下。。

为什么存在进程地址空间
进程地址空间保证了数据的安全性

每个进程都有进程地址空间，所有的进程都要通过页表映射到物理内存，如果进程直接访问物理内存，万一进程越界非法访问、非法读写时，页表就可以进行拦截，而且直接访问物理内存对于账号信息是非常不安全的，所以保证了内存数据的安全性。

地址空间的存在，可以更方便的进行进程和进程的数据代码的解耦，保证了进程独立性的特征

对于进程而言，都有独立的地址空间及页表，通过页表映射到不同的物理内存上，所以一个进程数据的改变不会影响到另一个进程，保证了进程的独立性，而对于上面我们所说的父进程和子进程而言，子进程的地址空间从父进程拷贝，页表都指向同一块物理内存，但是即使此时的数据是共享的，在修改数据的时候也会发生我们所说的写时拷贝，保证了进程的独立性。

让进程以统一的视角，看待进程对应的代码和数据各个区域，方便编译器也以统一的视角来进行编译代码

可执行程序被编译器编译的时候每个代码和数据在内存中已经有虚拟地址了（在磁盘上称为逻辑地址），也就是说，地址空间对于操作系统和编译器都是遵守的。所以当程序被加载到内存成为进程后，每个变量/函数都具备了物理地址。

所以我们现在有两套地址：
1.标识物理内存中代码和数据的地址

2.在程序内部互相跳转的时候的虚拟地址加载完成之后，代码的各个区域的地址已经知道。进程被调度时，CPU拿到虚拟地址，经过地址空间查页表通过映射，进行访问查到物理地址往后执行。也就是CPU通过了虚拟地址——页表映射——物理地址执行。也就是在整个CPU运行过程中,CPU并没有见到物理地址，用的都是虚拟地址。

每个进程都有自己独立的内核数据结构和其对应的代码和数据。
进程=内核数据结构+进程对应的代码和数据
![在这里插入图片描述](../_resources/a88bf0bb5efd4c69aee4f806948cd554.png)

其中我们熟悉的全局数据区，代码段，栈区，堆区以及共享区，再加上一个命令行参数环境变量所占用的进程地址空间统称用户空间，在32位操作系统下，这部分空间占总空间的3/4，即3G；剩下的1G属于内核空间。

--------------------

https://blog.csdn.net/m0_68931081/article/details/127716934

操作系统及进程概念

操作系统是一个进行软硬件资源管理的软件，操作系统包含了进程管理，文件管理，内存管理，驱动管理。
任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)。笼统的理解，操作系统包括：
    内核（进程管理，内存管理，文件管理，驱动管理）
    其他程序（例如函数库， shell程序等等）

所有的管理，本质是对数据做管理，管理的方法是先描述在组织
1.描述起来，用struct结构体或者类
2.组织起来，用链表或其他高效的数据结构

进程控制块PCB（process control block）
Linux操作系统下的PCB是: task_struct

进程  =  内核数据结构(task_struct) +  进程对应的磁盘代码

    task_ struct内容分类
        标示符: 描述本进程的唯一标示符，用来区别其他进程。
        状态: 任务状态，退出代码，退出信号等。
        优先级: 相对于其他进程的优先级。
        程序计数器: 程序中即将被执行的下一条指令的地址。
        内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
        上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。
        I／ O状态信息: 包括显示的I/O请求,分配给进程的I／ O设备和被进程使用的文件列表。
        记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
        其他信息

进程的信息可以通过  /proc  系统文件夹查看

getpid
getppid
fork

在fork之后，又创建了一个进程，两个进程分别在两个执行流中，因此可以分别执行if  和  else if，也可以分别进入while循环！

总结一句话，fork()之后，会有父进程+子进程两个进程在执行后续代码，fork()后续的代码，被父子进程共享，通过返回值不同，让父子进程执行共享代码的一部分，这就是并发式编程。

---------------------

https://blog.csdn.net/m0_68931081/article/details/128234469

进程状态、优先级和进程切换

进程状态可能有如下几种：运行、挂起、阻塞、新建、就绪、等待、挂机、死亡。

CPU在内核上维护了一个运行队列，进行对进程的管理。让进程入队列，本质就是将该进程的task_struct  结构体对象放入运行队列之中。
一个CPU就一个运行队列

运行状态
进程PCB在运行队列里就是运行状态，不是说这个进程正在运行，才是运行状态。

阻塞状态
进程不在运行队列之中，进程不能直接被调度，而是在等待外设资源的状态，进程的PCB就被放在硬件的等待队列中。本质是对tack_struct对象放到不同的队列中！
综上，所谓的进程不同的状态，本质是进程在不同的队列之中，等待某种资源

挂起状态

如果系统中存在许多进程，进程短期内不会被调度，代码和数据在短期内不会被执行，此时如果内存空间不足，操作系统就可以把代码和数据暂时保存到磁盘上，节省一部分空间，该进程暂时被挂起了，这就是挂起状态。

对于阻塞状态和挂起状态，阻塞不一定挂起，挂起一定是阻塞。

进程状态改变的本质是进程对应的  PCB (task_struct  对象)  处于不同设备的运行队列/等待队列中。

kernel源代码里
/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};

|     |     |
| --- | --- |
| R运行状态（running） : | 并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里。 |
| S睡眠状态（sleeping): | 意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠（interruptible sleep））。 |
| D磁盘休眠状态（Disk sleep） | 有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待IO的结束。 |
| T停止状态（stopped）： | 可以通过发送 SIGSTOP 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。 |
| X死亡状态（dead）： | 这个状态只是一个返回状态，你不会在任务列表里看到这个状态。 |
| z僵尸状态（zombie）： | 这个状态是一个已经运行完的子进程等待父进程回收它的返回信息。 |

![在这里插入图片描述](../_resources/6c6bdb392fa34a3a83c4206eab1bb416.png)

查看各种状态
ps aux / ps axj //命令

进程退出了，但退出信息没有父进程或者OS被回收，那么此时该进程就处于僵尸进程。

父进程先退出，子进程就称之为“孤儿进程”

状态后面带’+‘表示是前台进程，状态后面不带’+'是后台进程。
前台进程不能解释命令，但是可以用ctrl+c终止该进程
后台进程能解释命令，但不可以用ctrl+c终止该进程，用kill -9 进程PID来终止进程。

进程优先级
用ps  –l/ps -al命令则会类似输出以下几个内容
UID : 代表执行者的身份
PID : 代表这个进程的代号
PPID ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号
PRI ：代表这个进程可被执行的优先级，其值越小越早被执行
NI ：代表这个进程的nice值

Linux中由两个整型数字决定优先级:PRI（priority）和NI（nice）
最终优先级 = 老的优先级（PRI）+ NI（nice)

老的优先级PRI默认值是80！而NI取值是有范围，取值范围是[-20,19]

进入top后输入r然后在输入进程的pid(进入进程)输入要修改nice的值

-------------------

https://blog.csdn.net/m0_68931081/article/details/128547631

环境变量

环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性

常见的环境变量
    PATH : 指定命令的搜索路径
    HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
    SHELL : 当前Shell,它的值通常是/bin/bash
    LOGNAME:当前登录的用户名
    HOSTNAME：主机名

。echo &HOSTNAME

env  命令  (用于查看当前机器能用的所有环境变量)

通过代码来获取环境变量
getenv

std::cout << std::getenv("PATH") << std::endl;

// win10，  VS：
char* s;
size_t len;
errno_t err = _dupenv_s(&s, &len, "PATH");
if (err)
{
std::cout << " ??? " << std::endl;
return;
}
std::cout << s << std::endl;
std::cout << len << std::endl;

//extern char** env;                // unistd.h

int main(int argc, char* argv[], char* env[])
{
for (int i = 0; env[i]; ++i)
{
std::cout << env[i] << std::endl;                // cooooool
}
}

// 'putenv': The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _putenv. See online help for details.

//putenv("test=test1");

//char* cs = std::getenv("test");                // 这个始终是null，所以 _putenv 是临时的。
//if (cs == nullptr)
//{
//        std::cout << " no test" << std::endl;
//}
//else
//        std::cout << cs << std::endl;
//_putenv("test=test0034");
//std::cout << std::getenv("Test") << std::endl;

---------------------

https://blog.csdn.net/m0_68931081/article/details/128571317
进程控制

fork()函数
从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。

返回值：子进程中返回0，父进程返回子进程id，出错返回-1

。。fork()   子进程返回  0  ，  那就是说明  子进程是从  fork()  完成时  开始的？

fork之后，有两个执行流，父子进程代码是共享的，所以return会被调度两次，被父子进程各自执行return的。

pid_t id = fork();返回本质就是写，所以谁先返回，谁就先写入id，因为进程具有独立性，要进行写时拷贝。
同一个id,地址是一样的，但是内容却不一样。

进程调用fork，当控制转移到内核中的fork代码后，内核做：
    分配新的内存块和内核数据结构给子进程
    将父进程部分数据结构内容拷贝至子进程
    添加子进程到系统进程列表当中
    fork返回，开始调度器调度

fork常规用法
1.一个父进程希望复制自己，使父子进程同时执行不同的代码段。
2.一个进程要执行一个不同的程序。

进程退出码，可用echo $?查询

for (int i = 0; i < 200; ++i)
{
//std::cout << strerror(i) << std::endl;
char* err = strerror(i);

if (strcmp(err, "Unknown error") != 0)
{
std::cout << i << " : " << err << std::endl;
}
}
略小于140  个  错误码。

window需要windows.h，  unix需要  unistd.h。  才能使用  Sleep / sleep

printf("hi world.");
Sleep(1);
//_exit(12);
exit(12);

exit()和_exit()的结果却是不同。对于exit():结果会打印出来，对于_exit():结果没有显示，这是因为缓冲区的缘故。
。。但是我2个都打印了，不知道是不是  windows的原因。

所以exit()终止进程，会主动刷新缓冲区，_exit()终止进程，不会刷新缓冲区。

进程中有僵尸（Z）状态，造成原因：子进程退出了，父亲没有回收子进程的退出码，进而造成内存泄漏。另外，kill也无能为力，因为谁也没办法杀死不了一个已经死去的进程  ，最后，父进程派给子进程的任务完成的如何，我们需要知道，  如何去解决？通过进程等待的方式进行解决僵尸进程问题。

进程为什么要等待
1.父进程通过进程等待的方式，回收子进程资源
2.获取子进程退出信息

void wait_sub_process()
{
pid_t id = fork();
if (id == 0)
{
int cnt = 10;
while (cnt)
{
printf("%d, %d, %d", getpid(), getppid(), cnt--);
sleep(1);
}
exit(0);
}

sleep(15);
pid_t ret = wait(NULL);
if (id > 0)
{
printf("wait success: %d", ret);
}
}

ps ajx | head -1 && ps axj | grep WProc | grep -v grep

while :;do ps ajx | head -1 && ps ajx | grep Wproc | greap -v greap; sleep 1; done

waitpid()

wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充。
如果传递NULL，表示不关心子进程的退出状态信息。

kill -l  查看所有信号。
。LLL

linux提供的宏：
WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
。status  是  int

子进程退出变成僵尸，会把自己的退出的结果写入自己的task_struct，wait/waitpid是一个系统调用，OS有能力去读取子进程的task_struct:第一步让OS释放子进程的僵尸状态，第二步获取子进程的退出结果。

进程阻塞与非阻塞
阻塞等待（0）：父进程调用wait/waitpid等子进程时，等待子进程退出，这是阻塞时等待
非阻塞等待（WNOHANG）：检测状态，如果没有就绪父进程检测之后立即返回。每一次非阻塞等待都是一次，多次非阻塞等待称为轮询的过程。

。pid_t ret = waitpid(id, &status, WNOHANG)

非阻塞不会占用父进程的精力，可以在轮询期间，让父进程干别的事情。

进程替换
创建子进程的目的:
     让子进程执行父进程代码的一部分——执行父进程对应的磁盘代码中的一部分
     让子进程执行一个全新的程序——让子进程想办法加载到磁盘上指定的程序，执行新程序的代码和数据

#include <unistd.h>
int execl(const char *path, const char *arg, ...);//...是可变参数列表
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ...,char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);

execl系列函数结尾要以NULL结尾

替换原理

用fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支),子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动例程开始执行。调用exec并不创建新进程,所以调用exec前后该进程的id并未改变。

程序替换的本质就是将指定程序的代码和数据加载到指定的位置，覆盖自己的代码和数据。进程替换的时候并没有创建新的进程。

这些函数如果调用成功则加载新的程序从启动代码开始执行,不再返回，和接下去的代码无关了。如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值。

进程具有独立性，所以这里的替换并不会影响父进程。通过虚拟地址空间以及页表保证进程独立性，一旦执行流想替换代码或者数据就会发生写时拷贝。

l(list) : 表示参数采用列表，将参数一个一个的传入exec*
v(vector) : 参数用数组，将所有的执行参数，传入数组中，统一传递不用使用可变参数
p(path) : 有p自动搜索环境变量PATH，进行可执行程序的查找，不需要传程序的地址
e(env) : 表示自己维护环境变量

只有execve是真正的系统调用,其它五个函数最终都调用 execve

----------------------
https://blog.csdn.net/m0_68931081/article/details/129516676

缓冲区的理解

FIFE
因为IO相关函数与系统调用接口对应，并且库函数封装系统调用，所以本质上，访问文件都是通过fd访问的。
所以C库当中的FILE结构体内部，必定封装了fd。

fork会创建子进程。在创建子进程的时候，数据会被处理成两份，父子进程发生写时拷贝，我们进行printf调用数据的时候，数据写到显示器外设上，就不属于父进程了，数据没被写到显示器上，依旧属于父进程，而调用printf并不一定把数据刷到显示器上，没有被显示本质就是数据没有从内存到外设，所以这份没有被显示的数据依旧属于这进程，当我们去fork的时候，进程退出要刷新缓冲区，此时刷新的过程就是把数据从内存刷新到外设，刷新到外设的同时，也会把程序内部的缓冲区的数据直接清走，这就是写入，跟写时拷贝有关系

缓冲区
缓冲区本质就是一段内存！！

数据如果直接从内存到磁盘，在内存中速度快，但是访问外设效率比较低，那太消耗时间了，属于外设IO，所以缓冲区的意义是节省进程进行数据IO的时间。进程需要将数据拷贝到缓冲区中，这里我们并不需要拷贝，而是调用fwrite，与其理解fwrite是写入到文件的函数，倒不如理解fwrite是拷贝函数!!将数据从进程拷贝到缓冲区或者外设中。

数据直接拷贝到缓冲区，高速设备可以不必等待低速设备，提高了计算机运行速率。

缓冲区刷新策略:如果一块数据一次写入到外设（效率最高) VS  如果一块数据多次少批量写入到外设

立即刷新——无缓冲，场景少，即在printf后立即fflush

行刷新——行缓冲——显示器，数据的printf带上\n就会立马显示到显示器上。显示器为什么是行缓冲：显示器是外设，进程运行时在内存里的，把数据定期要刷新到外设，显示器设备比较特殊，是给用户来看的，从左到右，所以显示器为了保证刷新效率，并且用户体验良好，所以显示器采用行缓冲，满足用户的阅读体验并且在一定程度上效率不至于太低

缓冲区满——全缓冲——磁盘文件，效率最高，只需要一次IO，比如文件读写的时候，直接写到磁盘文件，缓冲区满了采取刷新，减少IO次数，提高效率。

存在特殊情况:1.用户强制刷新，2.进程退出——一般都要进行缓冲区刷新

缓冲区一定不在内核中！！  因为如果在内核中，系统接口write一定会打印两次！

我们一般所说的缓冲区是语言级别的缓冲区，C语言提供的在FILE结构体里对应的缓冲区。

综上： printf fwrite 库函数会自带缓冲区，而 write 系统调用没有带缓冲区。另外，我们这里所说的缓冲区，都是用户级缓冲区。其实为了提升整机性能，OS也会提供相关内核级缓冲区，不过不再我们讨论范围之内。那这个缓冲区谁提供呢？ printf fwrite 是库函数， write 是系统调用，库函数在系统调用的“上层”， 是对系统调用的“封装”，但是 write 没有缓冲区，而 printf fwrite 有，足以说明，该缓冲区是二次加上的，又因为是C，所以由C标准库提供。

1.如果我们没有进行 > (重定向），看到4条消息，stdout默认使用的是行刷新，在进程fork之前，三条C函数已经将数据进行打印输出到显示器上（外设），你的FILE内部进程内部不存在对应数据啦！

2.如果我们进行了重定向>，写入文件不在是显示器，而是普通文件，采用的刷新策略是全缓冲，采用的刷新策略是全缓冲，之前的3条显示函数虽然带了\n，但是不足以stdout缓冲区写满！数据并没有被刷新！！！执行fork的时候，stdout属于父进程，创建子进程时，紧接着就是进程退出！谁先退出，一定要进行缓冲区的刷新！（刷新本质就是修改）修改就会发生写时拷贝，数据最终会显示两部分！

简单来说：重定向导致刷新策略发生改变（由行缓冲变成了全缓冲）。同时发生了写时拷贝，父子进程各自刷新。

写一个小型缓冲区并封装一下来理解缓冲区
。AAAtest/buffer
。没有运行

---------------------
https://blog.csdn.net/m0_68931081/article/details/129349635

基础IO——系统文件IO&&fd&&重定向

C的fopen调用了底层的  open
fclose调用了底层的  close

系统调用接口：open/close/write/read/lseek必须用文件描述符
而C语言库函数（libc）接口：fopen/fclose/fwrite/fread/fseek是封装了系统调用接口

。open没有创建文件的功能，fopen有

文件操作的本质:进程和被打开文件的关系

#define FILE_NAME(number) "log.txt"#number
int main()
{
    int fd1 = open(FILE_NAME(1), O_WRONLY | O_CREAT | O_APPEND, 0666);

。。第一次知道  #xxx。  有什么用？  而且  log.txt  是  ""

printf("%d", stdin->_fileno);

文件描述符的本质是数组的下标

文件描述符就是从0开始的小整数。
当我们打开文件时，操作系统在内存中要创建相应的数据结构来描述目标文件。于是就有了file结构体。表示一个已经打开的文件对象。
而进程执行open系统调用，所以必须让进程和文件关联起来。
每个进程都有一个指针*files,  指向一张表files_struct,该表最重要的部分就是包含一个指针数组，
每个元素都是一个指向打开文件的指针！
所以，本质上，文件描述符就是该数组的下标。所以，只要拿着文件描述符，就可以找到对应的文件。

如果在创建一个文件对象，会在自己的文件描述符表从小到大按照顺序寻找最小的且没有被占用的fd.

文件描述符的分配规则：在files_struct数组当中，找到当前没有被使用的最小的一个下标，作为新的文件描述符

重定向
常见的重定向有:>（输出重定向）, >>（追加）, <（输入重定向）

重定向的本质是:上层用的fd不变，在内核中更改fd对应的struct file*的地址

dup2的作用是两个文件描述符之间进行拷贝，是把fd里面的内容拷贝

dup2(int oldfd, int newfd);
使得newfd  变成  oldfd  的一个copy。只剩下oldfd

Linux下一切皆文件
站在struct file上层看来，所有的设备和文件，统一都是struct file->，就可以调用到具体设备的方法。即Linux下一切皆文件

===============

===============

===============

===============

===============

已使用 Microsoft OneNote 2016 创建。