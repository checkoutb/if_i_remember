Java-GC
2022年1月8日
15:15

https://zhuanlan.zhihu.com/p/29564649

https://www.cnblogs.com/starcloud/p/14998819.html

garbage collection

=======================
程序计数器，元空间，调用栈，堆，，，

每个线程都线程栈

双亲委托

永久代  permanent generation

g1 cms区别
cms  jkd1x  开始  被废弃

=======================

经典的垃圾收集器

CMS收集器
用于老年代
过程：
初始标记，从GC  Roots枚举，需要停顿  所有线程，由于OopMap，速度很快
并发标记，从GC  Roots开始，遍历所有关联到的对象，无需停顿，与用户线程并发执行，使用三色标记算法，对于引用关系的改变，采取增量更新的方法解决
重写标记，将修正增量更新的改变修正
并发清除，清除垃圾

缺点：
并发标记  是和用户线程一起执行，会占用CPU，导致应用变慢。
使用  标记-清除算法，会产生内存碎片
会产生浮动垃圾，浮动垃圾过多，会导致Full  GC  的出现

G1收集器
面向整个堆内存进行回收，衡量标准不是分代，而是将内存分为等大的Region，哪个Region的回收价值高，就回收那个Region。

======================
垃圾回收的时机

Eden区满，会进行一次  新生代的收集
新生代垃圾收集前，判断老年代的连续空间  <  Eden每次收集后存活对象的平均值，进行老年代回收
使用CMS收集器时，老年代的空间被占用了92%，进行老年代收集。
新生代垃圾回收后，存活的对象>老年代空间，进行老年代收集

========================
内存分配策略

新创建的对象分配带Eden区
新创建的大对象直接分配在老年代(所以要避免创建  短命大对象)
长期存活的对象进入老年代

新生代收集后，survivor放不下，直接进入老年代(  所以需要适当调整Eden  和  survivor的比例，来确保  短命的对象  每次收集时都能放在survivor  下)

动态年龄判断，相同年龄的对象所占的survivor大于  survivor的一半，所有大于等于这个年龄的对象都进入老年代。

=======================

创建对象用  new，释放对象，只需要将该对象的所有引用赋值为null。
对象不可达，GC负责回收所有不可达的对象

=======================

新生代  有一个  Eden区  和2个survivor  区  (默认8:1，2个survivor，一个叫from，一个叫to)

首先将对象放入  Eden区，如果空间不足就向其中一个  survivor区上放，如果仍放不下，就触发一个  新生代的  minor GC，将存活的对象放到另一个survivor中，然后清空Eden  和  原先的survivor  的内存，在某次GC过程中，如果发现仍然有放不下的对象，就将这些对象放入老年代内存中。

GC开始时，对象只存在于  Eden  和  名为From的survivor区，名为To的survivor区是空的。紧接着进行GC，Eden中所有存活的对象都被复制到To。From中存活的对象需要根据他们的年龄来决定去向。年龄达到一定值(通过-XX:MaxTenuringThreshold设置)  的对象被移动到  老年代，没有达到阈值的被复制到  To。

GC后，Eden  和  From  区清空。From  和  To交换角色。
Minor GC  一直重复这样的过程。直到To  被填满，To被填满后，会将所有对象移动到老年代中。

因为年轻代中的对象存活时间很短，所以年轻代的垃圾回收算法是  复制算法。复制算法的基本思想就是将内存分为2块，每次只是用其中一块，当使用的这块内存用完，就将还活着的对象复制到另一块上面。复制算法不会产生内存碎片

大对象  及长期存活的对象  直接进入老年代

每次执行minor GC的时候  会对将晋升到  老年代的对象进行分析，如果这些马上就要到  老年代的对象的大小超过了  老年代的剩余大小，那么执行一次Full GC，以尽可能的获得老年代的空间。

。。但是  Major GC呢？

=======================

=======================

=======================

清除  从  GC  Roots  搜索不到，且经历过一次  标记清除  后仍然没有  复活的对象

GC回收内存前，会调用finalize()方法。但是靠不住的。

如何复活：重写finalize方法，在方法里面给对象以引用，但只能复活一次。
。。应该是因为  finalize  只会被调用一次的原因。

GC  Roots包含：虚拟机栈中的引用的对象，方法区中静态属性引用的对象，常量引用的对象，本地方法栈中JNI(即通常说的  native方法引用的对象)

=======================

新生代：复制清除
老年代：标记-清除  和  标记-压缩
永久代：存放Java中的类  和  加载类的  类加载器本身

=======================

从年轻代回收空间的GC  称为  Minor GC
Major  GC，清理老年代
Full  GC，清理整个堆空间。

=======================

=======================

什么对象会被回收

引用计数法：如果一个对象被引用一次，则引用计数+1，如果引用取消，则-1。减到0时，就需要被回收
问题：循环引用

可达性分析算法：从GC  Roots开始，找到GC  Root  直接或间接引用的对象，并标记，没有标记的就是需要回收的。

GC  Roots
        虚拟机栈（栈帧中的本地变量表）中引用的对象
        本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
        方法区中类静态属性引用的对象
        方法区中常量引用的对象
        同步锁持有的变量
        跨代引用的对象

=======================
垃圾回收算法

三个假说
大部分对象  朝生暮死。
越多次数跨过GC  的对象越难被回收
跨代引用很少

堆区域划分
新生代，新创建的对象和跨过  垃圾回收次数  小于某个值的对象
老年代，跨过垃圾回收次数  大于某个值的对象。默认15
有些收集器不使用分代，而是将内存分为等大的Region

三个标记算法
标记-清除算法，从GC  Roots开始遍历，遍历到的对象进行标记，清除没有被标记的
问题，内存碎片，严重影响内存利用率

标记-复制算法，内存按比例分开，一部分闲置称为A，另一部分存放对象称为B，一次标记结束后，将存活的对象复制到限制区域A，清空B。
大多数新生代收集器使用此技术

Appel式回收：将新生代分为  一个  Eden，2个survivor，比例8:1。分配内存只分配到Eden  和一个Survivor，HotSpot使用此技术

逃生门：当survivor放不在  Eden中的  存活对象，将这些对象直接放到老年代。
问题，浪费空间，大量对象存活时  复制浪费的时间长(  所以老年代不使用该方法)

标记-整理算法，将标记存活的对象朝内存空间的  一端移动，清除边界之外的对象。
问题，需要更新引用，操作复杂。

=========================
重要的算法

GC  Roots  枚举

GC  Roots  大部分存在于  栈帧的局部变量表中，而局部变量表中可能存放折一些基本数据类型  和引用类型，如果要遍历全部  以找出  引用类型来作为  GC  Roots  的话，效率太低。

当前主流的虚拟机都是  准确式垃圾收集，也就是说，虚拟机可以直接直到栈中的  变量是  基本数据类型  还是  引用数据类型。

HotSpot使用  OopMap  来解决这个问题，在即时编辑过程中，会在特定的位置记录下  栈里的哪些地方是引用。在GC  Roots枚举的时候，查找OopMap就可以快速找到  GC  Roots了

OopMap  记录引用的  信息，如果执行一次语句就需要更新一次OopMap，会导致效率低下，所以虚拟机使用了一个  叫  安全点的技术，安全点中  所有线程都将挂起，方便OopMap更新  和  GC  Roots枚举，在安全点之外不会更新OopMap，OopMap累积到一个安全点再一次性更新。

如何确定安全点？
虚拟机以"是否具有让程序长时间执行的特征"  为标准  选择安全点，准确的说就是：1.方法调用，2.循环跳转，3.异常跳转。
。。。跳转以后  大概率是一个  长时间执行的代码块。

如何让所有线程都跑到安全点挂起？

抢先式中断：虚拟机要垃圾回收的时候将全部线程中断，如果有线程不在安全点上，则让这个线程  执行，让它也走到安全点。(如果这个时间内  实例化了一个  超大对象  怎么办？)

主动式中断：虚拟机不会主动中断线程，而是设置一个标志位，所有线程执行过程中不断轮询这个标志位，如果这个标志位为真  就在最近的安全点挂起，标志位和安全点是重合的，并且加上所有要创建的对象和  分配内存的地方。(似乎解决了上面的问题)

安全区域
有些线程Sleep，它们不能走到安全点挂起，其他线程也不能等它们醒来，所以设置安全区域，在安全区域内所有引用关系将不会变化，安全区域就是拉长的安全点

=========================
记忆集和卡表

上面提到GC  Roots  包含着  跨代引用的对象，如果需要搜集新生代，如何找到跨代引用的对象，莫非要遍历整个老年代？这个问题通常通过记忆集的技术来解决

记忆集记录着  从肺收集区指向收集区域的指针的集合。在垃圾回收时，能通过记忆集来找出可以作为GC  Root的跨代引用的对象。

卡表
记忆集有精度之分，有些能精确到具体地址，有些只能精确到一块内存区域，HotSpot就是精确到一块内存区域，这种记忆集成为卡表。

HotSpot的卡表  是一个数组，数组中的每个元素对应一个内存块，称为卡页，如果一个卡页的值是1，则说明该内存块中包含着跨代指针，将它们加入GC  Roots中一起扫描。

写屏障
解决何时更新卡表的问题，写屏障简单而言就是一个AOP切片，当更新了引用时，会通过写屏障自动更新卡表信息。

三色标记

GC  Roots  的枚举会暂停所有线程，而现在的许多收集器在标记过程中是不需要暂停线程的，开始并发标记会带来漏标和错标，错标会导致回收正在使用的对象，导致程序崩溃，为解决这个问题，引入三色标记来解决。

黑色，已被标记，且这个对象下的属性也全部被标记过了。(程序所需要的对象)
灰色，已被标记，但是该对象下的属性没有被标记完。(GC需要从此对象去寻找垃圾)
白色，该对象没有被标记过。(垃圾对象)

当扫描结束，所有  非垃圾节点都变成黑色，这是如果某个引用取消，则被引用的对象成为垃圾，可仍然是黑色，属于漏标

判断错标的2个条件
赋值器插入一条或多条  从黑色对象  到白色对象的新引用
赋值器  删除了  全部  从灰色对象  到该白色对象的  直接或间接引用

为什么需要条件1？
    如果不是插入黑色到白色而是插入灰色到白色，这样下一轮扫描就会扫描灰色，必定会把新插入的白色对象也标记上。
    如果不是插入黑色到白色而是插入白色1到白色2，分两种情况：
        假设白色1不是垃圾，则它迟早会被标记，那么白色2也会被标记。
        假设白色1是垃圾，那如何找到白色1？假设不存在。

为何需要条件2？
    如果不是删除灰色到白色，而是删除黑色到白色，此假设不存在，黑色后面都是灰色。
    如果不是删除灰色到白色，而是删除白色到白色，分两种情况：
        假设白色1不是垃圾，那么所有灰色对象必会有一个间接或直接引用他。
        假设白色1是垃圾，那如何找到白色1？假设不存在。

解决错标
增量更新：为了打破条件1，当赋值器插入了一条或多条  从黑色到  白色的  新引用时，将黑色对象变成灰色。

原始快照：为了打破条件2，赋值器删除了全部  从灰色对象  到该白色对象的  直接或间接引用时，将改变前的引用关系快照保存，带并发扫描结束后，再扫描一遍改变前的快照(如果只满足了条件2，不满足条件1，这样做是不是可能产生浮动垃圾)

=========================

=========================

=========================

=========================

=========================

=========================

![](../_resources/199f2f971ec046b5b26532b0fe96df61.png)

=========================

=========================

-Xmx4g

-XX:MaxMetaspaceSize=512m

=========================

=========================

=========================

=========================

=========================

=========================

=========================

=========================

=========================

=========================

=========================

=========================

已使用 Microsoft OneNote 2016 创建。