Algo
2022年8月23日
17:36

[[toc]]


==============================

# Bloom  Filter

https://zhuanlan.zhihu.com/p/131285273

判断一个元素是否在一个集合中，计算机中的集合是用哈希表（hash table）来存储的。快速，准确，但是空间占用大。
当集合巨大时，hash  table 的存储效率低的问题就展现出来了。 存储1亿个email地址，需要1.6g内存(email被转成8字节的信息指纹，然后将这些信息指纹存储到 hash table中，由于hash table 的 存储效率只有50%, 所以一个 email地址占用 16个字节，一亿需要1.6g)。

布隆过滤器只需要 hash table 的 1/8 - 1/4 的大小。

布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。

原理：当一个元素被加入集合时，通过==K个Hash函数==将这些元素映射成一个位图阵列(位图)中的==K个点==，把它们==置为1==。当检索时，只需要看看这K个点是不是都是1就大约知道集合中有没有这个检索的元素。如果这些点有任何一个0，那么被检索元素一定不在，如果都是1，可能在。

## 优点:
- 不需要存储key，节省空间；
- 布隆过滤器存储空间和插入 / 查询时间都是常数O(k)；

## 缺点：
- 不能删除
- 存在误判率，布隆认为存在，但是实际不存在。



## 最优 hash函数个数
- 如果hash函数 个数多，那么对于 一个不属于集合的 元素进行查询，得到0 的概率就小
- 如果hash函数个数少，那么位数组中的 0 就多。

错误率为f，由前面已知错误率`f = (1-e^(-kn/m))=e^(kln(1-e^(-kn/m))`，令`g = kln(1-e^(-kn/m)`，则g为最小，错误率也取到最小。由于`p = e^(-kn/m)`，则
`g = (-m/n)ln(p)ln(1-p)`

通过对称性法则，可知当p = 1/2时即是k = ln2(m/n)时，取得最小值。也就是说，要想保持错误率低，最好让位数组有一半还空着。最小的错误率为`lnf = (-m/n)(ln2)^2`

而对于位数组的大小，经过推导，在错误率不大于x的情况下，m至少要等于nlog2(1/x)才能表示任意n个元素的集合。并且在哈希函数的个数取到最优时，要让错误率不超过x，m至少需要取到最小值的1.44倍。


## counting bloom filter
用 counter数组代替 位数组，就可以 支持删除。 但是空间消耗增加

## 场景
- 拼写检查，即判断一个单词是否在词典中
- 垃圾邮件过滤，判断邮件域或IP是否在黑名单中。如果 邮件服务器的通信邮件数量非常大(可以认为是上亿)，那么可以用布隆过滤器
- 加快数据库查询， Google的分布式数据库 Bigtable，使用 布隆过滤器 查找不存在的 行或列，来减少 磁盘IO。
  很多k-v 系统中也使用了 布隆过滤器 来加速查询过程，如 Hbase，Accumulo，Leveldb，一般来说，value存储在磁盘中，访问磁盘需要大量时间，布隆过滤器可以快读判断某个key的 value 是否存在，来减少很多不必要的 磁盘IO。不过 布隆过滤器需要消耗 一定的内存。



==============================

# 布谷鸟过滤器(Cuckoo Filter)

布隆过滤器  已经比较成熟了，但有一些缺点：  不支持删除操作，查询效率低，cpu缓存命中率低(  因为随机hash函数  探测的是bit数组中  多个  不同的点)

基于  布谷鸟hash算法  提出的  布谷鸟过滤器。


https://zhuanlan.zhihu.com/p/131285273

Cockoo filter 可以保证 元素存在的必然性，又可以删除任意元素，仅仅比 bitmap 牺牲了微量空间效率。

## Cuckoo hashing
布谷鸟hash函数 是成对的 (具体的实现可以根据需求 来设计)， 每个元素都是2个，分别映射到2个位置，一个是 记录的位置，一个是 备用位置，这个备用位置是 处理碰撞时用的。

1. 当2个hash位置有一个为空时，则插入该空位置
2. 当2个hash位置都不为空时，随机选择一个位置，将原先的key踢出，并计算 被踢出的 key的另一个 hash位置，如果为空，就放过去，不为空，则踢出 那个元素，然后再对被踢出的 元素重新计算。直到每个key都有位置。踢出的次数达到一个临界，则认为 hash表已满，执行re-hash 扩容。

## Cuckoo filter
Cuckoo filter 不会存储原信息，只存储 指纹信息。

因为在插入过程中可能因为反复踢出无限循环下去，这时就需要进行一次循环踢出的限制，超出限制则认为过滤器容量不足，需要进行扩容。
另外布谷鸟过滤器在bucket上存储的是key的指纹，主要是考虑到不同的key长度不定，节约空间。fingerprint 一般由key做hash得来，长度较短，一般为8-12bit，也可根据实际数据量调整。

由于计算key的存储位置使用的时key本身的值，而存储时仅存储了fingerprint，因此当key被挤出，需要重新找位置时，通过指纹信息来找到第二个bucket

Cuckoo filter 只需要使用 指纹信息就可以找到 第二个位置：
location1 = hash(key)
location2 = location1 ^ hash(指纹信息)

### 改进
每个hash位置 变成 一个桶(bucket)，桶离有4个槽(slot)。当hash 映射到 一个bucket时，slot未满，就不会踢出。


------------------

https://www.cnblogs.com/zhaodongge/p/15067657.html


1. 支持动态 增加 删除 item
2. 提供 比布隆更高的 查询性能，即使接近满时(比如 95%空间已使用)
3. 比 quotient filter 更容易实现
4. 如果要求误判率在3%以下，比布隆过滤器 占用空间 更少。

。。这里的 3% 是指， 布谷鸟filter 说没有， 实际上有。。。。。。。。

## 布谷鸟哈希
-    如果两个位置都为为空则将key随机存入其中一个位置
-    如果只有一个位置为空则存入为空的位置
-    如果都不为空，则随机踢出一个元素，踢出的元素再重新计算哈希找到相应的位置

一般会设置一个踢出阈值，如果在某次插入行为过程中连续踢出超过阈值，则进行扩容。


## 布谷鸟filter

和 朴素的布谷鸟hash 不同，布谷鸟过滤器 使用了 2个 并不独立的 hash函数
i1=hash(x)
i2=i1⊕hash(f)

为什么不直接用索引1和指纹做异或操作，
关于这个问题文中给了解释，因为指纹一般只是key映射出来的少量bit位置，那么假如不进行哈希操作，当指纹的比特位与整个桶数组相比很小时，那么备用位置使用“i⊕指纹”，将被放置到离桶i1很近的位置，比如使用八位的指纹大小，最多只能改变i1的低八位，所以也就是两个候选通的位置最多相差256，不利于均匀分配。

### 查找

布谷鸟过滤器的查找过程很简单，给定一个项x，算法首先根据上述插入公式，计算x的指纹和两个候选桶。然后读取这两个桶：如果两个桶中的任何现有指纹匹配，则布谷鸟过滤器返回true，否则过滤器返回false。此时，只要不发生桶溢出，就可以确保没有假阴性。


### 删除
标准布隆过滤器不能删除，因此删除单个项需要重建整个过滤器，而计数布隆过滤器需要更多的空间。布谷鸟过滤器就像计数布隆过滤器，可以通过从哈希表删除相应的指纹删除插入的项，其他具有类似删除过程的过滤器比布谷鸟过滤器更复杂。

具体删除的过程也很简单，检查给定项的两个候选桶；如果任何桶中的指纹匹配，则从该桶中删除匹配指纹的一份副本。


### 缺点
删除不完美，存在误删的概率。
删除的时候只是删除了一份指纹副本，并不能确定此指纹副本是要删除的key的指纹。同时这个问题也导致了假阳性的情况。
。。这个。。岂不是 不能用了， 过滤器说没有， 实际上是有的。 这个。。完全就不可用了啊。 果然没有十全十美啊。

插入复杂度比较高
随着插入元素的增多，复杂度会越来越高，因为存在桶满，踢出的操作，所以需要重新计算，但综合来讲复杂度还是常数级别。

存储空间的大小必须为2的指数的限制让空间效率打了折扣。
。。没有看到上面提及。

同一个元素最多插入kb次，（k指哈希函数的个数，b指的桶中能装指纹的个数也可以说是桶的尺寸大小）如果布谷鸟过滤器支持删除，则必须存储同一项的多个副本。 插入同一项kb+1次将导致插入失败。 这类似于计数布隆过滤器，其中重复插入会导致计数器溢出。





=============================
# Quotient filter




==============================

==============================
https://juejin.cn/post/7158977996462751780

# 7种哈希散列方法

## 拉链寻址
把碰撞的元素存放到链表上。

## 开放寻址(线性探测)
ThreadLocal  采用  斐波那契散列  +  开放寻址
开放寻址的设计  会对  碰撞的元素，寻找  哈希桶  上的  新位置，这个新位置  是从  当前碰撞位置  开始  向后寻找，直到找到空的位置存放。
ThreadLocal  中的实现  使用  斐波那契散列，索引计算累加，启发式清理，探测式清理  等操作，来减少碰撞。

## 合并散列

是  开放寻址  和  单独链接  的混合，  碰撞的节点  在  哈希表中  链接。适合固定分配内存的哈希桶，通过存放元素时  识别哈希桶上的  最大空槽位  来解决合并哈希  中的冲突。

合并散列  的最大目的  在于  将碰撞  元素  链接起来，  避免  因为  需要寻找  碰撞  元素所发生的循环遍历。

## 杜鹃散列
杜鹃鸟在孵化的时候，雏鸟会将  其他蛋  或  幼崽  推出巢穴。
。。。。唉。

类似的这个数据结构  会使用  2组  key  哈希表，将冲突元素  推到另外一个  key  哈希表中。

当多个键映射到同一个单元格时会发生这种情况。杜鹃散列的基本思想是通过使用两个散列函数而不是仅一个散列函数来解决冲突。

这为每个键在哈希表中提供了两个可能的位置。在该算法的一种常用变体中，哈希表被分成两个大小相等的较小的表，每个哈希函数都为这两个表之一提供索引。两个散列函数也可以为单个表提供索引。

在实践中，杜鹃哈希比线性探测慢约 20-30%，线性探测是常用方法中最快的。然而，由于它对搜索时间的最坏情况保证，当需要实时响应率时，杜鹃散列仍然很有价值。杜鹃散列的一个优点是它的无链接列表属性，非常适合 GPU 处理。

## 跳房子散列

是一种  基于开放寻址的算法，结合了  杜鹃散列，线性探测  和  链接的元素，通过  桶  邻域的概念  ---  任何给定  占用桶周围  的后续桶，也称为  "虚拟"桶。

该算法旨在  哈希表的  负载因子  增长超过  90%  时提供  更好的性能，它还在并发设置中  提供了  高吞吐量，因此非常适合  实现  可调整大小的  并发  哈希表。

该算法使用一个包含n 个桶的数组。对于每个桶，它的邻域是H个连续桶的小集合（即索引接近原始散列桶的那些）。邻域的期望属性是在邻域的桶中找到一个项目的成本接近于在桶本身中找到它的成本（例如，通过使邻域中的桶落在同一缓存行中）。在最坏的情况下，邻域的大小必须足以容纳对数个项目（即它必须容纳 log( n ) 个项目），但平均只能是一个常数。如果某个桶的邻域被填满，则调整表的大小。

## 罗宾汉哈希

基于开放寻址的  冲突解决算法，冲突是通过  偏向  从其  "原始位置"(即项目  被散列  到的  存储桶)  最远  或  最长  探测序列长度  (PSL)  的元素的位置  来决绝的。

==============================

## 斐波那契散列

是一种特殊的  乘法散列。
1. 关键字  k   乘上  常数  A (0<A<1)，  抽取出  kA  的小数部分。
2. 用  m  乘以  这个值，然后向下取证

m  一般是  2的幂次方

为了得到更好的随机性，Knuth  认为  A  取  黄金分割数  是一个比较理想的值。所以  A=0.6180339887....    这就是  斐波那契散列

==============================

==============================

==============================

==============================

==============================

已使用 Microsoft OneNote 2016 创建。




# 一致性哈希算法，用在分布式中

是一种哈希算法，
在移除或者添加一个服务器时，此算法能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系，尽可能满足单调性的要求。

普通hash，在 添加或移除 服务器时，会造成大量的 hash重定位， 一致性hash 不会。

## 思想

一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0~232-1。
整个空间按顺时针方向组织。
0~2^32-1在零点中方向重合。
接下来使用如下算法对服务请求进行映射，
1. 将服务请求使用哈希算法算出对应的hash值，
2. 然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。

当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。
综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。


一致性哈希算法作为分布式存储领域的一个重要算法，它基本解决了以P2P为代表的存储环境中一个关键的问题——如何在动态的网络拓扑中对数据进行分发和选择路由。
在算法所构成的存储拓扑中，每个存储节点仅需维护少量相邻节点的信息，并且在节点加入/退出系统时，仅有相关的少量节点参与到拓扑的维护中，这使得一致性哈希算法成为一个具有实用意义的DHT（DistributedHashTable，分布式哈希表）算法。

## 不足

但是一致性哈希算法尚有不足之处。
第一，在查询过程中，查询消息要经过O(n)步(n代表系统内的节点总数)才能到达被查询的节点。不难想象，当系统规模非常大时，节点数量可能超过百万，这样的查询效率显然难以满足使用的需要。
第二，当应用一致性哈希算法的分布式存储系统中添加或者删除新的物理节点时，要将下一个节点与之相关的数据迁移过来，查询命中率和存储效率下降，影响系统的整体性能

。。普通hash可以确保 所有的请求转发都是 相同几率的。 但是一致性hash没有办法，要看哪个节点前面的slot多，那么它的机会就大。
。。不过也有优势，可以天然地加权转发。

。。这个可以二分，或跳表啊。
。。虽然 2^32很大， 但是 机器最多也就 几千台 吧？。 把这些机器所在的 下标 放到数组中，那么也就是一个 几千个元素的 数组， lower_bound / upper_bound。
。。而且可以形成 B+树，这种"矮"树。 减少 查询的比较次数。
。。对的， 要商业使用，必然 是 B+树。。。不。 不知道到底是几台服务器， 10台以内，直接 数组遍历 应该更快。 可能100以内也是数组更快？ 。
。。而且 B+ 树这种应该是 10万+ 才会性能 好于 lower_bound 吧。
。。B+树是 节点+链表， 二分 是 数组， 数组快很多。  就是 ==一个 算法有优势，一个 数据结构有优势==。


一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件:==平衡性、单调性和分散性==。

1. 平衡性是指hash的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。
2. 单调性是指在新增或者删减节点时，不影响系统正常运行。
3. 分散性是指数据应该分散地存放在分布式集群中的各个节点(节点自己可以有备份)，不必每个节点都存储所有的数据


Davies-Meyer算法是一种较好的选择
。。我不太清楚，这个 Davies-Meyer 是不是 一致性hash算法的 别名。。


## 带虚拟节点的一致性hash

一致性hash在节点太少时，容易 由于分布不均匀而导致 数据倾斜。
为了避免数据倾斜， 一致性hash算法引入了 虚拟节点的机制。 也就是 ==每个机器节点会进行多次hash==，这样，每个节点 在 hash环 上会有 多个虚拟节点存在， 使用这种方法来避免数据倾斜。

。。是的,是多次hash，我看到一种实现，hash(ip), for i in (0..3) { hash(ip + "#" + i); } 。。或者直接 for，不需要之前的 hash(ip)。

实际运用中，通常将 虚拟节点数 设置为 32 或更大， 这样，即使 很少的服务节点 也能做到相对均匀的 数据分布。


# range分片

基于范围内的分片，将数据 划分为由 片键值 确定的 连续范围。






# 分库分表的分片规则

https://zhuanlan.zhihu.com/p/566117365


## 时间范围分片

要求 分片键 为 时间类型字段，可以支持按 年，月，日，小时 等范围 进行数据切分。

优点
扩容时 只需要添加节点，指定日期范围，可以避免扩容时的 数据迁移。

缺点
负载不均衡，容易导致 单节点故障。

场景
具有时间属性的数据 适合做范围分片， 比如 日志数据，前期查询频率较高，可以按 季度 或 月度 进行范围分割，后期不需要的时候，直接清空数据。


## 数值范围分片

。。就是0-1000 一个节点，1000-2000一个节点， 以此类推

和时间范围分片类似，唯一不同点就是，每个分片数据量 相对均衡，热点数据存在 但相对较少。

时间范围分片，比如2022.1-2022.6 为一个分片，在此分片上产生的数据是不可控的，可能是一万条，也可能是100万条数据。

数值范围没有这种问题，因为在 设置分片时，已规定 每个分片的数据量，所以 数据相对均衡。

优点
扩容时只需要增加节点，指定数值范围，可以避免扩容时的数据迁移
数据量可控，可以均衡，也可以不均衡。

缺点
无法解决热点问题，如果某一段数据访问QPS特别高，就会落到单节点上进行操作。

场景
业务场景中 热点数据比较少的 业务都可以使用，比如用户系统，以用户ID进行分片，用户ID采用全局递增。


## 取模分片

对 分片键的值 与 节点数 进行 取余。 如 分片键为6，节点总数是3， 那么 6%3=0，分片键应该保存到 第一个节点。


取模分片扩展 又分为 基础分片 和 hash取模分片：
- 基础分片： 要求 分片键 类型 为数值 或 值中必须要有数字，然后进行截取进行取余计算
- hash取模分片：对分片键类型没有要求， 先hash，然后取模。

优点
节点负载均衡。

缺点
扩容时，需要全量迁移。

场景
适用于 需要将数据 均匀分布的场景，例如 银行类客户业务应用，业务逻辑主体是客户，可以使用客户对应的表字段(如客户号)作为拆分键


## 一致性hash分片

增加虚拟节点。

优点
增加虚拟节点后，数据分布相对均匀，节点不存在热点问题

缺点
数据扩容 复杂， 一致性hash 在扩容时 只需要迁移 相邻节点 部分数据 即可， 但是为了 均衡，增加了 虚拟节点，导致 相邻 过多，那么 扩容就没有那么简单了。

场景
适用于 需要将数据 均匀分布的场景，在扩容时 不需要大量迁移数据的场景。




# Paxos

Basic Paxos
Multi Paxos


# Raft


# Zab


# Gossip


# etcd

https://zhuanlan.zhihu.com/p/339902098

非常可靠的kv存储系统，常在分布式系统中存储着关键的数据。

开源的分布式键值存储系统，具备以下特点：
-    简单：提供定义明确且面向用户的API
-    安全：支持SSL证书验证
-    性能：基准压测支持1w+/sec写入
-    可靠：采用Raft协议保证分布式系统数据的可用性和一致性。


## 常见功能

-    键值存储、查询功能：支持精准查询、range操作、ttl机制、key版本等。
-    一致性机制：采用raft协议保证强一致性。
-    可用性机制：提供集群和leader选举机制。
-    SSL认证机制。
-    watch机制。

## 常见场景

### 配置中心

etcd是一个分布式的键值存储系统，其优秀的读写性能、一致性和可用性的机制，非常适合用来做配置中心角色。


### 分布式锁

etcd的强一致性保证，可以用来做分布式场景下的同步机制保证。

### leader选举组件

分布式场景下，常采用leader-follower模式来保证有状态服务的高可用（即使leader挂掉，其他follower立马补上），比如k8s和kafka partition高可用机制。可以很方便的借助etcd来实现leader选举机制


### 服务注册与服务发现
为了解决微服务场景下，服务地址的注册和发现问题。和配置中心功能类似，不同之处在于服务注册和服务发现，==还伴随着状态检测。==


### 消息订阅和发布
etcd内置watch机制，完全可以实现一个小型的消息订阅和发布组件。


## etcd vs redis

etcd诞生之日起，就定位成一种分布式存储系统，并在k8s 服务注册和服务发现中，为大家所认识。
它偏重的是节点之间的通信和一致性的机制保证，并不强调单节点的读写性能。

而redis最早作为缓存系统出现在大众视野，也注定了redis需要更加侧重于读写性能和支持更多的存储模式，它不需要care一致性，也不需要侧重事务，因此可以达到很高的读写性能。

总结一下，redis常用来做缓存系统，etcd常用来做分布式系统中一些关键数据的存储服务，比如服务注册和服务发现。


## etcd vs consul

consul定位是一个端到端的服务框架，提供了内置的监控检查、DNS服务等，除此之外，还提供了HTTP API和Web UI，如果要实现简单的服务发现，基本上可以开箱即用。

但是缺点同样也存在，封装有利有弊，就导致灵活性弱了不少。除此之外，consul还比较年轻，暂未在大型项目中实践，可靠性还未可知。


## etcd vs zk

etcd站在了巨人的肩膀上。

## 性能

来自于官网介绍：https://etcd.io/docs/v3.4.0/op-guide/performance/ 
大致总结一下：
- 读：1w ~ 10w 之间
- 写：1w左右

建议：
- etcd需要部署到ssd盘（强烈建议）
- 多个写采用batch操作。
- 非必要情况下，避免range操作。

etcd集群更偏重一致性和稳定性，并不强调高性能，在绝大部分场景下均不会到达etcd性能瓶颈，如果出现瓶颈的话，需要重新review架构设计，比如拆分或者优化流程。












# baidu的时候联想了其他的算法：
米勒罗宾算法：素数测试+大数的因素分解的概率算法
Levenshtein：两个字符串之间的最小编辑距离， 这个记录过了
Fisher算法：对线性可分问题的非迭代解法,其将高维特征空间中的样本投影到一条直线上,实现从高维到一维的数据压缩
Dither：数字音乐处理上非常神奇的技巧,目的是通过用少数的 Bit 达到与较多 Bit 同样的听觉效果,方法是在最后一个 Bit (LSB)上动“手脚”。
    视频处理算法，抖动算法。
莱文贝格－马夸特方法（Levenberg–Marquardt algorithm）能提供数非线性最小化（局部最小）的数值解。
盖尔-沙普利(Gale-Shapley)稳定匹配算法是美国数学家 David Gale 和 Lloyd Shapley在1962年提出的一种寻找稳定婚姻的策略
LEACH算法：分簇路由算法，一种分簇协议,用于无线传感器网络中的能量有效性和数据聚合




