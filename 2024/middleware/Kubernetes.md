
2023-09-23 10:37


看了《凤凰架构》，kubernetes。
mule的run time fabic 也是 kubernetes的。

[[toc]]

---

# kubernetes doc

https://kubernetes.io/zh-cn/docs/home/


## 入门

### 学习环境使用的工具

### 生产环境使用的工具

### 最佳实践

#### 大规模集群的注意事项

Kubernetes v1.28 单个集群支持的最大节点数为 5,000。 更具体地说，Kubernetes 旨在适应满足以下所有标准的配置：
-    每个节点的 Pod 数量不超过 110
-    节点数不超过 5,000
-    Pod 总数不超过 150,000
-    容器总数不超过 300,000


#### 云供应商资源配额

在创建具有大规模节点的集群时，请考虑以下事项：
-    请求增加云资源的配额，例如：
    -    计算实例
    -    CPU
    -    存储卷
    -    使用中的 IP 地址
    -    数据包过滤规则集
    -    负载均衡数量
    -    网络子网
    -    日志流
-    由于某些云供应商限制了创建新实例的速度，因此通过分批启动新节点来控制集群扩展操作，并在各批之间有一个暂停。

#### 控制面组件

对于大型集群，你需要一个具有足够计算能力和其他资源的控制平面。

通常，你将在每个故障区域运行一个或两个控制平面实例， 先垂直缩放这些实例，然后在到达下降点（垂直）后再水平缩放。


#### etcd 存储
为了提高大规模集群的性能，你可以将事件对象存储在单独的专用 etcd 实例中。

在创建集群时，你可以（使用自定义工具）：
-    启动并配置额外的 etcd 实例
-    配置 API 服务器，将它用于存储事件

#### 插件资源
Kubernetes 资源限制 有助于最大程度地减少内存泄漏的影响以及 Pod 和容器可能对其他组件的其他方式的影响。 这些资源限制适用于插件资源， 就像它们适用于应用程序工作负载一样。

可以对日志组件设置 CPU 和内存限制：
```yaml
  containers:
  - name: fluentd-cloud-logging
    image: fluent/fluentd-kubernetes-daemonset:v1
    resources:
      limits:
        cpu: 100m
        memory: 200Mi
```

根据规模不同，插件消耗的资源也不同，所以不能认为，在中小规模 k8s 集群上可以运行，那么在 大规模 k8s 集群上也可以运行。

为避免遇到集群插件资源问题，在创建大规模集群时，请考虑以下事项：
- 部分垂直扩展插件
  总有一个插件副本服务于整个集群或服务于整个故障区域。 对于这些附加组件，请在扩大集群时加大资源请求和资源限制。
- 许多水平扩展插件
  你可以通过运行更多的 Pod 来增加容量——但是在大规模集群下， 可能还需要稍微提高 CPU 或内存限制。 VerticalPodAutoscaler 可以在 recommender 模式下运行， 以提供有关请求和限制的建议数字。
- 一些插件在每个节点上运行一个副本，并由 DaemonSet 控制： 
  例如，节点级日志聚合器。与水平扩展插件的情况类似， 你可能还需要稍微提高 CPU 或内存限制



### 运行于多可用区环境

。。略。。
节点一致性测试





## 概述

部署分为3个时代

![d6d7e09f20a69ee590349048753d9864.png](../_resources/d6d7e09f20a69ee590349048753d9864.png)


> 传统部署时代

早期，各个组织是在物理服务器上运行应用程序。 
由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致==资源分配问题==。 
例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 
一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程序资源利用率不高时，剩余资源无法被分配给其他应用程序， 而且维护许多物理服务器的成本很高。

> 虚拟化部署时代

虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 
虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。

虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 
通过虚拟化，你可以==将一组物理资源呈现为可丢弃的虚拟机集群==。

每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。

> 容器部署时代

容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是==更轻量级==的。
且与 VM 类似，每个容器都具==有自己的文件系统、CPU、内存、进程空间等==。 由于它们与基础架构分离，因此可以==跨云和 OS 发行版本进行移植==。

容器因具有许多优势而变得流行起来，例如：
-    敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像==创建的简便性和效率==。
-    持续开发、集成和部署：通过==快速简单的回滚==（由于镜像不可变性）， 提供==可靠且频繁==的容器镜像==构建和部署==。
-    关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。
-    可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的==运行状况和其他指标信号==。
-    跨开发、测试和生产的==环境一致性==：在笔记本计算机上也可以和在云中运行一样的应用程序。
-    跨云和操作系统发行版本的==可移植性==：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。
-    以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
-    ==松散耦合、分布式、弹性、解放的微服务==：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。
-    ==资源隔离==：可预测的应用程序性能。
-    ==资源利用==：高效率和高密度。


### 为什么需要 Kubernetes，它能做什么？

容器是打包和运行应用程序的好方式。
在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 
例如，如果一个容器发生故障，则你需要启动另一个容器。 
如果此行为交由给系统处理，是不是会更容易一些？

Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。

Kubernetes 为你提供：
- 服务发现和负载均衡
  Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。
- 存储编排
  Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。
- 自动部署和回滚
  你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 
  例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。
- 自动完成装箱计算
  你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 
  Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。
- 自我修复
  Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。
- 密钥与配置管理
  Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。


Kubernetes 不是什么

Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 
由于 Kubernetes 是在容器级别运行，而非在硬件级别，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡，允许用户集成他们的日志记录、监控和警报方案。 
但是，Kubernetes 不是单体式（monolithic）系统，那些默认解决方案都是可选、可插拔的。 
Kubernetes 为构建开发人员平台提供了基础，但是在重要的地方保留了用户选择权，能有更高的灵活性。

- 不限制支持的应用程序类型
- 不部署源代码，也不构建你的应用程序。
- 不提供应用程序级别的服务作为内置服务
- 不是日志记录、监视或警报的解决方案
- 不提供也不要求配置用的编程语言、系统
- 不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。
- Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 
  编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 
  而 Kubernetes 包含了一组独立可组合的控制过程，可以持续地将当前状态驱动到所提供的预期状态。


### Kubernetes 对象

本页说明了在 Kubernetes API 中是如何表示 Kubernetes 对象的， 以及如何使用 .yaml 格式的文件表示 Kubernetes 对象


#### 理解 Kubernetes 对象

Kubernetes 对象是==持久化的实体==。 Kubernetes 使用这些实体去==表示整个集群的状态==。

它们描述了如下信息
- 哪些容器化应用正在运行（以及在哪些节点上运行）
- 可以被应用使用的资源
- 关于应用运行时行为的策略，比如重启策略、升级策略以及容错策略

Kubernetes 对象是一种“意向表达（Record of Intent）”。
==一旦创建该对象， Kubernetes 系统将不断工作以确保该对象存在==。
通过创建对象，你本质上是在告知 Kubernetes 系统，==你想要的==集群工作负载状态看起来应是什么样子的， 这就是 Kubernetes 集群所谓的期望状态（Desired State）。

操作 Kubernetes 对象 —— 无论是创建、修改或者删除 —— 需要使用 Kubernetes API。 


#### 对象规约（Spec）与状态（Status）

几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 spec（规约） 和对象 status（状态）。 
对于具有 spec 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： 期望状态（Desired State）。

status 描述了对象的当前状态（Current State），它是由 Kubernetes 系统和组件设置并更新的。
在任何时刻，Kubernetes 控制平面 都一直在积极地管理着对象的实际状态，以使之达成期望状态。

。。spec 是你期望的状态， status 是对象的当前状态


#### 描述 Kubernetes 对象

创建 Kubernetes 对象时，必须提供对象的 spec，用来描述该对象的期望状态， 以及关于对象的一些基本信息（例如名称）。 
当使用 Kubernetes API 创建对象时（直接创建或经由 kubectl 创建）， API 请求必须在请求主体中包含 JSON 格式的信息。 
大多数情况下，你需要提供 .yaml 文件为 kubectl 提供这些信息。 
kubectl 在发起 API 请求时，将这些信息转换成 JSON 格式。

这里有一个 .yaml 示例文件，展示了 Kubernetes Deployment 的必需字段和对象 spec：


```yaml
# application/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # 告知 Deployment 运行 2 个与该模板匹配的 Pod
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

相较于上面使用 .yaml 文件来创建 Deployment，另一种类似的方式是使用 kubectl 命令行接口（CLI）中的 kubectl apply 命令， 将 .yaml 文件作为参数。下面是一个示例：

`kubectl apply -f https://k8s.io/examples/application/deployment.yaml`

。。这个url 是 yaml文件的url。

输出类似下面这样：
`deployment.apps/nginx-deployment created`


#### 必须字段

在想要创建的 Kubernetes 对象所对应的 .yaml 文件中，需要配置的字段如下：
- apiVersion
  创建该对象所使用的 Kubernetes API 的版本
- kind
  想要创建的对象的类别
- metadata
  帮助唯一标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace
- spec
  你所期望的该对象的状态

参阅 Pod API 参考文档中 spec 字段。 
对于每个 Pod，其 .spec 字段设置了 Pod 及其期望状态（例如 Pod 中每个容器的容器镜像名称）。 
另一个对象规约的例子是 StatefulSet API 中的 spec 字段。 
对于 StatefulSet 而言，其 .spec 字段设置了 StatefulSet 及其期望状态。


#### 服务器端字段验证
从 Kubernetes v1.25 开始，API 服务器提供了服务器端字段验证， 可以检测对象中未被识别或重复的字段。
它在服务器端提供了 `kubectl --validate` 的所有功能。

kubectl 工具使用 --validate 标志来设置字段验证级别。
它接受值 ignore、warn 和 strict，
同时还接受值 true（等同于 strict）和 false（等同于 ignore）。
kubectl 的默认验证设置为 --validate=true。

- Strict
    严格的字段验证，验证失败时会报错
- Warn
    执行字段验证，但错误会以警告形式提供而不是拒绝请求
- Ignore
    不执行服务器端字段验证

当 kubectl 无法连接到支持字段验证的 API 服务器时，它将回退为使用客户端验证。 


### Kubernetes 对象管理
kubectl 命令行工具支持多种不同的方式来创建和管理 Kubernetes 对象。 
本文档概述了不同的方法。 
阅读 Kubectl book 来了解 kubectl 管理对象的详细信息。


管理技巧

==警告==：应该只使用一种技术来管理 Kubernetes 对象。混合和匹配技术作用在同一对象上将导致未定义行为。


|管理技术	|作用于	|建议的环境	|支持的写者	|学习难度|
|--|--|--|--|--|
|指令式命令	|活跃对象	|开发项目	|1+	|最低|
|指令式对象配置	|单个文件	|生产项目	|1	|中等|
|声明式对象配置	|文件目录	|生产项目	|1+	|最高|

#### 具体例子
https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/
这个doc的最后是一些链接，具体的例子、流程、命令。

#### 指令式命令

使用指令式命令时，用户可以在集群中的活动对象上进行操作。用户将操作传给 kubectl 命令作为参数或标志。

这是开始或者在集群中==运行一次性任务的推荐方法==。因为这个技术直接在活跃对象 上操作，所以它不提供以前配置的历史记录。

通过创建 Deployment 对象来运行 nginx 容器的实例：
`kubectl create deployment nginx --image nginx`

与对象配置相比的优点：
- 命令用单个动词表示。
- 命令仅需一步即可对集群进行更改。

与对象配置相比的缺点：
- 命令不与变更审查流程集成。
- 命令不提供与更改关联的审核跟踪。
- 除了实时内容外，命令不提供记录源。
- 命令不提供用于创建新对象的模板。


#### 指令式对象配置
在指令式对象配置中，kubectl 命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。

==警告==
replace 指令式命令将现有规范替换为新提供的规范，并放弃对配置文件中 缺少的对象的所有更改。此方法不应与对象规约被独立于配置文件进行更新的 资源类型一起使用。比如类型为 LoadBalancer 的服务，它的 externalIPs 字段就是独立于集群配置进行更新。


创建配置文件中定义的对象：
`kubectl create -f nginx.yaml`

删除两个配置文件中定义的对象：
`kubectl delete -f nginx.yaml -f redis.yaml`

通过覆盖活动配置来更新配置文件中定义的对象：
`kubectl replace -f nginx.yaml`


与指令式命令相比的优点：
- 对象配置可以存储在源控制系统中，比如 Git。
- 对象配置可以与流程集成，例如在推送和审计之前检查更新。
- 对象配置提供了用于创建新对象的模板。

与指令式命令相比的缺点：
- 对象配置需要对对象架构有基本的了解。
- 对象配置需要额外的步骤来编写 YAML 文件。

与声明式对象配置相比的优点：
- 指令式对象配置行为更加简单易懂。
- 从 Kubernetes 1.5 版本开始，指令对象配置更加成熟。

与声明式对象配置相比的缺点：
- 指令式对象配置更适合文件，而非目录。
- 对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失。


#### 声明式对象配置
使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户 未定义要对该文件执行的操作。 kubectl 会自动检测每个文件的创建、更新和删除操作。 这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作。

说明：
声明式对象配置保留其他编写者所做的修改，即使这些更改并未合并到对象配置文件中。 可以通过使用 patch API 操作仅写入观察到的差异，而不是使用 replace API 操作来替换整个对象配置来实现。

处理 configs 目录中的所有对象配置文件，创建并更新活跃对象。 可以首先使用 diff 子命令查看将要进行的更改，然后在进行应用：
`kubectl diff -f configs/`
`kubectl apply -f configs/`

递归处理目录：
`kubectl diff -R -f configs/`
`kubectl apply -R -f configs/`


与指令式对象配置相比的优点：
- 对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。
- 声明性对象配置更好地支持对目录进行操作并自动检测每个文件的操作类型（创建，修补，删除）。

与指令式对象配置相比的缺点：
- 声明式对象配置难于调试并且出现异常时结果难以理解。
- 使用 diff 产生的部分更新会创建复杂的合并和补丁操作。


### 对象名称和 ID
集群中的==每一个对象==都有一个名称来标识在同类资源中的==唯一性==。

每个 ==Kubernetes 对象==也有一个 UID 来标识在整个集群中的==唯一性==。

比如，在同一个名字空间 中只能有一个名为 myapp-1234 的 Pod，但是可以命名一个 Pod 和一个 Deployment 同为 myapp-1234。

。。就是 类型+名称，唯一。不，还有 api组，名字空间。下面的 名字

对于用户提供的非唯一性的属性，Kubernetes 提供了标签（Label）和 注解（Annotation）机制。

#### 名称
客户端提供的字符串，引用资源 URL 中的对象，如/api/v1/pods/some name。

某一时刻，只能有一个给定类型的对象具有给定的名称。但是，如果删除该对象，则可以创建同名的新对象。

名称在同一资源的所有 API 版本中必须是唯一的。 这些 API 资源通过各自的 API 组、资源类型、名字空间（对于划分名字空间的资源）和名称来区分。 换言之，API 版本在此上下文中是不相关的。

说明：
当对象所代表的是一个物理实体（例如代表一台物理主机的 Node）时， 如果在 Node 对象未被删除并重建的条件下，重新创建了同名的物理主机， 则 Kubernetes 会将新的主机看作是老的主机，这可能会带来某种不一致性。


以下是比较常见的四种资源命名约束。

##### DNS 子域名

很多资源类型需要可以用作 DNS 子域名的名称。 DNS 子域名的定义可参见 RFC 1123。 这一要求意味着名称必须满足如下规则：
- 不能超过 253 个字符
- 只能包含小写字母、数字，以及 '-' 和 '.'
- 必须以字母数字开头
- 必须以字母数字结尾

##### RFC 1123 标签名
某些资源类型需要其名称遵循 RFC 1123 所定义的 DNS 标签标准。也就是命名必须满足如下规则：
- 最多 63 个字符
- 只能包含小写字母、数字，以及 '-'
- 必须以字母数字开头
- 必须以字母数字结尾


##### RFC 1035 标签名
某些资源类型需要其名称遵循 RFC 1035 所定义的 DNS 标签标准。也就是命名必须满足如下规则：
- 最多 63 个字符
- 只能包含小写字母、数字，以及 '-'
- 必须以字母开头
- 必须以字母数字结尾

##### 路径分段名称

某些资源类型要求名称能被安全地用作路径中的片段。 换句话说，其名称不能是 .、..，也不可以包含 / 或 % 这些字符。


下面是一个名为 nginx-demo 的 Pod 的配置清单：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-demo
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

#### UID
Kubernetes 系统生成的字符串，唯一标识对象。

在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 UID，它旨在区分类似实体的历史事件。

Kubernetes UID 是全局唯一标识符（也叫 UUID）。 UUID 是标准化的，见 ISO/IEC 9834-8 和 ITU-T X.667。



### 标签和选择算符

标签（Labels） 是附加到 Kubernetes 对象（比如 Pod）上的键值对。 
标签旨在用于指定对用户有意义且相关的对象的==标识属性==，但不直接对核心系统有语义含义。 
标签可以用于组织和选择对象的子集。
标签可以在创建时附加到对象，随后可以随时添加和修改。 
每个对象都可以定义一组键/值标签。
每个键对于给定对象必须是唯一的。

```json
"metadata": {
  "labels": {
    "key1" : "value1",
    "key2" : "value2"
  }
}
```

标签能够支持高效的查询和监听操作，对于用户界面和命令行是很理想的。 
应使用==注解记录非识别==信息。


#### 动机

标签使用户能够以松散耦合的方式将他们自己的==组织结构映射到系统对象==，而无需客户端存储这些映射。

服务部署和批处理流水线通常是多维实体（例如，多个分区或部署、多个发行序列、多个层，每层多个微服务）。 
管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。

示例标签：
- "release" : "stable", "release" : "canary"
- "environment" : "dev", "environment" : "qa", "environment" : "production"
- "tier" : "frontend", "tier" : "backend", "tier" : "cache"
- "partition" : "customerA", "partition" : "customerB"
- "track" : "daily", "track" : "weekly"


#### 语法和字符集
标签是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠（/）分隔。 
名称段是必需的，必须小于等于 63 个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾， 带有破折号（-），下划线（_），点（ .）和之间的字母数字。 
前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（.）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（/）。

kubernetes.io/ 和 k8s.io/ 前缀是为 Kubernetes 核心组件保留的。


#### 标签选择算符

通过标签选择算符，客户端/用户可以识别一组对象。标签选择算符是 Kubernetes 中的核心分组原语。

API 目前支持两种类型的选择算符：基于等值的和基于集合的。 标签选择算符可以由逗号分隔的多个需求组成。 在多个需求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑与（&&）运算符。

基于等值的需求

运算符有 =、== 和 != 三种。 前两个表示相等（并且是同义词），而后者表示不相等。例如：
environment = production
tier != frontend

前者选择所有资源，其键名等于 environment，值等于 production。 
后者选择所有资源，其键名等于 tier，值不同于 frontend，所有资源都没有带有 tier 键的标签。























3



































































