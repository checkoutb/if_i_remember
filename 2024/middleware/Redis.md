Redis
2021年11月15日
11:20

[[toc]]

====================================

====================================

zrange  myzset 0 1   返回  第一个，第二个  元素。
0 1  是下标范围，都是闭区间

zrange  myzset (5 10 byscore   返回  分数  >5  <=10  的
zrange  myzset (5 (10 byscore  >5 <10

====================================

====================================

bitmap

====================================

pipeline

====================================

主从，哨兵，cluster
。大多数公司用  cluster (?)

====================================

====================================

# 定时删除，惰性删除。

Redis配置文件中可以设置maxmemory，内存的最大使用量，到达限度时会执行内存淘汰机制。没有配置时，默认为no-eviction

![1](../_resources/2cb4cc8d20f049348b3abe68e2b0cb66.jpg)

====================================

====================================

https://juejin.cn/post/6989108481018036232

Redis只能做缓存？太out了！

# redis: 事实上的分布式缓存标准

redis由于它优秀的处理能力和丰富的数据结构，已经成为了事实上的分布式缓存标准。

redis丰富的数据结构，使得它的业务使用场景非常广泛，加上rdb的持久化特性，它甚至能够被当作落地的数据库使用。在这种情况下，redis能够撑起大多数互联网公司，尤其是社交、游戏、直播类公司的半壁江山。

Redis能胜任存储工作
redis提供了非常丰富的集群模式：主从，哨兵，cluster，满足高可用的需求。
redis提供了  2种  持久化方式：  aof  和  rdb。  常用的是  rdb

通过  bgsave  命令，主进程  会fork  出新进程，回写磁盘。  bgsave  相当于做了一个快照，由于  它没有  WAL  日志  和  checkpoint  机制，  是无法做到实时备份的。如果机器突然断电，那就很容易丢失数据。

幸运的是，redis是内存型数据库，主从同步非常快。如果你的集群维护得好，内存分配的合理，那么除非机房断电，否则  redis的  SLA，会一直维持在  非常高的水平。

听起来不是  绝对可靠，有丢失数据的可能。这在curd的业务中，是无法忍受的。但为什么redis能够满足大多数互联网公司的需求？这是由业务属性决定的。

在决定最大限度使用redis之前，你需要确定你的业务是否有以下的特点：
1. 面向是的  C  端用户，可以根据  用户ID  快速定位到  一类数据，数据集合普遍较小？无大范围查询需求？
2. 是否能忍受内存型数据的成本需求？
3. 是否业务几乎不需要事务操作？

幸运的是，这类业务需求特别的多，比如常见的  社交，游戏，直播，运营类业务，都是可以完全依赖redis的

## redis  应用场景
redis  具有松散的文档结构，丰富的数据类型，能够适应千变万化的schema变更需求，接下来介绍  redis  除了缓存外  的  大量的应用场景。

![1](../_resources/7c31d029ad284db3bc5ccbcc3271acd1.jpg)

### 基本用户数据存储

在传统的数据库设计中，用户表是非常难以设计的，变更的时候会伤筋动骨。使用redis的hash结构，可以实现松散的数据模型设计。某些不固定，验证性的功能属性，可以以  json  形式  直接存储在  hash  的value中。使用  hash结构，可以采用  hget  和  hmget  等命令，只获得自己所需要的数据，在使用上也是非常便捷的。

这种非统计型的，读多写少的  场景，非常适合  kv结构  进行存储。
redis  的  hash  提供了  非常丰富的指令，某个属性也可以通过  hincrby  进行  递增递减，非常方便。

### 实现计数器
对于redis  的key  本身来说，有  incrby  实现  值的  递增递减。
比如：统计某个帖子的  点赞数，存放某个话题的  关注数。存放某个标签的  粉丝数。存储一个大体的评论数，帖子的热度。红点消息数，点赞，喜欢，收藏数  等。

像redis  这种容易出现  热点的业务，传统数据库  肯定撑不住，就需要借助于  内存数据库，  由于redis  的速度非常快，就不用  再采用  传统  db  非常慢的  count  操作，所有这种递增操作  都是  毫秒级的，而且  效果都是实时的。

### 排行榜
本质上是一个  topn  问题

redis  有  zset  结构，使用  跳表  实现的有序列表，  很容易实现  排行榜  一类的问题。当存入  zset  中的数据，达到  千万甚至  亿  级别，依然能保持  非常高的  并发读写，并且  响应很低(5ms以内)。

使用  zadd  增加新记录，我们会使用  排行相关的分数，作为记录的  score值。然后  使用  zrevrange  指令  可以获得  实时的  排行榜数据，而  zrevrank  则可以  非常容易的  获取  用户的实时排名。

### 好友关系
set，  无重复的集合。你可以将  某个用户的关注列表，粉丝列表，双向关注列表，黑名单，点赞列表等，使用  独立的  zset  进行存储。

使用  zadd，zrank  等，  将用户的  黑名单  使用  zadd  添加，  zrank  使用  返回的score  来判断  是否存在  黑名单中。使用  sinter  指令，  获得  A  和  B  的共同好友。

除了好友关系，有着明确黑名单，白名单  业务场景的  数据，都可以使用  set  结构进行存储。  这种业务场景  还有：  用户上传的  通讯录，  计算通讯录的  好友关系等等。

实际使用中，使用  zset  存储这类关系更多一点，  zset  和  set  一样，都不允许都重复值，但是  zset  多了一个  score  字段，我们可以存储一个  时间戳，用户表明  关系建立的  时间。

### 统计活跃用户数

类似  统计每天的活跃用户，用户签到，用户在线状态，这种零散的  需求，实在太多了，  如果为  每一个  用户  存储  一个  bool  变量，那么占用的空间  就太多了。这种情况下，  我们可以使用bitmap  结构  来节约  大量的存储空间。

注意，如果你的id  很大，你需要先进行一次  预处理，否则它会占用  非常多的内存。
bitmap包含一串连续的  二进制数字，用  1bit  来表示  真假。  bitmap上可以使用  and, or, xor  等。

### 分布式锁
redis  的分布式锁，是一种  轻量级的  解决方案。  虽然可靠性比不上  zookeeper。但redis  分布式锁  有着极大的吞吐量。

最简单的加锁动作，可以使用  redis  的  带  nx  和  px  参数的  set  指令完成：
```Java
public String lock(String key, int timeOutSecond) {
    for (; ; ) {
        String stamp = String.valueOf(System.nanoTime());

        boolean exist = redisTemplate.opsForValue().setIfAbsent(key, stamp, timeOutSecond, TimeUnit.SECONDS);

        if (exist) {
            return stamp;
        }
    }
}
public void unlock(String key, String stamp) {
    redisTemplate.execute(script, Arrays.asList(key), stamp);
}
```

redisson  的  RedLock，  是  使用  最普遍的  分布式锁  解决方案，有读写锁的  差别，并处理了  多redis  实例情况下  的异常问题。

### 分布式限流

使用计数器  实现  简单的限流，在redis  中非常方便，只需要  使用  incr  配置  expire  指令  即可。
 incr key
 expire key 1

这种简单实现，通常不会有问题。但是流量比较大的情况下，在时间跨度上  会有  流量突然飙升的  风险。根本原因，就是这种  时间  切分方式  太固定了，没有类似  滑动窗口  这种平滑的  过度方案。

同样是  redisson  的  RRateLimiter，  实现了和  guava  中  类似的   分布式  限流工具类，下面是  使用的例子：
```Java
 RRateLimiter limiter = redisson.getRateLimiter("xjjdogLimiter");
 // 只需要初始化一次
 // 每2秒钟5个许可
 limiter.trySetRate(RateType.OVERALL, 5, 2, RateIntervalUnit.SECONDS);

 // 没有可用的许可，将一直阻塞
 limiter.acquire(3);
```

### 消息队列

redis  可以实现简单的  队列。在生产者端，使用  lpush  加入到  某个列表中；在消费端，不断地使用  rpop  取出这些数据，或  使用  阻塞的  brpop  指令获得数据，适合小规模的  抢购需求。

redis  还有  pub/sub  模式，不过  pub/sub  更适合  做  消息广播  之类的  业务。

redis  5  ，增加了  stream  类型的  数据结构，类似于  kafka，有主题  和消费组的  概念，可以实现  多播  及  持久化，  已经能满足大多数  业务需求了。

### LBS应用

在redis  3.2，就推出了  GEO  功能，通过  geoadd  指令  追加  lat,lng  经纬数据，可以实现  坐标之间的  距离计算，包含  关系计算，附近的人  等功能。

GEO功能，最强大的开源方案是  PostgreSQL  的  PostGIS，  但是对于一般规模的GEO服务，redis  已经足够了。

### 更多扩展应用场景

redisson  包含了丰富的  分布式数据结构，全部是  基于  redis  进行设计的。

redisson提供了

比如Set、 SetMultimap、 ScoredSortedSet、 SortedSet, Map、 ConcurrentMap、 List、 ListMultimap、 Queue、BlockingQueue等非常多的数据结构，使得基于redis的编程更加的方便。在github上，可以看到有上百个这样的数据结构:

https://github.com/redisson/redisson/tree/master/redisson/src/main/java/org/redisson/api

redis  基于内存，速度非常快，我们可以把它当做一个  中间数据的  存储仓库  去使用。比如  一些  公用的配置，放到redis  中进行  共享，它就充当一个  配置中心的  作用；  比如把  JWT  的令牌  放到  redis  中，就可以突破  jwt  的一些限制，做到  安全登出。

## 一站式redis面临的  挑战

redis的数据结构丰富，一般不会在功能性上  造成困扰。但是随着  请求量的  增加，SLA  要求的  提高。我们势必要对  redis  进行一些改造和  定制型开发。

### 高可用挑战
redis  提供了  主从，哨兵，cluster，3种  集群模式，  cluster模式  是目前大多数公司使用的  方式。

但是redis  的  cluster  模式，也有不少硬伤。  redis cluster  采用虚拟槽  的概念，把所有的  key  映射到  0~16383  个整数槽内，属于  无中心化的架构，但  它的  维护成本  较高，slave  也不能够参与  读取操作。

它的主要问题是，在于  一些批量操作的  限制。  由于key  被  hash  到  多台机器上，所以  mget,hmset,sunion  等操作  就非常的不友好，经常发生  性能问题。

redis  的主从模式  是最简单的  模式，但是无法做到自动  failover (容错，故障切换)。通常在主从切换后，还需要修改业务代码，这是不能忍受的。即使  加上  haproxy  这样的  负载均衡组件，复杂性也是非常高的。

哨兵模式，在  主从数量较多时，能  显著  体现它的价值。  一个哨兵集群，能够监控成百上千个  集群，但是  哨兵集群  本身的  维护比较困难。
幸运的是，redis  的文本协议  非常简单，在netty中，甚至直接提供了  redis的  codec。自研一套哨兵系统，加强它的功能，是可行的。

### 冷热数据分离

redis  的特点是，不管什么数据，都一股脑地  放到内存中  做计算，这对于有  时间序列  概念，有  冷热数据之分的  业务，造成了非常大的  成本考验。

为什么大多数开发者  喜欢把  数据存放在  MySQL中，而不是  redis中？  除了  事务性要求外，很大原因  是  历史数据的问题。

通常，这种  冷热数据的切换，是由  中间件完成的。  之前说到了，redis是一个  文本协议，非常简单。做一个中间件，或者做一个  协议兼容的  redis  模拟存储，是比较容易的。

比如redis中，只保留  最近一年的活跃用户。  一个好几年不活跃的  用户，访问系统，这时，我们获取数据时，就需要  中间件  进行转换，从  容量更大，速度更慢的存储中查找。

此时，redis  的作用，更新是一个  热库，更新是  传统cache  层做的事情，发生在  业务已经  上规模的时候，但是注意，直到此时，我们的  业务层代码，一直都是操作  redis  的  api。它使用  众多的  函数指令，并不关心  数据  到底  存储在  redis  中，还是  ssdb中。

### 功能性需求

redis  还有很多功能，如，全文搜索，很多人首选  es，但是  redis  提供了一个  模块：  RediSearch，可以做查询，可以做filter。

但是我们通常还有  更多的需求，比如  统计类，搜索类，运行效果分析  等。这类需求与  大数据相关，即使是  传统的  db  也不能胜任。  这时候，要把  redis中的数据，导入到其他平台进行计算。

如果你选择redis  数据库，那么  和  dba  打交道的  就是  rdb，而不是  binlog。有很多  rdb  解析工具  (如  redis-rdb-tools)，  能够定期把  rdb  解析为  记录，导入到  hadoop  等其他平台。

此时，rdb  称为所有团队的  中枢，成为基本的数据交换格式。  导入到其他db  后的业务，一切照旧，不会因为  业务系统使用了  redis  就无法运转。

## 总结
某些数据，并不是一定要  落地到  RDBMS  才算安全，它们并不是一个  强需求。

如果一个业务系统，每次交互的数据，都是一个  非常大的结果集，并且  涉及复杂的  统计，过滤  工作，那么  RDBMS  是必须的。  但是如果一个系统，能够通过某个表示，快速定位到一类数据，这一类数据在可以预见的  未来，是有限的，那就非常适合  redis。

电商，使用redis  作为存储就是  找死。  但是  社交系统就可以。

合适的场景使用合适的工具。

====================================

====================================

====================================

====================================

====================================

====================================

====================================

====================================

====================================

====================================

已使用 Microsoft OneNote 2016 创建。




# redis 集群

单机都会存在单点故障，
。。墨菲定律

为了高可用，分布式服务就出现了。

redis也是，为了解决单机故障引入了==主从模式==。但有一个问题：需要==人为的手动==将slave节点切换成为maser节点后服务才恢复。
然后引入了 哨兵模式，可以在 master 节点故障后，自动将salve节点提升成master节点，不需要人工干预操作就能恢复服务可用。

主从模式、哨兵模式都没有达到真正的数据sharding存储，每个redis实例中存储的都是全量数据，所以redis cluster就诞生了，实现了真正的数据分片存储。但是由于redis cluster发布得比较晚(2015年才发布正式版 )，各大厂等不及了，陆陆续续开发了自己的redis数据分片集群模式，比如：Twemproxy、Codis等。


## 主从模式
redis单节点可以通过 ==RDB 和 AOF 持久化机制== 将数据持久化到 硬盘上，但数据是存储在一台服务器上的，如果服务器出现硬盘故障等问题，会导致数据不可用，而且读写无法分离，读写都在同一台服务器上，请求量大时会出现I/O瓶颈。

为了避免单点故障 和读写不分离，Redis 提供了复制（replication）功能实现master数据库中的数据更新后，会自动将更新的数据同步到其他slave数据库上。

redis主从结构特点：==一个master==可以有多个salve节点；==salve节点可以有slave节点==，从节点是级联结构。

### 优点
具有读写分离，提高效率、数据备份，提供多个副本等优点

### 缺点
不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预。

### 操作
在从数据库中使用SLAVE NO ONE命令将从数据库==提升成主数据==继续服务。

启动之前崩溃的主数据库，然后使用SLAVEOF命令将其设置成新的主数据库的==从数据库==，即可同步数据。


## 哨兵模式

从2.6版本开始，2.8稳定

哨兵模式核心还是主从复制，只不过在相对于主从模式在主节点宕机导致不可写的情况下，多了一个竞选机制：从所有的从节点竞选出新的主节点。竞选机制的实现，是依赖于在系统中启动一个sentinel进程。

哨兵本身也有单点故障的问题，所以在一个一主多从的Redis系统中，可以使用==多个哨兵==进行监控，哨兵==不仅会监控主数据库和从数据库，哨兵之间也会相互监控==。每一个哨兵都是一个独立的==进程==，作为进程，它会独立运行。

故障切换：当哨兵监测到master宕机，会自动将slave切换成master，然后通过==发布订阅模式==通知其他的从服务器，修改配置文件，==让它们切换master==。同时那台有问题的旧主也会变为新主的从，也就是说当旧的主即使恢复时，并不会恢复原来的主身份，而是作为新主的一个从。

### 实现原理
哨兵在启动进程时，会读取配置文件的内容，通过如下的配置找出需要监控的主数据库：
```
sentinel monitor master-name ip port quorum
#master-name是主数据库的名字
#ip和port 是当前主数据库地址和端口号
#quorum表示在执行故障切换操作前，需要多少哨兵节点同意。
```

只需要连接主节点，是因为通过主节点的info命令，获取从节点信息，从而和从节点也建立连接，同时也能通过主节点的info信息知道新增从节点的信息。


一个哨兵节点可以监控多个主节点，但是并不提倡这么做，因为当哨兵节点崩溃时，同时有多个集群切换会发生故障。哨兵启动后，会与主数据库建立两条连接:
1. 订阅主数据库_sentinel_:hello频道以获取同样监控该数据库的哨兵节点信息
2. 定期向主数据库发送info命令，获取主数据库本身的信息。

跟主数据库建立连接后会定时执行以下三个操作：
（1）每隔10s向master和 slave发送==info==命令。作用是获取当前数据库信息，比如发现新增从节点时，会建立连接，并加入到监控列表中，当主从数据库的角色发生变化进行信息更新。
（2）每隔2s向主数据里和从数据库的==_sentinel_:hello==频道发送自己的信息。作用是将自己的监控数据和哨兵分享。每个哨兵会订阅数据库的_sentinel:hello频道，当其他哨兵收到消息后，会判断该哨兵是不是新的哨兵，如果是则将其加入哨兵列表，并建立连接。
（3）每隔1s向所有主从节点和所有哨兵节点发送==ping==命令，作用是监控节点是否存活。


### 主观下线和客观下线

哨兵节点发送ping命令时，当超过一定时间(down-after-millisecond)后，如果==节点未回复==，则哨兵认为==主观下线==。
主观下线表示当前哨兵认为该节点已经下线，
如果该节点为==主==数据库，哨兵会进一步判断是够需要对其进行故障切换，这时候就要发送命令(SENTINEL is-master-down-by-addr)==询问其他哨兵节点==是否认为该主节点是主观下线，当达到指定数量(quorum)时，哨兵就会认为是==客观下线==。

。。我认为你下线了， 大部分人都认为你下线了


当主节点==客观下线==时就需要进行==主从切换==，主从切换的步骤为：
1. 选出领头哨兵。
2. 领头哨兵所有的slave选出优先级最高的从数据库。优先级可以通过slave-priority选项设置。
3. 如果优先级相同，则从复制的命令偏移量越大（即复制同步数据越多，数据越新），越优先。
4. 如果以上条件都一样，则选择run ID较小的从数据库。

选出一个从数据库后，哨兵发送slave no one命令升级为主数据库，并发送slaveof命令将其他从节点的主数据库设置为新的主数据库。


### 优缺点

优点
哨兵模式是基于主从模式的，解决可主从模式中master故障不可以自动切换故障的问题。

缺点
是一种==中心化的集群==实现方案：始终==只有一个Redis主机==来接收和处理==写请求==，写操作受单机瓶颈影响。

集群里所有节点保存的都是==全量数据，浪费内存空间==，没有真正实现分布式存储。数据量过大时，==主从同步严重影响master的性能==。

Redis主机宕机后，哨兵模式正在投票选举的情况之外，因为投票选举结束之前，谁也不知道主机和从机是谁，此时Redis也会开启保护机制，==禁止写操作==，直到选举出了新的Redis主机。


## 各大厂的redis 集群方案

redis 3.0 之前只支持 单实例模式。

。。这里大概了解下， redis 3.0 是2015年出的，这些集群方案应该都 不怎么用了。

### 客户端分片
把分片的逻辑放在Redis客户端实现
通过Redis客户端预先定义好的路由规则(使用==一致性哈希==)，把对Key的访问转发到不同的Redis实例中，查询数据时把返回结果汇集


### 代理分片
redis代理分片用得最多的就是Twemproxy，由Twitter开源的Redis代理，其基本原理是：通过中间件的形式，Redis客户端把请求发送到Twemproxy，Twemproxy根据路由规则发送到正确的Redis实例，最后Twemproxy把结果汇集返回给客户端。


Twemproxy不能平滑增加Redis实例的问题带来了很大的不便，于是豌豆荚自主研发了==Codis==，一个支持平滑增加Redis实例的Redis代理软件，其基于Go和C语言开发，并于2014年11月在GitHub上开源。


## Redis Cluster

哨兵模式的不足：
每台redis存储相同的数据，浪费内存；当数据量太大时，主从同步影响master性能
是中心化的集群实现方案，每个从机和主机的耦合度很高，master宕机 到 slave 选举master恢复 期间服务不可用
只有一个redis主机来接收和处理写请求，写操作受到单机瓶颈，没有真正实现分布式架构。


redis在3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的数据。cluster模式为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。


Redis Cluster是一种服务器Sharding技术(分片和路由都是在服务端实现)，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。Redis Cluster集群采用了P2P的模式，完全去中心化。


官方推荐，集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式。


Redis Cluster集群具有如下几个特点
1. 集群完全去中心化，采用多主多从；所有的redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
2. 客户端与 Redis 节点直连，不需要中间代理层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。
3. 每一个分区都是由一个Redis主机和多个从机组成，分片和分片之间是相互平行的。
4. 每一个master节点负责维护一部分槽，以及槽所映射的键值数据；集群中每个节点都有全量的槽信息，通过槽每个node都知道具体数据存储到哪个node上。

redis cluster主要是针对海量数据+高并发+高可用的场景，海量数据，如果你的数据量很大，那么建议就用redis cluster，数据量不是很大时，使用sentinel就够了。redis cluster的性能和高可用性均优于哨兵模式。

Redis Cluster采用虚拟哈希槽分区而非一致性hash算法，预先分配一些卡槽，所有的键根据哈希函数映射到这些槽内，每一个分区内的master节点负责维护一部分槽以及槽所映射的键值数据。



# 分布式锁命令

setnx 和 expire 是不能 原子性的。需要使用 `set key value [EX seconds] [PX milliseconds] [NX|XX]`
EX是失效时长，单位秒
PX是失效时长，单位毫秒
NX：key不存在时设置 value，成功则返回 OK，失败返回 (nil)
XX：key存在时设置 value。



# 哨兵，集群

哨兵 

是高可用性的 解决方案，通过选举 一个 主服务器 和 多个 从服务器 来提供 数据冗余 和 故障转移。

哨兵 监控这些 redis服务器，一旦 主服务器 发生故障，哨兵会自动将 一个从服务器 升级为 新的 主服务器。

主要特点
- 自动故障转移， 当主服务器不可用时，自动 从 从服务器中 选举出 主服务器
- 监控和通知， 哨兵可以监控 redis服务器的状态，并在 发生故障时 发送通知
- 配置简单， 相对于 集群模式，配置 简单，适合 中小型 应用

---

集群

提供 高可用性 和 高性能的 分布式数据库解决方案

数据被 ==分散存储== 到多个节点上， 这些节点共同组成一个 redis集群。每个节点都存储数据的 一个子集， 并且可以处理客户端的请求。

主要特点
- 水平扩展， 通过增加更多的节点 来扩展 存储容量和 处理能力
- 自动分片， 数据自动在多个节点间 分片，提高性能和可用性
- 无中心架构， 所有节点都是 对等的，没有中心节点
- 支持多建操作， 可以执行跨多个键的操作，如事务和多键命令

