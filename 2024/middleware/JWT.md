JWT
2021年12月30日
8:37

JSON  Web Token

授权  Authorization，最常见场景，一旦用户登录，后续每个请求都将包含JWT。

信息交换  Information Exchange

=======================

3部分组成，之间用  .  连接
Header，Payload，Signature

Header  通常由2部分组成，token类型  和  算法名称，如
{
"alg":"HS256",
"typ":"JWT"
}
对这个JSON  进行base64  就获得  JWT  第一部分。

Payload，包含声明(要求)。声明是关于  实体(通常是用户)  和其他数据的  声明，声明有3种类型：registered，public，private。

Registered  claims:  有一组预定义的声明，非强制，但推荐，如iss(issuer),exp(expiration time),sub(subjext),aud(audience)  等。

iss: jwt签发者
sub: jwt所面向的用户
aud: 接收jwt的一方
exp: jwt的过期时间，这个过期时间必须要大于签发时间
nbf: 定义在什么时间之前，该jwt都是不可用的.
iat: jwt的签发时间
jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。

Public claims:  可以随意定义
Private claims:  用于在  同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。

{
"sub":"12345",
"name":"John",
"admin":true
}
对payload，base64  就获得  JWT  第二部分。

不要在  JWT的  header，payload  中放置敏感信息，除非它们是加密的。

Signature

为了得到  签名部分，你必须有编码过的  header  和payload，  一个秘钥，  使用header中指定的签名算法，对它们签名即可。

HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

签名是用于  验证消息  在传递过程中有没有被更改，并且对于私钥签名的token，它还可以验证JWT的发送方是否是它所宣称的发送方

。。。第三部分是什么？是  1+2+3  的  整体  的加密？  等于就是  b64(1).b64(2).SHA256(1+2+3)  ?
。。。不，HMACSHA256  的第一个参数是  1+2，  第二个参数是  3，  但是不知道  第一个参数用来干什么。而且  秘钥。。
。。ok，只是一个签名。。secret  就是秘钥，  把1+2  加密下。

。。那岂不是  JWT  放不了  敏感信息了？

=======================

认证

当用户  用他们的凭证  成功登陆以后，  一个JSON Web Token  被返回。此后，token就是用户凭证了，必须小心  以防止出现安全问题。一般来说，保存令牌的时候不应该超过你所需要它的时间。

无论何时  用户想要访问  受保护的路由  或者资源的时候，  用户代理(通常是浏览器)  都应该带上JWT，一般，通常放在  Authorization header，用  Bearer schema。

Authorization:  Bearer

服务器上  受保护的路由  会检查  Authorization header  中的JWT  是否有效，如果有效，则用户可以访问受保护的资源。如果JWT  包含足够多的必须的数据，那么就可以减少  对某些操作的  数据库查询的需要。

如果token  在  Authorization header中  发送，那么  跨资源共享(CORS)  将不会成为问题，因为它不使用cookie。

=======================

基于服务器的身份认证

HTTP协议是无状态的，所以  如果我们认证了一个用户，他下一次请求的时候，服务器不知道他是谁，所以必须再次认证。

传统做法是将已认证过的用户信息  保存到服务器上，比如Session，用户下次请求的时候带着Session ID，  服务器以此来检查用户是否认证过

缺点：
Sessions：每次用户认证过后，服务器需要创建一条记录保存用户信息，通常是内存中，随着用户越来越多，内存消耗也越来越大。
Scalability：Session是内存中的，带来了扩展性的问题

CORS：当我们要扩展我们的应用，让我们的数据  在多个移动设备使用时，我们必须考虑  跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。

CSRF：用户很容易受到CSRF攻击。

====================

JWT  和  Session的差异
相同点：都存储用户信息，然而，Session在服务器端的，JWT在客户端的。

JWT将用户状态分散到客户端中，可以明显减轻服务端的内存压力。

=======================

基于Token的身份认证是如何工作的

基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息。

没有Session信息，意味着应用程序可以根据需要扩展和添加更多的机器，而不必担心用户登录的位置。

具体实现可能不同，但是主要流程：
用户携带用户名和密码请求访问
服务器校验用户凭据
应用提供一个token  给客户端
客户端存储token，并且在随后的每一次请求中都带着它
服务器校验token  并返回数据

注意
每次请求都要带token
Token应该放在header中
还需要将服务器设置为  接受来自所有域的请求，用  Access-Control-Allow-Origin:*

Token的好处：
无状态和可扩展性：Tokens存储在客户端，完全无状态，可扩展。负载均衡器可以将用户请求传递到任意服务器，因为在任何地方都没有状态或会话信息

安全：Token不是Cookie。每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使你在实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话。

token在一段时期后会过期，这个时候用户需要重新登录，这有助于我们保持安全。

token撤销：允许我们根据相同的授权许可  使特定的token  甚至一组token  无效。

=======================

JWT  和  OAuth  的区别

OAuth2  是一种  授权框架，JWT  是一种认证协议。

无论哪种方式，切记使用  HTTPS  来保证数据的安全性。

OAuth2  适用于  使用第三方账号登录的情况，JWT用于  前后端分离，需要简单的对后台API进行保护时使用。

=======================

Session  的问题

Session在内存中，用户多，开销大。

扩展性，在内存中，意味着  用户的下一次请求  还需要  被这台服务器处理  才能拿到  授权的资源。

CSRF，因为是基于Cookie来进行用户识别的，如果Cookie被截获，用户很容易受到  跨站请求伪造的  攻击

=======================

跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

=======================

已使用 Microsoft OneNote 2016 创建。