软件架构-架构模式特征及实践指南

2024-05-08 13:21

[[toc]]

---
---

# 前言

软件开发生态系统处于一个恒定的动态平衡状态：尽管在任何给定的时间点都处千平衡状态，但在长期内表现出动态行为。
像 Kubemetes 这样的工具在十年前还不存在，但是现在甚至有了Kubemetes 用户大会。软件生态系统的变化是混沌的： 个小变化引起另一个小变化，如此重复数百次就会产生一个新的生态系统。


# ch1 概述


![e4b5984ff3099077080de2f3d33e5764.png](../_resources/e4b5984ff3099077080de2f3d33e5764.png)


与许多艺术品一样，架构只能在上下文中理解


软件架构由 结构，架构特征，架构决策，设计原则 组成

系统的 ==结构== 是指 实现该系统的一种或多种架构风格，比如，微服务，分层，微内核。

==架构特征==是 定义软件架构的 另一个维度，它定义了 系统的成功标准，这些标准往往与系统的 功能正交。 注意，在 理解 架构特征时，不需要 了解系统的功能，但它们却是 系统能正常工作所必须的。
架构特征指系统必须支持的功能：可用性，可靠性，可测试性，可伸缩性，安全性，敏捷性，容错性，弹性，可恢复性，性能，可部署性，可学习性

另一个维度是 ==架构决策==，它定义了一组 关于如何构建系统的规则，如，在一个分层架构中，架构师可能会规定 只有 业务层和 服务层可以访问数据库，限制 表现层直接调用数据库。架构决策 构成了 系统约束，并指导开发团队 哪些可以做，哪些不可以做。
如果由于某些条件 或约束的限制，导致无法在系统的某一部分执行特定的结构决策，那么可以通过 差异 来打破该规则。差异需要经过 首席架构师 或 架构审查委员会 的 批准。

设计原则 与架构决策的不同之处在于，设计原则 是 指导原则，不是 必须遵守的。比如，微服务之间主要通过MQ通信，但是允许开发人员使用 REST或 RPC


## 1.2 架构师的角色期望

对软件架构师有 8项核心期望
- 制定架构决策
- 持续分析架构
- 掌握最新趋势
- 确保决策被遵守
- 丰富的经历和经验
- 具备业务领域知识
- 具备人际交往能力
- 了解并驾驭(企业)政治

指导是第 个期望中的关键词。架构师应当指导而不是指定技术选择
。。但是书上，1.2.1 是 制定架构决策，和 指导 没有关系啊


1.2.5 丰富的经历和经验

如今大多数环境都是异构环境，架构师至少应该知道如何与多个系统和服务进行交互，无论它们是用什么语言、平台和技术实现的。

掌握这条期望的最佳方法之 就是不断地走出舒适区。
仅仅专注于一个技术或平台是不行的，一个称职的软件架构师应当积极寻找机会通过接触多种语言、 平台和技术来积累经验。
掌握这条期望的一个好方法就是专注千技术广度，而不是技术深度。
例如，对于一个架构师来说，熟悉 10 种不同的缓存产品以及每种缓存产品的利弊远比精通 种缓存产品要有价值得多


1.2.6 具备业务领域知识

想象一下，身为一个大型金融机构的架构师却不了解平均趋向指数、射幸合同、利率反弹、非优先债务等常见的财务术语。不专业的架构师无法得到利益相关者和业务用户的信任，毫无竞争力。


1.2.7 具备人际交往能力
作为技术人员，开发人员 和架构师 喜欢解决技术问题，而不是人的问题。然而正如 Gerald Weinberg 所说的："无论他们怎么说，总会存在人的问题"
无论架构师扮演的角色是什么，领导力都是必不可少的。
许多架构师都是优秀的技术人员，但由于无法带领团队(包括不能辅导和引导开发人员，不能有效地就 想法，架构决策和原则 与开发人员沟通) 而无法称为一个 称职的架构师。


## 1.3 与架构的交集

1.3.1 工程实践

传统上，软件架构和 软件开发 是分开的。 流行的软件开发方法有 数十种，包括：瀑布模型 和 许多敏捷方法论 ( Scrum, 极限编程，Lean，Crystal), 大多数情况下，这些方法论 不会影响 软件的架构

将软件开发流程 和 工程实践分开 是很有必要的。 
流程是指 如何组建 和 管理团队，如何召开会议，如何组织工作流程， 是指 人们相互组织 和 互动的机制。
软件工程实践 是与流程无关的，可以被重复执行，并且不断产生价值的 时间。例如，持续集成是一种行之有效的工程实践，不依赖特定的流程。

==极限编程(XP)== 是 将精力集中到 能使 项目成功的 实践上，并将这些实践 推到极致。 XP中将测试 实践到了极致：测试先行的开发。
XP又和其他敏捷流程集合到一起，在 DevOps中取得成果。DevOps 发生于 运营部门开始采用一些 XP的工程实践，如，自动化，测试，声明式单一数据源。


软件开发的 致命弱点之一 就是 估算，即 需要多少时间，资源，开销。

由于存在未知的位置，所有的架构都将变得迭代，敏捷只是意识到了这一点，并且提早做到了而已。


1.3.3 流程

架构的另一个关键点是 重组，这也是敏捷方法出众的地方。 团队经常需要将 架构从一种模式 迁移到 另一种模式。
敏捷方法强调更快速的 反馈循环，并鼓励采用 诸如 绞杀者模式 和 特性开关 这样的技术，因此可以更好地 支持架构迁移。

。。==绞杀者模式==： 来源于 绞杀者藤蔓，藤蔓沿着树干生长，最终遮蔽太阳，导致树死亡，腐烂，原地留下一颗树状的巨大藤蔓。
通过逐步 重构单体应用，逐渐构建出 一个新的应用程序。

。。特性开关：功能开关(新代码已经上生产，只能设置变量(开关)值)，AB测开关，运维开关(对于新功能，根据负载，可以决定禁用或降级；对于老功能，也可以降级)，权限开关(VIP，VVIP，新功能对某些用户开放)


## 1.4 软件架构定律

软件架构中的一切都是在做权衡。如果你发现了 不需要做权衡的东西，那么很有可能是 还没有发现 要舍弃的东西 而已。

原因比方法重要。



# ch2 架构思维

太多的架构师认为，架构思维只是"思考架构"
架构思维远不止于此。它是指 用架构的眼光 或 视角 来看待事物。

架构思维有4个 重要的方面
- 要明白架构和设计之间的区别，==了解如何与开发团队合作，进而使架构顺利落地==
- 需要在具备技术广度的同时，仍然保持一定水平的技术深度，这可以使架构师察觉到 其他人察觉不到的解决方案 和可能性
- 需要理解，分析，协调 各种解决方案 和技术之间的 权衡
- 需要了解 业务驱动的 重要性 以及 它们是如何转化为 架构问题的。




## 2.1 架构与设计

架构师，负责分析业务需求 以提取 和定义 架构特征，选择适合 该问题的 架构模式 和 架构风格，以创建组件 (即 系统的组成部分)
然后交给开发团队，开发团队 负责为 每个组件 创建类图，构建用户界面 以及开发和测试。
上面的传统模型(架构师交给开发团队) 是单向的， 隔离了 架构师 和 开发团队， 开发团队 对于 架构的改动 很少 反馈给 架构师。
为了使 架构落地，必须打破 架构师 和 开发人员 之间的 所有障碍，使得 架构师 和 开发团队 之间 形成 双向的强关联。
。。就是要 双向交流


## 2.2 技术广度

已知，已知的未知，未知的未知。

掌握的，听过的但不会，完全不知道的

架构师的技术广度比深度更重要。

冰封原始人反模式，架构师在 设计架构时，总处于 一种 非理性的担忧状态( 几年前的那次意外再次出现的话，该怎么办？这种 出现概率极小的问题。)。


## 2.3 分析权衡

架构师 需要在 每种 解决方案中进行 取舍。 需要分析利弊，确定最佳解决方案。

所谓的架构是不能通过 Google得到的

架构取决于 部署环境，业务驱动因素，公司文化，预算，时间表，开发人员技能集 等。

架构中没有对错，只有取舍


## 2.4 理解业务驱动因素

要理解业务驱动因素，并转为 架构特征(如 可伸缩性，性能，可用性)

## 2.5 平衡架构和动手编码

1. 将关键路径和框架代码委派给开发团队中的其他人，然后着重于实现业务功能(一个服务或一个页面)，并在1-3个迭代中完成。

2. 频繁进行 概念验证， 不仅需要写代码，还需要 考虑实现细节来帮助 验证架构决策。例如，2个缓存方案的取舍，解决方案之一就是 为每种方案 编写一个 可行的示例，并比较结果。

3. 处理技术债 或架构相关的故事问题，让开发团队 有更多时间 来处理 关键的功能性的用户故事。
4. 在迭代中修复bug
5. 创建简单的命令行工具 和 分析器 来进行自动化 帮助 开发团队完成日常任务。
6. 频繁的代码审查



# ch3 模块化

所有平台都支持 将代码 分组到模块。
模块的概念是通用的，但是没有 统一的定义。

在开发平台中了解 模块化 及其 多种形式，对于 架构师 至关重要。
分析架构的 许多工具 (例如，度量指标，适应度函数 和 可视化) 都依赖于 这些模块化 概念。

模块化是一种 组织原则

## 3.1 定义

词典中，模块是 可用于构建更复杂结构的一组标准化零件 或独立单元 中的一个

我们使用 模块化 来描述代码的 逻辑分组，这个逻辑分组可以是 面向对象语言中的 一组类，也可以是 结构化语言 和函数式语言 中的 函数。
大多数语言提供了模块化的机制， java 的package，c#的 namespace。
开发人员通常使用 模块 作为 将相关代码分组在一起的 一种方式。

各种语言有各种各样的打包机制，这使开发人员很难做出选择。

架构师必须了解 开发人员是如何规划包的，因为它在 架构中有重要意义。


## 3.2 度量模块化：内聚性，耦合，共生性

3个关键概念： 内聚性，耦合，共生性

3.2.1 内聚性

度量模块中 各部分的关联度高低

内聚性从好到坏：
- 功能内聚性
  各部分互相关联，且模块包含了 功能所需的所有内容
- 顺序内聚性
  2个模块相互交互，一个模块的输出是另一个模块的输入
- 通信内聚性
  2个模块构成了一条通信链，每个模块都基于信息 进行操作。
- 程序内聚性
  2个模块必须以 特定顺序执行代码
- 时间内聚性
  模块基于时序以来，如，有些模块必须初始化后使用
- 逻辑内聚性
  模块内的数据在逻辑上相似，但功能上无关。
- 偶然内聚性
  除了位于相同的源文件中，模块中的元素 互不相关。


考虑到 内聚性的主观性，计算机科学家 已经开发了一套 结构化 度量内聚性的方法。称为 ==CK== 。 用来度量 面向对象的软件系统的 特定部分。包括了许多常见的 代码度量标准。

。。就是 sonar？ 静态分析工具？  百度了下，没有ck的 信息。   ck上世纪的东西，应该没有意义了

。英文版也是 2020年的，但是 ck。。。


3.2.2 耦合

我们有更好的工具来分析代码库中的耦合

方法调用可以形成调用图，所以基于数学的分析成为可能。
1979年 Edward Yourdoo 和 Larry Constantine 出版了 Structured Design: Fundamentals of a Discipline of Compu-ter Programand Systems Design (Prentice-Hall) ，其中定义了许多核心概念
包括传入耦合，传输耦合，传入耦合是指 测量代码工件的 输入连接数，传出耦合是指 测量用于 连接到其他代码工件的输出连接。

。。。

。。太抽象了。跳了

3.2.3 抽象性 不稳定性以及与主序列的距离

3.2.4 与主序列的距离

3.2.5 共生性

1996年，命名 共生性，定义： 如果一个组件的变更需要修改另一个组件 才能保持系统的 整体正确性，则2个组件是 共生的。

分为 静态共生(源码级别的耦合)，动态共生(运行时调用)





# ch4 现有的架构特征

架构师 在定义领域 或 业务需求时 可以与他人合作，但是有一项 职责 与领域功能不直接相关，而 需要定义，发现，分析软件 必须包含的 全部功能，那就是 架构特征。

架构特征满足 3个标准
- 明确 非领域设计的 某个注意事项
  在设计应用时， 需求指定了 应用应该做什么， 架构特征 指定了 成功的操作和设计标准，设计如何实现需求以及为何做出某些决策。例如一个常见的架构特征 为 应用指定了 一定的 性能水平，这通常不会出现在需求文档中
- 影响设计的某些结构项
  此架构特征是否需要特殊的结构才能成功？例如，安全性，需要 所有系统都必须在设计和编码时符合预防措施的标准
- 是否对应用的成功至关重要



## 4.1 部分已经罗列出来的架构特征

4.1.1 运营性架构特征

- 可用性
  需要多长时间可用(24*7的话，需要一些措施来使得系统在故障时 能快速恢复，启动，运行)
- 连续性
  灾难恢复能力
- 性能
  压力测试，峰值分析，响应时间，所需容量。
- 可恢复性
  业务连续性要求,例如，灾难时，需要多长时间可以重新上线。这将影响 备份策略 和对 冗余硬件的要求
- 可靠性/安全性
  系统是否会发生 有严重影响的事故
- 健壮性
  网络中断，断电，硬件故障，能够在 运行时处理错误 和边界条件
- 可伸缩性
  随着用户/请求 的上升，系统的执行和操作能力。


4.1.2 结构性架构特征

- 可配置性
  最终用户可以 轻松地 (通过可用的界面) 更改软件的各项配置
- 可扩展性
  能方便插入新功能
- 可安装性
  易于在所有必要的平台上安装
- 可利用性/可重复使用性
  跨多个产品 复用组件
- 本地化
  输入输出 支持多种语言，度量单位，货币
- 可维护性
  易于更改和增强引用
- 可移植性
  是否需要在 多个平台上运行
- 可支持性
  应用需要什么级别的技术支持，调试错误需要什么级别的日志和其他功能
- 可升级性
  能将 之前的版本 方便地 升级到最新版本


4.1.3 跨领域架构特征

- 可访问性
  视力障碍，听力障碍
- 可归档性
  一段时间后 是否需要归档 或删除数据 (例如，客户账户 将在3个月后删除 会 标记为过时 冻结)
- 认证
  验证用户的身份
- 授权
  确保用户只能访问某些功能
- 法律
  
- 隐私性
  能够向公司内部人员 隐藏信息 (如 密码保留 加密后的)
- 安全性
  是否要在 数据库中对 数据加密？内部系统通信是否需要加密？远程用户访问需要使用哪种身份验证？
- 可支持性
  应用需要什么级别的技术支持？
- 易用性/可实现性
  用户易于使用应用


ISO发布一个列表
- 性能效率
  时间(响应，处理，吞吐量)，资源利用率，容量
- 兼容性
  可以和 共享硬件软件的 其他软件 一起执行
- 易用性
  用户易于使用
- 可靠性
  在指定条件下，指定时间段内运行 的稳定程度。
- 安全性
  保护信息和数据的程度，以便其他人员，产品，系统 根据其类型 授权数据访问级别
- 可维护性
  开发人员修改软件 的 有效性 和效率。
- 可移植性
  从一种硬件，软件，操作系统 移植到 另一种
- 功能适用性
- 功能完整性
- 功能正确性
- 功能适当性



## 4.2 权衡和最差可用的架构

永远不要为最好的架构而努力，而要为最差可用的架构而努力

太多的架构特征导致通用的解决方案，试图解决每个业务的问题，但是这些架构很少起作用，因为设计太过笨重。


# ch5 识别架构特征

识别架构特征的驱动因素是 创建架构 或 确定现有架构有效性 的第一步。
通过至少3种方式从 领域关注点，需求，隐式领域知识 中 提取架构特征。

## 5.1 从领域问题中提取架构特征

架构师必须能够“翻译“领域问题，以识别正确的架构特征。例如，可伸缩性是最重要的问题，还是容错性、安全性或性能

架构中的常见 反模式 是想要设计一种支持所有架构特征的通用架构

大多数架构特征来自于与关键的领域利益相关者的沟通。


## 5.2 从需求中提取架构特征




# ch6 度量和治理架构特征


# ch7 架构特征的范围

## 7.2 架构量子与粒度

架构量子是具有 高度 功能内聚 和同步共生性的 可独立部署的 工件。


# ch8 组件化思维

### 8.2.1 架构划分

2种架构风格： 分层，模块化

分层就是 技术划分
模块化 就是 领域划分


领域划分
通过工作流 或领域 将 顶级组件 分隔开
优点
- 更接近于业务功能 而不是 实现细节的建模
- 更容易利用逆向康威演习 来围绕 领域 构建 跨功能团队
- 更接近模块单体 和微服务架构风格
- 消息流 匹配 问题域
- 易于将 数据和组件 迁移到 分布式架构中

缺点
- 定制化代码出现在多个地方


技术划分
根据技术能力 分离顶级组件。 这些层 可能受 模型-视图-控制器 划分 或 其他技术 划分的启发
优点
- 清晰地分离定制代码
- 更接近分层架构模式

缺点
- 更高程度的全局耦合。对通用组件或本地组件的更改 可能影响 所有其他组件
- 开发人员 可能不得不 在 通用层 和本地层 中重入引入 领域概念
- 通常在数据级 有更高的耦合。




## 8.4 组件识别流程

8.4.1 识别初始组件

8.4.2 将需求分配给组件

8.4.3 分析角色和职责
8.4.4 分析架构特征

8.4.5 重组组件

## 8.5 组件粒度
过于细粒度，导致 组件之间的通信过多。
粗粒度，导致 组件有很高的内部耦合。 部署，测试 困难， 及有模块化相关的 负面影响


## 8.6 组件设计

没有公认的 正确方法
要做的事 在各种技术中 进行权衡取舍

下面是一些 发现组件和 避免陷阱的 常规方法

### 8.6.1 发现组件

架构师通常与 其他角色(如 开发人员，业务分析人员，主题专家) 协作，基于系统的 一般知识 及 架构划分 方式 (基于 技术 或 领域 划分) 来设计初始组件。团队的目标是 进行初步设计，将问题空间划分为 考虑不同架构特征的 粗块

实体陷阱
这是一种常见的 反模式。
假设一个架构师正在为 "前进，前进，消失" 卡塔设计组件
。。不知道这个是什么， https://developer.aliyun.com/article/1203740   这里也提到了，但是还是不知道是什么。
。。感觉就是一个 拍卖会。

最终得到下面的设计
![34255acd167f65e0d698b55627981466.png](../_resources/34255acd167f65e0d698b55627981466.png)

上图中，架构师基本获取了 需求中标识的每个实体，并基于该实体 创建了一个 管理员组件。
这不是一个架构，而是 框架到数据库的 关系映射。换句话说，如果系统只需要 简单的 数据库 CRUD，那么 架构师可以下载一个 框架 来直接 从数据库创建用户界面
当架构师错误地 ==将数据库关系 标识为 应用中的工作流时，就会出现实体陷阱 反模式==，这种对应 在 现实世界中 很少出现。
这种模式 通常表示 ==没有考虑到 应用的 实际工作流==。
使用在实体陷阱影响下创建的组件也往往过于粗粒度，在源代码打包和 总体结构方面 没有为 开发团队 提供任何指导。

。。要的是 步骤，工作流， 而不是 实体。 就是 实体的 变化，转换 的 流程。 实体很简单，直接映射 真实世界 就可以。 但是 数据 怎么变化 就需要 仔细思考。



# ch9 基础

架构风格(也叫架构模式) 描述 包含各种架构特征的 组件的 命名关系。

## 9.1 基础模式

### 9.1.3 客户端/服务器

架构中的一种基础风格将 技术功能划分为 前端和后端，称为 2层架构，即 客户端/服务器端 架构。

- 桌面+数据库服务器
- 浏览器+web服务器
- 三层架构，数据库层，应用层，前端。


## 9.2 单体架构与分布式架构

单体架构
- 分层架构
- 管道架构
- 微内核架构

分布式架构
- 基于服务的架构
- 事件驱动架构
- 基于空间的架构
- 面向服务的架构
- 微服务架构


### 分布式计算的8个谬论

- 网络是可靠的
- 零延迟
- 带宽是无限的
- 网络是安全的
- 拓扑结构从不改变
- 只有一个管理员
- 传输成本为0
- 网络是同构的

### 9.2.9 其他分布式方面的考虑
- 分布式日志
- 分布式事务
- 契约维护，版本控制



# ch10 分层架构风格

大多数分层架构由 4个标准层 组成
- 展示层
- 业务层
- 持久层
- 数据库层

按照物理分布(部署)，上面的4层可以分为3种
1. 展示，业务，持久 这3层 组成一个 部署单元， 数据库层 通常表示为 一个单独的 外部物理数据库(或文件系统)
2. 在上面的基础上，展示层 独立部署。
3. 4层组成一个 部署单元。对于有 内嵌的数据库 或 内存数据库 的 小型应用 很有用。

。。实际上，2 可以看到 手机app吧。 传递的是 json，然后 手机这里 处理，然后展示。



## 10.2 分层隔离性

分层架构中，每层既可以是 封闭的，又可以是 开放的。

封闭意味着 一个请求 自顶向下 传递， 不能跳过 任何层。

分层隔离性 意味着 架构中 一个 分层所做的更改 通常不会 影响其他分层中的组件，前提是 这些层之间的 契约保持不变。

分层隔离性 还运行在不影响 任何其他层的情况下 替换架构中的 任何层。

。。但是 就算 展示层 直接 访问 持久层， 也是可以替换的啊。 代码 只需要保证 接口不变，哪层来的请求 并不关心啊。
。。分层 只是 为了 更好地 组织文件， 划分 新功能的 放置位置(哪个类 或哪个文件)。 而且更容易复用，不同层次，粒度不同，所以 上层的 可能能够 复用 下层的代码。
。将 需要 开放 的 接口 组织到 新的 文件中。 这样的话，一层中， 部分接口是封闭的，部分接口是 开放的。 应该也行吧。

## 10.3 增加分层


## 10.4 其他考虑

对于分层架构，需要注意 架构污水池反模式。即 请求 简单的 被 一层层 转发，除了最后一层，其他的 没有 实质的 业务逻辑。

每个分层架构都会出现一些 反模式。
确定 架构污水池反模式 是否出现的 关键是 这类请求的 百分比， 80-20 是一个很好的实践。 如果只有 20%的请求是 污水池，是可以接受的， 80%的请求是 污水池，是 不能接受的。

解决 架构污水池反模式的 另一种方法是 开发 架构中的 所有层， 这会增加 架构中 管理 变更的难度


## 10.5 为什么使用这种架构模式

对于小型，简单的应用或网站来说，分层架构是一个很好的选择。
对于 预算和时间 非常紧张的情况，它也是一个 很好的选择， 特别是作为一个 起点

分层架构可能是 成本最低的 架构之一，可以促进小型应用程序的开发便捷性。

当架构师 仍然在分析业务需求，并且不确定 哪种结构风格最好时， 分层架构 往往是一个不错的选择


## 10.6 架构特征评级


![f67e7f75eea56ad11b89faaa700a23b0.png](../_resources/f67e7f75eea56ad11b89faaa700a23b0.png)



# ch11 管道架构风格

常见的架构风格

只要开发人员 和架构师决定 ==将功能划分为离散的部件==，就会遵循这种模式

管道结构 由 管线 和过滤器组成

管线 组成了 过滤器之间的 通信通道，由于 性能原因，每个 管线 通常是 ==单向 和 点对点==的， 接收来自一个源的输入，并总是输出到 另一个源
管线上的工作负载可以是 任何数据格式，但是 架构师为了实现 高性能 喜欢使用更少的数据

过滤器 是自包含的，独立于 其他过滤器，并且 通常是 无状态的。
过滤器应该 ==只执行一个任务==， 复合任务 应该由 一系列 过滤器来处理。

管道架构中有4种类型的过滤器
- 生产者
  流程的起点，仅提供输出
- 转换器
  接收输入，选择性地 对部分或全部数据 执行转换，然后发到输出管道。函数式提倡者 将这个 特性称为 map
- 测试器
  接收输入，测试一个或多个条件，然后根据测试结果 生成输出。 函数式程序员称之为 reduce
- 消费者
  管道流的终点。有时会将管道处理的最终结果保存到数据库中，或在用户的界面上显示。

管线，过滤器的 单向特性 和 简单性 鼓励 组件重用。

。现在 管线可以用 MQ 来代替。

## 11.3 架构特征评级

![2b765f1e52d185a5c0d65b921767758b.png](../_resources/2b765f1e52d185a5c0d65b921767758b.png)

管道架构的弹性和可伸缩性非常低，这主要是由于 单体部署。
由于单体部署 和 缺乏架构模块化，管道架构 不支持 容错。

。。管道架构是单体的，不过 通过 MQ可以变成 分布式，而且 可以广播，这样的话， 弹性，伸缩性，容错 应该都不是问题了吧。 
。。不，这里是 单体架构，
。。不知道分布式架构哪里 把 通过MQ 拆分的 架构 叫什么


# ch12 微内核架构风格/插件架构

非常适合 基于产品的应用程序 (打包并作为 单个，独立的 部署 提供下载和安装，通常作为 第三方产品 安装在客户的站点上)


微内核架构是 一个相对简单的 单体架构，有2个 架构组件： (基本的)核心系统，(独立的)插件组件。
提供良好的 扩展性，适应性，应用程序特性 和 自定义处理逻辑的 隔离


eclipse 就是一个很好的例子。核心系统只是一个 基本的文本编辑器。添加插件，才成为可用的产品。

核心系统的另一个定义是 通过应用的 通用处理流， 消除 核心系统的 循环复杂度，并将其放到 单独的 插件组件中，可以更好扩展，维护。

比如 电子设备回收应用
```java
public void assessDevice(String device) {
    if (device.equals("iphone22")) {
        assessIphone22();
    } else if (device.equals("iphone23")) {
        assessIphone23();
    } else if (device.equals(iphone24)) {
        assessIphone24();
    }
    ...
}
```

不如将 被评估的电子设备创建一个 单独的插件组件。
要添加评估的新电子设备 只需要增加一个 新的插件 并更新注册表

```java
public void assessDevice(String device) {
    String plugin = pluginRegistry.get(device);
    Class<?> clz = Class.forName(plugin);
    Constructor<?> cons = clz.getConstructor();
    DevicePlugin dp = (DevicePlugin) cons.newInstance();
    dp.assess();
}
```

根据规模 和复杂不同，核心系统可以实现为 分层架构，也可以实现为 模块化的 整体架构。


插件组 不一定 必须与核心系统 进行 点对点通信。还有其他选择，包括使用 REST 或 MQ 作为 调用插件 的方法，每个插件都是 独立的服务。
注意，由于采用了 单核心系统，所以它依然是一个 单点架构


## 12.2 注册

通过插件注册中心。 核心系统可以知道 哪些模块可用，以及 怎么访问它们

插件注册 可能需要，服务名称，数据输入输出格式。


## 12.3 契约

插件 和 核心 之间的契约通常是 跨组件的 标准契约，包括：从插件返回的行为，输入，输出。
第三方插件 可能有 定制契约，此时，可以在 插件契约 和 标准契约之间 创建适配器。




## 12.5 架构特征评级

![3b66959e20735465c1e727c4a201df2b.png](../_resources/3b66959e20735465c1e727c4a201df2b.png)


# ch13 基于服务的架构风格

基于服务的架构 是微服务架构风格的混合

由于其灵活性，被认为是 ==最实用==的架构风格之一

基于服务的架构 是一种 分布式架构，但它没有 其他分布式架构的 复杂性和成本。
使得它成为 许多和业务 相关的 应用程序的 一个 非常流行的选择


13.1 拓扑结构

该结构 由 单独部署的 用户界面，单独部署的 远程粗粒度 服务 和 单体数据库组成。

这种架构风格中的 服务 通常是 粗粒度的 "应用程序的一部分" (通常称为 域服务)，它们是独立 且 单独部署的。
应用程序上下文中 服务的数量通常在 4-12之间。

服务通常 和单体应用 一样部署。

服务由 用户界面 通过 远程访问协议 进行远程访问。 从用户界面访问 服务 通常使用 REST，也可以使用 消息传递，RPC，甚至 SOAP。

通常使用 中心化共享的 数据库。 


13.2 拓扑结构变体

1. 分为多个用户界面

2. 数据库 可以拆分为 多个独立数据库，根据 不同的数据库 来拆分 服务组件。

3. 添加一个API层，做为 代理或网关，可以将 服务中共同的功能(如 度量指标，安全性，审计需求，服务发现) 拆分出去。


13.3 服务设计和粒度

服务是粗粒度的，所以可以满足 常规的 事务ACID

粗粒度的代价是，一旦进行修改，那么需要测试该粗粒度服务的全部功能。 
而 细粒度的话，功能很少，测试很快。


## 13.4 数据库逻辑分区

通常，基于服务的架构 中的 所有服务 都共享一个 单一的单体数据库。

对于表结构的改变 可能会影响所有的服务。

降低数据库变更的影响 的方法是 对数据库进行 ==逻辑分区==，并通过 联合共享库 表明逻辑分区。
比如，将数据库在逻辑上分为5个独立的区：通用，客户，发票，订单，跟踪。各个服务 使用 相应的 区。 对数据库某个区的变更 只会影响 这个区对应的 服务。

13.5 示例

## 13.6 架构特征评级

![8cb44e886ee703e4df67e1d41583e78e.png](../_resources/8cb44e886ee703e4df67e1d41583e78e.png)

由于服务的粗粒度特性，基于服务的架构 比 其他分布式架构 更可靠。更大的服务意味着 服务之间的网络流量更少，分布式事务更少。


## 13.7 何时使用这种架构风格

这种架构的 灵活性，加上 其他 3星，4星 的架构特征，使 基于服务的架构 成为 最实用的 架构风格之一。
还有其他更强大的分布式架构，但是 成本更高，而且 有时候 不需要 那么强大的功能

进行域驱动设计的时候，基于服务的架构非常适合，由于 服务是粗粒度的，所以和 域 特别 契合。每个服务 包含一个 域。

维护和协调 数据库事务 始终 是 分布式架构的一个问题。 由于 服务的粗粒度，基于服务的 架构 比其他分布式架构 能更好地 保留 ACID 事务， 而不需要 BASE事务， sagas事务。

基于服务的架构 对于 实现良好的 架构模块化 是一个很好的选择。



# ch14 事件驱动的架构风格

事件驱动的架构风格 是一种 ==流行的 分布式异步架构风格==，用于 构建 ==高度可伸缩，高性能== 的应用
适应性很强，可以用于 小型应用，也可以用于 大型，复杂的 应用。

事件驱动的 架构由 异步接收 和 处理事件的解耦事件处理组件 组成。
可以作为独立的架构风格使用，也可以嵌入其他架构风格 (例如 事件驱动的 微服务架构)

大多数应用 遵循 所谓的 基于请求的模型。在此模型中，为 执行某种操作 而向 系统发出的请求 被发送到 请求编制器。 
请求编制器 通常是一个 用户界面，也可以通过 API层 或 企业服务总线 实现。
请求编制器 用于确保 同步地将 请求 定向到 各个请求处理器。
请求处理器 处理请求


14.1 拓扑结构

有2种： 中介拓扑，代理拓扑
需要对 事件流程 的工作流进行 控制时，使用 中介拓扑
需要对事件的处理 进行高度响应 和动态控制时，使用 代理拓扑


## 14.2 代理拓扑

代理拓扑 和 中介拓扑 的不同之处在于 代理拓扑没有 中心事件中介。
在代理拓扑中，消息流 以 类似 链的方式 通过 轻量级==消息代理==(RabbitMQ,ActiveMQ,HornetQ等) 分布在 事件处理器 组件之间。
当有一个 相对简单的事件处理流 且不需要 中心事件 协调时，此拓扑很有用。

4个主要架构组件： ==初始事件，事件代理，事件处理器，待处理事件==
初始事件被发送到 事件代理 的事件通道 进行处理。 代理拓扑没有 中介组件，所以 事件处理器 从 事件代理 接收初始事件 并开始处理。处理后，创建 待处理事件 来异步通知 系统的其他部分 它们需要做什么。 待处理事件 异步发送到 事件代理。

可扩展性非常强，很容易就可以增加 模块。

性能，响应性，可伸缩性 都是 代理拓扑的优势，但是 也有缺点， 它无法控制 与 初始事件 关联的 整个工作流。工作流是动态的， 没人能知道 事件 何时完成。
错误处理也是一个难点，因为没有 中介监视 或 控制业务事务，所以 发生故障，没有人会知道。

代理拓扑 不支持 重启业务事务 (可恢复性)。 没有人监控，所以不知道 事件已经被处理到 哪一步了。

优点
- 高度解耦的事件处理器
- 高可伸缩性
- 高响应性
- 高性能
- 高容错性

缺点
- 工作流控制
- 错误处理
- 可恢复性
- 重启能力
- 数据不一致性

## 14.3 中介拓扑

中介拓扑 解决了 代理拓扑的一些缺点。

中介拓扑的 核心是 事件中介， 它管理 和控制 初始事件的 工作流，初始事件由多个 事件处理器协调。
构成中介拓扑的架构组件 包括 ==初始事件，事件队列，事件中介，事件通道，事件处理器==。

初始事件是 启动 整个事件过程的的事件， 与代理拓扑不同的是，初始事件被发送到 初始事件队列后，该队列由事件中介接受。事件中介只知道 处理事件所涉及的步骤，因此生成相应的处理事件，这些事件以点对点消息传递方式发送到 专用事件通道(通常是队列)。然后 事件处理器 监听 事件通道，处理事件，并通常 向 中介返回 已完成工作的响应。

大多数中介拓扑的实现中 存在多个中介，通常与特定的域 或 事件分组相关。这减少了 与此拓扑相关的 单点故障问题，还提高了 总体吞吐量 和性能。

事件中介 可以以多种方式实现，这取决于 它正处理的事件的性质和复杂性。
例如，对于 需要简单的错误处理和编排的事件，通常使用 apache camel, mule esb, spring integration 就足够了。 这些类型的 中介中的 消息流 和 消息路由 通常是用 代码 定制的，以控制事件处理的工作流。

如果事件工作流 需要大量的 条件处理 和 具有复杂的 错误处理指令 的多个动态路径，那么可以选择 apache ode, oracle bpel 流程管理器 这样的 中介
。。ode  19年 已经 retired了， bpel baidu的 也是 10年前的文章。。
。现在的工作流框架： Activiti， bpm引擎 business process management

了解 中介处理的事件的类型非常重要， apache camel 对于 复杂且长时间的事件 难以编写 和维护， 对于简单的事件 ，BPM引擎需要 数月的时间，但是 apache camel 只需要 几天。

。到时百度下呗，  apache camel activiti
. https://www.cnblogs.com/rongfengliang/articles/4002300.html
.很多 业务规则引擎， apache camel 第一个介绍，虽然不是名次，但是也说明了一些东西。。。基本都是 java的，


很难将事件 都归为一类，所以 建议将 事件 分为 简单，困难或复杂，并让 每个事件 都通过 一个 简单的中介 (如 apache camel,或 mule)。 然后 简单中介 可以查询 事件的 分类，并 自己处理事件 或 转发给 处理复杂事件的 中介。

中介组件 对于 工作流 的感知和控制， 是 代理拓扑 所不具备的。
因为 中介控制工作流，所以它可以维护事件状态 并管理 错误处理，可恢复性 和重启。

代理拓扑和 中介拓扑 另一个内在差异 体现在 待处理事件的 含义和使用方式上。
代理拓扑示例中，待处理事件作为系统中发生的事件发布（例如订单创建、付款和电子邮件发送）。事件处理器执行一些操作，其他事件处理器响应该操作。
然而，在中介拓扑中，待处理事件（如下订单、发送邮件和履行订单）是命令（需要发生的事情），而不是事件（已经发生的事情）。
同样，在中介拓扑中，必须处理待处理事件（命令），而在代理拓扑中可以忽略它（响应）。

中介拓扑也有一些负面影响，
首先，以声明的方式 对复杂事件流中发生的 动态处理 进行建模是非常困难的。因此，中介内的 许多工作流 只处理一般的处理，，而将中介拓扑和代理拓扑结合起来的混合模型用于处理复杂事件处理的动态特性
此外，虽然事件处理器可以很容易地 以 和代理拓扑相同的方式 伸缩，但是中介也必须伸缩，这有时会在 整个事件处理流中产生瓶颈。
最后，事件处理器在中介拓扑中 不像代理拓扑 那样具有 高度解耦

优点
- 工作流控制
- 错误处理
- 可恢复性
- 重启能力
- 较好的数据一致性

缺点
- 事件处理器更加耦合
- 较低的可伸缩性
- 较低的性能
- 较差的容错
- 对复杂的工作流进行建模

代理拓扑和 中介拓扑 之间的选择 本质上就是 工作流的控制和错误处理能力 与 高性能和可伸缩 之间的 选择。


## 14.4 异步能力

事件驱动架构风格 比其他架构风格 额外提供一个独特的特性，即 它完全依赖于异步通信来进行 "即发即弃"处理 (不需要响应) 和 请求/应答处理 (需要 来自事件使用者的响应)。
异步通信技术可以增强系统的总体响应能力
。。举的例子感觉是错的，而且 异步通信，意味着 你不需要 结果， 却是可以增强 响应能力，但是 其他架构 也可以 UDP 发 或 服务器直接202 啊。

使用了异步，如果需要结果，那么需要其他的方式，比如 向用户发送一条信息。

异步通信的主要问题是 错误处理。

## 14.5 错误处理

响应式架构的 工作流事件模式 可以处理异步工作流 中 与错误处理相关的问题。
此模式是一种同时具有弹性和响应性的响应式架构模式。 
换句话说，系统可以在不影响 响应性的情况下灵活地处理错误。

工作流事件模式通过使用 工作流 委托 来实现委托、控制和修复

事件生成者通过 消息通道 异步地 将数据传递给 事件使用者。
如果事件使用者在处理数据时遇到错误，它会立即将 该错误委托给 工作流处理器，并继续处理 事件队列中的 下一个消息。

工作流处理器收到错误后，它会试图找出消息的错误之处。这可能是一个 静态，确定性的错误。它也可以利用一些 机器学习算法来分析消息，以发现其中的异常。
工作流处理器 以代码的方式(不需要人工) 对原始数据进行更改并尝试修复它，然后将其发送会 原始队列。事件使用者将此消息 视为一个 新消息。
如果工作流处理器 无法确定 消息出了什么问题，则将 详细发送到 另一个队列，进行显示 与 人工处理。

使用工作流事件模式，错误消息在重新提交时 会按照新的顺序被处理。 可以维护消息顺序，但是很复杂。


## 14.6 防止消息丢失

数据丢失可能出现在3个方面
1. 消息永远不会从 事件处理器 到达队列，即使到达了队列，代理页会在 下一个事件处理器检索消息之前停止工作。
2. 事件处理器拿到消息，在处理之前，崩溃
3. 由于某些数据错误，无法将消息持久化到数据库中。

问题1，使用持久消息队列 来解决， 发送者需要等待 队列的 响应， 队列在发出响应前 需要 持久化到 磁盘
问题2，队列需要收到 事件处理器的 响应后 才会删除消息
问题3，（由于一些数据错误，事件处理器 无法将消息持久化到数据库中）是通过利用支持ACID （原子性、 致性、隔离性、持久性）事务的数据库提交来解决的 。一旦数据库提交发生，数据就会被持久化到数据库中。利用被称为最后参与者支持 (Last articipant Support, LPS) 的技术确认处理已经完成，消息已经持久化到数据库中，从而删除持久化队列中的消息 这保证了消息从事件处理器 传输到数据库的过程中不丢失。

## 14.7 广播功能

事件驱动的架构的另一个 独有特征是 能够在 不知道消息接收方 是谁，及 如何处理消息 的情况下 广播事件。

广播可能是 事件处理器间 解耦的最高级别，因为广播消息的生产者通常不知道 哪个事件处理器将接收广播消息。

广播功能是 最终一致性，复杂事件处理(CEP) 以及 许多其他模式的重要组成部分。


## 14.8 请求-应答

事件驱动的架构中，同步通信是通过 请求-应答 消息传递机制 (有时称为 伪同步通信) 来实现的。
请求-应答消息传递中的 每个事件通道 由2个队列组成，一个请求队列一个应答队列。
对消息的初始请求 异步发送到 请求队列，然后 将控制权返回给 消息生产者。
然后 消息生产者在 应答队列上 执行阻塞等待。
最后，事件生产者接收带有 响应数据的消息。

实现请求-应答消息传递 有2种主要技术。
第一种，也是最常见的是 使用 消息头中包含的 关联ID。关联ID是回复消息中的 一个字段，通常设置为原始 请求消息的 消息ID。 工作原理如下
- 事件生产者向请求队列发送一条消息并记录唯一的消息ID
- 事件生产者现在使用消息过滤器(也称为 消息选择器) 在应答队列上 执行阻塞等待
- 事件使用者 接收消息 并处理请求
- 事件使用者 创建包含响应的 应答消息，并将消息头中的 关联ID 设置为 原始消息ID
- 事件使用者 将新消息 发送到 应答队列
- 事件生产者接收消息，通过关联ID 匹配到 消息选择器

另一种技术是 使用临时队列。这个临时队列专用于特定请求，在请求发出时创建，请求结束时 删除。 这种技术 不需要关联ID。

虽然临时队列简单，但是需要为每个请求创建一个 临时队列，然后删除它。 会影响 性能和响应能力。

## 14.9 在基于请求和基于事件之间进行选择

基于请求的模型 和基于事件的模型 在设计软件系统时 都是可行的。
建议 在 需要 确定和控制工作流的情况下，为 结构良好，数据驱动的请求 (如 检索客户概要数据) 使用 基于请求的模型。
为灵活，基于操作的事件 选择基于事件的模型，这些事件 需要较高的响应能力和 可伸缩性，并且有 复杂 和动态的 用户处理。


基于事件 比 基于请求 的优势
- 更好地响应动态用户内容
- 更好的可伸缩性和弹性
- 更好的敏捷性和变更管理
- 更好的响应能力和性能
- 更好的实时决策
- 对态势感知有更好的响应


基于事件 比 基于请求的 劣势
- 只支持最终一致性
- 对处理流程的控制更少
- 事件流 结果的 不确定性较高
- 难以测试和调试


## 14.10 混合的事件驱动的架构

虽然许多应用程序将 事件驱动 作为 主要的总体架构， 但 事件驱动 经常和其他架构 一起使用。
一些常见的架构(如 微服务，基于空间的架构) 将事件驱动的架构作为 另一种架构风格的一部分。 
还有一些其他混合方案，如 事件驱动的 微内核架构 和 事件驱动的 管道架构。


## 14.11 架构特征评级

![d685a756da2b8900bc4fc05fa179109e.png](../_resources/d685a756da2b8900bc4fc05fa179109e.png)




## ch15 基于空间的架构风格

大多数基千 Web 的业务应用程序普遍遵循相同的请求流程：来自浏览器的请求先访问Web 服务器，然后是应用程序服务器，最后是数据库服务器。

随着用户增加，瓶颈开始出现，首先是 web服务器层， 然后是 应用服务器层，最后是 数据库服务器层。
扩展web服务器层 会将 瓶颈向下移动到 应用服务器， 扩展应用服务器会将 瓶颈 移动到 数据库。
数据库的扩展 是 困难 且 昂贵的。

在任何 有大量并发用户负载的 大容量应用中，数据库通常是 决定并发处理事务数的 最大因素， 虽然 有 cache 和数据库扩展产品， 但 依然很困难。

基于空间的架构 是专门解决 涉及 高可伸缩性，弹性 和 高并发性 的问题 而设计的。对于具有可变 且 不可预测的 并发用户数量的 应用，它也是一种有用的架构。

从架构上解决 极端 和 可变的 可伸缩性问题 通常 比 尝试扩展 数据库 或 将 缓存技术 改进为 不可伸缩性 的架构更好。

## 15.1 常规拓扑结构

基于空间的架构得名于元组空间的概念，元组空间是一种使用==多个并行处理器通过共享内存进行通信==的技术。
高可伸缩性、高弹性和高性能是通过==删除中央数据库==作为系统中的同步约束实现的，取而代之的是==利用复制的内存数据网格==。

应用程序 数据保存在内存中，并在 所有活动的处理单元之间复制。
当处理单元更新数据时，它通过带有持久队列的 消息传递 异步地 将该数据发送到 数据库。
随着用户负载的 增加和减少，处理单元 动态地启动和关闭， 从而解决 伸缩性。

由于在 应用程序的 标准事务处理中 不涉及 中央数据库，因此消除了 数据库瓶颈，从而在 应用程序中 提供了 近乎无限的 可伸缩性

基于空间的架构由以下几种架构组件组成：
- 包含应用程序代码的处理单元、
- 用于管理和协调处理单元的虚拟化中间件、
- 异步发送更新的数据到数据库的数据泵、
- 执行从数据泵产生的更新的数据写入器、
- 读取数据库中的数据并在处理单元启动时交付数据的数据读取器



![1e0be2b73873b9f026e364c7bffd4e88.png](../_resources/1e0be2b73873b9f026e364c7bffd4e88.png)



### 15.1.1 处理单元

处理单元 包括应用程序逻辑 (或逻辑的一部分)。
通常包括 基于 web的 组件以及后端业务逻辑。
处理单元的内容因应用程序的类型而异。较小的 基于web的应用程序 可能被部署到 单个处理单元中，而较大的应用程序 可能 拆分为 多个 处理单元。处理单元还可以包含 小型，单一用途的服务(与微服务一样)。
除了应用程序逻辑之外，处理单元还包含 内存数据库网格 和 复制引擎，通常通过 Hazelcast, Apache Ignite 和 Oracle Coherence 等产品实现。


### 15.1.2 虚拟化中间件

虚拟化中间件 处理架构中的基础设施问题，这些控制着 数据同步 和请求处理的不同方面。
由 消息传递网络，数据网格，处理网格 和部署管理器 等组件组成。 这些组件 可以作为 第三方产品 定制或购买

消息传递网格
管理输入请求 和 会话状态。当请求进入 虚拟化中间件时，消息传递网格组件 确定哪些活动处理组件 可用来接收请求，并将请求转发到 其中一个 处理单元。
消息传递网格 既设计简单的循环算法，也涉及复杂的 next-available算法，后者负责监控 处理单元正在处理哪个请求。 
此组件通常使用 具有负载均衡功能的 典型web服务器 (如 HAproxy， Nginx) 来实现


数据网格
==最重要，最关键的组件==
大多数现代实现中，数据网格仅在处理单元内作为复制缓存实现。但是，对于那些需要外部控制器 或 使用分布式缓存 的复制缓存实现，该功能将同时存在于 处理单元 和虚拟化中间件的 数据网格组件中。
由于消息传递网格可以将请求转发给任何可用的处理单元，因此每个处理单元的内存数据网格中必须包含完全相同的数据
数据在包含同名数据网格的处理单元之间同步，考虑下面的代码，该代码为包含 客户概要信息的 处理单元 创建内部复制数据网格
```java
HazelcastInstance hz = Hazelcast.newHazelcastInstance();
Map<String, CustomerProfile> profileCache = hz.getReplicatedMap("CustomerProfile");
```
所有需要访问客户概要信息的 处理单元都将包含此代码。在任何处理单元中 对 CustomerProfile 这个缓存的 更改 都将 同步到 包含这个缓存的 其他处理单元。


部署管理器
根据负载 管理 处理单元实例的 动态启动和关闭。
持续监控 响应时间 和 用户负载。
是 实现 可变伸缩性 的关键组件

处理网格
是虚拟化中间件中一个 可选组件，
当单个业务请求涉及多个处理单元时， 它管理编排的请求处理。
如果传入的请求 需要不同类型的 处理单元之间的协调，则处理网格将协调和编排这2个处理单元之间的请求




### 15.1.3 数据泵

将数据 发送到 另一个处理器，然后该处理器更新数据库中的数据。
是一个必要组件，因为 处理单元 不直接读写数据库。
基于空间的架构中 数据泵 始终是异步的，通过 内存缓存 和 数据库 实现最终一致性。
数据泵通常使用 MQ 来实现。 需要 FIFO 
大多数情况下 存在 多个 数据泵，每个数据泵专用与 一个特定的 域。


### 15.1.4 数据写入器
数据写入器 接收 来自 数据泵的消息，并使用其中的信息 更新数据库 
数据写入器 可以实现为 服务，应用，数据集线器 (如 AB Initio)
数据写入器的 粒度可以根据数据泵 和处理单元的 范围 而变化。

基于域的写入器
或者 每个处理单元 有自己的 专用数据写入器


### 15.1.5 数据读取器

数据读取器负责 从数据库中读取数据 并通过 反向数据泵 将数据发送给 处理单元
在基于空间的架构中，数据读取器仅在以下3种情况下 调用：
- 同名缓存的 所有处理单元实例崩溃
- 同名缓存内的 所有处理单元 重新部署
- 检索复制缓存中不包含的 存档数据


## 15.2 数据冲突
在复制缓存时，会对 包含 同名缓存的 所有服务实例 进行更新，可能会由于 延迟 而导致 数据冲突。

冲突概率 = N * UR^2 * RL / S
N 是使用同名缓存的服务实例的数量
UR 表示 毫秒 为单位的更新速率
S 表示缓存大小 (以行数为单位)
RL 表示 缓存产品的 复制延迟

UR： 20次/秒
N： 5
S： 50000行
RL： 100ms

更新：72000次/小时
冲突概率：14.4次每小时
百分比： 0.02%

大多数系统不会在 很长一段时间内 保持固定的更新频率。因此，在使用此计算时，了解峰值使用期间的 最大更新速率 并计算最小值，正常值 和峰值冲突率 是很有帮助的。


## 15.3 云实现与预置实现

在 部署环境 方面，基于空间的 架构提供了一些独特的选择。整个拓扑，包括处理单元，虚拟化中间件，数据泵，数据读取器，数据写入器，数据库， 都可以部署在 基于云的 预置环境中。

这个架构的一个 强大特性是 在托管的基于云的环境中 通过处理单元 和虚拟化中间件部署 应用程序，同时将 物理数据库 和 相应的数据部署在 预置环境中。
正是由于这种架构风格的异步数据泵 和最终一致性模型，这种拓扑支持 非常有效的 基于云的数据同步。
事务处理可以在 动态的 灵活的 基于云的环境中进行， 同时 数据保留在 安全的 本地的 预置环境中。


## 15.4 复制缓存和分布式缓存

基于空间的架构依赖于应用程序事务处理的缓存。
消除对数据库的直接读写需求是基于空间的架构能够支持 高可伸缩性、高弹性和高性能的原因。
基于空间的架构主要依赖于复制缓存，不过也可以使用分布式缓存

复制缓存 是 基于空间的架构的 标准缓存模型，但在某些情况下 无法使用。例如，缓存数据量太大 或更新率过高。  此时 可以使用 分布式缓存
。。redis来啦

|决策条件|复制缓存|分布式缓存|
|--|--|--|
|优化|性能|一致性|
|缓存大小|`小(<100mb)`|`大(>500mb)`|
|数据类型|相对静态|高度动态|
|更新频率|相对低频|更新频率高|
|容错|高|低|


## 15.5 近缓存 中的注意事项
近缓存 是一种 缓存混合模型，它用分布式缓存 连接 内存中的 数据网格。
在这个模型中，分布式缓存 被称为 完全后端缓存，每个处理单元中 包含的 内存数据网格 被称为 前端缓存。
前端缓存 是 完全后端缓存的 一个 子集，它使用过期策略 来 移除老的数据。
虽然前端缓存始终与完全后端缓存保持同步，但是每个处理单元中包含的前端缓存在共享相同数据的其他处理单元之间并不同步。这意味着共享相同数据上下文 的多个处理单元的前端缓存中可能都有不同的数据。因此，==不建议== 在 基于空间的架构中 使用 近缓存模型


## 15.6 实现示例

演唱会票务系统
在线拍卖系统


## 15.7 架构特征评级

![b0680a956ab48a47e69ba0bac2a4a59e.png](../_resources/b0680a956ab48a47e69ba0bac2a4a59e.png)





# ch16 编制驱动的面向服务的架构

。。不知道 编制 的英文是什么。。 前面也有很多 编制，我会改成 编排。

和艺术一样，架构必须在 时代背景下进行理解，该架构最能体现这一原则。

## 16.1 历史与哲学

20世纪90年代后期，很多公司 通过 合并，极速成长为 大企业，这些企业需要 更复杂的 IT化 来适应 这种增长， 于是编制驱动的 面向服务的架构 应运而生

在这个时代，许多外力迫使架构师采用具有重大约束的分布式架构。
在开源操作系统被认为足以可靠地用于重要工作之前，操作系统是昂贵的，并且每台机器都要获取授权许可。
类似地，商业数据库服务器带有拜占庭式的许可方案，这导致了应用服务器供应商（提供数据库连接池）与数据库供应商之间的竞争。
因此，架构师期望尽可能多地实现重用。
事实上，==所有形式的重用成为这个架构的主导哲学==

这种风格的架构也展示了架构师可以将技术划分的概念推进多远，但是往往好心办坏事。


## 16.2 拓扑结构

这种类型的面向服务的架构的拓扑结构如图 

![fea97c7d0d42dd85b719525f21a6f9fa.png](../_resources/fea97c7d0d42dd85b719525f21a6f9fa.png)

并不是所有这种类型的架构都具有如图 16-1 所示的确切分层，但是它们都遵循相同思想，即在架构中建立服务分类，每个分层都有特定的职责

面向服务的架构是一种分布式架构


## 16.3 分类

架构师 在此架构中的 驱动哲学 围绕着 企业级重用。

16.3.1 业务服务
位于架构顶部，提供入口。
这些服务的定义不包含代码，只包含 输入输出，有时也包含 模式信息。 
通常有 业务用户定义，因此命名为 业务服务

16.3.2 企业服务
包含细粒度的 共享实现。
通常，开发团队的任务是围绕特定的业务领域 构建原子行为。这些服务是 粗粒度业务服务 的组成部分，通过 编制引擎 绑定在一起。
在这个架构中，基于重用 这一目标 产生了 职责分离。如果开发人员可以在 正确的粒度级别上构建细粒度的企业服务，那么业务就不必重写这一部分业务工作流。 业务将逐渐以可重用企业服务的形式构建可重用资产的集合。
但，现实的动态性会阻碍这些尝试。 业务组件不像 建筑材料 一样可以持续几十年。

16.3.3 应用程序服务
并非架构中所有的服务 都需要 与企业服务保持相同的粒度 或重用级别。
应用程序服务是 一次性，单一实现的 服务。

16.3.4 基础设置服务
基础设置服务提供运维关注点，如 监控，日志记录，身份验证和授权。

16.3.5 编制引擎

编制引擎 是这个分布式架构的==核心==， 使用编制 (包括 事务协调 和 消息转换等功能) 将业务服务实现组合在一起。这种架构通常绑定一个 或几个 关系数据库，而==不是像微服务架构中 那样 每个服务对应一个数据库==。因此，事务行为是在编制引擎中(而不是在数据库中) 以声明的方式处理
编制引擎定义了 业务 和企业服务之间的关系 以及 其映射关系 以及 事务边界的位置。 它还充当 集成中心，运行架构师将定制代码 与 包 和 遗留软件系统集成到一起。
因为这个机制 形成了 架构的核心，所以 康威定律(8.2.1) 正确地 预测了 负责这个 引擎的 集成架构师团队 将成为 组织内的 政治力量，并最终成为 官僚主义的瓶颈。

虽然这种方法听起来很有吸引力，但实际上却是一场==灾难==。 将事务行为 放到 编制工具上 听起来不错，但是找到 事务的正确粒度级别 变得越来越难。虽然可以在分布式事务中 构建一些封装的事务，但是 由于开发人员 必须确定服务之间 合适的 事务边界，因此 架构变得越来越难。

16.3.6 消息流
所有的请求都要进过 编制引擎 --- 它是架构中的逻辑所在。因此 甚至 内部调用的消息流 也需要经过引擎。


## 16.4 重用与解耦
此架构的一个主要目标是在 服务级别上 实现重用 --- 逐渐构建可以随着时间推移 实现增量重用的 业务行为的能力。 该架构中的架构师应经可能地 寻找重用机会。
然而，架构师们 慢慢意识到 这种设计的负面影响，首先，当团队主要围绕重用来构建系统时，组件之间也会产生大量耦合。 一处修改 可能波及所有业务。 因此，在面向服务的架构中，架构师努力进行增量更改。
合并行为还有其它的负面影响。 。。就是有些逻辑并不关心某些属性。 就是一个 巨大类。
也许这个架构最具破坏性的启示来自 对构建一个 如此关注技术分区的架构的不切实际的认识。

## 16.5 架构特征评级

![674f1c0af52165e1b15d3f9aa763fb57.png](../_resources/674f1c0af52165e1b15d3f9aa763fb57.png)

。。早知道这个评分，就跳了。 一开始的 哲学 太唬人了。

对这个架构的缺点的 改进 产生了 更现代的 架构，如微服务。



# ch17 微服务架构

非常流行的架构风格，近年来 发展迅猛

## 17.1 历史

2014年，Martin Fowler, James Lewis 的 《Microservices》

深受 DDD(域驱动设计) 的启发。DDD中有一个 特别的概念，即 有界上下文。 有界上下文代表了一种解耦风格。

虽然重用是有益的， 但记住 软件架构 关于 权衡的 第一定律。==重用的负面影响是耦合==


## 17.2 拓扑结构

![eb06a2150ae880ff10da6c1deb9ee9d8.png](../_resources/eb06a2150ae880ff10da6c1deb9ee9d8.png)

由于单一用途的特性，微服务中 服务比其他 分布式架构 中的服务要小的多。
架构师希望 每个服务 都包含 独立操作 所需的 所有部分， 包括 数据库 和其他相关组件。


## 17.3 分布式
微服务形成了 分布式架构： 每个服务在自己的进程中运行， 进程 最初意味着一台物理计算机，很快演变成了 ==虚拟机 和容器==。

将每个服务分离到 其自己的进程中 可以解决 共享带来的 所有问题。
得益于 云资源和容器技术，团队现在可以从 极限解耦中 获益。

性能通常是 微服务的分布式 特性的 副作用。 ==网络调用 比 方法调用 花费的时间长得多==，而且 每个端点的==安全性验证 增加了 额外的处理时间==， 这要求 架构师 在设计 系统时 应该仔细==考虑 粒度的影响==

由于微服务是 分布式架构，经验丰富的架构师 建议==不要跨服务边界 使用事务==，这使得确定 服务的粒度 成为该架构 成功的关键

## 17.4 有界上下文

微服务的驱动哲学是 有界上下文： 每个服务建模一个 域 或工作流。
因此，每个服务都包含了 应用 运行所需的一切，包括 类，其他组件，数据库。


17.4.1 粒度
很难找到正确的服务粒度。

微服务是一个标签，不是描述 -- Martin Fowler

即，这个术语的创建者 需要为这种 风格命名，他们选择了 微服务 来和 当时的主流架构风格 -- 面向服务的架构(可以被称为 巨大的服务) -- 进行对比。
然而很多开发人员 将 微服务 视为 戒律，而不是一种描述，并创建 ==过于细粒度的服务==
==微服务中 服务边界的目的是 识别域 或工作流==。 某些应用中，某些部分的 自然边界 可能很大。

以下是一些 用于找到 合适边界的 指导方针

目的
最明显的边界 就是 域。 理性情况下，每个微服务有 非常高的 功能内聚性，代表整个应用程序 贡献一种重要的行为

事务
有界上下文 是 业务工作流，在事务中需要 协作的实体 通常 为 架构师提供了 良好的服务边界。
因为事务 会在 分布式架构中 引起问题，如果架构师可以设计他们的系统 来避免事务，那么就可以产生 更好的设计。
。。应该是 避免 分布式事务

编排
如果构建了一组服务，这些服务 有着 优秀的 域隔离， 但需要大量通信 才能发挥作用，那么架构师可以考虑将这些服务打包到一个 更大的服务中，以避免通信开销。
。。但是 大量通信 就意味着，我需要你的数据，你需要我的数据， 这就是一种 耦合啊。

==迭代是确保良好服务设计的唯一方法==


17.4.2 数据隔离

有界上下文 驱动的微服务的另一个需求是 ==数据隔离==。
许多其它架构风格 使用 单个数据库进行持久化。
微服务试图避免所有类型的耦合，包括 用作集成点的 共享模式 和 数据库。
。。服务注册中心：？

数据隔离是 架构师在考虑服务粒度时 必须关注的 一个因素。 
架构师==必须警惕 实体陷阱(8.6.1)，不能简单地 将服务 建模为 类似 数据库中的单个实体==

架构师习惯于 使用 关系型数据库 来统一系统内的值，从而创建 单一的真相来源，这不再是 在 架构内 分发数据时的选择。因此，架构师必须决定如何处理这个问题：要么将某个域 标记为某个事实的真相来源，并与之协调 以检索值，要么使用数据库复制 或缓存来分发信息。

虽然这种级别的 数据隔离 带来了麻烦，也是也提供了机会。
现在团队 不必使用单个数据库， 他们 可以 各自判断(价格，存储类型等) 使用 合适的工具。 可以在 不影响其他团队的情况下使用 更合适的数据库。


## 17.5 API层

微服务的大多数 都包含一个位于系统使用者(用户界面或其他系统的调用) 之间的 API层，这个是可选的。  但很常见，因为它在架构中 提供了 良好的位置 来执行 有用的任务，可以通过 ==间接代理 或 绑定到 运维设置(如命名服务==) 来实现

虽然api层有 多种用途，但如果架构师 想要 忠于这个架构的基本理念，则不应该吧 api层 用作 中介 或 编制工具： ==该框架中 所有 的 逻辑 应该发生在一个 有界上下文中，而 将编制 或 其他逻辑 放入 中介 则 有违 这一原则==。
这也说明了 架构中 ==基于 技术分区 和 基于 域分区的 区别： 架构师 通常在 基于技术分区的 架构中 使用中介， 而微服务则使 严格的域分区。==


## 17.6 运维重用

既然微服务更喜欢复制而不是耦合，那么架构师该如何处理架构中确实能从耦合中获益的部分（比如监控、日志记录和断路器之类的运维问题）呢？
传统的面向服务的架构的理念之一是尽可能重用更多的功能，域和运维都是如此。
在微服务中，架构师试图将这两个关注点分开。

一且一个团队构建了几个微服务，他们就会意识到每个服务中都有从相似中受益的公共元素。
例如，如果一个组织允许每个服务团队实现自己的监控，他们如何确保每个团队都这样做呢？他们如何处理升级等问题？是否每个团队都要负责将监控工具升级到新版本，这需要多长时间？

==sidecar (边车) 模式== 为这个问题提供了一种解决方案

![b6d62cf9c4569f5a99ebbd324b978a4e.png](../_resources/b6d62cf9c4569f5a99ebbd324b978a4e.png)

在每个服务中，常见的运维关注点作为单独的组件出现， 可以由单个团队或共享基础设施团队拥有。边车组件处理所有的运维关注点，而所有团队则从这种 耦合中获益。
当需要升级监控工具时，共享基础设施团队 可以更新边车，并且每个微服务可以使用这个新功能。

一旦团队知道 每个服务包含一个 公共的边车组件，他们就可以构建一个 服务网格，从而 实现 跨架构的 统一控制，以解决 日志记录 和 监控等问题。
==公共边车组件 连接在一起，形成 跨所有微服务的 一致运维界面==

![a92c3df33bcff7e83aed041c757cc468.png](../_resources/a92c3df33bcff7e83aed041c757cc468.png)

上图中，每个边车 都连接到 服务平面， 形成 每个服务的一致接口。

。。所以是 要么不耦合， 一旦耦合，就必然是 全体通用的 那部分(日志，监控，控制，运维)。   不能 api层 是因为 一旦api层，那么 部分逻辑 就需要  让api层知道，破坏了 内聚。   就是 日志 之类的 本身就是 可以完整切分出来的 一个模块，但是 api层 不行。
。。但是 怎么连接微服务，没有api层的话，直接连接？ 还是 nginx ？ 但是 nginx 不也知道了 一些逻辑了吗。 只是 nginx代理的话， 应该没有问题吧。
。。nginx 就像 下面的 服务发现。 可以完整拆分的 那种。
。。那 上面的api层 到底有什么？ 感觉也是可以 完成拆分的东西啊。

每个服务在整个网格中形成一个节点。 服务网格形成一个控制台，允许团队 全局控制运维耦合。

架构师可以使用 ==服务发现 在微服务中 构建弹性==。
请求不是通过 调用单个服务，而是通过 服务发现工具 进行的，
启动新的服务实例 来处理 伸缩，弹性问题。
架构师通常将 服务发现 包含在 服务网格中，使其成为 每个微服务的一部分。
==api层==通常用于 托管服务发现，允许用户界面或其他调用系统在 单一位置 以弹性，一致 的方式 查找和创建服务。


## 17.7 前端

微服务热衷于解耦，理想情况下应该包含 用户界面 和后端。
实际上，微服务最初的 设想是 将用户界面 作为 有界上下文的 一部分，忠于 DDD中的原则。
然而 web应用 所需的 分区实用性 和其他外部约束 使得 这个目标很难实现。
因此，微服务架构通常出现 2种类型的用户界面。


![440c809feda68eedab383799826b3861.png](../_resources/440c809feda68eedab383799826b3861.png)

单体前端 具有一个通过API层调用 以满足用户请求的 用户界面。
前端可以是 富桌面，移动应用程序 或 web 应用程序。

---

![5b0c3b7ec9c2778afa1aeec62fcb0307.png](../_resources/5b0c3b7ec9c2778afa1aeec62fcb0307.png)

微前端，利用 用户界面级别的 组件 在 用户界面中 创建 与后端服务 一样的粒度 和隔离级别。
每个服务与该服务对应的用户界面交互，前端与其他的 用户界面组件协调。
使用此模式，团队可以将 服务边界 从 用户界面 隔离到 后端服务，从而 在单个团队中 统一 整个域


## 17.8 通信

微服务中，纠结于 确定合适的粒度，因为这会影响 数据隔离 和通信。
必须决定 同步通信 还是 异步通信。
微服务 通常利用 协议感知 的异构 互操作性。

- 协议感知
  由于微服务通常不能包括集中式 集成中心 以避免运维耦合(。应该就是 要重启机器/发布新版本，会影响到 集成中心，影响到其他服务？)，
  因此每个服务都应该知道 如何调用其他服务。
  因此 架构师通常根据特定服务相互调用的方式 进行标准化：特定级别的 REST，消息队列等。
  这意味着服务必须知道(或发现) 使用哪个协议来调用其他服务

- 异构
  由于微服务是一种分布式架构，因此每个服务都可以在不同的技术栈中编写。
  异构表明 微服务 完全支持 多语言环境。

- 互操作性
  描述服务之间的相互调用。当微服务的架构师 试图 阻止 事务方法调用时，服务通常通过网络 调用其他服务来协作 并 发送/接收 信息。
  。。？


异步通信，架构师通常使用 事件 和消息，因此在 内部使用 事件驱动的架构(ch14)。
代理模式 和中介模式 在微服务中 表现为 编排 和 编制。


17.8.1 编排和编制

编排使用 与 代理事件驱动的 架构 相同的通信风格。 即，这个架构不存在 中心协调器，并且 遵循有界上下文。
因此 架构师发现在服务之间 实现解耦的事件 是很自然的。

。。？？。跳。  2个很大的例子。


17.8.2 事务和saga
架构师希望在微服务中 实现 极致解耦，但常常会遇到 如何跨服务 进行事务协调的问题。
由于架构中的解耦 需要在 数据库中实现同级别的 解耦，因此 原子性 在分布式应用中 就成了一个 问题。
。。还有就是 跨应用的事务。

跨服务边界 构建事务 违反了 微服务的 核心解耦原则，还创建了 最糟糕的 动态共生性 和 值共生性。
对于希望跨 服务进行事务处理的架构师，==最好的建议是：不要这样做，而是应该 修改组件的粒度==
通常，构建微服务架构的 架构师 会发现 需要将 粒度 与 事务连接在一起，他们的设计 往往过于细化。
==事务边界是 服务粒度的常用指标之一==

例外总是存在的， 微服务中流行的 分布式事务 是 ==saga 模式==

服务充当 跨多个服务调用的 中介 并协调 事务。中介调用事务的 每个部分，记录成功或失败，并协调结果。
在错误的情况下，中介必须确保如果事务一部分失败，则整个事务都不成功。
如果第一部分成功，第二部分失败，则中介必须向 事务中 成功的 部分 发送请求，告知它们 撤销 之前的请求。
- 通过 让 来自中介的 每个请求 进入挂起状态，直到中介指示 事务总体成功为止  来实现 撤销功能。 如果必须同时 同时处理异步请求，则 会变得很复杂。 也会 创建 大量的协调流量。
- 另一种是，为每个可能的事务 编写 do 和 undo。这样，在事务期间 的协调 较少。但是 undo 比 do 复杂很多。

少用跨应用事务！

## 17.9 架构特征评级

![1ad8c56f5d6766ffab1c67a45a879569.png](../_resources/1ad8c56f5d6766ffab1c67a45a879569.png)

性能优点拉。

微服务无疑是一种以域为中心的架构，其中每个服务边界都应该与领域相对应



# ch18 选择合适的架构风格


没有什么比组织内部的众多因素及其构建的软件更具有上下文关联了。
架构风格的选择是对架构特征、域考虑、战略目标等进行多方权衡，深入分析和思考后得出的结果。


## 18.1 改变架构"时尚"

架构风格会随着 时间的推移而 改变，因为
- 以史为鉴
  新的架构风格往往来自对过去架构的观察和痛点分析
- 生态变化
  软件开发生态不断变化。比如 kubernetes，现在非常火爆，但是几年前 没有人知道它，而且几年后，会不会有新工具取代它？
- 新功能
  新功能出现时，架构需要变为一个全新的范式。 如 docker的出现。
- 加速度
  变化的速度在不断加快。
  新工具创建了 新的工程实践，进而导致 新的设计 和功能
- 领域变化
  业务发展，或公司合并。
- 技术变化
  随着技术的不断发展，组织至少要跟上其中的一些变化，特别是那些具有明显底线利益的变化。
- 外部因素
  价格之类的

架构师应该了解当前行业趋势，以便对何时 遵循趋势 何时反其道而行之 做出明智的决策


## 18.2 决策标准

从根本上说，架构师设计 2 件事： 指定的域，以及使 系统成功所需的 所有其他结构元素。

在进行设计决策时，应该考虑：
- 域
  应该了解 域的许多重要方面，特别是那些影响 运营性架构特征的方面。
- 影响结构的架构特征
  必须发现并阐明 支持域 和 其他恒定因素 所需的 架构特征
- 数据架构
  架构师和DBA 必须在 数据库，模式 和 其他 与数据相关的 问题上进行 协作。
  架构师 必须理解 数据设计 可能对其 设计产生的影响。
- 组织因素
  许多外部因素可能影响设计， 如 特定云供应商的成本。
- 了解过程，团队和运维关注点
- 领域/架构同构
  一些问题域 与 架构的 拓扑结构相对应。


架构师必须做出以下决定：
- 单体与分布式
- 数据放哪里？
  几个数据库。
- 服务之间的通信风格是什么，同步还是异步？
  大多数时候， 同步通信更方便，但带来 不可扩展性，不可靠性。
  异步在 性能，扩展 方面较好，但是也带来 数据OT那个不，死锁，竞态条件，调试

同步通信 带来的 设计，实现，调试 的挑战更少，所以 应该默认 同步。


## 18.3 单体案例研究：硅三明治

## 18.4 分布式案例研究：前进，前进，消失




第三部分 技巧和软技能

# ch19 架构决策

对架构师的主要期望之一就是做出架构决策。
架构决策通常涉及应用程序或系统的结构，但也可能涉及技术决策，尤其是当这些技术决策影响架构特征时。
无论在什么情况下，一个好的架构决策是能够指导开发团队做出正确技术选择的架构决策。
做出架构决策需要收集足够多的相关信息 证明决策的合理性，记录决策并将决策有效地传达给正确的利益相关者。



## 19.1 架构决策反模式

3种主要的 架构反模式
- 掩盖你的资产，covering youe assets
- 土拨鼠日，groundhog day
- 电子邮件驱动架构，email driven architecture

这3种反模式 通常是 循序渐进的， 克服 掩盖你的资产 会导致 土拨鼠日，克服 土拨鼠日会导致 电子邮件驱动架构。


19.1.1 掩盖你的资产 反模式

当架构师由于 担心做出 错误选择而 避免或推迟 做出架构决策时，就会发生这种反模式
有2种方法克服
- 等待最后的责任时刻 再完成 重要的架构策略
  最后的责任时刻 意味着 一直等待 你有足够的 信息 来证明 和验证 你的决策， 但不能等太久，以免 拖延 开发团队 或 陷入分析瘫痪 反模式。
- 持续地与开发团队协作，以确保你做出的决策能够按预期实现。
  这一点至关重要，你无法掌握所有细节，所以必须 与开发团队 紧密合作，在出现问题时 尽快 改变 架构策略


19.1.2 土拨鼠日 反模式
一旦 克服 掩盖你的资产 反模式 并开始 做出决策，就会出现 第二个反模式：土拨鼠日 反模式。
当人们不知道 为什么要做出某个决策时，就会发生 土拨鼠日 反模式。
土拨鼠日 来自 电影《土拨鼠日》，里面每天都是 2月2日

发生土拨鼠日的原因是 架构师做出了某个架构决策，但无法为该决策 提供理由 (或无法提供一个 完整的理由)。
在论证架构决策时，为决策提供技术和业务辩护是非常重要的。

一个好的业务合理性可能是：更快地交付新的业务功能，从而缩短产品上市时间；另一个可能是减少开发和发布新功能的成本。

4个最常见的 业务合理性 包括 ==成本，上市时间，用户满意度，战略定位==


19.1.3 电子邮件驱动架构 反模式
一旦架构师做出了一系列决策并充分证明了这些架构决策的合理性，就会出现第3个架构反模式：电子邮件驱动架构反模式
电子邮件驱动架构反模式 是指 因 遗弃，忘记 或者 甚至不知道已经做出的架构决策 而无法实现该架构决策。

这个反模式讲的就是要有效地沟通架构决策。
电子邮件是一种很好的交流工具，但它并不是好的文档存储库系统。

沟通架构决策的第一条规则就是不要在电子邮件正文中包含架构决策，因为这会为该决策创建多个系统记录。
更好的方法是仅在电子邮件正文中提及决策的性质和上下文，并提供架构决策和相应详细信息的单个系统记录链接（无论它是一个 wiki 页面还是文件系统中的文档）。

有效的架构决策沟通的第 条规则是只通知真正关心架构决策的人 。一种有效的方法是编写如下的电子邮件：
＂嗨， Sandra, 我对服务间的通信做了一个重要的决策，它会直接影响到你。请使用以下链接查看这个决策 …”

注意第1句话中的措辞：“对==服务间的通信==做了一个重要的决策。”这里交代了决策的上下文，而不是决策本身。
第一句话的第2部分更为重要：“它会==直接影响到你==。“如果某个架构决策不会直接影响这个人，为什么要就这个架构决策打扰人家呢？
这是一个很好的试金石，用来确定应该将架构决策直接通知给哪些利益相关者（包括开发人员）。
第二句话提供了架构==决策的链接==，因而保证架构决策仅存储在1个地方，是决策的单一系统记录


## 19.2 具备架构意义

许多架构师认为，如果架构决策涉及任何特定技术，那它就不是一个架构决策，而是技术决策。事实上并非总是如此

具备架构意义的决策是那些会影响==结构、非功能特性 依赖项、接口或构建==技术的决策。


## 19.3 架构决策记录

记录架构决策的 最有效方法之一 就是 进行架构决策记录(ADR)

一条ADR 是 描述特定架构决策的 短文本文件(通常 1-2页).  通常使用 某种文本格式 (如 AsciiDoc 或 Markdown) 来编写。 当然，也可以使用 wiki 页面模板 来编写 ADR
==https://github.com/npryce/adr-tools==
。。不过应该是 命令行的，感觉有点过时了啊。不如 可视化界面 那么 好看。 不过我没用过，不知道 到底怎么样。


### 19.3.1 基本结构

adr 包含5个部分
- 标题
  架构决策简介，通常带上序号
- 状态
  已提议(需要更高一层来决定)，已接受(已通过，可以编码)，已取代(及被谁取代)
- 背景
  为什么要做这个决策
- 决策
  决策内容及合理性分析
- 后果
  这个决策所产生的影响

我们通常会再添加2个内容
- 合规性
  如何确保决策的合规性
- 备注
  决策的一些元数据(如 作者，通过时间，通过人，取代时间，最近修改时间，修改人等)


19.3.2 ADR 的存储

无论哪里存储，每个架构决策 都应该具有 自己的文件 或 wiki 页面。
一些架构师喜欢 将 ADR和源码 一起保留在 git仓库中，这样还可以对 ADR 进行 版本控制 和 跟踪。
但对于大型组织， 不能这样做，因为：
- 需要查看架构决策的人 可能无法访问 git仓库
- 对于 应用的git代码库之外的上下文而言，这不是好的存储 adr的地方。

我们建议将 adr 存储在 wiki (使用wiki模板) 或 共享文件服务器上的 共享目录中，并对 adr 进行分类，分为 application(又分为common, 每个应用一个文件夹), integration, enterprise
- application 包含 某些应用上下文相关的架构决策。
  - common 存放 适合所有应用的 架构决策
  - 每个应用一个文件夹
- intergration 包含与 应用，系统，服务 之间通信 相关的 adr。
- enterprise，影响所有系统 和应用的全局架构决策。





# ch20 分析架构风险

每个架构 都设计 可用性，可扩展性，数据完整性 的风险。

## 20.1 风险矩阵

2个维度 给 风险定性： 风险的整体影响 和 该风险发生的可能性
每个维度有 1,2,3 3个级别。  在网格内 22相乘 就是 风险的客观数字。
1,2 低风险， 3,4中风险， 6,9高风险

|-|风险发生概率低|中|高|
|--|--|--|--|
|风险整体影响低|1|2|3|
|中|2|4|6|
|高|3|6|9|



## 20.2 风险评估

风险矩阵可用于构建风险评估。风险评估是对架构总体风险的汇总报告，与一些上下文且有意义的评估标准相关。

|风险标准|用户注册|目录检出|订单履约|订单出货|整体风险|
|--|--|--|--|--|--|
|可扩展性|2|6|1|2|11|
|可用性|3|4|2|1|10|
|性能|4|2|3|6|15|
|安全性|6|3|1|1|11|
|数据完整性|9|6|1|1|17|
|整体风险|24|21|8|11|-|

可以将 非高风险的 置空， 然后计算 整体风险 得到表格。

但是 表格无法看到 情况是在改善 还是 恶化

可以在 每个格子 中增加 标记 来标识。 需要说明 标记的含义， 比如 + 或 向上的箭头 是风险加 还是 风险减少？


## 20.3 风险风暴

没有架构师 可以单枪匹马 确定 系统的 整体风险。因为
- 单个架构师 可能会 错过 或忽略 某个风险域， 
- 很少有 架构师能 对系统的每个部分都有 全面的了解。 

这就是 风险风暴可以 发挥作用的地方

风险风暴是一种 协作活动，用于 确定 特定维度内的 架构风险。
常见的维度(风险的类别)包括 ==未经验证的技术，性能，可扩展性，可用性(包括依赖传递项)，数据丢失，单点故障，安全性==。

尽管 大多 风险风暴 由 多个架构师 共同完成，但是 引入 高级开发人员 和技术主管 是 明智的选择。 因为可以带来 实施层的视角， 也有助于 开发人员 更好地了解架构。

风险风暴主要分为 3个活动
- 识别风险
- 达成共识
- 缓解风险


。。跳


# ch21 架构绘图和演示


新晋架构师经常说，他们惊讶地发现自己的工作包含技术知识和经验之外各种各样的内容，而正是这些最初吸引他们成为架构师。
尤其是==有效沟通，它对架构师的成功至关重要==

对架构师来说，==架构绘图和演示==是两项关键软技能。


### 21 1.2 绘图标准： UML，C4 和 ArchiMate

UML
统一建模语言 (UML) 个标准，统 20 世纪 80 年代相互竞争的3种设计哲学
它本应是世界上最好的绘图标准，但就像由委员会设计的许多东西，它未能在使用它的组织之外产生太大影响。

架构师和开发人员仍会使用 ==UML 类图和序列图==来沟通代码结构和程序流，其他大多数已经被废弃

C4
旨在解决UML的不足 并使用 更现代化的方法

4个C的含义

- Context 上下文
- Container 容器
- Component 组件
- Class 类

如果公司在寻找 标准化的 绘图技术，C4是一个很好的选择。 但是 它无法表达 每一种设计。
对于 容器 和组件关系 可能会 不同的 单体架构， C4十分合适。
但对于 分布式 (如微服务)， C4就不太合适了。


ArchiMate
是开源的 企业级架构 建模语言，支持 对 业务域内 和 跨业务域 的架构 进行描述，分析，可视化。
是 The Open Group 的技术标准，它为 企业生态系统 提供了 一种 轻量级的 建模语言。
ArchiMate 的目标是 尽可能小， 不强调 包含 所有 极端情况。 因此，它成为许多架构师的 选择




# ch22 打造高效团队



## 22.4 团队告警信号

团队越大，需要的控制就越多。

在考虑最高效的 开发团队规模时，有3个因素 发挥作用
- 过程损失
- 多元无知
- 责任扩散


过程损失 也称为 布鲁克定律。 基本概念是： 向项目中添加的人员越多，项目所花费的时间就越多。
比如，合并冲突，那就说明 成员 互相 "踩到彼此的脚"，并处理相同的代码。

团队规模变得太大时，会出现 多元无知，指 每个人都统一 (但私下拒绝) 一种规范，因为他们认为 自己遗留了一些明显的东西。
比如，在一个 大型团队中， 大多数人 同意 在2个 远程服务之间使用 消息传递 是最佳方法。 但是，团队中 有一个人 认为这是一个愚蠢的想法，因为 2个服务之间有一个 安全防火墙。 但是这个人 没有 说出来， 因为 他担心 自己要么错过了 一些明显的东西，要么 担心 如果自己大声说出来 会被当成傻瓜。

多元无知的概念来自 《皇帝的新衣》。 所有的臣民 都害怕被认为是 愚蠢 或无价值的。

架构师 应该在 任何形式的 会议 或讨论中 观察 面部表情和肢体语言， 并在 感觉到 多元无知者时 充当 促进者。

第三个表明合适团队规模的 因素是 责任扩散， 它基于这样一个事实：随着团队规模的扩大，会对 沟通产生负面影响。


## 22.5 利用检查清单

不要在清单中 列举明显的东西。 这些明显的东西 经常被 跳过 或错过。

最有效的 3个关键 检查清单 是 ==开发人员代码完成检查清单，单元和功能测试检查清单，软件发布检查清单==

霍桑效应 (告知开发者，这个要查的，实际，抽查)

。可以用 sonar 。


# ch23 谈判和领导能力

23.4 总结
罗斯福：成功公式中最重要的一个因素就是知道如何与人相处


# ch24 打造职业发展路径

不断学习

知识广度

新闻源，网站。


## 24.1 20分钟规则

每天至少花 20分钟 来学习 新知识 或深入 研究某个 特定主题。

比如 InfoQ， DZone Refcardz ，ThoughtWorks Technology Radar

了解一些不熟悉的术语(未知的未知)， 把这些知识 推广到 已知的未知 中。 
或 深入某个特定的话题来获得更多的知识

我们强烈建议 早上 第一件事情 就是 利用20分钟规则。
因为早上的 第一件事情 是 一杯咖啡， 第二件事情 是查看 email。 一旦看了email，注意力就被转移了。

我们强烈建议 第一件事情就是 20分钟规则 (在咖啡之后， email之前)。 早点去上班。



## 24.2 开发个人雷达

使用 ThoughsWorks 。 构建一个雷达。


## 24.3 使用社交媒体

强链接：家庭，同事，经常联系的人
弱连接：泛泛之交，远亲，一年只见几次的人

某个人的下一份工作更有可能来自弱链接，而不是强链接

利用社交网络的特点，架构师可以利用社交媒体来提高他们的技术广度。
通过专业地使用 Twitter 这样的社交媒体，架构师能够找到他们所需要的技术人员，并在社交媒体上关注他们 。这允许架构师在新的、有趣的技术上构建一个网络，以评估和跟上技术世界的快速变化。



# 附录A 自测问题

很多问题。
很好的问题。

ch1
- 软件架构的4个维度是什么
- 架构决策 和 设计原则之间的区别是什么
- 架构师的 8个核心期望是什么
- 架构的第一定律是什么


ch2
- 描述架构与开发的传统方法，并解释 为什么这种方法不再有效
- 列出知识金字塔的3个层次，并为每层举例
- 为什么架构师 技术的广度 比深度更重要
- 哪些方法可以 为 架构师 保持 技术深度 


ch3
- 共生性的意思
- 静态共生性，动态共生性 区别
- 类型共生性的含义， 它是静态还是动态 共生性
- 最强的共生性形式 是什么
- 最弱的共生性形式
- 基于代码的共生性中，静态共生性，动态共生性 哪个更好

ch4
- 要将属性视为架构特征，必须满足哪3个条件
- 隐式特征 和显示特征 区别是什么，各举一个例子
- 提供一个 运营性特征的例子
- 提供一个 结构特征的例子
- 提供一个 横切特征的例子
- 对于 可用性 或性能而言， 哪个架构特征更重要

ch5
- 说明为什么 限制 架构应该支持的 特征的数量 是一个好的实践
- T or F：大多数架构特征来自业务需求和用户故事
- 如果业务利益相关者声明了上市时间 是最重要的业务问题，架构需要支持哪些架构特征
- 可伸缩性 和弹性之间的区别是什么
- 你发现 你的公司 即将进行几项重大收购，以显著增加 其客户基础。应该担心哪些架构特征

ch6
- 为什么圈复杂性是 架构分析的一个重要指标
- 什么是 架构适应度函数，如何使用它们来分析架构
- 提供一个架构适应度函数的 示例，以度量架构的可伸缩性
- 对于允许架构师和 开发人员创建适合的功能的架构特征，最重要的标准是什么

ch7
- 什么是 架构量子，为什么它对架构很重要
- 假设系统由一个 用户界面 和 4个独立部署的 服务组成，每个服务都包含 自己的独立数据库。这个系统会有 一个量子 还是 4个量子？为什么？
- 假设系统包含管理部分，管理静态引用数据(如 产品目录 和仓库信息)，以及管理订单放置 的面向客户的部分。 这个系统应该有多少量子？为什么？如果 有多个量子，管理量子 和 面向客户的量子 可以共享一个 数据库吗？ 如果是这样，数据库需要驻留在哪个量子中？

ch8
- 我们将组件这个术语定义为 应用程序的一个构件块 -- 应用程序所做的事件。组件通常由 一组类 或 源文件组成。组件通常如何在 应用程序或服务中显示
- 技术分区 和 域分区 的区别是什么？ 各提供一个例子
- 域分区的优点是什么？
- 在什么情况下，技术分区 优于域分区？
- 什么是实体陷阱？为什么它不是组件表示的 好方法
- 在确定核心组件时，什么时候可以选择工作流方法 而不是 参与者/操作方法

ch9
- 列出 分布式计算的 8个谬误
- 说出3个分布式机构 拥有 而 单机架构 没有 的挑战
- 什么是 特征耦合
- 有哪些方法可以解决 特征耦合

ch10
- 开放层 和封闭层的 区别是什么
- 描述隔离层的 概念 和这个概念的好处
- 什么是 架构污水池反模式
- 驱动你 使用 分层架构的 主要架构特征是什么
- 为什么分层架构 风格不能很好地 支持 可测试性
- 为什么敏捷性 在分层架构风格中 没有得到很好的支持

ch11
- 管道架构中的管道 可以是双向的吗
- 说出 4种类型的过滤器 及 用途
- 过滤器可以通过 多个管道发送数据吗
- 管道架构样式 是技术分区 还是 域分区
- 管道架构以何种方式 支持模块化
- 提供 2个管道架构样式的 实例

ch12
- 微内核架构风格的 另一个名称是什么
- 在什么情况下 插件组件 可以依赖于其他插件组件
- 有哪些工具 和框架 可以用来 管理插件
- 如果你有一个 不符合 核心系统的标准插件契约的第三方插件，你会怎么做
- 提供微内核架构风格的 2个示例
- 微内核架构 是技术分区 还是 域分区
- 为什么 微内核架构 总是一个 单一的 架构量子
- 什么是 域/架构 同构

ch13
- 在典型的基于服务的架构中有多少服务
- 必须在基于服务的架构中拆分数据库吗
- 在什么情况下需要拆分数据库
- 在基于服务的架构中，可以使用什么技术来管理 数据库更改
- 域服务是否需要一个 容器(如docker) 来运行
- 基于服务的架构样式很好地 支持哪些架构特征
- 为什么在基于服务的架构中 不能很好地支持弹性
- 如何在基于服务的架构中增加 架构量子的 数量


ch14
- 代理拓扑和中介拓扑之间的主要区别是什么
- 为了更好地控制工作流，使用 中介拓扑还是 代理拓扑
- 代理拓扑通常是 利用 带有主题的 发布-订阅模型 还是 带有队列的 点对点模型
- 说出异步通信的 2个主要优点
- 给出一个基于 请求模型的 典型请求的例子
- 给出一个 基于 事件模型的 典型请求的例子
- 在事件驱动的架构中，初始事件和处理事件有什么区别
- 在从队列发出和接收消息时，有哪些技术可以防止数据丢失
- 使用事件驱动架构的 3个主要驱动架构特征是什么
- 事件驱动的架构中有哪些架构特征没有得到很好的支持


ch15
- 基于空间的架构的名字从何而来
- 基于空间的架构与其他架构风格的主要区别是什么
- 请说出 基于空间的 架构中的 虚拟化中间件的 4个组件的名称
- 消息传递网络的角色是什么
- 数据写入器 在基于空间的 架构中扮演什么角色
- 服务需要在什么条件下 通过数据读取器访问数据
- 小的缓存大小 是否会增加 或减少 数据冲突的机会
- 复制缓存 和分布式缓存的区别 是什么？ 哪个是典型的用于空间的架构
- 列出基于空间的架构中 最受支持的 3个架构特征
- 为什么基于空间的架构的 测试率如此之低

ch16
- 面向服务的架构背后的主要驱动力是什么
- 面向服务的架构中四种主要服务类型是什么
- 列出一些导致面向服务的架构 崩溃的因素
- 面向服务的架构是 技术分区 还是域分区
- 如何在 SOA中实现 域重用？如何处理可操作的重用？

ch17
- 为什么有界上下文概念 对于微服务架构如此重要
- 确定微服务中是否有正确的 粒度级别的3种方式是什么
- 边车可能包含哪些功能
- 编制和编排的区别，微服务支持哪些功能，微服务中的一种通信风格是否更容易
- 微服务的 saga 是什么
- 为什么微服务能很好地支持敏捷性，可测试性和 可部署性
- 性能在微服务中 通常是一个问题的 2个原因是什么
- 微服务架构是 域分区还是 技术分区
- 描述一个 拓扑结构，其中 微服务生态系统 可能只是一个量子
- 如何在微服务中 实现域重用，如何处理可操作的重用

ch18
- 数据结构(逻辑和物理数据模型的结构) 以 何种方式 影响架构风格的选择
- 它如何影响你对使用的架构风格的选择
- 描述架构师用于确定 架构样式，数据分区，通信样式的步骤
- 什么因素导致架构师 采用 分布式架构

ch19
- 什么是 掩盖资产 反模式
- 有哪些技术 可以避免电子邮件驱动的架构反模式
- 识别具有重要架构意义的事物(。事务？)的 5个因素是什么
- 架构决策记录的 5个基本部分时什么
- 在ADR的哪个部分，你通常会添加 架构决策的理由
- 假设你不需要一个 单独的 替代部分，你会在 ADR的哪个部分列出 你所建议的 解决方案的 替代部分
- 你将 ADR的状态 标记为 Proposed 的3个基本标准是什么

ch20
- 风险评估矩阵的 2个维度是什么
- 在风险评估中有哪些方法可以显示特定风险的方向，你能想到其他的方法来表明风险 是降低 还是 加剧了吗
- 为什么有必要将 风险风暴 作为一项协作活动
- 为什么 风险风暴中的识别活动 必须是 一个 单独的活动，而不是一个 协作的活动
- 如果3个参与者认为 架构的 某个特定区域 风险很高，而另一个参与者认为 风险只是中等，你会怎么做
- 对于 未经证实 或 未知的技术，你会给出什么样的风险等级

ch21
- 什么是 非理性的工件附件，为什么它在编写架构文档 和 绘制架构图方面很重要
- C4 建模技术中 4个C 指什么
- 在绘制架构图时， 组件之间的 虚线是什么意思
- 什么是 满是子弹的尸体 反模式，在创建 演讲文稿时 如何避免这种反模式
- 在演示时，演示者的2个主要 信息渠道是什么

ch22
- 架构师个性的3种类型是什么，每种个性创造了什么样的边界
- 决定你的团队中应该表现出的控制水平的 5个因素是什么
- 你可以通过哪3个警告信号 来判断的你的团队 是否过于庞大
- 列出 3个对开发团队有好处的基本清单

ch23
- 为什么协商 对架构师如此重要
- 当业务利益相关者 坚持要 5个9， 但实际上 只需要 3个9时，说出一些 协商技巧
- 你能从 一个 告诉你 "我昨天就需要它" 的业务利益相关者那里得到什么
- 为什么重要的是 把 关于时间 和成本的 讨论留到 谈判的最后
- 分治法则是什么，当与业务利益相关者 协商 架构特征时，如何应用它，提供一个例子
- 列出架构的 4c
- 解释为什么 架构师既要务实 又要有 远见
- 管理和减少 被邀请参加的 会议的 技巧有哪些

ch24
- 20分钟规则是什么， 什么时候使用它最好
- 在 ThoughtWorks 技术雷达上的 4个环是什么？ 它们是什么意思，如何将它们应用到你的雷达上
- 描述应用于 架构师的 知识 深度 和 广度之间的差异。 应该追求哪个最大化


---

2024-05-11 18:29












