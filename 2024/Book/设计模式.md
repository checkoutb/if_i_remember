设计模式 可复用面向对象软件的基础

2024-05-11 18:30

不一定看的完。

[[toc]]

---
---


# ch1 引言

我们都知道设计经验的重要价值。
你曾经多少次有过这种感觉：你已经解决过一个问题但就是不能确切地知道是在什么地方或怎么解决的

设计模式使人们可以更加简单方便地复用成功的设计和体系结构。

本书中涉及的设计模式并不描述新的或未经证实的设计，我们只收录那些在不同系统中==多次使用过的成功设计==。


## 1.1 什么是设计模式

Christopher Alexander说过：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”
尽管他指的是 城市和建筑模式，但他的思想同样适用于 面向对象设计模式

一般而言，一个模式有四个基本要素
- 模式名（pattern name）
- 问题（problem）
- 解决方案（solution）
- 效果（consequence）


这些方案的实现语言是Smalltalk和C++等主流面向对象编程语言，而不是过程式语言（Pascal、C、Ada）或更具动态特性的面向对象语言（CLOS、Dylan、Self）。
我们从实用角度出发选择了Smalltalk和C++，因为在这些语言的使用上我们积累了许多经验，况且它们也变得越来越流行。
。。java: 我呢?


## 1.2 Smalltalk MVC 中的设计模式

在 Smalltalk-80 中，类的 模型/视图/控制器 被用来构建 用户界面。

。。我以为 java的

MVC包括三类对象。
- 模型（Model）是应用对象，
- 视图（View）是它在屏幕上的表示，
- 控制器（Controller）定义用户界面对用户输入的响应方式。

不使用MVC，用户界面设计往往将这些对象混在一起，而MVC则将它们分离以提高灵活性和复用性。


MVC通过建立一个“订购/通知”协议来分离视图和模型。
视图必须保证它的显示正确地反映了模型的状态。
一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。
这种方法可以让你为==一个模型==提供不同的==多个视图==表现形式，也能够为一个模型==创建新的视图==而==无须重写模型==。

MVC的另一个特征是视图可以嵌套。
例如，按钮控制面板可以用一个嵌套了按钮的复杂视图来实现。
对象查看器的用户界面可由嵌套的视图构成，这些视图又可复用于调试器。
MVC用View类的子类——CompositeView类来支持嵌套视图。

MVC的主要关系还是由Observer、Composite和Strategy三个设计模式给出的。


1.3 描述设计模式

## 1.4 23个设计模式总览

- Abstract Factory 3.1
  提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。
- Adapter 4.1
  将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- Bridge 4.2
  将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- Builder 3.2
  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- Chain of Responsibility 5.1
  解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它
- Command 5.2
  将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持==可取消的操作==。
- Composite 4.3
  将对象组合成树形结构以表示“部分–整体”的层次结构。Composite使得客户对单个对象和组合对象的使用具有一致性。
- Decorator 装饰器 4.4
  动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
- Facade 4.5
  为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- Factory Method 3.3
  定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
- Flyweight 4.6
  运用共享技术有效地支持大量细粒度的对象。
- Interpreter 5.3
  给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
- Iterator 5.3
  提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
- Mediator 5.5
  用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
- Memento 5.6
  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
- Observer 5.7
  定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
- Prototype 3.4
  用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
- Proxy 4.7
  为其他对象提供一个代理以控制对这个对象的访问。
- Singleton 3.5
  保证一个类仅有一个实例，并提供一个访问它的全局访问点
- State 5.8
  允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
- Strategy 5.9
  定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
- Template Method 5.10
  定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。
- Visitor 5.11
  表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作



## 1.5 组织编目

![f637d57bf486cbf83d73071e16db71f6.png](../_resources/f637d57bf486cbf83d73071e16db71f6.png)


![325f8c35e30c26ba233b74ec021a98f9.png](../_resources/325f8c35e30c26ba233b74ec021a98f9.png)




## 1.6 设计模式怎样解决设计问题

这里给出几个问题以及使用设计模式解决它们的方法

### 1.6.1 寻找合适的对象

面向对象程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或操作。

面向对象设计最困难的部分是将系统分解成对象集合。
因为要考虑许多因素：==封装、粒度、依赖关系、灵活性、性能、演化、复用等==，它们都影响着系统的分解，并且这些因素通常还是互相冲突的。

设计的许多对象来源于现实世界的分析模型。但是，设计结果所得到的类通常在现实世界中并不存在

设计中的抽象对于产生灵活的设计是至关重要的。

设计模式帮你确定并不明显的抽象和描述这些抽象的对象。


### 1.6.2 决定对象的粒度

对象在大小和数目上变化极大。它们能表示下至硬件或上至整个应用的任何事物。那么我们怎样决定一个对象应该是什么呢？

设计模式很好地讲述了这个问题。
- Facade（4.5）模式描述了怎样用对象表示完整的子系统，
- Flyweight（4.6）模式描述了如何支持大量的最小粒度的对象。

其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。
- Abstract Factory（3.1）和Builder（3.2）产生那些专门负责生成其他对象的对象。
- Visitor（5.10）和Command（5.2）生成的对象专门负责实现对其他对象或对象组的请求。


### 1.6.3 指定对象接口

对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构（signature 。。。签名啊，而且有时候返回值不算）。
对象操作所定义的所有操作型构的集合被称为该对象的接口（interface）。

在面向对象系统中，接口是基本的组成部分。对象只有通过它们的接口才能与外部交流

对象接口与其功能实现是分离的，不同对象可以对请求做不同的实现，也就是说，两个有相同接口的对象可以有完全不同的实现。

动态绑定是指发送的请求直到运行时才受你的具体实现的约束。

动态绑定允许你在运行时彼此替换有相同接口的对象。这种可替换性就称为多态（polymorphism）

设计模式也许还会告诉你接口中不应包括哪些东西。
Memento（5.6）模式是一个很好的例子，它描述了怎样封装和保存对象内部的状态，以便一段时间后对象能恢复到这一状态。
它规定了Memento对象必须定义两个接口：一个允许客户保持和复制memento的限制接口，一个只有原对象才能使用的用来储存和提取memento中状态的特权接口。

设计模式也指定了接口之间的关系。
特别是，它们经常要求一些类具有相似的接口，或它们对一些类的接口做了限制。
例如，Decorator（4.4）和Proxy（4.7）模式分别要求Decorator和Proxy对象的接口与被修饰的对象和受委托的对象一致。
而Visitor（5.11）模式中，Visitor接口必须反映出visitor能访问的对象的所有类。


### 1.6.4 描述对象的实现

抽象类（abstract class）的主要目的是为它的子类定义公共接口。
抽象类将把它的部分或全部操作的实现延迟到子类中

混入类（mixin class）是给其他类提供可选择的接口或功能的类。
它与抽象类一样不能实例化。混入类要求多继承


理解类继承和接口继承（或子类型化）之间的差别也十分重要。
类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是==代码和表示的共享机制==。
然而，接口继承（或子类型化）描述了==一个对象什么时候能被用来替代另一个对象==。


对接口编程，而不是对实现编程


当你不得不在系统的某个地方实例化具体的类（即指定一个特定的实现）时，创建型模式（Abstract Factory（3.1）、Builder（3.2）、Factory Method（3.3）、Prototype（3.4）和Singleton（3.5））可以帮你。
通过抽象对象的创建过程，这些模式提供不同的方式以在实例化时建立接口和实现的透明连接。创建型模式确保你的系统是采用针对接口的方式，而不是针对实现的方式而书写的


### 1.6.5 运用复用机制

理解对象、接口、类和继承之类的概念对大多数人来说并不难，问题的关键在于如何运用它们写出灵活的、可复用的软件。
设计模式将告诉你怎样去做。

1. 继承和组合的比较
功能复用的两种最常用技术是 类继承 和 对象组合

类继承允许你根据其他类的实现来定义一个类的实现。
这种通过生成子类的复用通常被称为白箱复用（white-box reuse）。
术语“白箱”是相对可视性而言的：在继承方式中，父类的内部细节对子类可见。

新的更复杂的功能可以通过组装或组合对象来获得。
对象组合要求被组合的对象具有良好定义的接口。
这种复用风格被称为黑箱复用（black-box reuse），因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。


类继承是在编译时静态定义的，且可直接使用，因为程序设计语言直接支持类继承。类继承可以较方便地改变被复用的实现。

类继承也有一些不足之处。首先，因为继承在编译时就定义了，所以无法在==运行时改变从父类继承的实现==。
更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的==实现细节==，所以继承常被认为“==破坏了封装性==”。
子类中的实现与它的父类有如此==紧密的依赖==关系，以至于父类实现中的任何变化必然会导致子类发生变化。

当你需要复用子类时，实现上的依赖性就会产生一些问题。
如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。
这种依赖关系限制了灵活性并最终限制了复用性。
一个可用的解决方法就是==只继承抽象类==，因为抽象类通常提供较少的实现。
。。就是 子子类 集成了 子类，但是发现 父类的方法 不适用。 挺奇怪的场景。

---

对象组合是通过获得对其他对象的引用而在运行时动态定义的。
组合要求对象遵守彼此的接口约定，进而要求更==仔细地定义接口==，而这些接口并不妨碍你将一个对象和其他对象一起使用。
这还会产生良好的结果：因为对象==只能通过接口访问==，所以我们并==不破坏封装性==；只要类型一致，==运行时==还可以用一个对象来==替代==另一个对象；更进一步，因为对象的实现是==基于接口==写的，所以实现上存在==较少的依赖==关系。

对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。
这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。
另外，基于对象组合的设计会有更多的对象（而有较少的类），且系统的行为将依赖于对象间的关系而不是被定义在某个类中。

==优先使用对象组合，而不是类继承。==

设计者往往过度使用了继承这种复用技术。
依赖于对象组合技术的设计却有更好的复用性（或更简单）

2. 委托
委托（delegation）是一种组合方法，它==使组合具有与继承同样的复用能力==

在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者（delegate）。这类似于子类将请求交给它的父类处理

举例来说，我们可以在窗口类中保存一个矩形类的实例变量来代理矩形类的特定操作，这样窗口类可以复用矩形类的操作，而不必像继承时那样定义成矩形类的子类。
也就是说，一个窗口拥有一个矩形，而不是一个窗口就是一个矩形。窗口现在必须显式地将请求转发给它的矩形实例，而不是像以前那样必须继承矩形的操作。
。。？ 这不就是 组合？
。。
委托:一个对象数据成员中包含另一个Class的指针,我们称这种关系为委托。 组合:组合就是将一个庞大的整体拆开成多个小零件,每个小零件自成一个类
。。
。指针 与 实体 的区别。

委托的主要优点在于它便于运行时组合对象操作以及改变这些操作的组合方式。

假定矩形对象和圆对象有相同的类型，我们只需要简单地用圆对象替换矩形对象，得到的窗口就是圆形的。

。。感觉 就是 组合 是真实的包含，真的含有。  委托是 借用 其他类的方法，可以替换。
。。组合 实体， 委托 接口。  所以是 组合是整体拆开成小零件，  委托是 指针。

委托与那些通过对象组合取得软件灵活性的技术一样，具有如下不足之处：动态的、高度参数化的软件比静态软件更难于理解。还有运行低效问题

只有当委托使设计比较简单而不是更复杂时，它才是好的选择。

有一些模式使用了委托，如State（5.8）、Strategy（5.9）和Visitor（5.11）。
- 在State模式中，一个对象将请求委托给一个描述当前状态的State对象来处理。
- 在Strategy模式中，一个对象将一个特定的请求委托给一个描述请求执行策略的对象，一个对象只会有一个状态，但它对不同的请求可以有许多策略。

这两个模式的目的都是通过改变受托对象来改变委托对象的行为。

- 在Visitor中，对象结构的每个元素上的操作总是被委托到Visitor对象。


3. 继承和参数化类型的比较
另一种功能复用技术（并非严格的面向对象技术）是参数化类型（parameterized type），也就是类属（generic）（Ada、Eiffel）或模板（template）（C++）。

。。generic， 泛型

参数化类型给我们提供除了类继承和对象组合外的 第三种 方法来组合面向对象系统中的行为。

本书没有一种模式是与参数化类型有关的


### 1.6.6 关联运行时和编译时的结构

聚合意味着一个对象拥有另一个对象或对另一个对象负责
聚合意味着聚合对象和其所有者具有相同的生命周期。

相识意味着一个对象仅仅知道另一个对象。
有时相识也被称为“关联”或“引用”关系
相识的对象可能请求彼此的操作，但是它们不为对方负责。
相识是一种比聚合要弱的关系，它只标识了对象间较松散的耦合关系。

聚合还是相识是由你的意图而不是显式的语言机制决定的。
尽管它们之间的区别在编译时的结构中很难看出来，但这些区别还是很大的。
聚合关系使用较少且比相识关系更持久；而相识关系则出现频率较高，但有时只存在于一个操作期间，相识也更具动态性，使得它在源代码中更难被辨别出来。


许多设计模式（特别是那些属于对象范围的）显式地记述了编译时和运行时结构的差别。
- Composite（4.3）和Decorator（4.4）对于构造复杂的运行时结构特别有用。
- Observer（5.7）也与运行时结构有关，但这些结构对于不了解该模式的人来说是很难理解的。
- Chain ofResponsibility（5.1）也产生了继承所无法展现的通信模式。

总之，只有理解了模式，你才能清楚代码中的运行时结构


### 1.6.7 设计应支持变化

获得最大限度复用的关键在于对新需求和已有==需求发生变化==时的==预见性==，要求你的系统设计能够==相应地改进==。

为了设计适应这种变化且具有健壮性的系统，你必须考虑系统在它的生命周期内==会发生怎样的变化==。

一些==导致重新设计==的一般原因，以及解决这些问题的设计模式：
- 通过显式地指定一个类来创建对象
  指定类名将使你受特定实现的约束而不是特定接口的约束
  要避免这种情况，应该间接地创建对象
  设计模式：Abstract Factory（3.1），Factory Method（3.3），Prototype（3.4）。
- 对特殊操作的依赖
  当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时或运行时很方便地改变响应请求的方法
  设计模式：Chain of Resposibility（5.1），Command（5.2）。
- 对硬件和软件平台的依赖
  外部的操作系统接口和应用编程接口（API）在不同的软硬件平台上是不同的。
  设计模式：Abstract Factory（3.1），Bridge（4.2）。
- 对对象表示或实现的依赖
  知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。
  设计模式：Abstract Factory（3.1），Bridge（4.2），Memento（5.6），Proxy（4.7）。
- 算法依赖
  算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化
  设计模式：Builder（3.2），Iterator（5.4），Strategy（5.9），Template Method（5.10），Visitor（5.11）。
- 紧耦合
  紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。
  设计模式：Abstract Factory（3.1），Command（5.2），Facade（4.5），Mediator（5.5），Observer（5.7），Chain of Responsibility（5.1）
- 通过生成子类来扩充功能
  通常很难通过定义子类来定制对象
  一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。
  设计模式：Bridge（4.2），Chain of Responsibility（5.1），Composite（4.3），Decorator（4.4），Observer（5.7），Strategy（5.9）。
- 不能方便地对类进行修改
  有时你不得不改变一个难以修改的类。也许你需要源代码而又没有（对于商业类库就有这种情况），或者可能对类的任何改变会要求修改许多已存在的其他子类。
  设计模式：Adapter（4.1），Decorator（4.4），Visitor（5.11）。


设计模式在开发如下三类主要软件中所起的作用：应用程序、工具箱和框架。

。跳


## 1.7 怎样选择设计模式

- 考虑设计模式是怎样解决设计问题的
- 浏览模式的意图部分
- 研究模式怎样互相关联
- 研究目的相似的模式
- 检查重新设计的原因
- 考虑你的设计中哪些是可变的

![e030e9778f048233cc75c05045849d02.png](../_resources/e030e9778f048233cc75c05045849d02.png)



## 1.8 怎样使用设计模式

- 大致浏览一遍模式
- 回头研究结构部分、参与者部分和协作部分
- 看代码示例部分，看看这个模式代码形式的具体例子
- 选择模式参与者的名字，使它们在应用上下文中有意义
- 定义类
- 定义模式中专用于应用的操作名称
- 实现执行模式中责任和协作的操作




# ch2 实例研究：设计一个文档编辑器

。跳


# ch3 创建型模式

创建型设计模式抽象了实例化过程

它们帮助一个系统独立于如何创建、组合和表示它的那些对象

一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。

随着系统演化得越来越依赖于对象组合而不是类继承，创建型模式变得更为重要。
。。因为 继承，只需要 new 子类， 而 组合，需要 注入合适的 对象作为 属性(就是 new完 还需要 set一些属性， 不过 new(属性1，属性2，..) 也可以， 但是也 最好 只需要一个参数 就可以 获得 组合好的对象)

在这些模式中有两个不断出现的主旋律。
第一，它们都将关于该系统使用哪些==具体的类==的信息封装起来。
第二，它们隐藏了这些类的实例是如何被==创建和放在一起==的

配置可以是静态的（即在编译时指定），也可以是动态的（在运行时指定）


我们将所有5个模式一起研究以突出它们的相似点和差异点。
我们也将举一个通用的例子——为一个电脑游戏创建一个迷宫——来说明它们的实现


类Room、Door和Wall定义了我们所有的例子中用到的构件

每个房间有4面，使用 枚举 Direction 来指定房间的 东南西北
`enum Direction {North, South, East, West};`

类MapSite是所有迷宫构件的公共抽象类。
为简化例子，MapSite仅定义了一个操作Enter，它的含义取决于你在进入哪里。
- 如果你进入一个房间，那么你的位置会发生改变。
- 如果你试图进入一扇门，那么将发生以下两件事之一：
  - 如果门是开着的，你进入另一个房间；
  - 如果门是关着的，那么你就会碰壁

```C++
class MapSite {
public:
  virtual void Enter() = 0;
};
```

Room 是 MapSite的一个 具体子类
```C++
class Room : public MapSite {
public:
  Room(int roomNo);
  MapSite* GetSide(Direction) const;
  void SetSide(Direction, MapSite*);
  virtual void Enter();

private:
  MapSite* _side[4];
  int _roomNumber;
};
```

下面的类描述了一个房间的每一面所出现的墙壁或门。
```C++
class Wall : public MapSite {
public:
  Wall();
  virtual void Enter();
};

class Door : public MapSite {
public:
  Door(Room* = 0, Room* = 0);
  virtual void Enter();
  Room* OtherSideFrom(Room*);

private:
  Room* _room1;
  Room* _room2;
  bool _isOpen;
};
```

我们不仅需要知道迷宫的各部分，还要定义一个用来表示房间集合的Maze类。

```C++
class Maze {
public:
  Maze();
  void AddRoom(Room*);
  Room* RoomNo(int) const;
private:
  // ...
};
```

另一个类是MazeGame，由它来创建迷宫。
```C++
Maze* MazeGame::CreateMaze() {
  Maze* aMaze = new Maze;
  Room* r1 = new Room(1);
  Room* r2 = new Room(2);
  Door* theDoor = new Door(r1, r2);

  aMaze->AddRoom(r1);
  aMaze->AddRoom(r2);

  r1->SetSide(North, new Wall);
  r1->SetSide(East, theDoor);
  r1->SetSide(South, new Wall);
  r1->SetSide(West, new Wall);

  r2->SetSide(North, new Wall);
  r2->SetSide(East, new Wall);
  r2->SetSide(South, new Wall);
  r2->SetSide(West, theDoor);
};
```


假设你想在一个包含（所有的东西）施了魔法的迷宫的新游戏中复用一个已有的迷宫布局。
施了魔法的迷宫游戏有新的构件，如 DoorNeedingSpell，它是一扇只能用咒语才能被锁上和打开的门；以及EnchantedRoom，一个可以有不寻常东西的房间，比如魔法钥匙或者咒语。
你怎样才能较容易地改变CreateMaze以让它用这些新类型的对象创建迷宫呢？

这种情况下，改变的最大障碍是对已实例化的类进行硬编码。

- 如果CreateMaze调用虚函数而不是构造器来创建它需要的房间、墙壁和门，那么你可以创建一个MazeGame的子类并重定义这些虚函数，从而改变被实例化的类。这一方法是Factory Method（3.3）模式的一个例子。
- 如果传递一个对象给CreateMaze作为参数来创建房间、墙壁和门，那么你可以传递不同的参数来改变房间、墙壁和门的类。这是Abstract Factory（3.1）模式的一个例子
- 如果传递一个对象给CreateMaze，这个对象可以在它所建造的迷宫中使用增加房间、墙壁和门的操作来全面创建一个新的迷宫，那么你可以使用继承来改变迷宫的一些部分或迷宫的建造方式。这是Builder（3.2）模式的一个例子。
- 如果CreateMaze由多种原型的房间、墙壁和门对象参数化，它复制并将这些对象增加到迷宫中，那么你可以用不同的对象替换这些原型对象以改变迷宫的构成。这是Prototype（3.4）模式的一个例子


## 3.1 Abstract Factory（抽象工厂）——对象创建型模式

意图
提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。

别名
Kit

动机




































