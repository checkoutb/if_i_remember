BV15d4y1U7HH

[[toc]]

---


# C++梳理

BV15d4y1U7HH

这篇视频主讲内存，函数，多态

stack,heap,static
variable,pointer,reference
class,object
new,delete
constructor,destructor,RAII
smart pointer,garbage collection

。。我感觉可以跳啊。

全局变量，程序代码 分配在 static内存区域 ( 在程序的生命周期内，这些内存都被占用)
局部变量，函数返回值等，分配在 栈 中

每次调用函数，在 栈中 分配一个 大小合适的 栈帧，存储 这一次调用的 局部变量，参数，返回值。


```C++
template<class T>
void swap(T& a, T& b) {
    T tmp = std::move(a);
    a = std::move(b);
    b = std::move(tmp);
}
```


模板类/方法 的声明和定义需要在一起， 一起放 头文件。
。主要就是 实例化， 需要在 编译期 实例化 模板，所以 需要知道定义。   而不能 只知道一个 符号，这样 链接器 无法链接。



---

# STL 与 基础数据结构

BV1Rg41117YB


## iterator

所有迭代器都支持 `*,++` 运算符
- input iterator 额外支持 `==, !=, 单次读取, ->`
- output iterator 仅支持单次写入
- forward iterator 在 input iterator 基础上支持 重复访问 及 读写
- bidirectional iterator，在 forward iterator 基础上支持 `--`运算符
- random access iterator 在上面基础上支持 `[], +, +=, -, -=, <, <=, >, >=`， 和普通指针功能相同。

`#include <iterator>` 提供了一些 迭代器 的辅助方法
- `std::advance(iter, n)` 自增n次
- `std::distance(iter1, iter2)` 返回 iter1 和 iter2 的距离
- `std::next(iter, n=1)`, `std::prev(iter, n=1)` 返回 iter+n 或 iter-1

如果 iterator 不是 随机访问迭代器，那么 复杂度 可能是线性的


`for (auto it = c.begin(); it != c.end(); ++it)`

`for (auto& x : c)`

迭代器的类型为 `${container type}::iterator`

begin(),end(),cbegin(),cend(),rbegin(),rend(),crbegin(),crend()
`for (const auto& x : c)`


---

容器的(通用)接口

构造器
ContainerType c(num);
ContainerType c(num, x);
ContainerType c(beg, end);

容量
c.size()
c.empty()
c.resize(num)
c.resize(num, x)
c.clear()

---

## stack

`std::stack<T, Container>`
是一个 container adapter。

initializer_list

emplace_back()


用数组来 自定义stack的话
push: `stack[top++] = x;`
pop: `int y = stack[--top];`
size: `return top;`
empty: `return top == 0;`


给定长度 n 的入栈序列，合法的出栈序列有多少种？

## Catalan数

假设 a1 是 第 i个出栈的， 那么 2到 i-1 的元素 都必须在 a1 之前入栈 出栈， i+1 及之后的元素 必须在 i 之后 入栈 出栈。
所以 原问题被 a1 划分为 2个 子问题。

F(n) = for(i=1,n) { F(i-1) * F(n-i)},  边界条件 F0=1

F(n) = 2nCn - 2nC(n-1)

括号序列，三角剖分，二叉树计数， 都用到 Catalan


---

## queue

container adapter

push，pop
front，back

用2个stack 实现 queue


---

## vector

`[], at(x), front(), back()`
`insert(iter, x)`
`push_back(x)` emplace_back
erase(iter), pop_back();

capacity()   空间大小
reserve(new_cap)   手动设置空间大小， 如果 new_cap <= capacity() ， do nothing

resize(n) 如果 n 小于 当前size，那么 会删除 尾巴


https://en.cppreference.com/w/cpp/container/vector/reserve
`If new_cap is greater than the current capacity(), new storage is allocated, otherwise the function does nothing.`


收缩，如果 一半空间空闲 就 回收 ，这不行的，比如， 元素满，开始 push,pop,push 反复 会导致 不停 扩张，收缩。

是有 3/4 空闲， 收缩 一半。  这个复杂度分析 需要 势能分析。
。。找不到 其他的文章 来证明 对错。
。依赖于 编译器实现。


---

## list

front() back()
insert(iter, x), push_back(x), push_front(x)
erase(iter), pop_back(), pop_front()


forword_list 单向链表 forward iter
list 双向链表  bidirectional iter

哨兵节点。 头 尾 各增加一个 哨兵节点。 head，tail, 降低 增 删 节点时(特别是 对空list进行增 及 删除节点list后为空 的情况) 的难度

list有 insert(iter, x)
forward_list 只有 insert_after(iter, x)

`std::list::reverse()`


---

## priority_queue

底层是 vector + 辅助方法(make_heap，heap_pop等)

`std::priority_queue<T, Container=std::vector<T>, Compare=std::less<T>>`
less 是最大堆。


---

## 其他stl

容器
set
map
deque 英标/dek/

算法
sort
lower_bound
upper_bound
merge





# 基础算法

BV1ya411N7Z3

搜索(剪枝)
贪心
二分与三分
递归与分治
基本的排序算法



## 搜索

搜索树

dfs
bfs

dfs，容易爆栈，需要考虑回溯撤销(。指全排序的时候，x用过了，就要设置状态，退出遍历的时候要把 x状态 改成 未使用)，dfs可能无法停止
bfs，空间开销大(但可以用堆内存)，状态单向拓展(不考虑撤销)，实现较为简单，可以知道从初始状态到每个状态的最少步数(。dfs也可以最少步数)


### 枚举层数+dfs

使用dfs，可能碰到 层数不确定的问题
空间限制，导致不适合 bfs， 但题目又要求 "层数最小" 的解
==可以枚举层数限制，使用dfs，深度到达枚举值时 退出 递归==。    6，完全没有想过，但觉得 不行吧，感觉tle 妥妥的。 或者可以 二分层数，不，第一次dfs就可能 爆栈。 或者 枚举层数时 步长大一些。

如果相邻层状态数成固定比例(下层比上层多)，那么 迭代 + dfs 在 渐进意义下 不影响复杂度。    。。6.



---

### 搜索剪枝

可行性剪枝
- 如果当前状态已经不满足题目要求，则不继续拓展
- 可以用于 最优化问题，也可以用于 统计解

最优性剪枝
- 只能用于 最优化问题
- 如果从当前状态出发，可以得到的最优解 一定不比 已得到的最优解 优，则不再拓展

还有其他剪枝思路，例如，双人游戏中 alpha-beta 剪枝等


八皇后
剪枝1：每行只能一个，每列只能一个，所以 8!
剪枝2：检查 斜向 是否冲突   。。这个应该要 分为 向左斜，向右斜，然后每下降一层，向左斜的 全部-1， 向右的 +1。 还要考虑回溯


埃及分数
用各不相同的单位分数(分子为1的分数) 的和表示 有理数 a/b
1. 使用的 单位分数个数 越少越好
2. 相同数量时，最小分数 越大越好，如果 最小分数相同，则 次小分数 越大越好

。a个 1/b，然后 合并？ 就是 a个1， 合并， 要求合并后 数组长度最小，且 每个元素 能整除 b，且 最小元素 越大越好 ？ 合并的话， 质数么？ 和质数无关。 应该是 把 b的因子拿出来，然后 dfs
。。。。。

层数不固定，但存储又比较麻烦 -> 迭代加深搜索， 按 分数从大到小(即 分母从小到大) 搜索
可行性剪枝1：枚举层数显示L，可以算出 最大的分数 分母最大是多少 ( L/x > a/b  =>  x <= Lb/a)
可行性剪枝2：如果还剩下 x/y，最小的分母 q >= y/x, 如果至少还有2个分数则 q > y/x
可行性剪枝3：最后一层 剩下 x,y 直接判断 y/x 是否为整数。
最优性剪枝4：如果已经搜到一组解，且该组解的 最小分数的 分母是 p，那么 后续计算其他 可行解的时候， 分母必须 <= p。
。。
层数L 代表 结果由几个 分数组成。
按照分数 由大到小。

。剪枝1：
L为1，那么 分数至少是  1/ceil(b/a)  . 或者说， 分数为x， x*L >= a/b, L是1， x >= a/b , x >= 1/(b/a)。  因为 计算的时候 第一层是 最大值，下面的都小于 这一层。
。。这种有可能是， 类似： 2个次大  vs.  最大+2个极小 的情况吗？   这里似乎 只考虑 最大 + xx。。。。不会， 2个次大 在 L=2的时候 就算出来了。

---

剪枝2

如果最小分母 q < y/x， 则 分数 1/y > x/y 的，加起来 会大于 a/b

。。


扩展： 分支定界法



## 启发式搜索

对于最优化问题，使用评估函数 评估解的优秀程度。


### A, A*

二维平面，求点s 到 点t 的最短路径

f(n) = g(n) + h(n)，计算经过n 的最短路径
f(n) 是 整条路径的最短距离
g(n) 是 从s 到n 的最短距离
h(n) 是 从n到 t 的最短距离

h(n) 是启发式函数。

A算法：使用 f(n) 对 待扩展节点进行评价，优先扩展 f(n) 最小的

如果 h(n) 恒等于0， 就是 Dijkstra

---


八数码问题

一个 3*3 的棋盘，上面有 8个格子，分别是 1-8 整数

格子如果 和空白格子相邻，那么可以滑动过去。

给出 2个棋盘状态， 求 最少操作次数

g(n) 可以取 当目前为止 操作的次数
h(n) 可以取 当前状态 和 目标状态 不同的格子的 数量。

h(n) 还可以： 当前状态 的 每个值 与 目标状态中的 该值 的 曼哈顿距离 之和

上面的2个 h(n) 都是满足 A* 算法的。

---

A算法，任取h。 用f(n) 对待扩展节点 进行评价，优先扩展 f(n) 小的。

==A* 算法， 要求 h(n) <= h*(n)，(h*(n) 是真实情况)==； 如果边权都非负，那么可以保证 第一次 拓展到t 时经过的路径是最优的。
。。边权。。图 怎么 设置 h(n) 啊。完全不知道 距离是多少啊。  估计是 memo，每次 扩展的时候，都刷新下 最短距离， 这样计算量有点大。

。A* ，确实 直接用 |x diff|+|y diff|  这个肯定是 <= 真实情况的。
。小于 真实情况，这样才能在 其他 解之前 出现，  就是 如果它是最优情况，但是 h(n) 太离谱，导致 排到 最后， 那么 在 计算到 它之前，就 计算到 次优解了， 那么会把 次优解 当做 最优解 返回。


A*算法的性质
- 如果 s 到t 存在合法路径， A* 一定可以找到最优解
- 如果 2个启发函数 h1，h2, 如果 对于所有 非s,t 节点n，都有 h1(n) < h2(n)，那么 使用h1的 A* 拓展的节点 一定 不少于 使用 h2 的A*   。。。h都是小于 真实h 的， h1 < h2，说明 h2 更加真实，所以 h2 拓展的节点更少，更快地 找到 最优解。
  - 如果 h 是真实的 h，那么不需要拓展多余的点
- 如果 h(n) 是单调的，则每个节点最多被拓展一次。 。。单调的定义是一个数学公式。h(t)=0; h(ni) <= d(ni, nj) + h(nj)


---

扩展， 记忆化搜索

有时 会递归到 重复的状态， 如 fibonacci

记忆化搜索 也可以视为 一种剪枝
对于一些递推顺序比较复杂 或 无效状态较多的 dp，可以考虑 用记忆化搜索 降低 常数。




## 贪心

搜索： 遍历所有解
贪心： 沿着一条看上去最优的路径走到底

每次评估当前状态的所有后续，选择最优后续

贪心选择性质：可以通过 局部最优 的贪心决策来构建 全局最优 解，不需要考虑 后效性。

当一个问题有 最优子结构时， 贪心算法往往效果比较好。因为 有最优子结构时，整个问题的 最优解 可以由 子问题的最优解构造得到


和dp的区别

dp要求：最优子结构，无后效性，子问题重叠
贪心：最优子结构，贪心选择性质

dp为后续的每一阶段 决策保留了足够多的子问题
贪心只保留其中一种，简化了处理过程，但因此也不保证总能找到正解


找零钱问题
面值1, 5, 10, 20, 50, 100，组成 给定金额。 贪心(每次选择可选的面值最大)有效  

1,2,4,8,16， 贪心有效

1,5,10,20,25， 贪心无效： 40=20*2


---

证明 贪心的正确性

归纳法：首先证明边界情况是正确的，然后 归纳证明一般情况

反证法：假设某步采用不同的策略，能得到的最优解不比贪心得到的更优


---

合并石子
有n堆石子，每堆有自己的重量。 进行如下操作
  合并两堆石子，代价是 2堆石子的 重量之和。
求把 n堆石子 合并成一堆的 最小代价和

贪心：每次合并当前重量最小的 两堆。


---

Huffman 编码

用最少的 二进制位 压缩给定的字符串，其中每个字符对应唯一的二进制变长编码，且压缩可以复原

。。出现最多的 是1， 次多01，001，000

下面是 边的值 .省略了 非root节点
       root
     0      1(出现最多1)
   0   1 (次多01)
  0 1  (次次多，次次次多，000，001) (一共就4个字符，所以可以结束)


合并石子 就是 一棵哈夫曼树
每堆石子被合并的次数等于 对应 哈夫曼树上叶子节点的 深度， 所以 ==哈夫曼树 是 叶子的带权路径长度 (叶子权值 * 深度) 和最小的 二叉树==

叶子权值越低，放到越深的地方，总和最小。  。 就是  `权值小 * 深度大 + 权值大 * 深度小`  vs. `权值大*深度大 + 权值小*深度小`  。前者更小。

---


## 二分与三分

图书馆 书籍警报， 不能二分， 可能全都是 没有办理借阅的，二分的话， N本书，可以带走 N-1 
。。没有想到， 不过可能 2堆都 检查下，这样也比 一本本快。

二分：在一个集合中有 ==唯一== 一个符合某种特征的 元素，想高效地定位到这个元素。
如果可以 快速判断 一个集合内 是否 包含 该目标元素，则可以通过 二分

常见的二分场景
- 给定一个有序序列，要查找某个元素x，或 查找大于 某个值的 最小元素，或 查找 小于某个值 的最大元素
- 给定一个 单调函数 f(x) ， 求 f(x)=c 的解

注意终止条件
- 对于有限集合，找到需要的元素即可停止
- 对于无限集合(如 实数区间)，需要根据 精度 设置 停止条件

最好保证 左右端点性质不同 ( 一般 使用 左闭右开) 

如果二分判断的时候 使用 ==target， 那么 就需要2次比较， 因为 ==target的几率非常小，并且 ==的时候 就可以返回了， 所以 大概率是判断2次， ==target， > target，2次。  

可以减少比较
```text
while l < r:
  m = (l+r)/2;
  if a[m] < x { r = m }   // 往左 1次比较， 往右2次比较
  else if a[m] == x { return n}
  else { l = m + 1 }
```


### C++

std::lower_bound
std::upper_bound
std::binary_search
std::equal_range


对于不支持O(1) 访问任意元素的 有序stl (如 set)， 用这些函数会使得 复杂度退化。
应该使用 成员函数进行查找

。。std::lower_bound 应该是 O(nlogn)， 而 成员函数 是 O(n) 。


### 三分

二分解方程

三分找最优解

已知 f(x) 在 [l, r] 上是 凸/凹的， 求f(x) 在该区间上的 最大/小值

取 三等分点。

。。我一直取 中点 和 中点旁边一点。判断 趋势。

三等分点 是 每次 剔除 1/3 的区间。

还要注意 函数图形， 如果有 一段 平行于 x 轴的， 那么 可能 三等分点的值 相同，但是 不能 取中间。
。。就是图形是  先下降，然后上升，然后 平行于x，  且 2个 三等分点  都取在 平行于x 的 区间上， 不能 取 中间的区间。




## 递归与分治

主定理 是分析 递归算法 时间复杂度的 一个工具


快速幂：分治


## 排序

冒泡  稳定 

插入排序  稳定

选择排序   不稳定， n^2， 使用较少

归并排序   稳定 nlogn

快速排序   选择轴点 进行拆分， 2端维护指针，从外向内扫描





# dp

BV1VW4y1Y7A3


1. 从实际背景/题目 中 抽象出 可计算的 数学模型
2. 用 递归/递推式 的方法 求解这个 数学模型， 然后换一种形式 描述 递归/递推式，加速 递归/递推式 的求解

实际编程中，边界条件 的设置 也很重要

可以尝试画一画 递归程序的 递归实例


## 网格路径数统计

A*B 的矩形网格通道，有些点有障碍，求 左上 到 右下的 最短路径条数

`f[i][j] = f[i-1][j] + f[i][j-1]`  如果 `f[i-1][j]`, `f[i][j-1]`可达。

2种方法
1. 递归函数 + memo
2. for for

```C
int f(int x, int y) {
  if (x == 0 && y == 0)
    return 1;
  if (x < 0 || y < 0)
    return 0;
  
  if (obstable[x][y]) // 障碍
    return 0;
  
  if (visited[x][y])
    return record[x][y]
  
  visited[x][y] = true;
  record[x][y] = f(x-1, y) + f(x, y-1);
  return record[x][y];
}
```

```C
int f() {
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
      if (obstable[i][j])
        record[i][j] = 0;
      else
        record[i][j] = (i == 0 ? 0 : record[i-1][j]) + (j == 0 ? 0 : record[i][j-1]);
    }
  }
}
```
优化： 只需要2行就可以。 不需要 n*m



## 有向无环图 记忆化搜索

计算 有向无环图 2个顶点的 最短路径

加权

```C
int f(int x) {
  if (vst[x]) return shortest[x];
  vst[x] = true;
  if (x = dest) shortest[x] = 0;
  else {
    shortest[x] = INT_MAX;
    for (auto nxt : next[x]) {
      int dis = f(nxt.next_node) + nxt.weight;
      if (dis < shortest[x])
        shortest[x] = dis;
    }
  }
}

void DAG() {
  for (int i = 0; i < n; ++i) {
    f(i);   // 计算每个节点 到 dest 的最短距离
  }
}
```


有向无环图 是大量 dp问题 背后的 模型

很多时候，问题就在于 如何选择恰当的抽象
定义合适的状态 及 状态转移关系，从而获得一张可计算的 有向无环图， 或者 一个 拓扑序


## 最长上升子序列 LIS

。。想了一会儿，放弃了，满脑子都是 stack 做单调序列 。。 结果 根本不是 stack
。我还想到了 这就是一个 range query，所以 BIT 。 BIT应该可行的 ( 就是 用来搜索 小于当前值 的 LIS)， 但是 如果 值太大，BIT的底层数组 不够。 。 不过可以 map。

```C
void LIS() {
  for (int i = 0; i < n; ++i) {
    vi[i] = 1;  // end at i, LIS
    for (int j = 0; j < i; ++j) {
      if (sequence[j] < sequence[i]) {  // input
        if (vi[j] >= vi[i]) {
          vi[i] = vi[j] + 1;
      }
    }
  }
}
```

使用平衡树 可以 O(nlogn)

。这里平衡树的 作用 应该和 BIT 一样。 而且 不会有 值太大 的问题。 应该就是把 BIT 底层 使用真的树，而不是 数组。  而且是 平衡树，所以 logn。
。平衡树，可以使用 splay， treap 树


## 最长公共子序列 LCS


```C
void LCS() {
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
      vvi[i][j] = max(vvi[i-1][j], vvi[i][j-1]);
      if (s1[i] == s2[j])
        vvi[i][j] = max(vvi[i][k], vvi[i-1][j-1] + 1);
    }
  }
}
```


LCS 尝试转为 LIS，满足什么条件的 LCS可以转为 LIS？

。视频中例子是 一个序列是 a-z 的顺序序列( 比如 aaccffhh, 就是 当前字符必然>=前面的字符)， 另一个是 随机的 a-z。  把 a-z的顺序序列 当做 大小，来 对 另一个序列 进行 LIS。



## 以区间为状态

### 合并石子

n堆石子，合并，要求 分数之和最大。 分数是 合并后的 石子堆的数目。

`dp[i][j]`  从 i 到j 的 石子合并 的 最大分数

```C
int f(int i, int j) {
  if (i==j) return 0;
  if (vst[i][j]) return dp[i][j];
  vst[i][j] = true;
  dp[i][j] = 0;
  int accu = accumulate(i, j);
  for (int k = i; k < j; ++k) {
    if (f(i, k) + f(k, j) + accu > dp[i][j]) {
      dp[i][j] = f(i, k) + f(k, j) + accu;
    }
  }
  return dp[i][j];
}
```

。。bottom-up 的话，就是 步长从1 上升


如果石子堆是一个环，那么如何解？

将序列扩展成 2n，然后 计算 for(i in 1..n) { f(i, i+n) }, 取max。   或 bottom-up 步长从1到n, 取max



### 多边形

n个节点的环 ( 或 n边形)， 每个 顶点 代表 整数， 边代表 +或*， 每次选择一条边，进行计算，合并。 求最后 结果最大是多少。

延展一倍

2个负数 相乘 得到一个 最大值
一正一负 相乘 得到 最小值

所以需要保存 区间的 最大值，最小值


## 以二进制集合为状态 的dp

使用一个 二进制整数来表示 一些集合。每个数位表示一个元素是否在当前集合中。

这种问题的 状态数/时间复杂度 通常为 指数级


### 旅行商问题

给出n个城市，22之间有道路连接，如何找到一条最短路线，经过每个城市一次，且仅一次，并 回到出发点。

目标，将 n! 的 时间复杂度 降低到 n*2^n

任选一个出发点，在状态中记录目前走过哪些点

`f[set][x]` 表示已经走过 集合 set中的点，目前位于x，所走的 最短路径。

`f[set][x] = min{ f[set-x][i] + w[i][x] }`

集合状态 是 整数表示的，所以 可以按照 集合状态 从小到大 枚举，这样可以保证 子集一定在前面被枚举到 。。。降低当前搜索的层数。



### 棋盘放置棋子

在 N*N 的棋盘上，放置 n个棋子，使得 任何一个棋子周围 的8个位置 都没有其他棋子，有多少种方案？ (n <= 10)

。。我知道，但我不知道名字了， 就是 `[i][j]` 往前一行(j个元素) 组成状态。 但是，不知道怎么处理：我完全空开2行，然后放。。。 知道了 `[i][j][state]` 以 `[i][j]`为结尾，往前一行组成 的状态 state 的 方案 、、 不， `[i][j][k][state]` k 是还剩几个棋子。


`f[row][set][total]`， 已经放置 total个棋子 在 前row 行，其中 最后一行的棋子的 放置方式是 set 的 方案数。


另外一个问题： N*M 的棋盘，放置 k个 中国象棋的炮， 且无法攻击， 有多少种方案？
一行或一列 最多 2个炮

。。这个状态 有3种，所以需要 2个bit位。 就是 遍历行， 在一行上 可能放 0,1,2 个炮， 而放的地方 需要 确保 列上 的 炮数 < 2 才可以放。 那么需要记录 这列 已有的炮数 是 0 or 1 or 2， 3个状态， 需要2个bit。 也还行， 00,01,10, 只需要判断 高位bit 就可以知道 是否可以放，  所以 3个状态 用 00,01,11 来表示， 这种每次变一个bit的 是 gray码啊。   应该可以。


## 背包问题

N个物品，每个物品有 cost[i], values[i]
选取若干物品，在总花费不超过 MaxCost 的情况下，最大化总价值

在 MaxCost， cost[i] 不太大的情况下
f[i][j] 表示 在前i个物品中选，总花费为j 的 最大价值

```C
for (int i = 0; i < n; ++i) {
  for (int j = 0; j <= MaxCost; ++j) {
    f[i][j] = max(f[i-1][j], f[i-1][j-cost[i]] + value[i]);
  }
}
```

。。我记得最标准的是 dfs 每层 取或不取 。但是这样的话 没有 剪枝。
。还有 按照 cost倒序。
。for for 的 没印象。  特别是 内层for 是 for 的 0 - MaxCost

可以使用 2个一维数组。 而不是 二维数组

从后往前计算的话，只需要 一个 一维数组


---

### 变种

如果MaxCost， cost[i] 都很大， 但 value[i] 较小

可以改变状态定义

。。vvi[i][value] = min cost ？  也是 forfor？ 如果 没有，就是 0 or INT_MAX？  0， min cost 。不，不会没有，第一次就把所有的 value 都设置为 cost[0]。 这样就不需要 在意 有没有了。

`f[i][j] = min(f[i-1][j], f[i-1][j-value[i]] + cost[i])`

。第 i 个物品 是基于 i-1， 所以 min中都是 i-1,  基于i-1，选择取或不取，无论取 不取，最后的价值都是 j，   而且 f[i][j] 只设置一次，后续不会再 变更。


---

### cloakroom

n件物品，每件 有3个属性 a[i] b[i] c[i], 其中 a[i] < b[i]

有 q 个查询，每个查询由 非负整数 m k s 组成，判断是否 能选取某些物品 使得下面成立
1. 对于每个选的物品，满足 a[i] <= m 且 b[i] > m+s
2. 所有选出的物品的 c[i] 和 == k

n <= 1000, c[i] <= 1000, 1 <= a[i] < b[i] <= 10^9, q <= 1000000
1 <= m <= 10^9, 1 <= k <= 100000, 0 <= s <= 10^9

允许 先读取所有询问，然后再输出所有答案


。。
。按 a[i] 排序， 这样 遍历 0-x， x是 第一个 a[x] > m， x时就可以停止了。
。。将 b 按照 a 的顺序 排列后， 构造一个 prefix max 数组， 这样可以根据 m+s 快速找到 起始下标y， y之前的都是 b 小于等于 m+s 的。    不过这个提升 估计不太。
。然后就是 对这个 范围 进行 背包。 。 dfs的话，需要跳过 不满足 b > m+s 的数据。  forfor 也要跳。
。。dp[idx][c] 。 n是1000， k是10万， 用 一维数组 是够的。
。 这个有办法复用 q吗？ 就是 把q 排序后，  后面的 q 会用到前面q 的结果？  应该不行。  m k s  无法复用。 差一点点 就是 完全不同的答案了。
。只能复用 之前 排序的 a， 还有 b 的前缀max。
。 q 是100万，k是10万，所以 k 重复的概率很大，但是 s m 不重复，k重复 没有意义啊
。。估计不行， q是100万， dp[idx][c]  ， 复杂度 相乘，直接TLE。


只用 a[i] <= m 来跑背包。

。。这个是 遍历所有 可能性，然后 根据 q 来直接找答案。
。但是怎么写？ m 是变化的。 怎么体现 到 答案上？ 而且 m 是 10亿，没有办法 数组的。
。。物品只有 1000个， 不知道怎么用 这个限制。

。。问题 问的是 是否能够选取 某些物品 ， 而不是 什么 cost 最小。

。所以 应该走 c[i] 和 == k ？  但是 m s 怎么加进去？
。 走不了。 2^1000 比 整个宇宙的原子都多。
。。看下面的， 每次加一个 物品， 不是 2^1000, 是 forfor。


按 a[i] 升序，依次 添加 物品 跑 背包。

。是不是 跑背包的时候， 记录下 选取的 物品的 最小的 b[i] ？  还记录下 c[i] 和。
。。似乎就是这样啊。 但是 记录， b 太大了， 10亿啊。 map ？


先读取所有查询，将 物品按照 a[i] 升序， 然后开始 运行 "背包"算法，  所有查询 按照 m 升序

f[x][y]，在 a[i] 最小的 前 x个物品中，选出 c[i] 之和 为 y 的 一些物品时， ==最小的 b 是多少==

。。是否可行    最小代价    最大价值
。。一步之遥，天壤之别。



## 数字统计问题

[L, R] 区间内，有多少数字符合 xxx 这一特征

存在一些比 从L 循环到 R 更快的算法

最简单 的形式： [L, R] 有多少个偶数

。。不是 直接 /2 么。。    难道后续的问题会是 多少能被 2 or 3 整除的？



### windy数

不包含前导0 且 2个相邻数字之差 至少为2 的正整数 称为 windy数。  
求 [A, B] 之间有多少 windy数

1 <= A <= B <= 20亿

。先转为 1-x 有多少。 这样就是  f(1, B) - f(1, A-1) 就是 [A, B] 的
。。感觉就是 从 1位开始构建， 就是  vi[0-9] 就是 末尾是 0-9 的 有多少。 这样的话 还需要 记录 位数。
。。就是 vi[x][y]，x是 整数有多少位 ( 最多10位)， y 就是 末尾是多少。
。。这里还有个问题，就是 上限是 34534535 时，这个得分为 30000000，4000000，500000，30000，4000，500 来算，不然 不好算啊。  所以 需要 记录有多少位。  那还得记录 开头是多少啊。
。。好像 求 2个相邻数字之差 <= 2 更快一些，但是 还是有这个问题，34534535 怎么算


枚举 第一次出现不同的 位置， 枚举这个位置 可能的值。
。就是 数的比较，相同位数的时候， 第一次不同的地方 就决定了 2个数的 大小。

f[x][y] 表示 x位数组，相邻之差 超过2， 且 第一位是 y 的方案数目。  
。这个y 就是上面的 第一次不同的地方。

。。。我之前想的 差不多。 之前的 [y] 是 末尾是y， 实际上 数字 可以 在 前面加， 所以 开头是 y 。
。。不过 还有 34534535 这种， 唉。


### 手机号码

寻找 [L, R] 满足下列条件的 不包含 前导0 的 11位数
- 至少出现 3个 连续的 相同数组
- 不能同时出现 8 和 4

。。
。至少3个连续， 那就是 反算， 最多 2个连续。
。应该是 计算：  不同时出现4和8 的11位数，   不同时 出现4和8 且 最多2个连续的 11位数。 相减 就是结果。
。。不同时出现4，8，可以分为  3种，0-9不包含4,8,   0-9不包含4,必包含8    0-9不含8，必含4，  后2个 个数应该是一样的。
。。
。。[L, R] 区间。 这个也是 遍历 第一个不同的地方？



遍历第一个不同的地方，且遍历 可能的值。
f[i][1000][bool][bool][bool]
第0维：包含i个数字
第一维：后缀的 前3个数字，  因为 第一个不同的值 + 后缀的2个前缀  可能是 3个 相同的数
第二维：是否出现4
第三维：是否出现8
第四维：是否 连续3个相同

。。这个有点问题，不，只是注意点，  包含2个数字的时候， 第一维的1 代表 01 。 包含3个数字的时候 1代表 001

。但是 怎么编码 呢？ 。。。
。。应该是 遍历 1000 这个维度， 前面加一个 数字， 就可以了，  前面加4， 加8， 或者 加上后 导致 3连  都可以判断 出来的。




# 字符串和hash

BV1Wa411Z7gY

|123| = 3  长度


## trie

节点要保存是否终止。

还可以保存出现次数

没有分支的可以压缩
。。压缩的时候 ， 只需要修改 node 所代表的 字符串， 不必改 分支数组。



查询，插入


插入的时候， (创建节点)， 将末节点设置为 终止节点。


### 长度*次数最大的前缀

给定一些字符串，求 长度 * 出现次数 最大的 前缀。

。在trie上保存 经过的次数。  每次insert的时候 就 +1


求 长度 * 次数 最大的后缀的话， 反向建立 trie。


### 是否存在函数映射使得字符串最小

给定 n个字符串，寻找一种 char -> int 的映射关系，使得 该 字符串 字典序 最小。
返回 存在这种映射关系的 string

n 3万， 长度和 30万

。。trie 确实好用。 构建trie，然后 对每个 string 判断： 从 root出发， 每个节点 的 分支数组， 该string 的 char 必须： 还未映射过，那么 取 未映射的 最小的 int， 然后 这个char 对应的 int 必须是 存在 后续节点的 char 已有的映射的 int 中 最小的
。。思路还是挺复杂的。 不过上面的没有问题。
。azzb  azzz  。。  上面还是错了，  如果没有映射过， 且 只有这一个char ，那么不需要 映射。。 就算有多个char，也不一定 要 选 最小的。  比如 { azzb, azzz, accc },  有多种映射方法： { 1332, 1333, 1555} or {1223, 1222 1555}， 这2种映射下，分别是 azzb, azzz 最小。
。。所以 ==不是 映射，而是 一种关系==。  要求 azzb 最小时，就要求 b < z； 要求 azzz 最小时，就要求 z < b;
。还有， 路上遇到的那些，也需要作为 关系。 azzb accc 就需要保证 z < c;
。。这种关系 怎么保存？  `map<char, set<char>>` ？ 保存 比 key 大的。 然后 最后 进行 遍历， 查看是否 有环， 有环 就 找不到映射关系。


如果前缀是 存在的字符串，则不可能最小。

构建 有向图，判环。


### 01 Trie 树

保存 数的 二进制的 trie

通常 补齐前导0，使所有串 长度相同

在处理 位运算时 比较有用

问题：给定一些 int范围内的数，对于给定的 数x， 求与x 异或 最大的 数。

。。异或， 那么 构建 trie，然后每次 走 x 相反的 那条路。
。。这应该是 二叉树，  也是 trie 树。
。。
。。普通的做法，应该是 O(32*n) = O(n) 。 就是 对每个 bit 判断，要 和 x 的 同位置 bit 不同， 如果 都相同，那么 都进入下一轮。  有不同的，那么 只有 不同的 进入下一轮。  可以通过 tag数组 或 直接 set 来 判断 是否被淘汰。




## hash


hash冲突
- 封闭散列
  - 线性试探， hash(k), hash(k)+1, hash(k)+2 ...
  - 平凡试探, hash(k), hash(k)+1^2, hash(k)+2^2 ...
  - 双向平凡试探, hash(k), hash(k)+1^2, hash(k)-1^2, hash(k)+2^2, hash(k)-2^2 ...
- 开放散列
  - 拉链法


卡hash， 使用 hash 可以加速 字符串 判断 是否相等，但是 案例中 可能存在 2个不同的 string，某种hash方法 后相同。
。cf 那道 unordered_map tle， map accept，就是 卡了hash， 案例中 hash后的 值 经过 % 后相同，导致 所有的 样本 都是一个 桶， 然后 简单的 拉链，没有 转 RB树， 导致 每次 unordered_map 的操作 变成了 O(n)， 而不是 O(1)

。手动 hash 快速判断 string 是否相同， 有这种题目的， 我忘记 这个 算法叫什么了，难道是 tarjan？



### 恢复表达式

A+B=C
删除 + = 后， 变成一个字符串。
求一组可行解

A,B,C 不包含 前导0， 且 长度之和 < 10万


。。？ 只能硬算吧？
。B 和 C 的 分界 肯定是  字符串的一半 到 2/3 之间
。整个 最后一位 就是 C的最后一位， B的最后一位 是 一半 到 2/3之间。
。。 根据 C的最后一位， B的最后一位，可以 计算出 A的最后一位。
。。 然后 根据 A 的 最后一位 找 可能的下标， 然后 计算 是否 满足 A + B = C
。。这个 A的下标 需要一个 vvi 就可以了啊， vvi[1] 这个数组 表示 数字1 所在的 下标位置。  而且 A的 最后一位 必然在 前一半。
。。用不到hash啊。
。不过可能会 tle？因为这个是 O(n^2) 的。

`|ABC| <= 10^6` ，话说这个 ABC是 相乘 还是 字符串相加 ？  字符串相加， 题目里有 "给出ABC这个数字串"

。估计要 快速判断 分割 后，长度 是否正确。 比如 100个数字，分为 10 50 40 的长度 肯定不对， 因为C的长度必然 >= max(a.len, b.len) 的。


枚举 = 的位置，判断可能的情况
- |A| = |C|
- |A| + 1 = |C|
- |B| = |C|
- |B| + 1 = |C|


。所以 一旦 = 的位置 确定，  + 的位置 只有4个可能 。 。。 所以 不需要 B C 的最后一位，  而是 使用 C的长度 + 加法的性质。

。。但是和 hash有什么关系呢？  这已经 O(4n)  O(n) 了。
。没讲明白。 感觉完全不需要。


## 桶,基数,计数 排序

。跳了 ， 应该不会遇到。


## KMP

1:11:30

s串： aaaaaaaaab
t串： aaab

假设 t 已经匹配到 t1..tk, 匹配 tk+1 时 失配
如果已知 i 使得 t1..ti 与 tk-i+1..tk 匹配，就可以用 ti+1 去匹配

。。就是 失败时， 已匹配的 子串的  后缀 与前缀的 最长相同。 可以确定 在失败的地方，已经可以匹配 这个前缀了。 所以 用 前缀的 后一位 去 和 失配的sj 匹配



next数组：当匹配到 t[i] 时发生失配，应该 跳转到 t[next[i]] 继续尝试匹配

为了计算 next，先计算辅助的 f 数组： fi 定义为 能使 t~1~..t~j-1~ = t~i-j+1~..t~i-1~ 的最大 j (j < i)
- 定义 ==f~1~ = 0==
- 由于 j=1时， t~1~..t~j-1~ = t~i-j+1~..t~i-1~ = 空字符串， 除了 f1之外， 其余fi 至少为1


KMP原论文中需要使用 next 求f， 这里提供一种不使用 next数组 求 f 数组 的方法


。。必须使用 sub sup了，不然 下标分不清。  ~~ 不能下标的下标。 只能标签。

根据 f~i~ 的定义，假设已知 t~1~ .. t<sub>f<sub>i</sub>-1</sub> = t<sub>i-f<sub>i</sub>+1</sub> .. t~i-1~
- 如果 t<sub>f<sub>i</sub></sub> = t~i~， 则有 t~1~ .. t<sub>f<sub>i</sub></sub> = t~1~ .. t<sub>f<sub>i</sub>-1</sub>t<sub>f<sub>i</sub></sub> = t<sub>i-f<sub>i</sub>+1</sub> .. t~i~
- 根据定义，可以反证得到 f~i+1~ = f~i~ + 1

。。没说 如果不想等 会怎么办
。这个就是 已有 后缀 == 前缀， 然后 本次判断 后缀后的char 是否等于 前缀后的char，等于的话， 可以直接 使用 上一次的 fi。

==不匹配时，找次大==， f<sub>f<sub>i</sub></sub>
最多跳转到 f~1~ = 0, 此时 f~i+1~ = f~1~ + 1 = 1



原论文 使用 next求f。 

现在我们 不用 next 求 f， 而是 考虑如何用 f 得到 next

直接令 next = f 是一种 保守 但可行的 方案


next[0] 始终是0

```C
// i >= 1
if (t[f[i]] == t[i])
  next[i] = next[f[i]];
else
  next[i] = f[i]
```


---

题目

给定s,t，求t 在s中出现的次数。
- KMP 匹配成功，跳到下一个next    。。  有点转不过来。

给定s，当且仅当 t是 s 的前缀和 后缀时， 称t 是 s 的 border， 求 s 的border
- KMP， fail数组， fail[n], fail[fail[n]] 一路跳。   。。。似乎明白

给定s，问 s 最多是由多少个相同的子字符串拼接而成
- 等价于求 最小循环节 使得下面成立 ， l能整除n
- s~1~ .. s~l~ = s~l+1~ .. s~2l~ = .. = s~n-l+1~ .. s~n~     
- 等价于 l整除n， s~1~ .. s~n-l~ = s~l+1~ .. s~n~  等价于 求最大border。



Milking Grid

给定 R * C 的字符网格，求面积最小的矩形 使得 它是 这个网格的 "循环节"，输出其面积。  这里的 "循环节" 不要求 恰好是 长度，宽度的 因数
input： 
ababa
ababa

输出： 2 (即 ab)    . 就是 ab + ab + ab ， 多一个b无所谓的。

R <= 10000, C <= 75

。。
。最大循环节 就是 字符网格它本身。
。感觉是对 每行求 最小循环节， 然后 取一个 最小公倍数。
。然后 每列 求最小循环节， 然后 公倍数。
。但怎么求 最小循环节， 扩展 fail/next 数组， 多出来的 当做 匹配成功？ 但多出来多少？
。。

公倍数 是错的  aabaabaa, aaaaaaba， 是7

一句话题解：每行跑一遍KMP，然后求最小共同循环节长度
还有一种做法是 将整行，或整列 做KMP，比较时 相当于比较 2行 或2列是否相等。

。。也没有具体说清啊。 。。 还是不知道怎么做。
。搜 Milking Grid 。



# 二叉树，平衡树

BV13U4y167VG

介绍理论，没有代码。

二叉树
AVL
splay
treap

---

平衡 查询，插入，删除。

树：无向无环连通图
。不联通 就是 森林


二叉树的中序序列 是有序的，就是 二叉搜索树

中序序列 是 树 的节点 向下的 投影。


删除节点
- 将 待删除节点 和 直接后继 交换位置 后删除。
- 或 删除节点后，将 右子树的最小节点放到 删除节点的位置
- 或 合并2棵 子树。


## AVL

每次操作 ( 搜索，插入，删除) 都是 O(logn)

在任意节点，左右子树的树高 最多相差1

旋转
新根的 一个子树(靠内的那个子树) 赋给 老根。

![e736a9c591e8e9bfd502e9b71f15685d.png](../_resources/e736a9c591e8e9bfd502e9b71f15685d.png)


插入后，向上，找到第一个失衡节点，然后进行 旋转， 继续向上，直到 碰到平衡的节点。

。插入，后 失衡，必然是 有一个 节点太深了，  如果 这个节点 在外侧，那么 一次旋转即可。 如果在内侧，那么需要把 子子树 先 旋转，然后 再旋转 子树

删除 类似。 删除后，一路向上


## splay

充分利用 操作的 局部性

均摊复杂度 O(logn)， 单次操作复杂度 可能到达 O(n)

将 访问/插入 的数据 放到 树根

。。==新插入的节点必然是叶子节点==

删除时，将 其旋转到 根，然后删除。  将左子树 最大元素 作为新根

在 将某个节点 旋转提升到 根时，==一次 考虑 2级祖先， 如果自己和父亲 位于同侧，则采用这样的 双旋策略：先将父亲旋转上去，然后再将自己旋转上去==

。。。
```text
1
 2
  3
   4
    5

要将5提升到root
如果每次旋转一个，那么就是
1
 2
  3
   5
  4

1
 2
  5
 3
  4

1
 5
2
 3
  5

 5
1
 2
  3
   4

-------

如果一次考虑2个祖先

1
 2
  4
 3 5

1
 2
  5
 4
3

  2
1   5
   4
  3

  5
 2  4
1  3

平衡了很多。
```
。。。




## treap

容易实现， 适合于 竞赛，机试

每个节点 增加一个 额外的属性：优先级

这个优先级 需要组成 最大堆 或 最小堆

数的形态 是唯一的。因为 root 必然是 优先级最小的， 然后根据 root的 value， 分为 2部分， 每部分的 优先级最小的 是 子树根， 依次 递归。


。。==新插入的节点必然是叶子节点==

插入： 先插入到叶子节点，然后根据 优先级 和 父节点 比较， 不满足 就 向上旋转 (视情况 左旋或右旋)

删除： 将待删除的节点 向下 旋转到 叶子节点，然后删除。  旋转的时候 根据优先级 选取 新的 root。  也可以 旋转到 只有 一个孩子的 时候 直接删除。


## 线段树

二叉搜索树的变体

用于维护 一系列区间/线段 上具有 可加性的数据

令 根节点表示 区间 [1, n]， 左右孩子 分别表示 左右区间。 向下递归建树，叶子节点 表示 不可分割的 单位长度区间。

。。似乎 用 TreeNode 比 数组 方便/简单 很多。
。TreeNode 需要保存： L， R， MID， value

==单位长度区间 是虚指==， 指 不需要 再分割的 区间。 并不是 真的 1,2,3,4, 这种单位

。不过 这种 会导致 树的不平衡。

。应该还是 数组好。






# 例题选讲

BV1wG411t7dw


quorum机制
n个节点的分布式系统，
- 写操作： 每个写操作至少向 w (n/2 < w <= n) 台机器写入数据
- 读操作： 按 既定的顺序 访问节点，获得 当前 众数数据，并更新 未更新的 机器。



数论：
- 费马小定理
- 逆元
- 二次剩余
- 原根
- 丢蕃图方程(扩展欧几里得算法)
- 正整数幂和的方法
  - 拉格朗日插值
  - 斯特林数
  - 下降幂
  - 伯努利数
  - 生成函数





# 图论

BV12U4y167zK

- 图与树
- 最短路
- 最小生成树


欧拉路径/回路，  一笔画  ，  欧拉路径： 只有2个 度数为基数的 点    欧拉回路：全都是偶数
。。欧拉路径/回路 是 走过所有的 边， 所以 有 孤立点 也是 欧拉图。

完全图
平面图


二分图染色

---

最短路


LCA， 树， 连接s 和 t的 最短路径 一定经过 LCA， 可以根据 LCA， s， t 的深度 得到 s-t 最短路径的 长度。


Bellman-Ford， 带负权边的 单元最短路径。 可以检测 负环
每轮，对所有边尝试松弛

SPFA， 在Bellman-Ford 的基础上， 每轮 不需要 对所有边进行 松弛
使用队列，保存 更新的节点， 然后对 队列中的 节点 的 出边 进行松弛，如果 修改了 点的 值，那么加入到 队列中。



没有 负权边， 用 Dijkstra



---

所有点对间最短路径，  Floyd-Warshall算法

稀疏图，直接跑 顶点个数 次 单源最短路径。


floyd 可以 多线程加速

---

割集

Prim， 从起点开始，依次 加入 最近的点

Kruskal， 最短的边 一定在 最终的 最小生成树上。  将边排序，如果 边的2端 还没有联通，则将 这条边 加入生成树

Boruvka、Sollin， 可以理解为，从当前的每个点/每个连通块 出发，做 prim， 迭代，直到 整个图只有一个 连通块。   可以并行化。




# 数学专题

BV1te4y1Y7Ed


只讲 简单 数论。


- 数论
  - 初等数论
  - 计算数论，如 素性测试，素因素分解
- 离散数学
  - 集合论，代数结构
  - 图论
  - 组合数学(研究生)
  - 数理逻辑
- 概率论
  - 概率论
  - 数理统计
  - 随机过程，Markov链
- 数值分析
  - 浮点误差
  - 非线性方程求根， 牛顿迭代法
  - 解线性方程组， 高斯消元法
  - 函数逼近与函数插值， 拉格朗日插值
  - 数值积分与数值微分， 辛普森积分
- 多项式全家桶
  - 傅里叶变换，快速傅里叶变换
- 计算几何，针对离散与组合 几何结构的算法研究
  - 基本的 点，线计算
  - 凸包，半平面交
  - 三角剖分，Voronoi图
  - 点定位
    - 扫描线，KD-tree
- 博弈论
  - 双人零和博弈，双矩阵博弈，Nash均衡， 很少
  - 组合游戏：Nim游戏，有向图游戏，SG函数， 较多
- 运筹学
  - 线性规划，非线性规划，整数规划
  - 动态规划
  - 组合规划(涉及 图论中的各类最优化问题)
  - 博弈论
- 微积分
- 线性代数



## 整除，gcd，exgcd

`n=km <=> m|n`

一个正整数 n 的因数最多有 2sqrt(n)个。  n=qp，则 p，q 必有一个 小于等于 sqrt(n)


最大公因数
最小公倍数

d 是m和n的公因数， 当且仅当 d|m 和 d|n 同时成立

`gcd(m,n) = (m,n) = max{d | d|m 且 d|n}`
gcd(0, n) = n
如果 gcd(n,m)=1，则称 m和n 互质，记作 m ⊥ n


`lcm(m,n) = [m,n] = min{k | k>0, m|k 且 n|k}`

```text
gcd(kn, km) = k * gcd(n,m)
lcm(kn,km) = k lcm(n,m)
gcd(m,n) = gcd(m-n,n) (m>=n)
gcd(k,m,n) = gcd(gcd(k,m),n)
lcm(k,m,n) = lcm(lcm(k,m),n)
k|m 且 k|n  <=>  k|gcd(m,n)
m|k 且 n|k  <=>  lcm(m,n)|k
gcd(n,m) * lcm(n,m) = n * m  // 求出gcd 后就知道 lcm
```

### 辗转相除法 求gcd

斐波那契数列，通项公式， Fn = (((1+sqrt(5))/2)^n - ((1-sqrt(5))/2)^n)/sqrt(5) 。 是一个指数函数，所以 反函数 约是 O(logn)
当 n m 是 斐波那契 中相邻两项时，辗转相除法最慢。


### 更相减损术 

一般情况下 速度慢。  高精度时 比 辗转相除法 快。 ( 因为 mod 操作， 如果 几百位的话，会慢)

1. 如果 2个数都是 偶数，那么 /2, 重复这一步
2. 不断用 较大数 减去 较小数， 用这个 结果 替换 较大的数， 直到 2数相等
3. gcd为 最后 得到的数 * 之前所有的 /2 的 2


## 裴蜀(贝祖)定理

a,b > 0, x,y 的方程 ax + by = d 有整数解(可以为负) 等价于  `gcd(a,b) | d` 。 gcd 能整除 d

推论： 用 ax + by 能表示所有整数  等价于  gcd(a,b)=1

---

给定 a，b， 求出任意一组解x,y, 满足 ax + by = gcd(a,b)  .  .. 求出这个解后， 乘以 d/gcd(a,b) 就可以==得到== ax + by = d 的解。

假设 gcd(a,b) = gcd(c,0)  
显然 1c + 0*0 = gcd(a,b) = c   。 这个是将 a=c, b=0 代入， 一组可行解就是 x=1,y=0  。。 但是凭什么 a=c,b=0 ？

![c72aace81e8d1f2d6959cd8e8ed39fc2.png](../_resources/c72aace81e8d1f2d6959cd8e8ed39fc2.png)


。。不知道。 搞不懂求的是 a,b  还是 求 x,y 。  实际应用 (题目) 是什么？



### 扩展欧几里得算法

上面的 求解的算法 是 扩展欧几里得算法 exgcd

该算法求出的 解 满足 |x| + |y| 最小，且 |x| <= (b/gcd(a,b)), |y| <= (a/gcd(a,b))

```C++
void exgcd(int a, int b, int& x,int& y) {
  if (b == 0)
    x = 1, y = 0;
  else {
    exgcd(b, a%b, y, x);
    y -= a/b*x;      // 第一次到这里时， x=1,y=0, 然后修改 y
  }
}
```

gcd(a,b) 可以通过 ax+by 得到。可以作为返回值。


## 素数与筛法

如果 素数 p 满足 p|ab, 则 p|a 或 p|b


每个大于1的整数，要么 本身就是素数，要么 可以表示为 至少2个素数的乘积，且排序后，表示方法唯一。

![adceefaa575561a119b9f07a40ed491e.png](../_resources/adceefaa575561a119b9f07a40ed491e.png)

。。序列 2,3,5,  素数
。现在看懂了， 大约也能理解正确性 ，但是 真碰到了，估计完全想不起来。


---

素数计数函数

素数(分布)定理

梅滕斯第二定理


### 埃氏筛

公元前 200年的人，测量地球周长

复杂度 O(nlnlnn)


### 欧拉筛

对 埃氏筛的优化

让每个合数 只被 最小的 素数 筛掉一次， 复杂度 O(n)

。。看了例子。似乎是：
```C++
vector<bool> prm(sz1; true);
vector<int> vi;
for (int i = 2; i <= n; ++i) {
  if (prm[i]) {
    vi.push_back(i);
  }
  for (int j = 0; j < vi.size(); ++j) {
    prm[i * vi[j]] = false;
    if (i % vi[j] == 0)
      break;
  }
}
```

。用数据 代入，确实正确的。
。。就是 薪火传承下去。 每次传承一个。


### 区间筛

用 [2, sqrt(r)] 来 筛 [l, r] 的素数

对 素数 枚举 [l, r] 区间中的倍数， 。。 就是 起始是  prm * ceil(l / prm)



## 素性测试 及 素因素分解

素性测试： 给定 n，判断 n 是否是 素数
- 暴力枚举 [2, sqrt(n)] 的所有 素数/整数，判断能否整除 n
- 如果给了很多数，那么：Miller-Rabin

素因数分解： 求n 的所有素因数 (有时需要 求出 各素因数的 次数)
- Pollard-Rho



## 同余与逆元

模： x mod y = x - y * floor(x/y)
C++ 模： (-x) % y = -(x%y)

同余： `x mod p = y mod p`  <=>  `x ≡ y (mod p)`

`a ≡ b (mod p)`  =>  `a+c ≡ b+c`, `a-c ≡ b-c`, `ac ≡ bc` (mod p)

`a ≡ b 且 c ≡ d (mod p)` => `a+c ≡ b+d`, `a-c ≡ b-d`, `ac ≡ bd` (mod p)

费马小定理： p为质数，a为自然数， `a^p ≡ a (mod p)`, 即 `a^(p-1) ≡ 1 (a != 0)`

。。 a^p ≡ a,  a不为0时，两边 /a ， a^(p-1) ≡ 1

威尔逊定理： p为质数， (p-1)! ≡ -1 (mod p)
。。 -1(mod p) 是指 `p-1 (mod p)` ?
。。 2: (2-1)!=1, -1(mod 2)=1,   3: (3-1)!=2,  -1(mod 3)=2


幂在同余类上的循环

|2^n|mod 10|mod 6|
|--|--|--|
|1|1|1|
|2|2|2|
|4|4|4|
|8|8|2|
|16|6|4|
|32|2|2|
|64|4|4|
|128|8|2|

。。 256 , 512  1024 2048

mod 质数(5,7)， 也是循环， 循环体包含 1   上面的 mod 合数，循环体不包含 1


### 逆元

`ac ≡ bc (mod p)` 不能推出 `a ≡ b(modp)`

模意义下，不能 合理地 定义除法

在 模 p (p >= 2) 意义下，如果 `ax ≡ 1 (mod p)`， 则称 a 是 x 的乘法逆元 (简称逆元)， 记作 `a ≡ x^-1`


如果 gcd(p,x) != 1，则 x 在 模p下 没有逆元

虽然 `(a + p*n) * x ≡ 1 (mod p)， n是自然数`  <=>  `ax ≡ 1 (mod p)` 但为了计算方便，一般取 [1, p) 中的数作为逆元


如果在 模p 意义下 n 存在逆元 n^-1， 定义 `m/n ≡ m * n^-1 (mod p)`

---

模7 逆元

1-1， 1*1 ≡ 1(mod 7), 所以 1 是1 的逆元
2-4， 2*4 ≡ 1(mod 7)
3-5， 3*5 = 1(mod 7)
4-2， 4*2 = 1(mod 7)
5-3， 3*5
6-6， 6*6

。。6,12,18,24,30,  36
。。7,14,21,28,     35
。视频里也是枚举的。

模 奇素数 p 意义下
- 1 的逆元是 本身 1
- p-1 的逆元是 本身 p-1
- 2,3,..p-2 都有逆元，且 22成对
- 故有 威尔逊定理： `p是素数` <=> `(p-1)! ≡ -1(mod p)`

。。 (p-1)! = 1*2*3..*(p-1) 
。。 mod p， 我感觉是对的，但是 看了下，没有说。。就是  ` (a * b) (mod p) ≡ (a (mod p) * b (mod p)) (mod p) `  .
。。 这样才可以 将 1*2*3..*(p-1) ，使用 交换律，得到  1 * (2 * {2的逆元}) * (3 * {3的逆元}) .. * (p-2 * {p-2的逆元}) * (p-1)。 就变成了 1*1*1..*1*(p-1) mod p = (p-1) mod p = -1 mod p 。。
。。肯定有交换律吧。


#### 3种方法求逆元

在 模p 的意义下，如果 ax ≡ 1 (mod p), 则称 a是 x 的乘法逆元 (简称逆元)， 记作 a ≡ x^-1

1. 使用 exgcd 求出 nx + py = 1 的一组解 (x0, y0), 则 n * x0 ≡ 1 (mod p)， 故 x0 即所求的逆元。 复杂度 O(log p)

2. 使用 费马小定理 (p 为素数): `n * n^(p-2) ≡ 1 (mod p)`  <=> `1/n ≡ n^(p-2)`, 快速幂计算即可，复杂度 O(log p)
  。。 `1/n = n^-1` , 所以 逆元就是 n^(p-2) 。 这个好像最简单。 不过有前提 p为素数。

3. 预处理 [1, n] 逆元:  记 A = floor(p/x), B = p mod x,  则 `Ax + B ≡ 0 (mod p)`  =>  `x^-1 ≡ -AB^-1` 。 从1开始递推即可，复杂度 O(n)
  。。？ 这个不能直接 求？ 为什么要递推？ 看公式不需要啊。 。。 B^-1 是 B 的逆元， 不是 算术的 1 除以 B


### 同余方程组

已知
- x ≡ 2 (mod 3)
- x ≡ 3 (mod 5)
- x ≡ 2 (mod 7)

求x


中国剩余定理： 设 m1,..mk 是 正整数 且 互质， 设 m 为这k个数 相乘，  又设 a1,..ak,A 是 整数， 那么 恰好存在一个 整数 a (A <= a < A+m) 使得， `a ≡ ai (mod mi)`

。。同余方程组 一定有解。  3,5,7就是 m1 m2 m3， 2,3,2 就是 a1,a2,a3,   要找 a。  由 中国剩余定理 可知 a 必然有一个 解。



![327323c6cb3f70f1f2fe25c25067a55a.png](../_resources/327323c6cb3f70f1f2fe25c25067a55a.png)

。 pp^-1， 由于有 p 所以必然是 0 mod p





## 素性测试 及 素因数分解

费马小定理的 逆命题 是否成立？
即， 任意正整数 p， 如果 对于所有 正整数 a， 都有 a^p ≡ a (mod p)，则 p 是素数。 是否成立？
不成立，561

满足 费马小定理 逆命题的 合数 称为 费马伪素数

如果一个合数 n 满足， 所有 和 n 互质的 a， a^(n-1) ≡ 1, 则称 n 为 卡迈克尔数

卡迈克尔数 真包含于 费马伪素数。

。。baidu 卡迈克尔 ， 余建春。  ~~~

所以无法通过 卡迈克尔数 来剔除 费马伪素数 ，从而得到 素数

一个改进思路： 通过别的幂次来检测： Miller-Rabin  。 参考 算法导论 31.8 。。。 确实有。


2002， 首个 不依赖于 未证明猜想 的 确定性 多项式 素性 测试算法 AKS。 复杂度为 O( (logn)^12 ) ( n是长度) ， 后改进到 7.5次方。


---


如果是 合数，最好 还能求出 它的 素因素分解

Pollard-Rho 可以进行 素因数分解， 大致是通过 迭代 产生伪随机数 去 试。

算法导论 31.9

O(n^0.25)， (n 就是 输入的值)

如果命令行 有 factor (linux)，可以尝试 factor 99999999999999999999999991 ,



## RSA加密


基本原理：
- 公私钥的产生
  1. 随机选择2个不同大质数 p 和q，计算 N = q * p
  2. 根据欧拉函数性质，求得 r = φ(N) = φ(p) * φ(q) = (p-1)(q-1)
  3. 选择一个小于 r 的正整数 e， 是 e 和 r 互质。 并求得 e 关于r 的乘法逆元 d， 有 ed = 1 (mod r)
  4. 将 p 和 q 的记录销毁。 此时 (N, e) 是公钥， (N, d) 是私钥
- 消息加密：首先需要将 消息 m 以 一个双方约定好的格式 转化为 一个 小于 N， 且 与 N 互质的整数 n。如果消息太长，可以将 消息分为几段，这就是 我们所说的 快加密，然后 对 每个部分 使用如下 公式 加密
  - n^e = c (mod N)
- 消息解密：利用 密钥 d 解密
  - c^d = n (mod N)

RSA不被破解的基础是
1. 随机生成大素数比较快 ( 根据素数分布规律，直接 随机奇数 并判断是否 素数)
2. 通过给定的 p*q 分解出 p 和q 比较麻烦

如果发现 素因素分解的 较快算法，则很多依赖于 上述2条 的加密算法 都有被 破解的风险



![414ed75f2f590f3c1ba8bebe5b6a7347.png](../_resources/414ed75f2f590f3c1ba8bebe5b6a7347.png)


。。 =1 有解 是 裴蜀定理

![bff3cc61fd1b369d5e285ebc73875cf9.png](../_resources/bff3cc61fd1b369d5e285ebc73875cf9.png)


。。。gg



## 积性函数

在数论领域： 定义在 正整数上的 函数 f 满足 f(1) = 1， 且对 任意互质的 a,b，都有 f(a)f(b) = f(ab) 则称 f 是 积性函数。
  思考： 为什么要规定 f(1) = 1

特别地，如果 任意正整数 a,b 都满足 积性条件， 则称 f 是 完全积性函数。


### 筛法求积性函数

。。


## 欧拉总计函数

φ(n)： <= n 且 和 n 互质的 数的 个数

对于所有 质数 p， φ(p) = p-1
对于 n = p^k ( p是质数，k是 正整数)， 每 p个连续的 整数中 恰有一个 拥有因数 p， 所以 φ(n) = ((p-1)/p) * n = (p-1) * p^(k-1)
如果 n = n1 * n2 (n1 n2 互质)， 则 φ(n) = {将n=n1n2代入} = { 分开 } = φ(n1)φ(n2)
  φ 是 积性的。


如何快速求 φ(1) .. φ(n)

可以直接 套用 筛法求积性函数，但比较麻烦

![bf7624500269fa8a8b259f1c5d5589de.png](../_resources/bf7624500269fa8a8b259f1c5d5589de.png)

。。。

![2f1250307fa1b048dbd964345f77534d.png](../_resources/2f1250307fa1b048dbd964345f77534d.png)


---

题目 CF906D

。要把 欧拉定理扩展一下。





---

# 2023

# 矩阵快速幂

BV1qk4y137eu

- 快速幂
- 矩阵 及操作
- 矩阵快速幂 及 简单应用

## 快速幂

快速幂 就是 快速求 a^b mod c
。b 非常大， 比如 10^15. for循环就不可能了

- a^(2b) = (a^2)^b
- a^(2b + 1) = a * (a^2)^b


```C
// base^n
while (n) {
  if (n & 1)
    ans = ans * base % MOD;

  base = base * base % MOD;
  n >>= 1;
}
```

---

## 矩阵

。。行 * 列

矩阵乘法 不满足交换律
满足结合律  ABC = (AB)C = A(BC)   ..重要。
满足分配律  A(B+C) = AB + AC

只需要满足结合律， 都可以使用 快速幂 。比如 快速乘。   
。。baidu ， 快速乘 是 计算 2个大数 相乘， 直接乘 会溢出，所以 使用 加法 来 完成 乘法。   一些需要快速乘的算法： Miller Rabin 判大因数， Pollard Rho 大数因子寻找。 BSGS 大步小步算法


## 矩阵快速幂

矩阵相乘 + 快速幂

把 快速幂的 int 变成矩阵， 快速幂的 乘 变成 矩阵乘


---

上面是理论， 下面开始 题目


给出一个数列，定义如下：
f(1) = 1, f(2) = 1, f(n) = Af(n-1) + Bf(n-2)
给你 A B n, 计算 f(n)
1 <= A,B <= 1000, n <= 10^8

。。
。。 第一眼，Fibonacci， 只需要 加一个 memo 
。。但是 n 太大了， memo 内存不够。
。。ok，知道了， 这里是 矩阵快速幂， 所以 是 2个矩阵的 乘法：
[A, B] * [f(n-1), f(n-2)]     f 是竖的。
。
但 怎么用快速幂？

f(2) = 1
f(3) = [A, B] * [f(2), f(1)] = [A, B] * [1, 1] = A + B
f(4) = [A, B] * [A+B,  1] = A(A+B) + B
f(5) = [A, B] * [A(A+B)+B, A+B] = A(A(A+B)+B) + B*(A+B)
f(6) = A * (A(A(A+B)+B) + B*(A+B)) + B * (A(A+B) + B)

f(4) = [A, B] * [f(3), f(2)]
= [A, B] * [ [A, B] * [f(2), f(1)], f(2)]
。这个不是 矩阵连乘啊。
。。


![b957bf2a442f7350075f014a8773564b.png](../_resources/b957bf2a442f7350075f014a8773564b.png)


。。。
。应该是 为了矩阵连乘，所以 结果也是一个矩阵。。。 并且这个 结果 正好是 高一级的 输入。
。。哈哈，当时直播的弹幕有人问了。

---

代码 部分

```C++
struct Matrix {
  int map[n][m];
  Matrix operator* (const Matrix b) {

  }
  // operator+
};
```
。。不抄了，这个没意义。


i行k列矩阵A * k行j列矩阵B 得到 i行j列矩阵C

Cij = { Aik * Bkj | k in 0..sz }

在实现的时候, 3重for， 用 i k j 的顺序， 因为 局部性原理， 使得 B[k][j] 能走局部性原理。 C[i][j] 也走局部性原理，  只有 A[i][k] 没有走，实际上 它也走了， 只不过需要 for完j 才下一个，所以不太重要。
如果 i j k 的顺序， 只有 A[i][k] 走了 局部性， B[k][j] 完全没有局部性， C[i][j] 的局部性不太重要。

或者说， A[i][k] 可以推出 i 必须在 k 外层 , B[k][j]  k在j外层, C[i][j] i在j外层， 所以 i k j 完美符合。。。 ==应该是这个==

有了上面的 矩阵类后， 矩阵快速幂的 while 中内容结构 和 普通快速幂的 一样



---

给 a,b 的 和 与 积， 求 a^n + b^n , 答案 % 2^64


。。
a + b = a + b
a^2 + b^2 = (a+b)^2 - 2ab
a^3 + b^3 = (a+b)^3 - 3 * a^2 * b - 3ab^2 = (a+b)^3 - 3ab*(a+b)
a^4 + b^4 = (a^2 + b^2)^2 - 2a^2b^2
a^5 + b^5 = (a2 + b2) * (a3 + b3) - a3b2 - a2b3   。 后半部分 a2b2 * (a+b)
。。
。不太对， a^3+b^3 使用的是 (a+b)^3 - xxx
a^4+b^4 使用的是 (a^2 + b^2)^2
.
。感觉 a^4 是对的， 因为 次方直接 /2了
。奇数的话 ， 次方就分别是 n/2  n/2+1
。。
。不， a^3 也对， (a+b)^1000 ， 可以 快速幂。
。a^3 的话， 减去的 那部分 有点难啊， 系数 是 杨辉三角？  指数就是 相加等于n。
  。。。 杨辉三角  的值 和 组合数 一样。

2^64 使用 unsigned long long ，自然溢出即可。

(a^n + b^n)(a + b) = (a^(n+1) + b^(n+1) + ab(a^(n-1) + b^(n-1)))


。。
f(n) (a+b) = f(n+1) + ab*f(n-1)
af(n) + bf(n) = f(n+1) + ab*f(n-1)
af(n) - abf(n-1) = f(n+1) - bf(n)
a * (f(n) - bf(n-1)) = f(n+1) - bf(n)
。。
。。。。。


(an + bn)(a+b) - ab(a^(n-1) + b^(n-1)) = a^(n+1) + b^(n+1)

令 A=a+b, B=ab, F(n)=a^n+b^n ,有

![56d1883f7b84467897553f97d7ca80c2.png](../_resources/56d1883f7b84467897553f97d7ca80c2.png)

先计算出 F(n+1), 然后 保持一致，所以 需要 F(n)



---

给定 N，K， 求 (1^K + 2^K + 3^K + ... + N^K) (mod 2^32)
n <= 10^15, k <= 50


。。
。 对每项 快速幂， 会是 O(nlogk)， n太大 ，所以不行。
。
。 2^K = (1+1)^K
。 3^K = (2+1)^K
。
。 N是 10^15， for都不行。
1+2+3+..+N
1+4+9+..+N2
1+8+27+...+N3

竖着算，不行，因为 N太大，for不了。  竖着算 是等比数列
。。


对 N 进行二分。进行 log

。。假设 M = 2n
。。M^2 = (n+n)^2 = n2+n2+2n2 = 4n2 ......  (2n)2 = 2^2 * n^2 = 4n2
。。  M = 2n+1
M2 = (n+n+1)^2 = 
。。 和矩阵无关。  这里是 单纯的 二分。
。
。之前的矩阵 都是 f(n), f(n+1)
。所以 。 应该 是 n作为参数， 而不是 k 作为参数
。f(x) = x^K
f(x+1) = (x+1)^K = x^K + ?
。不， n作为参数，得 for 10^15 ，不可能。
。
。视频里说 要进行 logn， 所以 应该就是 上面 单纯的二分。 但是不知道 怎么转为 矩阵。
。。感觉还是不对， logn。 但是 还是得 for 10^15 啊。

。。难道是 等比数列 之间 有关系？  没用， 等比数列的和 中用到了 最高项。


线性组合


![f52a01f05417174b1534c0777ec23daf.png](../_resources/f52a01f05417174b1534c0777ec23daf.png)

先算 Sn = Sn-1 + n^k 。 这样得到 第一行的 1 1 0 0 0 0
然后 为了 输入 = 输出，所以 Sn 下面就需要 (n+1)^k


矩阵乘法， 可以通过 傅里叶变换 加速， 本题不需要。 如果 k=100，可能需要。


---

给定一个 n*n 的矩阵 A，  一个正整数 k， 求下面的 和
S = A + A^2 + .. + A^k

n <= 30, k <= 10^9


。。
照上一个的写法， 应该是  Sn = Sn-1 * A + A    ， 可以提取出来的。 满足分配律的

[A, 1
0, 1] * [Sn-1, A] = [Sn, A]

。可以吧？ 
。。



![a85c79593094c2dcaa46c49ce1e0ea6e.png](../_resources/a85c79593094c2dcaa46c49ce1e0ea6e.png)


。可惜了， 忘记 A是矩阵了。 E估计是 主对角线全1，其他全0 的 矩阵 。是的，单位矩阵

代码中， 是可以把 4个矩阵 中的内容放到一个 矩阵的， 这样可以？ 就是 二度矩阵 变成了 一度矩阵  。。 似乎可以。



---

从 A点 经过恰好 k个点 到达 B点 的方案数。  方案数可能很大，所以 mod 1000

建立关系矩阵A, i能到达j 则 Aij = 1, 否则为0. 那么 A^n 就是 每个点恰好经过 n 个点 后到达 的 方案数




# 2024

# 单调栈，队列，堆，并查集

BV1aE4m1R7qo



。有时间再看啦。  24年的也太多了。。
。2024-10-24































