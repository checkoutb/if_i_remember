
https://github.com/krahets/hello-algo

C、C++、Rust

主要以C语言

2024-06-20 17:46

---

[[toc]]


---
---


# p42/35 O(2^n),O(logn),O(nlogn),O(n!)


O(2^n)

生物的 细胞分裂 是典型例子： 1个分为2个，2个分为4，4分为8

常出现于 递归函数中。

```C
int expRecur(int n) {
    if (n == 1)
        return 1;
    return expRecur(n - 1) + expRecur(n - 1) + 1;
}
```

---

O(logn)

O(logn) 和 O(2^n) 相反， 2^n 是 每次 *2，logn是每次 /2

---

O(nlogn)

```C
int linearLogRecur(int n) {
    if (n <= 1)
        return 1;
    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
    for (int i = 0; i < n; ++i) {
        count++;
    }
    return count;
}
```

第一层，一个for循环，从0 - n        共 n  
第二层，2个 for循环，每个从 0 - n/2  共 n  
第三层，4个 for， 0 - n/4           共 n  

所以 一共有 logn 层，每层共 n。  


---

O(n!)

数学的 全排列问题

n! = n * (n-1) * (n-2) * (n-3) ... * 1

```C
int factorialRecur(int n) {
    if (n == 0)
        return 1;
    int count = 0;
    for (int i = 0; i < n; i++) {
        count += factorialRecur(n - 1);
    }
    return count;
}
```

第一层 n次，每次计算 f(n-1)
第二层 n-1次，每次计算 f(n-2)





# p70/63 utf-8,16,32

- utf-8
  - 0xxxxxxx
  - 10xxxxxx 0xxxxxxx
  - 110xxxxx 0xxxxxxx 0xxxxxxx
  - 1110xxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx
  兼容 ASCII 码
- utf-16
  使用 2或4字节 来表示一个字符。 所有ASCII字符或 常用的非英文字符，都用2字节表示，少数字符要用到4字节。
- utf-32
  每个字符都是4字节


对于大多数 编程语言，运行时，字符串都是采用 UTF-16 或 UTF-32 。优点：
- 随机访问，UTF-16 可以很容易地进行随机访问。 utf-8 想要找到 第i个字符，需要从头开始计算
- 字符统计
- 字符串操作

。。但是 utf-16 不是可能4字节吗，怎么随机访问？
。看网上有种说法是， 大多数编程语言中 utf-16 是 固定2字节的。
。。还有 utf-16 可以使用 代理对， 似乎是 2字节表示 4字节。




---

# p80/73 数组优点与缺点

优点
- 空间效率高
- 支持随机访问
- 缓存局部性

缺点
- 插入和删除效率低
- 长度不可变
- 空间浪费



---

单向链表
环形链表
双向链表


---


# 93/ 缓存

- 缓存行
- 预取机制
- 空间局部性
- 时间局部性

链表对于 缓存的利用率 非常低
- 链表占用了更多的空间，导致 缓存中 能容纳的数量 更少
- 链表 数据分布在 内存各处， 缓存行利用率低
- 链表 不具备 可预测性
- 链表 无法享受 空间局部性

数据的 缓存命中率更高。



# 129/ hashmap 的 C实现


哈希冲突
- 拉链法
- 开发寻址，(不能直接删除元素)
  - 线性探测
  - 平方探测
  - 多次hash





# 150/ 二叉树类型

- 完美二叉树/满二叉树，perfect binary tree 最下面一行是满的
- 完全二叉树，complete binary tree 最下面一行从左向右填入(可能非满)
- 完满二叉树，full binary tree 每个节点要么没有叶子节点，要么有2个叶子节点
- 平衡二叉树，balanced binary tree 任意节点的 左子树和右子树的 高度差的绝对值不超过1




AVL树，平衡二叉树 + 二叉搜索树

173

旋转
- 右旋
- 左旋
- 先右旋后左旋
- 先左旋后右旋

哪个节点失衡 就对 哪个节点操作。
左旋 右旋 是由于树是对称的。


---

右旋
```text
      5
     / \
    4   6
   /
  1
 /
0
```

4失衡，进行右旋，变成 它 子节点的 子节点
```text
      5
     / \
    1   6
   / \
  0   4
```

---

```text
      5
     / \
    3   6
   / \
  1   4
 /
0

// 5失衡，进行右旋

    3
   / \
  1   5
 /   / \
0   4   6
```


---

先左旋再右旋

```text
      4
     / \
    3   5
   /
  1
   \
    2

// 节点3 失衡

// 先对 1 进行左旋
      4
     / \
    3   5
   /
  2
 /
1

// 然后再 对3右旋
      4
     / \
    2   5
   / \
  1   3
```

当失衡节点的子树的形状是 左左 时，一次 右旋
当形状是 左右 时，先左旋然后右旋

那
```text
      6
     / \
    4   7
   / \   \
  2   5  (8)
 / \
1   3

// 这种删除 8 后，怎么平衡？  6失衡，所以 它旋转

    4
   / \
  2   6
 / \  / \
1   3 5  7


因为 4的 子树 肯定是 小于 4的 父节点6的， 所以 4的 右子树 作为 6的 左子树 就可以了。 并且 6之前的 左子树4 正好全部 不再作为 6的 左子树了 (6的左子树 空缺)

```

旋转的选择 是通过 失衡节点的 较深侧 的 子树的 形状。 一共就4种
- 左左，进行 右旋
- 右右，进行 左旋
- 左右，先左旋 后右旋
- 右左，先右旋 后左旋

这里有个问题， 下面这种形状
```text
      6
     / \
    4   7
   / \   \
  2  (5)  8
 / \
1   3

移除5, 怎么旋转
不能先左旋再右旋

左旋 会变成

        6
       / \
      4   7
     /     \
    3       8
   /
  2
 /
1

只能直接右旋

      6
     / \
    2   7
   / \   \
  1   4   8
     /
    3

```

所以上面的 4种条件是 有优先级的， 出现 左左的时候 (不管是否有 左右) 直接右旋，


AVL树 插入的时候 也会导致 失衡，这时要 自底向上 一路 旋转

删除 也是 自底向上


---


红黑树 也是一种 平衡二叉搜索树，平衡条件更宽松， 插入，删除 时 所需的 旋转更少。




# p189/ 出堆: 堆顶和最后一个元素swap，然后新堆顶开始下降



# p191/ 堆用于 优先队列，堆排序，max k 元素




# p222/ 二分查找

一般使用 `[]` 区间搜索，因为操作对称。

`[]` 区间 搜索
```C
while (st <= en) {
  mid = st + (en - st) / 2;
  if (nums[mid] < target)
    st = mid + 1;
  else if (nums[mid] > target)
    en = mid - 1;
  else
    return mid;
}
return -1;
```


`[)` 区间 搜索

```C
while (st < en) {
  mid = st + (en - st) / 2;
  if (nums[mid] < target)
    st = mid + 1;
  else if (nums[mid] > target)
    en = mid;
  else 
    return mid;
}
return -1;
```



## 225 二分寻找插入点

无重复元素

```C
while (st <= en) {
  int md = st + (en - st) / 2;
  if (nums[md] < target)
    st = md + 1;
  else if (nums[md] > target)
    en = md - 1;
  else
    return md;
}
return st;
```


有重复元素

```C
while (st <= en) {
  int md = st + (en - st) / 2;
  if (nums[md] < target)
    st = md + 1;
  else if (nums[md] > target)
    en = md - 1;
  else 
    en = md - 1;  // <<<<<<
}
return st;
```




# p240 排序


评价指标
- 运行效率
- 是否原地
- 稳定性(相同值的元素，排序前在前面的 排序后依然在前面)
- 自适应性
  时间复杂度是否受到输入数据的影响， 。。需要 正向自适应
  - 如果最差时间复杂度 差于 平均时间复杂度，说明排序算法在 某些数据下 性能会劣化，是 ==负面属性==
  - 如果最优时间复杂度 优于 平均时间复杂度，则视为 ==正面属性==
- 是否基于比较
  基于 比较运算符 来判断 元素的相对顺序，理论最优是 O(nlogn)。
  不基于比较运算符，理论最优是 O(n)



具体算法

- 选择排序
  每次选未排序的最小的元素
- 冒泡
  每次比较相邻元素，如果反序，就swap
  有正向自适应，如果某次循环 没有交换数据，说明已经有序。
- 插入排序
  选一个未排序的元素，插入到有序的队列中
  有正向自适应，如果已经有序，则插入每次都在末尾，不需要移动元素，可以 O(n)
  数据量较小的情况下， 插入排序 优于 快速排序
- 快速排序
  分治，高效
  核心是 哨兵划分， 选择某个元素作为基准( 一种优化是 取 首中末 3个元素，选中间的 作为 基准，降低 最差情况的出现概率)，将小于它的移动到右侧，大于它的移动到左侧，分为 2部分，然后进行 递归。
  快速排序为什么快？
  - 出现最差情况的概率很低。 最差是 O(n^2)，绝大多数情况下，可以 O(nlogn)
  - 缓存使用率高。 遍历，不会跳跃式访问
  - 复杂度的常数系数小， 比较，赋值，交换 等操作的 总数量较少。
  尾递归优化，最差情况下，可能分为 0和 m-1长度的 2个子数组。我们可以仅对 较短的子数组进行递归。
  ```C
  void quickSort(int nums[], int left, int right) {
    int pivot = partition(nums, let, right);
    if (pivot - left < right - pivot) {
      quickSort(nums, left, pivot - 1);
      left = pivot + 1;
    } else {
      quickSort(nums, pivot + 1, right);
      right = pivot - 1;
    }
  }
  ```
- 归并排序
  分治， 从数组中点断开，进行递归， 长度为1时，开始合并，将2个短的有序的数组 合并为1个 长的 有序数组
  - 链表排序
    对于链表，归并排序 有显著优势，可以将链表排序的 空间复杂度优化至O(n)
    - 可以使用 迭代 代替 递归 来实现 链表划分工作。
- 堆排序
  使用 最小堆进行


前面的 排序算法都是 基于比较的排序算法

下面的是 非比较排序算法

- 桶排序
  长度为n 的数组
  - 初始化k个桶
  - 将 n个元素 分配到 k个桶中，这里是 按照 值范围进行分配的。( 就是，第一个桶 0-100，第二个桶 101-500，第三个桶 501-1000...)
  - 对 每个桶 进行排序 ( 基本是使用 语言内置的排序算法)
  - 从前往后 合并所有桶
  桶排序 适用于 处理 体量很大的 数据。
  难点是 桶的范围的划分
  - 进行抽样来判断 分布率，然后设置 桶
  - 或者，如果 桶中元素过多，那么 这个桶 再分为 几个桶。
- 计数排序
  统计元素数量， 通常应用于 整数数组
  - 遍历 数组，找到最大的 数字m，创建一个 m+1 个元素的 数组 counter
  - 遍历数组，`counter[num]++`
  - 遍历counter，生成有序数组
  计数排序 可以视为 桶只保存相同元素 的桶排序
- 基数排序
  核心思想 和 计数排序 类似
  基数排序 利用 数字各位之间的 递进关系，依次对每一位进行排序，从而得到最终的结果
  - 初始 k=0 ( 0是最低位)
  - 对第k位进行排序，k++，继续排序，直到k大于最高位
  对计数排序 稍作修改就可以 得到 基数排序。
  计数排序 必须稳定，==不稳定时，无法进行 基数排序== ； 计数排序稳定时，基数排序也是稳定的






# p274 分治

- 问题可以分解
- 子问题独立
- 子问题的解 可以合并


分治 不仅可以 解决问题， 往往还可以 提高 算法效率

提示算法效率：
- 操作数量优化
  冒泡排序，将数组分为 2个子数组，分别进行 冒泡， 然后进行 合并。 可以减少 一半的 时间， 从 O(n^2) 变成 O((n/2)^2 + n)  (依然是O(n^2) 但是 常数系数变小了)。  多设置几个 划分点 ，就变成了 桶排序。 (。桶排序是 先初步划分，然后 各自sort，然后 直接取就可以， 这里是 直接划分，各自sort，然后合并sort， 当然 这个 划分 和 合并 是可以 调换的， 就是 先初步划分 + 简单合并 或者 先简单划分 + 合并排序)
- 并行计算优化


分治用于解决许多算法问题：
- 寻找最近点对
- 大整数乘法
- 矩阵乘法
- hanno塔
- ==求解逆序对==

用于算法，数据结构中
- 二分查找
- 归并排序
- 快速排序
- 桶排序
- 树
- 堆
- hash表







# p294 回溯-剪枝

找到值 提前返回。
根据某些约束，提前返回。


大规模的问题， 回溯算法的效率 可能难以接受

但 回溯算法 仍然是 某些搜索问题 和约束满足 问题的 最佳解决方案。
关键是 如何优化效率
- 剪枝，避免搜索 不可能产生解的 路径
- 启发式搜索， 使用 策略或 估计值，从而 优先 搜索 可能产生 解的 路径。


搜索问题，目标是 找到满足特定条件的解
- 全排序，给定一个 集合，给出所有的 排列组合
- 子集的和，给定一个集合 和一个目标和，找到 集合中 和为 目标的 子集
- hanno塔

约束满足问题，目标是 找到 满足所有约束条件的 解
- n皇后， n*n 的棋盘上，防止 n个皇后，互不攻击
- 数独
- 图着色， 给定无向图，用最少的颜色 为每个顶点着色，使得相邻顶点的颜色不同

组合优化问题，目标是 在一个组合空间中 找到 满足某些条件的 最优解
- 0-1背包问题， 给定一组物品 和一个背包，每个物品有一定价值 和重量，要求在 背包容量限制内，选择物品 使得 总价值最大
- 旅行商问题，在一个图中，从一个点出发，访问所有其他点 恰好一次 后返回起点，求最短路径
- 最大团问题，给定一个 无向图，找到 最大的完全子图，即 子图中 任意2个顶点之间都有 边相连

对于组合优化问题，回溯不会最优的
- 0-1背包 通常使用 动态规划
- 旅行商 是 NP-hard 问题，常用解法是 ==遗传算法 和 蚁群算法==
- 最大团，使用 贪心算法 等 启发式算法





# p330 dp步骤

1. 思考每轮的决策，定义状态，从而得到 dp表
2. 找到最优子结构，进而推导出状态转移方程
3. 确定边界条件和状态转移顺序







2024.06.23 21:08







