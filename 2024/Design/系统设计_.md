
[[toc]]


---


# 系统设计的步骤四部曲(面试指南)

https://www.bilibili.com/video/BV1bYpweBEkX

1. 了解问题，确定设计范围， 5min
2. 提出高层设计 并获得支持， 20min
3. 深入设计， 15min
4. 总结， 5min

系统设计问题通常是开放式的，有时，它们的呈现方式故意含糊不清，这考验了我们组织思考和专注于重要事情的能力。  
我们需要 尽可能多地 提出问题，以充分理解面试题。

我们应该问什么？ 我们需要了解 
- 为什么要构建这个系统
- 用户是谁
- 我们需要构建哪些功能

比如，我们被要求设计一款聊天应用程序， 我们需要意识到 市场上有不同类型的聊天应用， 有一对一的，小组聊天的，办公室聊天，群聊  
目标是 按照优先级顺序 了解 我们正在构建的功能，我们应该专注于哪些功能，并确保 面试官认同功能表  

提出问题来了解 非功能性问题也很重要，在 面试中，建议重点关注 ==规模和性能==
多少qps

。。聊天应该还有私密性？ 办公室聊天的话， 内网？ 直接类似 gitlab 自建？

第一步完成后，我们会得到 一个简短的设计功能列表，一些需要满足的 重要的非功能性需求。


---

对于大多数设计，我们建议使用 自上而下的方法，并从 api 开始  
api 在 终端用户 和 后端系统之间 建立了 契约  

收集需求后 应该清除 我们需要 哪些api， 一般 遵循 RESTful。  
仔细定义 每个api 的 输入参数 和输出响应  
仔细察看api，验证它们是否满足功能需求  

某些设计可能需要 客户端和服务器之间的 双向通信， 此时 websocket 是一种常见的解决方案  
但注意， websocket 是有状态的，上规模后 具有相当的挑战。  
如果规模很大，请深入讨论 如何管理websocket部署

一般从 网关/LB 开始  

许多服务需要某种形式的持久性，我们需要引入数据存储层。 不必讨论具体的 数据库技术， 在设计了 数据模式 后才需要开始 讨论 数据库技术。

- 数据库伸缩性
- 高并发
- 失败处理

不要过早地 深入研究太多细节。(因为此时，你的了解并不全面)

数据模型和模式， 我们应该讨论 数据访问模式 和 读写比例。  

从规模上看，数据模型可能会显著影响设计性能

如果很简单，还可以讨论 数据库的选择，索引

最后，我们要审查设计，确保 每个功能都是 端到端 完整的。


---

深入设计

目的是 证明我们能够识别出 可能存在的问题领域， 提出解决方案 并讨论 利弊

完全开放性的。  
察言观色，了解 面试官 对哪些方面不满意

- 提出问题
- 提出至少2个解决方案
- 讨论方案利弊


---

总结，保持简短。


---



# 系统设计应该知道的算法

https://www.bilibili.com/video/BV1BTpuezESF


不讨论算法细节，着重于介绍 为什么重要，在哪里使用它们

- consistent hashing
- geohash
- quadtree
- leaky bucket
- token bucket
- trie
- bloom filter
- raft/paxos


## consistent hashing

Cassandra (apache的，开源，分布式k-v存储系统，用于存储特别大的数据) 使用一致性hash 跨多个服务器分发数据

移除或增加 节点，只需要 rehash 一部分， 而普通的hash需要rehash所有。

虚拟节点 解决 数据分布不均匀问题， 

更深入，察看 集合点hash (Rendezvous hashing)，跳转一致性hash (jump consistent hash)

高效的数据分发至关重要。 一致性hash 可以最大限度减少 增删服务器 时的 中断。


## geohash

。。这个视频里没有讲。。 网上收集了下

对于纬度，范围是 (-90, 90) ,那么分为2个区间 (-90,0) (0,90)， 0代表第一个区间，1代表第二个区间。  
如果是 1， 那么 继续划分为 (0,45),(45,90), 也是通过 0/1 来选择。   
无限划分下去，就可以获得 一串 01码。

对于经度，也是这样处理， 也得到一串 01码。

最后合并 经纬度， 偶数下标经度， 奇数下标纬度，  交错合并。

然后可以转为 base32， 就是 按 5个 bit 分组， 5个bit转为 十进制， 并转为 对应的 base32码。

base32的映射规则：  0-9 + 去除a i l o 后的 22个英文字母， 就是 32个字符了， 就对应 0-31  
即，10->b, 20->n, 31->z

。估计 手写体的 a，o  (和 q相比) 有一点点类似，所以就删除了。






## quadtree (四叉树) 用于空间索引

工作原理， 将2D空间 递归地分解为 4个象限， 每个节点代表一个区域，并且具有 0-4个子节点

四叉树，可以 实现 基于位置 的 快速插入 和搜索， 可以快速 找到 半径内的点。

非常适合 索引 地图应用中的空间数据

更深入的话，察看其他 空间索引树：R树，KD树


## leaky bucket 速率限制

就是一个 漏桶， 请求就像水 一样涌入， 如果水桶满了，那么就拒绝 请求。

通的大小 控制 突发容量  
以设定的速率 泄漏

其他的速率限制算法： 令牌桶，滑动窗口计数器


## trie (音：try)

针对 存储 字符串和前缀 进行优化的 树

trie 的真正威力 在于 非常快 的查找速度

每个节点 维护了 多个子指针， 所以 内存消耗 有点大。

一些变体： 基数树 Radix tree， 后缀树 Suffix tree， 可以优化内存

。。基数树就是 做了一些合并，之前 每层 都是单个字符作为key的， 基数树把 哪些 非常少用的 合并了， 比如 只有一个单词 有 rfvdfgsdf 的后缀，那么 这个 rfvdfgsdf 直接就是 一个 key，而不是 一串 节点。



## bloom filter


用于检查 成员是否存在

可以想象成 一个bit数组 和 一些hash函数 的组合

数据项 被 hash计算，并设置到 bit数组 的相应位置中

检查 数据项是否存在时， 也是 对数据项进行 hash，察看 bit数据中 对应的位置 是否已经设置， 如果 没有，那么 数据 绝对不存在。

一旦添加元素，就无法删除

通过 调整 bit数据的大小 或 hash函数 来 平衡 消耗的内存空间 和 准确性

在 缓存，数据去重，分析 方面 表现出色


## 共识算法 consensus algorithm

分布式系统中，达成共识( 所有结点一致同意共享状态) 是很棘手的， 尤其在 网络问题 和故障时

raft 以简单 和 高效 著称

许多 分布式系统(如 kafka，etcd) 都使用 raft 来进行 复制，故障转移，leader选举


















