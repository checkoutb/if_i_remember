
2024-03-23 16:14

[[toc]]

---
---
---

# 注意点

## 超时

调用其他接口时，一定要有逻辑来处理 ==超时==
我们并不知道 超时，是 对方没有收到请求，还是 我们没有收到响应
如果是后者，那么 请求已经被处理了，我们不能回滚。
所以 出 超时 问题后，一定要 去查询下 请求的状态。





# 防重 vs 幂等

防重是为了避免产生重复数据，把重复请求拦截下来即可
幂等是相同的请求 有相同的效果。
。。返回值 也是效果，所以 防重可以直接 返回 异常，告诉客户端重复了， 幂等要返回成功，但是怎么可能做到，比如删除，我要返回 删除的 条数。 第一次删除1条，返回1， 第二次删除0条，我怎么可能返回1呢？



# 1. 数据库唯一主键
只能前端生成，后端收到2个请求，生成的2个主键是不同的。
适用于插入。

。。。
直接insert，捕捉异常。
先select，没有，再insert，捕捉异常。
上面这2种 哪种快？这个应该要看 重复的几率，如果重复的几率很小，直接insert 快， 如果 大概率重复，那么select+insert快？ 问题是 这个大概率 要大到什么程序呢？ 
感觉直接insert最好。
。。。

# 2. 乐观锁
适用于更新

# 3. 分布式锁

长流程的时候，可以用分布式锁(用户ID + 流程缩写)， 流程开始加锁，流程结束 解锁。

。淘宝不能 2个手机 同时登录 一个账号， 不然 2个手机 同时点击 支付，无法处理的。
。。对，可以 购物车，点下一步的时候， ==分布式 锁 用户ID+pay，把支付流程锁住==。。 不过这个没有办法 处理 多次 支付。 。 不过这个锁 应该也是要的，不然 ==网页上 准备支付， 手机上准备支付==， 并且 购物车 选的东西还差不多。

# 4. token
服务器提供 token接口，客户端通过接口 获得 token
服务器生成 token后，插入到redis (考虑设置过期时间)，然后将token发给客户端
服务器收到 客户端的请求后，先删除redis里的数据，判断返回值(返回的是删除的条数，所以如果1，说明可以继续执行业务逻辑，如果是0，说明已经执行过了)

。让客户端 通过 UUID 生成 主键/流水号，然后服务器 setnx (+过期时间) 也可以吧。(。。==这个是分布式锁==)。 html页面怎么弄？我感觉好像没有办法，html每次都会生成一个吧。html能做的逻辑太少了。
。客户端的 流水号/主键 可以：用 用户的ID + timestamp + random值， random值可以用一个 static atomic/int 代替，它每次都 (x+1) % (2^10)，这样循环，要重复只能是 用户在同一毫秒点一千次。。 不过 timestamp 估计不能实时，所以可能 这一ms 和下一ms，返回的毫秒数是一样的。 不过可以增大 MOD。
。这个 流水号/主键 的生成时机 应该也是 购物车 点下一步的时候。

。或者：购物车 勾选好商品，点下一步的时候，后端返回 总金额 + 流水号/主键，点支付的时候 把 流水号/主键 带给后端， 顺便从购物车删除 购买的物品。

。既然 购物车要点 下一步，那么 在 点击下一步的 响应中 带上 token 也没什么问题。


# 5. 状态机幂等
很多业务表，都是有状态的。
。。状态等于 是 乐观锁。。 不， 乐观锁是 commit的时候报错。不。这就是 1 的问题：是直接 insert 还是 select+insert， 在这里就是： 是乐观锁 还是 select+乐观锁。

。。而且 业务表的话，可以直接 悲观锁， 反正没有其他请求 会处理这条数据，直接锁上。 。。不不不，==悲观锁 是无法 幂等的==。  请求进来，悲观锁开始，处理，悲观锁结束， 请求再次进来，悲观锁开始，处理，悲观锁结束



---

# 接口如何防抖，防止重复提交

BV13i421a7yP

需要防抖的接口一般有：
1. 用户输入类接口，比如 搜索框输入，表单输入
2. 按钮点击类，如 提交表单，保存设置
3. 滚动加载，如 下拉刷新，上拉加载

如何防抖(防重复提交)
1. 接口的2次调用之间增加一个 时间间隔。
2. 比较2个请求 的 (部分)参数，
3. 更好一点，增加一个 请求地址的对比


代码逻辑
1. 用户提交请求
2. 根据上下文 和参数 生成 key
3. 将key 和参数 保存到缓存，并设置 失效时间
4. 第二次请求，也生成 key
5. 判断 key是否已经存在，已存在就是 重复请求。













