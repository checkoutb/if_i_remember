Za
2022年4月14日
12:13

[[toc]]


# 并行，并发
并行Parallel，多核，同时发生
并发Concurrent，需要切换

=====================
# 进程，线程，协程

--------
https://baijiahao.baidu.com/s?id=1689257281653417916&wfr=spider&for=pc

对于OS来说，进程是分配资源的基本单位，线程在很长时间被称为轻量级进程，是程序执行的基本单位。

这样看来  一个是分配资源的基本单位，一个是  程序执行的基本单位。  大部分面试中的回答都是这个。

进程，需要内存资源，CPU，文件资源。
线程仅需要分配CPU资源

线程概念被提出以后，因为只分配了CPU计算资源，所以也叫做轻量级的进程。

## 内核级线程和用户级线程

通过OS来调度线程，也就是说OS创建线程后，进程的入口程序被放在主线程中，看起来感觉是OS在调度进程，实际上调度的是进程中的线程，这种被OS直接调度的线程叫做内核级线程。

主程序通过程序的方式实现子线程，这就是用户级线程。

### 用户态线程
完全在用户空间创建，对于OS来说毫不知情的，用户级线程的优势：
1. 切换成本低：用户空间自己维护，不走OS的调度
2. 管理开销小：创建和销毁不需要OS调用
缺点：
1. 与内核沟通成本大：因为这种线程大部分时间在用户空间，如果进行IO，很难利用内核的优势，且需要频繁地切换  用户态和内核态
2. 线程之间的协作麻烦：2个线程需要通信，通信通常会涉及IO，IO设计到系统调用，系统调用又要发生用户态和内核态的切换成本
3. OS无法针对线程的调度进行优化：如果一个进程的  用户态线程  阻塞了，OS无法及时发现和处理阻塞，它不会切换其他线程。

### 内核态线程
内核态线程执行在内核态，一般通过OS调用创造一个内核级线程，优点：
1. OS级优化：内核中的线程即使执行IO也不需要系统调用，一个内核阻塞  可以让其他立刻执行
2. 充分利用多核优势：内核权限足够高，可以在多个CPU核心执行内核线程
缺点：
1. 创建成本高：创建的时候需要使用系统调用  即切换到内核态
2. 切换成本高：切换的时候需要进行  内核操作
3. 扩展性差：因为一个内核管理，坑位有限，不可能数量太多

用户态线程创建成本低，不可以利用多核，而  内核态线程创建成本高，虽可以利用多核，但是切换速度慢。所以，通常会在内核中预留一些线程并反复使用这些线程，至此出现了以下几种映射关系

## 用户态和内核态映射关系
### 多对一
内核线程创建的成本既然高，那么我们就让多个  用户态进程的多线程  复用一个内核态线程，可以这样无法并发，所以此模型用户很少。

### 一对一

每个用户态线程分配一个单独的内核态线程，每个用户态线程通过系统调用创建一个绑定的内核线程，这种模型可以并发，充分利用多核的优势，Windows  NT  就是这种模型，但是如果线程比较多，对内核的压力就很大。

### 多对多
n个用户态线程  对应  m个内核态线程，通常m  小于  n，m通常设置为核数。linux采用这种模型。

CPU既然要执行它，势必需要去了解从哪里加载它，又从哪里开始运行，也就是说，需要系统提前设置将它们设置好CPU寄存器和程序计数器

程序计数器用来记录正在执行的指令的位置，这些CPU需要依赖的环境就是CPU的上下文

将前一个任务的CPU上下文保存下来，加载新任务的上下文到寄存器和程序计数器，然后跳转到程序计数器所指向的位置。
根据任务的不同又分为进程的上下文  和  线程的上下文。

## 进程的上下文

进程在用户空间运行的时候叫做用户态，陷入到内核空间叫做进程的内核态，如果用户态的进程想转变到内核态，则可以通过系统调用的方式完成。进程由内核调度，进程的切换发生在内核态。

既然进程的切换发生在内核态，那么进程的上下文不仅仅包括  虚拟机内存，栈，全局变量  等用户空间资源，还包括了  内核堆栈，寄存器等内核空间的状态。

这里的保存上下文  和  恢复上下文也不是免费的，需要内核在CPU上运行才能完成。

## 线程上下文切换
线程是调度的基本单位，而进程是资源拥有的基本单位。说白了，内核的任务调度实际上调度的是线程，进程只是为线程提供虚拟内存，全局变量等资源，所以这么理解可能更好：
进程如果只有一个线程，那么认为进程就是线程
如果进程由多个线程，那么多个线程会共享相同的虚拟内存和全局变量等资源，上下文的切换不会影响这些资源
线程拥有自己的自由数据比如  栈和寄存器，上下文切换时需要提前保存。

综上所述，线程的上下文切换将分为2个部分：
2个线程不属于同一个进程，那么资源不共享，所以切换过程就会涉及到进程的上下文切换。
第二种情况，即2个线程属于同一个进程。因为共享虚拟内存，所以切换的时候这些资源保持不动，只需要切换线程的私有数据等不共享的数据。

这也从侧面表明了，进程内的线程切换比  多进程间的切换  会节省不少资源，这也是多线程逐渐替代  多进程的一个原因

系统调用又是如何执行的？
如果用户态的程序要执行系统调用，则需要切换到内核态执行，这个过程如下图所示

![用  执 行 系 统 调 用  trap  统 调 用 返  用 户 态  trap  内 核 态  执 行 系 统 调 用](../_resources/c27a4909fda3473d93d21546d9b734be.png)

既然分为了  用户态和内核态，2者权限级别不尽相同，用户态的程序发起系统调用，因为涉及到权限问题，不得不牵扯到特权指令，所以就会通过  中断的方式执行，即上图的  trap  。

发生中断后，内核程序就开始执行，处理完成又触发trap，切换到用户态，又涉及到了中断。

## 中断做了什么？

以键盘输入为例，当我们敲下键盘，主板收到按钮后通知CPU，此时CPU可能在处理其他程序，需要先中断当前执行的程序，然后将  PC指针  跳转到  固定的位置，这就是一次中断的简单描述。

不同的组合键对应了不同的事件，所以需要根据中断类型判断  PC指针  到底跳转到哪里，中断类型的不同，PC指针  所执行的位置也就不同，因此进行了分类，这个类型  我们称为  中断识别码。CPU通过  PC指针直到需要跳转到哪个地址  进行处理，这个地址叫做  中断向量表。

## 调度通过时间片

进程的周期一般分为以下3种状态
1. 就绪状态，进行创建后会开始排队，这个时候就是  就绪状态
2. 运行状态，开始执行；时间片用完后  变成就绪状态
3. 阻塞状态，等待某个进程的完成

还有2种级别状态

1. 创建状态，进程刚被创建，还没有提交，主要功能是  分配和建立进程控制块等  初始化工作，创建进程有2个阶段，第一个阶段是为  新的进程创建必要的管理信息，第二个阶段是  让进程进入就绪状态。

2. 终止状态，进程退出的状态，即回收除了进程控制块以外的资源。也分为2个阶段，第一个阶段是  等待OS进行善后处理，第二个阶段是  释放主存

还有另外2种状态
1. 就绪挂起，
2. 阻塞挂起，
挂起是一种行为，而阻塞时进程的状态
导致进程挂起的原因  通常是  因为内存不足  或用户的请求，进程的修改等，而进程的阻塞时进程正在等待某个事件发生，可能是等待资源或响应
挂起对应的行为是  激活，将外存中的  进程加载到  内存中，而处于阻塞状态的  进程需要等待其他进程  或  系统  唤醒
挂起属于被动行为，进程被迫从内存转移到外存，而进入阻塞  是主动的行为。

![七 种 杰  新 建  提  提 交  调 度  释 放  就 绪 挂 起  事 件 出 现  事 件 出 现  阻 塞  阻 塞 挂 起](../_resources/27078250a275444ba12e6e7764105fe1.png)

## 进程和线程在内存中如何表示
在整个设计过程中，涉及了2张表，分别是进程表  和  线程表。
进程表记录进程在内存中的位置，PID，当前状态，分配了多少内存，属于哪个用户等

![迮 轰  进 程 优 先 级  父 进 程  环 境 变 量  内 存 位 置  用 户](../_resources/88ec1fe25fea483d996f6dbe7b0b1bd4.png)

尤其要注意  进程表的几个部分
1. 资源信息
这个会记录这个进程有哪些资源，比如进程和虚拟内存怎么映射，拥有哪些文件等。
1. 内存布局
栈，系统自动分配释放，包括，函数参数值，局部变量，返回地址等。
堆，存放动态分配的数据，通常由开发人员自行管理，程序结束后由OS回收。

数据段，存放  全局变量和静态变量。其中初始化数据段(.data)存放显式初始化的全局变量和静态变量，未初始化数据段，通常被称为BSS段(.bss)，存放未进行显式初始化的全局变量和静态变量。

![迮 内 有 有  栈 （ 向 下 增 长 ）  空 闲 区  颯 向 下 增 长 ）  数 据 段 （ 全 局 变 量  堂 数 ）  正 文 段](../_resources/6cda8e083abf4165b25d6c9cc5f31c69.png)

。。我记得  栈和堆是  面对面增长的。。。对，这张图里，堆的下面是数据段，上面是空闲区，所以堆应该往上增长。

1. 描述信息
包含进程的唯一识别号，进程的名字及用户等。

除了给进程一张表外，给线程也安排了一张表，这就是线程表。线程表也包含了一个ID，称为ThreadID，同时也会记录自己在不同阶段的状态，比如阻塞，运行，就绪。由于多个线程会共用CPU且需要不停地切换，所以需要记录  程序计数器和寄存器的值

两者的映射关系如何表示？
。。应该是指  进程表和线程表的关系

可以相像内核中有一个线程池，给予用户空间使用，每次用户级线程  把程序计数器等  传递过去，执行结束后，内核线程不销毁，等待下一个任务。从这里可以看出  创建进程开销大，成本高；创建线程开销小，成本低。

这么多进程难道共用内存？

OS有很多进程，为了让它们各司其职，互不干扰，考虑为它们分配完全隔离的内存区域，即使程序内部读取相同的内存地址，但实际上它们的物理地址也不一样。就彷佛我在X座的501，你在Y座的501，都是501，但是是不同的房子，这就是地址空间。

所以在正常情况下，A进程  不能访问  B进程的内存，除非你植入一个木马，或者通过  进程间通信。

## 进程如何切换？
每次切换前需要先记录下  当前寄存器值的内存地址，方便下次回到原位置继续执行。恢复执行的时候就从内存中读取，然后恢复状态执行即可。

步骤：
1. OS感知到有进程需要切换，先发出一个  中断信号给CPU，让其停止当前进程
2. CPU收到中断信号后，正在执行的进程会停止，OS会先保存当前状态

3. OS接管当前中断后，执行一段汇编程序帮助寄存器之前进程的状态。。。不知道"之前"是什么意思，或者说前面有什么单词？(加载，保存？)结合下面的，应该是  恢复之前进程的状态

4. OS保存好状态后，会执行调度程序，让其决定下一个将要执行的进程
5. 最后OS会执行下一个进程。

## 中断以后如何恢复之前进程运行？
上面说到OS会执行一段代码帮助进程恢复状态，其实现方式中，有一种方式即  通过栈的FIFO  的数据结构。
进程(线程)中断后，OS负责压栈关键数据(比如寄存器)。恢复执行时，OS负责出栈和恢复寄存器的值。

## 协程

为什么需要协程？

我们在执行多任务的时候，通常采用多线程的方式并发执行。我们以电商卖茅台为例，10个用户，每当收到10条付款信息就开启10个线程去查询数据库，当有100个，有1000个。

假设每个线程占用4m内存，那么10000个线程大约需要40g内存。

多个线程在进行作业时，难免会遇到  某个线程等待IO的情况，此时会阻塞当前线程切换到其他线程，使得其它线程照常执行，线程数量多了以后就会出现问题，会占据非常多的内存空间，且过多的线程的切换也会占用大量的系统时间。

此时就可以通过协程来解决这个问题
协程运行在线程之上，协程执行完以后，可以选择主动让出，让另一个协程运行在当前线程之上。

即协程没有增加线程的数量，而是在  线程的基础上通过分时复用的方式运行多个协程，还有关键一点是它的切换发生在用户态，所以不存在  用户态到内核态的切换，代价更低。

类比上面，我们只需要100个线程，每个线程跑100个协程就可以完成之前的  同时处理10000个任务。

协程在使用过程中需要哪些东西？

刚说协程运行于线程之上，如果线程等待IO的时候阻塞了，这时候会出现什么情况？其实OS主要关心线程，协程调用阻塞IO的时候，OS会让进程处于阻塞状态，此时当前的协程和绑定在线程之上的协程都会陷入阻塞而得不到调度，这就很难受了。

因此，协程中，不能调用导致线程阻塞的操作，即协程最好和异步IO结合起来才能发挥最大威力。

怎么处理在协程中调用阻塞IO的操作呢
比较简单的思路是  当调用阻塞IO时，重新启动一个线程去执行这个操作，等待执行完成后，协程再去读取结果。
将系统IO进行封装，改为异步调用的方式，此时需要大量的工作，所以需要编程语言的原生支持。

所以对于计算密集型的任务不太建议使用协程，计算密集型的任务需要大量的线程切换，线程切换涉及太多的资源交换。

---------

=====================

Java的  Thread  是用户级线程。

=====================

=====================

=====================

=====================

=====================

=====================

已使用 Microsoft OneNote 2016 创建。


# 处理错误的4种方法

https://pythoncat.top/posts/2023-05-08-error


## 返回错误代码:C

如果出错，返回一个 错误代码(通常是 负数 或 null)

例如，C常用的：
```C
FILE* fp = fopen("file.txt" , "w");
if (!fp) {
  // 发生了错误
}
```

简单，易实现，易理解。
执行效率高，因为只需要 进行标准的 函数调用，并返回一个值，不需要有 运行时支持 或分配内存。

缺点：
- 用户很容易忘记处理函数的错误，比如 C中，printf 可能会出错，但几乎没有程序 检查它的返回值
- 如果代码必须处理 多个不同的错误 ( 打开文件，写入文件，从一个文件读取等)，那么传递错误到调用堆栈会很麻烦。
- 除非你的编程语言支持多个返回值，否则如果必须返回一个有效值或一个错误，就很麻烦。这导致 C 和 C++ 中的许多函数必须通过指针来传递存储了“成功”返回值的地址空间，再由函数填充，类似:

```C
my_struct *success_result;
int error_code = my_function(&success_result);
if (!error_code) {
  // can use success_result
}
```

。。就是 使用 输出形参。

Go也使用这种方法来处理错误，因为它 允许 多返回值。
```Go
user, err = FindUser(username)
if err != nil {
    return err
}
```

## 异常

可能是 最常用的错误处理模式

try catch finally 相当有效，而是使用简单。

异常在 上世纪90年代 到2000年 间 非常流行，被许多语言采用，如 Java， C#, Python

与错误代码 相比，异常的优点：
- 自然地区分了 正确路径 和 错误处理路径
- 自动从 调用堆栈中冒泡出来
- 你不会忘记处理 异常。

缺点：
- 需要一些特定的 运行时支持，通常会带来相当大的 性能开销。
- 更重要的是，它们具有“深远”的影响——某些代码可能会抛出异常，但被调用堆栈中非常远的异常处理程序捕获，这会影响代码的可读性。
- 仅凭查看函数的签名，无法确定它是否会抛出异常。

C++ 试图通过throws 关键字来解决这个问题，但它很少被使用，因此在 C++ 17 中已被弃用 ，并在 C++ 20 中被删除。此后，它一直试图引入noexcept 关键字


Java 曾试图使用“受检的异常（checked exceptions）”，即你必须将异常声明为函数签名的一部分
但是这种方法被认为是失败的，因此像 Spring 这种现代框架只使用“运行时异常”，
而有些 JVM 语言（如 Kotlin）则完全抛弃了这个概念。
这造成的结果是，你根本无法确定一个函数是否会抛出什么异常，最终只得到了一片混乱。



## 回调函数

JavaScript 非常常见的方法。

回调函数 会在 函数成功或 失败时 调用。 这通常会和 异步编程结合使用，其中IO操作在后台执行，不会阻塞执行流。

但，这种方法进程会导致 所谓的 回调地狱 问题，因为一个回调可能需要调用其它的异步 I/O，这可能又需要更多的回调，最终导致混乱且难以跟踪的代码。

使用回调进行错误处理是一种值得了解的重要模式，不仅仅在 JavaScript 中如此，人们在 C 语言中也使用了很多年。但是，它现在已经不太常见了，你很可能会用的是某种形式的async/await。


## 函数式语言的Result

起源于函数式语言，如 Hashell。

由于 Rust的流行，它变得非常主流。

它的创意是提供一个Result类型，例如：
```Rust
enum Result<S, E> {
  Ok(S),
  Err(E)
}
```

为了在调用堆栈中抛出错误，通常会编写如下的代码：
```Rust
let result = match my_fallible_function() {
  Err(e) => return Err(e),
  Ok(some_data) => some_data,
};
```

由于这种模式非常常见，Rust 专门引入了一个操作符（即问号 ?） 来简化上面的代码：
```Rust
let result = my_fallible_function()?;   // 注意有个"?"号
```

优点是它使错误处理既明显又类型安全，因为编译器会确保处理每个可能的结果。

在支持这种模式的编程语言中，Result 通常是一个 monad，它允许将可能失败的函数组合起来，而无需使用 try/catch 块或嵌套的 if 语句。

==函数式编程认为函数的输入和输出应该是纯粹的，不应该有任何副作用或状态变化。monad 是一个函数式编程的概念，它通过隔离副作用和状态来提高代码的可读性和可维护性，并允许组合多个操作来构建更复杂的操作==







