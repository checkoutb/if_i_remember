
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1" />
						<link rel="stylesheet" href="pluginAssets/katex/katex.css"><link rel="stylesheet" href="pluginAssets/highlight.js/atom-one-light.css">
						<title>Nothing is Harder, Except Math and …</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">Nothing is Harder, Except Math and …</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}
		::-webkit-scrollbar {
			width: 7px;
			height: 7px;
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(100, 100, 100, 0.3); 
			border-radius: 5px;
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(100, 100, 100, 0.7); 
		}

		

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: 1.35em;

			/*
				Adds support for RTL text in the note body. It automatically detects the direction using the content.
				Issue: https://github.com/laurent22/joplin/issues/3991
			*/
			unicode-bidi: plaintext;
		}

		h1, h2, h3, h4, h5, h6, ul, table {
			margin-bottom: 0.65em;
		}

		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
			font-weight: bold;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}

		.resource-icon {
			display: inline-block;
			position: relative;
			top: 0.3em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to precvent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: 0.7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		.not-loaded-resource img {
			width: 1.15em;
			height: 1.15em;
			background: white;
			padding: 2px !important;
			border-radius: 2px;
			box-shadow: 0 1px 3px #000000aa;
		}

		a.not-loaded-resource img {
			margin-right: .2em;
		}

		a.not-loaded-resource {
			display: flex;
			flex-direction: row;
			align-items: center;
		}

		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		mark {
			background: #F7D26E;
			color: black;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 35rem;
			width: 100%;
			max-width: 1000px;
			margin: 0;
			border: 0;
			display: block;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* To make code blocks horizontally scrollable */
		/* https://github.com/laurent22/joplin/issues/5740 */
		pre.hljs {
			overflow-x: auto;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}</style><div id="rendered-md"><p>Nothing is Harder, Except Math and …<br>
2021年8月25日<br>
8:49</p>
<nav class="table-of-contents"><ul><li><a href="#kadane">Kadane</a></li><li><a href="#kmp">KMP</a></li><li><a href="#sunday">Sunday</a><ul><li><a href="#实际使用中sunday-比-bm略优">实际使用中，Sunday  比  BM略优。</a></li></ul></li><li><a href="#bm算法">BM算法</a></li><li><a href="#morris-traversal">Morris Traversal</a></li><li><a href="#rabin-karp-rolling-hash-pattern-match">Rabin-Karp / Rolling hash (pattern match)</a></li><li><a href="#fisher-yates-algorithm-and-knuth-shuffle">Fisher-Yates Algorithm and Knuth Shuffle</a></li><li><a href="#flood-fill">flood fill</a></li><li><a href="#sweep-line">sweep line</a></li><li><a href="#manacher-最长回文-on">Manacher  最长回文  O(n)</a></li><li><a href="#moore-voting-algorithm">Moore Voting Algorithm</a></li><li><a href="#欧拉图">欧拉图</a></li><li><a href="#欧拉回路">欧拉回路</a></li><li><a href="#hierholzers-algorithm">Hierholzer&#39;s algorithm</a></li><li><a href="#弗勒里算法">弗勒里算法</a></li><li><a href="#lis-longest-increment-subsequence">LIS, longest increment subsequence</a></li><li><a href="#水塘抽样蓄水池抽样算法reservoir-sampling">水塘抽样/蓄水池抽样算法(Reservoir Sampling)</a><ul><li><a href="#分布式的蓄水池抽样">分布式的蓄水池抽样</a></li></ul></li><li><a href="#kosaraju算法">Kosaraju算法</a><ul><li><a href="#在实际的测试中tarjan的效率-比kosaraju-高-30-左右">在实际的测试中，Tarjan的效率  比Kosaraju  高  30%  左右。</a></li></ul></li><li><a href="#tarjan算法">Tarjan算法</a><ul><li><a href="#线性时间求解有向图强连通分量">线性时间求解有向图强连通分量</a></li><li><a href="#lca">LCA</a></li><li><a href="#无向图的割点与桥割边">无向图的割点与桥(割边)</a></li></ul></li><li><a href="#lca-1">LCA</a><ul><li><a href="#朴素算法">朴素算法</a><ul><li><a href="#调整深度上浮">调整深度+上浮</a></li><li><a href="#treenode">TreeNode</a></li><li><a href="#只给了-边">只给了 边</a></li></ul></li><li><a href="#tarjan-见tarjan-lca">Tarjan (见Tarjan-LCA)</a></li><li><a href="#倍增法">倍增法</a></li><li><a href="#欧拉序列-rmqst">欧拉序(列) + RMQ/ST</a></li></ul></li><li><a href="#dijkstra">Dijkstra</a></li><li><a href="#prim">Prim</a></li><li><a href="#kruskal">Kruskal</a></li><li><a href="#spfa">SPFA</a></li><li><a href="#floyd">Floyd</a></li><li><a href="#bellman-ford">Bellman-Ford</a></li><li><a href="#suffix-array">Suffix  Array</a><ul><li><a href="#倍增算法">倍增算法</a></li></ul></li><li><a href="#lcp-array">LCP array</a></li><li><a href="#rmq-算法">RMQ  算法</a></li><li><a href="#travelling-salesman-problem">Travelling Salesman Problem</a></li><li><a href="#线段树">线段树</a><ul><li><a href="#segment-tree-impl">segment tree impl</a></li><li><a href="#segment-tree-impl2">segment tree impl2</a></li><li><a href="#lazy-propagation-an-optimization-to-make-range-updates-faster">Lazy  Propagation  –  An optimization to make range updates faster</a></li><li><a href="#persistent-segment-tree">Persistent Segment Tree</a></li></ul></li><li><a href="#binary-indexed-tree-or-fenwick-tree">Binary Indexed Tree or Fenwick Tree</a><ul><li><a href="#bit-impl-index-start-from-1">BIT impl (index start from 1)</a></li><li><a href="#bit-impl-2">BIT impl 2</a></li><li><a href="#bit-impl-3">BIT impl 3</a></li><li><a href="#bit-impl-2d-array">BIT impl 2D array</a></li><li><a href="#bit-impl-index-start-from-1-1">BIT impl (index start from 1)</a></li></ul></li><li><a href="#splay">Splay</a></li><li><a href="#分块">分块</a></li><li><a href="#莫队">莫队</a></li><li><a href="#珂朵莉树">珂朵莉树</a></li><li><a href="#哈夫曼树">哈夫曼树</a></li><li><a href="#数学">数学</a><ul><li><a href="#裴蜀定理">裴蜀定理</a></li><li><a href="#威尔逊定理数论四大定理之一">威尔逊定理(数论四大定理之一)</a></li><li><a href="#费马小定理">费马小定理</a></li><li><a href="#欧拉定理">欧拉定理</a></li><li><a href="#孙子定理中国余数定理">孙子定理，中国余数定理</a></li><li><a href="#模逆">模逆</a><ul><li><a href="#扩展欧几里得求乘法逆元">扩展欧几里得求乘法逆元</a></li><li><a href="#欧拉定理求乘法逆元">欧拉定理求乘法逆元</a></li><li><a href="#费马小定理求乘法逆元">费马小定理求乘法逆元</a></li><li><a href="#递推求乘法逆元">递推求乘法逆元</a></li><li><a href="#阶乘与逆元">阶乘与逆元</a></li></ul></li><li><a href="#模的逆">模的逆</a><ul><li><a href="#应用my">应用my</a></li></ul></li><li><a href="#快速傅里叶变换fft">快速傅里叶变换FFT</a></li><li><a href="#鞋带公式-求多边形面积">鞋带公式 - 求多边形面积</a></li><li><a href="#欧几里得算法-辗转相除法">欧几里得算法 - 辗转相除法</a></li></ul></li><li><a href="#差分数组">差分数组</a></li><li><a href="#快速幂">快速幂</a></li><li><a href="#range-minimum-query-square-root-decomposition-and-sparse-table">Range Minimum Query (Square Root Decomposition and Sparse Table)</a></li><li><a href="#lsm-tree-nosql数据库存储结构">LSM tree - nosql数据库存储结构</a></li><li><a href="#用卡特兰数来求出栈序列个数">用卡特兰数来求出栈序列个数</a></li><li><a href="#指派问题匈牙利算法">指派问题，匈牙利算法</a></li><li><a href="#匈牙利算法-二分图最大匹配">匈牙利算法  -  二分图最大匹配</a><ul><li><a href="#匈牙利树">匈牙利树</a></li><li><a href="#konig-定理">Konig  定理</a></li><li><a href="#二分图最大匹配">二分图最大匹配</a></li></ul></li><li><a href="#判断二分图">判断二分图</a></li><li><a href="#ternary-search">ternary search</a></li><li><a href="#大数组合combination">大数组合Combination</a></li><li><a href="#lucas卢卡斯定理">Lucas卢卡斯定理</a></li><li><a href="#st表-sparse-table之前有">ST表, (sparse table，之前有)</a></li><li><a href="#uf">UF</a></li><li><a href="#轮廓线dp">轮廓线DP</a></li><li><a href="#状态压缩dp">状态压缩DP</a></li><li><a href="#莱文斯坦距离">莱文斯坦距离</a></li><li><a href="#后缀自动机sam">后缀自动机SAM</a></li><li><a href="#基环树-环套树">基环树、环套树</a></li><li><a href="#哈密顿回路hamiltonian-cycle">哈密顿回路（Hamiltonian cycle）</a></li><li><a href="#de-brujin">De Brujin</a></li><li><a href="#牛顿迭代法">牛顿迭代法</a></li><li><a href="#01背包">01背包</a></li><li><a href="#z-function">z-function</a></li></ul></nav><p>Kadane，KMP，  Morris遍历</p>
<p><a data-from-md title='https://queue.acm.org/topics.cfm' href='https://queue.acm.org/topics.cfm'>https://queue.acm.org/topics.cfm</a></p>
<p>==================</p>
<h1 id="kadane">Kadane</h1>
<p>给与一个数组，求数组中最大连续  子数组的和。</p>
<p>暴力算法：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="Python" data-joplin-source-open="```Python&#10;" data-joplin-source-close="&#10;```">        for i in range(0,length):
            for j in range(i+1,length+1):
                sub = nums[i:j]
                sub_sum = sum(sub)
                if sub_sum&gt;MAX:
                    MAX = sub_sum
        return MAX</pre><pre class="hljs"><code>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,length):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,length+<span class="hljs-number">1</span>):
                sub = nums[i:j]
                sub_sum = <span class="hljs-built_in">sum</span>(sub)
                <span class="hljs-keyword">if</span> sub_sum&gt;MAX:
                    MAX = sub_sum
        <span class="hljs-keyword">return</span> MAX</code></pre></div>
<p>优化到O(n^2)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="Python" data-joplin-source-open="```Python&#10;" data-joplin-source-close="&#10;```">        for i in range(0,length):
            sum_sub = 0
            for j in range(i, length):
                sum_sub += nums[j]
                if sum_sub&gt;MAX:
                    MAX = sum_sub
        return MAX</pre><pre class="hljs"><code>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,length):
            sum_sub = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, length):
                sum_sub += nums[j]
                <span class="hljs-keyword">if</span> sum_sub&gt;MAX:
                    MAX = sum_sub
        <span class="hljs-keyword">return</span> MAX</code></pre></div>
<p>上面的代码中，我们是以  某个节点为开头的所有子序列：[a],[a,b],[a,b,c]，然后  [b],[b,c]。<br>
这样，在计算的时候，需要对所有子数组之和进行计算和比较。</p>
<p>改变对子数组的遍历方式，以  子序列的结束节点为基准，先遍历以某个结点为结束的所有子序列。[a,b],[b]   [a,b,c],[b,c],[c]  等。</p>
<p>这样，我们想获得  以c为结束点的子序列的信息时，可以利用之前的以b为结束点的子序列信息，  已有[a,b]的情况下，加上c就是[a,b,c]。  sum[i] = sum[i - 1] + arr[i]</p>
<p>新的遍历方式可以产生递推关系，使得  当前问题的解  可以在  先前问题的解的基础上  获得。</p>
<p>dp关键有3点，定义子问题，递推基(问题规模在最简单的情况下的解是什么)，递推关系(如何通过之前的子问题的解来获得当前解)</p>
<p>常见的定义子问题的方式有2种，定义目标问题为子问题，定义非目标问题为子问题，目标问题的解可以通过所保存的所有子问题的解来获得。</p>
<p>先尝试第一种方式来定义子问题，我们将问题抽象问array[0, n-1]的最大子数组之和  maxSubSum(n-1)，n代表数组长度。子问题就是求  array[0,i]的最大子数组之和  maxSubSum(i)，我们用数组dp来记录子问题的解。递推基为  dp[0] = arr[0].递推关系需要考虑maxSubSum(i-1)和maxSubSum(i)的关系。这样的递推关系很难获得。例如，数组[-2,1,-3,4,-1,2,1,-5,4]递推基为dp[0]=-2，而dp[1]=1, dp[2]=1, dp[3]=4, dp[3]和dp[2]之间的关系并不明确。</p>
<p>所以尝试使用第二种方式来定义子问题。我们<strong>将子问题定义为  求以i为终止下标的子数组之和的最大值</strong>，这样最终可以通过比较  以下标0为终止下标的子数组的最大值，为下标1为终止下标的子数组的最大值，以下标2为终止下标的子数组的最大值。。以下标n-1为终止下标的子数组的最大值。递推基为dp[0]=arr[0],递推关系：如果dp[i-1]&lt;0，arr[i]&gt;0,则dp[i]=arr[i]，如果dp[i-1]&lt;0,arr[i]&lt;0,则dp[i]=arr[i],如果dp[i-1]&gt;0，arr[i]&lt;0,dp[i]=dp[i-1]+arr[i],  如果dp[i-1]&gt;0,arr[i]&gt;0,则dp[i]=dp[i-1]+arr[i]。  最后，原始问题的解就是max(dp)</p>
<p>递推关系可以简化为：  dp[i]=max(dp[i-1],arr[i],arr[i])<br>
时间O(n),空间O(n)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="Python" data-joplin-source-open="```Python&#10;" data-joplin-source-close="&#10;```">    dp[0] = nums[0]
    for i in range(1, length):
        dp[i] = max(dp[i-1]+nums[i], nums[i])
    return max(dp)</pre><pre class="hljs"><code>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length):
        dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)</code></pre></div>
<p>kadane是在动态规划的基础上进一步优化，使用一根指针保存以i为结尾的子数组和的最大值，另一根指针保存迄今为止的子数组和的最大值。<br>
时间O(n),空间O(1)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="Python" data-joplin-source-open="```Python&#10;" data-joplin-source-close="&#10;```">    max_ending_here = max_sub_sum = nums[0]
    for i in range(1,length):
        max_ending_here = max(max_ending_here+nums[i],nums[i])
        max_sub_sum = max(max_ending_here, max_sub_sum)
    return max_sub_sum</pre><pre class="hljs"><code>    max_ending_here = max_sub_sum = nums[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,length):
        max_ending_here = <span class="hljs-built_in">max</span>(max_ending_here+nums[i],nums[i])
        max_sub_sum = <span class="hljs-built_in">max</span>(max_ending_here, max_sub_sum)
    <span class="hljs-keyword">return</span> max_sub_sum</code></pre></div>
<p>实际应用场景<br>
计算机视觉中，通过kadane算法来检测图像中最亮区域的最高分数子序列</p>
<p>有些其他的算法题可以转化为最大子数组之和的问题，用kadane算法求解。如LT121。</p>
<p>LT121来了：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">        int maxCur = 0, maxSoFar = 0;
        for(int i = 1; i &lt; prices.length; i++) {
            maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);
            maxSoFar = Math.max(maxCur, maxSoFar);
        }
        return maxSoFar;</pre><pre class="hljs"><code>        <span class="hljs-type">int</span> maxCur = <span class="hljs-number">0</span>, maxSoFar = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">length</span>; i++) {
            maxCur = Math.<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, maxCur += prices[i] - prices[i<span class="hljs-number">-1</span>]);
            maxSoFar = Math.<span class="hljs-built_in">max</span>(maxCur, maxSoFar);
        }
        <span class="hljs-keyword">return</span> maxSoFar;</code></pre></div>
<p><a data-from-md title='https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane&apos;s-Algorithm-Since-no-one-has-mentioned-about-this-so-far-%3A' href='https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane%27s-Algorithm-Since-no-one-has-mentioned-about-this-so-far-%3A'>https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane's-Algorithm-Since-no-one-has-mentioned-about-this-so-far-%3A</a>)-(In-case-if-interviewer-twists-the-input)</p>
<p>=================================</p>
<h1 id="kmp">KMP</h1>
<p>LPS which is Longest Prefix also Suffix</p>
<p><img src="../_resources/b39449ec44e0338d5748ee5c4dcb55e6.png" alt="1"></p>
<p><img src="../_resources/3cd6632c4d12748c2852f7a3e0d609b8.png" alt="1"></p>
<p>。。以当前char作为结尾的  所有  subStr  中  是  整个string  的  prefix的  且  长度最长的  那个  subStr  的长度  就是  LPS  的值。。并且suffix  还不能包含  当前char (第二个例子中i=1时，subStr可以是AA，但是LPS  是  1)。</p>
<p>。。以当前char  的前一个char  作为结尾的  所有  substr  中  是  string  的  前缀  的最长的长度  就是  LPS  的值。</p>
<p>。。就是  匹配到  当前的  char  不相等时，此时知道  前面的  substr  如果  是  string  的前缀，那么  就可以跳过  前缀的判断，直接  从  这个前缀  后面  开始。</p>
<p>。。下面的  形参  是  pattern  。</p>
<p>。。主要是  绿色的  j = lps[j-1]   。。  dp  了已有的结果，进入这个分支  代表  j-1  是匹配的，  [j]  不等于  [i]，  现在要  设置[i]  的值，  但是[i] != [j]，  但是  能肯定的是  [i-1]==[j-1]  (  如果j &gt; 0的话。)  ，  所以  有一个  j!=0  的判断。  。  所以dp  了一个  kmp算法。  尝试用  [j-1]  为  结尾的  所有  substr  中  是  string  的  前缀的  最长  的  substr  来  尝试  继续匹配。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    private int[] computeKMPTable(String pattern) {
        int i = 1, j = 0, n = pattern.length();
        int[] lps = new int[n];
        while (i &lt; n) {
            if (pattern.charAt(i) == pattern.charAt(j)) {
                lps[i++] = ++j;
            } else {

                if (j != 0) j = lps[j - 1]; // try match with longest prefix suffix

                else i++; // don't match -&gt; go to next character
            }
        }
        return lps;
    }</pre><pre class="hljs"><code>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> compute<span class="hljs-constructor">KMPTable(String <span class="hljs-params">pattern</span>)</span> {
        <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>, n = pattern.length<span class="hljs-literal">()</span>;
        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> lps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span>;
        <span class="hljs-keyword">while</span> (i &lt; n) {
            <span class="hljs-keyword">if</span> (pattern.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>pattern.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>) {
                lps<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span> = ++j;
            } <span class="hljs-keyword">else</span> {

                <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) j = lps<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>; <span class="hljs-comment">// try match with longest prefix suffix</span>

                <span class="hljs-keyword">else</span> i++; <span class="hljs-comment">// don&#x27;t match -&gt; go to next character</span>
            }
        }
        return lps;
    }</code></pre></div>
<p>。。上面是构造  LPS<br>
。。尾部(j)  操作。<br>
。。j代表  前面某个字符的  lps长度。</p>
<p>以上面的第二个LPS例子为例：<br>
i1 j0 :  if  成立，所以  lps[1] = 1<br>
i2 j1: if  不成立，  里面的if成立，  j=lps[0]=0<br>
i2 j0: if不成立，  里面的if不成立，  i++<br>
i3 j0: if  成立，lps[3] = 1<br>
i4 j1: if  成立，  lps[4] = 2<br>
l5 j2:  if成立，  lps[4] = 3<br>
i6 j3:  成立<br>
i7 j4:  成立<br>
i8 j5:  if不成立，内层if成立，  j =  lps[4]  = 2<br>
i8 j2:  成立。</p>
<p>if成立能理解。</p>
<p>j = lps[j - 1];</p>
<p>lps保存的是以  这个下标为结尾的substr集合  中  最长的  可以作为  整个string的  prefix的  那个substr的长度<br>
j是  上一个char的  最长lps长度。<br>
假设当前下标是  x，  并且此时  不满足  if。  x-1的时候是满足  if的。  并且  x-1的lps是  j<br>
说明  s[0, j-1]  等于  s[x-j, x-1] .<br>
现在不满足if。<br>
降级到lps[j-1]  。。。  不知道为什么要  lps[j-1]。。。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">
        int[] lps = computeKMPTable(needle);
        int i = 0, j = 0, n = haystack.length(), m = needle.length();
        while (i &lt; n) {
            if (haystack.charAt(i) == needle.charAt(j)) {
                ++i; ++j;
                if (j == m) return i - m; // found solution
            } else {

                if (j != 0) j = lps[j - 1]; // try match with longest prefix suffix

                else i++; // don't match -&gt; go to next character of `haystack` string

            }
        }
。上面是使用。真正的搜索  首次匹配。

        int[] lps = new int[n];
        for (int i = 1, j = 0; i &lt; n; i++) {
            while (j &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j))
              j = lps[j - 1];

            if (pattern.charAt(i) == pattern.charAt(j)) lps[i] = ++j;
        }
。另一种  创建  lps的方法。

        vector&lt;int&gt; lps(n, 0);
        for (int i = 1, len = 0; i &lt; n;) {
            if (needle[i] == needle[len]) {
                lps[i++] = ++len;
            } else if (len) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
。。另一种创建  lps
</pre><pre class="hljs"><code>
        int[] lps = computeKMPTable(needle);
        int i = 0, j = 0, n = haystack.length(), m = needle.length();
        while (i &lt; n) {
            if (haystack.charAt(i) == needle.charAt(j)) {
                ++i; ++j;
                if (j == m) return i - m; // found solution
            } else {

                if (j != 0) j = lps[j - 1]; // try match with longest prefix suffix

                else i++; // don't match -&gt; go to next character of `haystack` string

            }
        }
。上面是使用。真正的搜索  首次匹配。

        int[] lps = new int[n];
        for (int i = 1, j = 0; i &lt; n; i++) {
            while (j &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j))
              j = lps[j - 1];

            if (pattern.charAt(i) == pattern.charAt(j)) lps[i] = ++j;
        }
。另一种  创建  lps的方法。

        vector&lt;int&gt; lps(n, 0);
        for (int i = 1, len = 0; i &lt; n;) {
            if (needle[i] == needle[len]) {
                lps[i++] = ++len;
            } else if (len) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
。。另一种创建  lps
</code></pre></div>
<p>===============================</p>
<h1 id="sunday">Sunday</h1>
<p>字符串匹配- Sunday</p>
<p>KMP不常用，BM常用，Sunday在其基础上做了一些改动。</p>
<p>从前往后扫描模式串，思路更像是对  坏字符  策略的升华。关注的是主串中  参与匹配的最末字符(并非正在匹配的)的下一位。<br>
。。只有BM是从后往前，其他都是  从前往后。</p>
<p>Sunday只有一个启发策略<br>
当遇到不匹配的字符时，如果  关注的字符  没有在模式串中出现则直接跳过。即移动位数=子串长度+1</p>
<p><img src="../_resources/90d38d8321b186715f0ce542e21287ed.png" alt="1"></p>
<p>当遇到不匹配的字符时，如果  关注的字符  在模式串中也存在，则移动位数=模式串长度-该字符最右出现的位置(以0开始)  或  移动位数=模式串中该字符<mark>最右，即最后一次出现</mark>的位置到尾部的距离+1</p>
<p><img src="../_resources/557bff50ff4af99ca351e4c2f0df2c5c.png" alt="1"></p>
<p>缺点：<br>
主串:  baaaabaaaabaaaabaaaa<br>
模式串:  aaaaa<br>
此时时间复杂度  O(m*n)</p>
<p>。。。？上面的例子为什么是  m*n？  第一次比较就不相等，此时第二个b  在  模式串中并不存在，则会直接移动  5+1个位置啊。  估计  模式串应该是  baaaaa</p>
<p>Sunday算法的移动取决于子串，但这个子串重复很多的时候，就非常糟糕。</p>
<p>时间复杂度</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>KMP</td>
<td>O(m+n)</td>
</tr>
<tr>
<td>BM</td>
<td>O(m/n) - O(m*n)</td>
</tr>
<tr>
<td>Sunday</td>
<td>O(m/n) - O(m*n)</td>
</tr>
</tbody>
</table>
<h2 id="实际使用中sunday-比-bm略优">实际使用中，Sunday  比  BM略优。</h2>
<hr>
<p>LT0028</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">    int lta(string haystack, string needle)
    {
        int arr[123] = { 0 };
        int sz1 = haystack.size();
        int sz2 = needle.size();
        if (sz2 &gt; sz1)
            return -1;
        for (int i = 0; i &lt; sz2; ++i)
        {
            arr[needle[i]] = sz2 - i;   // 最后出现的位置 到 模式串的尾巴 + 1.
        }

        for (int i = 'a'; i &lt;= 'z'; ++i)
            if (arr[i] == 0)
                arr[i] = sz2 + 1;    // 没有出现 则等于 模式串.size + 1

        for (int i = 0; i &lt; sz1; )
        {
            for (int j = 0; j &lt; sz2; ++j)
            {
                if (haystack[i + j] != needle[j])
                    goto AAA;
            }
            return i;

            AAA:
            i += (i + sz2 &lt; sz1) ? arr[haystack[i + sz2]] : 1;          // 检查 i + sz2 这个 char

        }
        return -1;
    }</pre><pre class="hljs"><code>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lta</span><span class="hljs-params">(string haystack, string needle)</span>
    </span>{
        <span class="hljs-type">int</span> arr[<span class="hljs-number">123</span>] = { <span class="hljs-number">0</span> };
        <span class="hljs-type">int</span> sz1 = haystack.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> sz2 = needle.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span> (sz2 &gt; sz1)
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz2; ++i)
        {
            arr[needle[i]] = sz2 - i;   <span class="hljs-comment">// 最后出现的位置 到 模式串的尾巴 + 1.</span>
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++i)
            <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-number">0</span>)
                arr[i] = sz2 + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 没有出现 则等于 模式串.size + 1</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz1; )
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; sz2; ++j)
            {
                <span class="hljs-keyword">if</span> (haystack[i + j] != needle[j])
                    <span class="hljs-keyword">goto</span> AAA;
            }
            <span class="hljs-keyword">return</span> i;

            AAA:
            i += (i + sz2 &lt; sz1) ? arr[haystack[i + sz2]] : <span class="hljs-number">1</span>;          <span class="hljs-comment">// 检查 i + sz2 这个 char</span>

        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }</code></pre></div>
<p>===============================</p>
<h1 id="bm算法">BM算法</h1>
<p>// Boyer-Moore</p>
<p>与KMP从前往后扫描模式串不同，BM算法是从后往前对模式串进行扫描与主串进行匹配的。</p>
<p>核心是2个启发策略：<br>
1  坏字符算法<br>
当出现一个坏字符时，BM算法向右移动模式串，让模式串中最靠右的对应字符与坏字符相对，然后继续匹配。<br>
坏字符算法有2种情况：<br>
1  模式串中有对应的坏字符时，让模式串中最靠右的对应字符与坏字符相对，(BM不可能走回头路，因为走回头路，移动距离就是负数，肯定不是最大移动步数了)<br>
。。为什么不是最左的。感觉最右的话，前面的b或许还有机会。不，应该没有了。下次的坏字符就不是这个b了。。<br>
。。还有，如果是  xxaxxxbxxx这种，a不匹配的情况下，用b岂不是倒退了？可能是括号里的，不可能回头路吧，可能是必须大于等于1？<br>
。。不，BM算法  从后往前的。就是  模式串从后往前，整体还是从前往后。<br>
。。所以下面的  u  是成功匹配部分。</p>
<p><img src="../_resources/66ecaabaf77424500ae3790b06146fa6.png" alt="shift  contains no b"></p>
<p>2  模式串中不存在坏字符，那么直接右移整个模式串长度的步数<br>
。。看图，不是整个模式串长度，是  已匹配的长度。</p>
<p><img src="../_resources/f1abd23e6cf0134c83f3a1fcf7619c55.png" alt="shift  contains no b"></p>
<p>2  好后缀算法<br>
如果程序匹配了一个好后缀，并且在模式串中还有另外一个相同的后缀或后缀的部分，那把下一个后缀或部分移动到当前后缀位置。</p>
<p>即，模式串的后u个字符和主串已经匹配了，但是接下来的一个字符不匹配，如果说后u个字符在模式串其他位置也出现过或部分出现，我们将模式串右移到前面的u个字符或部分和最后u个字符或部分相同的位置，如果说后u个字符在模式串其他位置完全没有出现，那么就直接右移整个模式串。</p>
<p>1  模式串中有子串和好后缀完全匹配，则将最靠右的那个子串移动到好后缀的位置继续进行匹配。<br>
<img src="../_resources/befc572da451e12f5d28b36267db3be7.png" alt="shift"><br>
2  如果不存在和好后缀完全匹配的子串，则在好后缀中找具有如下特征的最长子串，使得P[m-s, m] = P[0, s]<br>
<img src="../_resources/0615d98ef2c268099cce887fb29270df.png" alt="shift"></p>
<p>3  如果完全不存在和好后缀匹配的子串，则右移整个模式串。</p>
<p>3  移动规则<br>
每次向右移动模式串的距离是  max(shift(好后缀),  shift(坏字符))</p>
<p>时间复杂度<br>
KMP: O(m+n)<br>
BM: O(m/n) - O(m*n)</p>
<p>。。好后缀，坏字符，这种要预先计算，不，应该是cache的懒计算。</p>
<p>BM算法，从后往前扫描模式串使得它更好地利用了&quot;后缀&quot;，BM算法的启发策略也使得模式串可以更加有效率的移动。</p>
<hr>
<p>经典的BM算法其实是对后缀蛮力匹配算法的改进。为了实现更快移动模式串，BM算法定义了两个规则，好后缀规则和坏字符规则</p>
<p><img src="../_resources/a369d9b157b0ab8bc19c16e362e9f21a.png" alt="1"></p>
<p>利用好后缀和坏字符可以大大加快模式串的移动距离，不是简单的++j，而是j+=max (shift(好后缀), shift(坏字符))</p>
<p>shift(坏字符)分为两种情况<br>
坏字符没出现在模式串中，这时可以把模式串移动到坏字符的下一个字符<br>
<img src="../_resources/68297afefd5a4cd95efd89fa96618119.png" alt="1"></p>
<p>坏字符出现在模式串中，这时可以把模式串第一个出现的坏字符和母串的坏字符对齐，当然，这样可能造成模式串倒退移动<br>
<img src="../_resources/6aefdb0e49eb1ef7bf8234aff25ac095.jpg" alt="1"></p>
<p>此处配的图是不准确的，因为显然加粗的那个b并不是”最  靠右的”b。而且也与下面给出的代码冲突！论文的意思是最右边的。</p>
<p>为了用代码来描述上述的两种情况，设计一个数组bmBc['k']，表示坏字符‘k’在模式串中出现的位置距离模式串末尾的最大长度，那么当遇到坏字符的时候，模式串可以移动距离为：  shift(坏字符) = bmBc[T[i]]-（m-1-i)。</p>
<p><img src="../_resources/ca5d029c6bfe1dd7a44131428eee9e9a.png" alt="1"></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">void preBmBc(char *x, int m, int bmBc[]) {
   int i;
   for (i = 0; i &lt; ASIZE; ++i)
      bmBc[i] = m;
   for (i = 0; i &lt;= m - 1; ++i)
      bmBc[x[i]] = m - i - 1;
}</pre><pre class="hljs"><code>void pre<span class="hljs-constructor">BmBc(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">m</span>, <span class="hljs-params">int</span> <span class="hljs-params">bmBc</span>[])</span> {
   <span class="hljs-built_in">int</span> i;
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ASIZE; ++i)
      bmBc<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = m;
   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= m - <span class="hljs-number">1</span>; ++i)
      bmBc<span class="hljs-literal">[<span class="hljs-identifier">x</span>[<span class="hljs-identifier">i</span>]</span>] = m - i - <span class="hljs-number">1</span>;
}</code></pre></div>
<p>ASIZE是指字符种类个数，为了方便起见，就直接把ASCII表中的256个字符全表示了，哈哈，这样就不会漏掉哪个字符了。</p>
<p>第一个for循环处理上述的第一种情况，这种情况比较容易理解就不多提了。第二个for循环，bmBc[x[i]]中x[i]表示模式串中的第i个字符。bmBc[x[i]] = m - i - 1;也就是计算x[i]这个字符到串尾部的距离。</p>
<p>为什么第二个for循环中，i从小到大的顺序计算呢？哈哈，技巧就在这儿了，原因在于就可以在同一字符多次出现的时候以最靠右的那个字符到尾部距离为最终的距离。当然了，如果没在模式串中出现的字符，其距离就是m了。</p>
<p>shift（好后缀）分为三种情况<br>
模式串中有子串匹配上好后缀，此时移动模式串，让该子串和好后缀对齐即可，如果超过一个子串匹配上好后缀，则选择最靠左边的子串对齐。<br>
<img src="../_resources/ed760b6d24252df6dc996c959f61747d.png" alt="1"></p>
<p>模式串中没有子串匹配上后后缀，此时需要寻找模式串的一个最长前缀，并让该前缀等于好后缀的后缀，寻找到该前缀后，让该前缀和好后缀对齐即可<br>
<img src="../_resources/6638ec755e8fe9d53428f6038d4c91eb.png" alt="1"></p>
<p>模式串中没有子串匹配上后后缀，并且在模式串中找不到最长前缀，让该前缀等于好后缀的后缀。此时，直接移动模式到好后缀的下一个字符<br>
<img src="../_resources/a2e93a8ed89ac1f9b553c8e209028a62.png" alt="1"></p>
<p>为了实现好后缀规则，需要定义一个数组suffix[]，其中suffix[i] = s  表示以i为边界，与模式串后缀匹配的最大长度，如下图所示，用公式可以描述：满足P[i-s, i] == P[m-s, m]的最大长度s。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void suffixes(char *x, int m, int *suff)
{
    suff[m-1]=m;
    for (i=m-2；i&gt;=0；--i){
        q=i;
        while(q&gt;=0&amp;&amp;x[q]==x[m-1-i+q])
            --q;
        suff[i]=i-q;
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">suffixes</span><span class="hljs-params">(<span class="hljs-type">char</span> *x, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> *suff)</span>
</span>{
    suff[m<span class="hljs-number">-1</span>]=m;
    <span class="hljs-keyword">for</span> (i=m<span class="hljs-number">-2</span>；i&gt;=<span class="hljs-number">0</span>；--i){
        q=i;
        <span class="hljs-keyword">while</span>(q&gt;=<span class="hljs-number">0</span>&amp;&amp;x[q]==x[m<span class="hljs-number">-1</span>-i+q])
            --q;
        suff[i]=i-q;
    }
}</code></pre></div>
<p>有了suffix数组，就可以定义bmGs[]数组，bmGs[i]  表示遇到好后缀时，模式串应该移动的距离，其中i表示好后缀前面一个字符的位置（也就是坏字符的位置），构建bmGs数组分为三种情况，分别对应上述的移动模式串的三种情况</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">void preBmGs(char *x, int m, int bmGs[]) {
   int i, j, suff[XSIZE];
   suffixes(x, m, suff);
   for (i = 0; i &lt; m; ++i)
      bmGs[i] = m;
   j = 0;
   for (i = m - 1; i &gt;= 0; --i)
      if (suff[i] == i + 1)
         for (; j &lt; m - 1 - i; ++j)
            if (bmGs[j] == m)
               bmGs[j] = m - 1 - i;
   for (i = 0; i &lt;= m - 2; ++i)
      bmGs[m - 1 - suff[i]] = m - 1 - i;
}</pre><pre class="hljs"><code>void preBmGs(char *x, int m, int <span class="hljs-keyword">bmGs[]) </span>{
   int i, <span class="hljs-keyword">j, </span>suff[XSIZE];
   suffixes(x, m, suff);
   for (i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; m; ++i)</span>
      <span class="hljs-keyword">bmGs[i] </span>= m;
   <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span>;
   for (i = m - <span class="hljs-number">1</span><span class="hljs-comment">; i &gt;= 0; --i)</span>
      if (suff[i] == i + <span class="hljs-number">1</span>)
         for (<span class="hljs-comment">; j &lt; m - 1 - i; ++j)</span>
            if (<span class="hljs-keyword">bmGs[j] </span>== m)
               <span class="hljs-keyword">bmGs[j] </span>= m - <span class="hljs-number">1</span> - i;
   for (i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt;= m - 2; ++i)</span>
      <span class="hljs-keyword">bmGs[m </span>- <span class="hljs-number">1</span> - suff[i]] = m - <span class="hljs-number">1</span> - i;
}</code></pre></div>
<p>BM算法</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">void BM(char *x, int m, char *y, int n) {
   int i, j, bmGs[XSIZE], bmBc[ASIZE];

   /* Preprocessing */
   preBmGs(x, m, bmGs);
   preBmBc(x, m, bmBc);

   /* Searching */
   j = 0;
   while (j &lt;= n - m) {
      for (i = m - 1; i &gt;= 0 &amp;&amp; x[i] == y[i + j]; --i);
      if (i &lt; 0) {
         OUTPUT(j);
         j += bmGs[0];
      }
      else
         j += MAX(bmGs[i], bmBc[y[i + j]] - m + 1 + i);
   }
}</pre><pre class="hljs"><code>void <span class="hljs-keyword">BM(char </span>*x, int m, char *y, int n) {
   int i, <span class="hljs-keyword">j, </span><span class="hljs-keyword">bmGs[XSIZE], </span><span class="hljs-keyword">bmBc[ASIZE];
</span>
   <span class="hljs-comment">/* Preprocessing */</span>
   preBmGs(x, m, <span class="hljs-keyword">bmGs);
</span>   preBmBc(x, m, <span class="hljs-keyword">bmBc);
</span>
   <span class="hljs-comment">/* Searching */</span>
   <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span>;
   while (<span class="hljs-keyword">j </span>&lt;= n - m) {
      for (i = m - <span class="hljs-number">1</span><span class="hljs-comment">; i &gt;= 0 &amp;&amp; x[i] == y[i + j]; --i);</span>
      if (i &lt; <span class="hljs-number">0</span>) {
         OUTPUT(<span class="hljs-keyword">j);
</span>         <span class="hljs-keyword">j </span>+= <span class="hljs-keyword">bmGs[0];
</span>      }
      else
         <span class="hljs-keyword">j </span>+= MAX(<span class="hljs-keyword">bmGs[i], </span><span class="hljs-keyword">bmBc[y[i </span>+ <span class="hljs-keyword">j]] </span>- m + <span class="hljs-number">1</span> + i);
   }
}</code></pre></div>
<hr>
<p><a data-from-md title='https://www.cnblogs.com/Philip-Tell-Truth/p/5185267.html' href='https://www.cnblogs.com/Philip-Tell-Truth/p/5185267.html'>https://www.cnblogs.com/Philip-Tell-Truth/p/5185267.html</a></p>
<p>BM算法</p>
<p>BM算法利用了  串  的后缀信息，用了  2个  类似  KMP的  Next数组的  表  来存储  模式串的信息，  一个是  坏字符表，一个是  好后缀表。</p>
<p>坏字符表有  2种情况</p>
<ol>
<li>目标串  中出现了  模式串中没有的  字符，此时  模式串  直接  整体  对齐到  这个字符的后方，继续比较。</li>
</ol>
<p>。。BM  是从后往前  对比的，  所以  出现了  一个  不匹配的  位置，  并且  target  在这个位置上  的  char  并没有  出现在  pattern  中，  那么  就  将  pattern  的  第一个char  放到  不匹配位置的   后一个char  上，  然后开始   对  pattern  从后往前  对比。</p>
<ol>
<li>目标串  中  出现了  不匹配的字符A，并且  不和  其他  子串  形成后缀  (  这种情况也可以理解为  好后缀表  的  len == 1  的  特殊情况)，  则把  模式串中的  最右的  A  和  目标串的  A  对齐。</li>
</ol>
<p>。。到底是  模式串最右，  还是  模式串当前不匹配位置  左侧的  最右？  应该是后者啊。<br>
。。主要是  形成后缀。。到底是什么？</p>
<p>。。根据代码来看，是前者，就是  模式串最右的出现。  当然  还有  好后缀的帮助，  不过  感觉  直接  设置  当前位置  左侧的  最右，  能跳过的  更多啊。  这种会导致  不正确吗？  。。  不会，而且  肯定能跳过更多，  因为  如果  模式串最右  出现在  当前不匹配的   右侧，那么会导致  pattern  回退，这肯定没有意义的，  所以  这种  应该  靠  好后缀  来  规避。   那么  就  只能  ，，，  不，想简单了，  想得是  构建  当前不匹配位置的  左侧的  最右，  只需要  遍历的时候  前缀  就可以了，  但是不是，  因为有  很多字符，所以  要在  当前不匹配  位置上  把  所有  target  中出现的  字符  就需要  计算出  在  左侧  的  最右。  不可能的，  特别是  中文  字符  太多了。  也不是，可以靠  map，  毕竟  出现在  左侧的  是可以靠  遍历一次的，  target中再多，  只要不出现在  pattern中，  就没有意义，都是跳过  整个pattern  长度。   如果target  中多，就。。。。不过  map  的  size  可以确保  &lt;= pattern  的size。  不过  需要  pattern.size()  个  map，  除非有一些能保存历史记录  的  map结构  (但即使有  也是应该是靠  时间换空间吧，而且意义不大，map  的话  本身就  不保存冗余数据的，  不像arr[][]，三角矩阵就浪费一半)。  但  无论如何，意义不大，  1  是  最坏情况size*size  的空间，  2是  map  终究不如  array  。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">typedef int Postion;
typedef char * _String;
void BuildBads(_String pattern, const int p_len, int *const BadS_List)
{
    fill(BadS_List, BadS_List + 256, p_len);
    for (int i = 0; i &lt; p_len; i++)
        BadS_List[pattern[i]] = p_len - 1 - i;
}</pre><pre class="hljs"><code><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Postion;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> * _String;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildBads</span><span class="hljs-params">(_String pattern, <span class="hljs-type">const</span> <span class="hljs-type">int</span> p_len, <span class="hljs-type">int</span> *<span class="hljs-type">const</span> BadS_List)</span>
</span>{
    <span class="hljs-built_in">fill</span>(BadS_List, BadS_List + <span class="hljs-number">256</span>, p_len);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; p_len; i++)
        BadS_List[pattern[i]] = p_len - <span class="hljs-number">1</span> - i;
}</code></pre></div>
<p>。。这个  和  之前的   preBmBc  。  都是  全部初始化为  pattern的  size。  然后  遍历  pattern，  而且  由于  是  从  0  到  size  的遍历，  所以  最后  数组中  保存的  是  最后一次出现  的  结果，  所以  是  最右侧的  出现。</p>
<p>好后缀表</p>
<ol>
<li>如果模式串中  存在  已经匹配成功的  好后缀，则把  目标串  和  好后缀  对齐，然后从  模式串的  尾部开始  往前匹配。</li>
<li>如果无法找到  匹配好的后缀，那么  我们就找一个  匹配的  最长的  前缀，让  目标串  与  最长的前缀对齐  (如果这个前缀存在的话)</li>
<li>如果无法找到前缀，并且  也没有好后缀，则直接移动  模式串的size  的长度。</li>
</ol>
<p>构建  好后缀的  思路，有2种<br>
第一个是  O(n^3)  的方法</p>
<ol>
<li>
<p>先定义一个  pre[i]  数组，含义和  KMP的  最长公共长度表  差不多，不同在于：pre[i]  存储  的是从  pattern[k, k+sz-1-i]  等于  pattern[i,sz-1]  的  且  pattern[k]!=pattern[i]   的最大的  k  值  (相当于  后缀的匹配)  ，在构建pre  表的时候  我们顺便  把  最大的  前缀长度  记录起来，  我们可以把  pre  全部初始化为  sz，然后一个个  枚举就可以了，然后我们构建good_list，根据  good_list  的性质，我们可以得到：</p>
<ol>
<li>
<p>如果  pre[i] != sz，则说明是  第一种情况，我们直接把  目标串  前移  sz-1-pre[i]  个单位</p>
</li>
<li>
<p>如果  pre[i] = sz，这里分为2种情况：</p>
<ol>
<li>
<p>如果前缀存在，则我们把  目标串  与  前缀对齐  (但前提是  匹配的个数  已经比前缀的长度  大)，则移动  sz-1-i-c个单位  (c就是前缀长度)；</p>
</li>
<li>
<p>如果不存在前缀，或匹配的长度  不够前缀的长度，就直接移动  sz-1-i  就可以了。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>于是就有了下面这个很难懂的代码，注意这里把  pre[i]  和  good_list  写一起了，因为  pre  只用一次。<br>
时间复杂度O(n^3) (2个for  加一个  memcpy)<br>
注意  这个算法  Good_List  最后一位  固定是1</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">void BuildGoods_Slow(_String pattern, const int p_len, int *const Goods_List)
{
    //以O(n^3)的时间构建好后缀表
    int max_suffix_length = 0;

    fill(Goods_List, Goods_List + p_len, p_len);
    Goods_List[p_len - 1] = 1;//最后一位固定是1

    for (Postion i = p_len - 1; i &gt; 0; i--)
    {
        if (Inffix_Suffix_Compare(pattern, pattern + i, p_len - i))
            max_suffix_length = p_len - i;//记录最长的后缀
        for (Postion j = 1; j &lt; i; j++)
        {
            if (Inffix_Suffix_Compare(pattern + j, pattern + i, p_len - i)
                &amp;&amp; pattern[i - 1] != pattern[j - 1])//一定要是不等于的时候才记录，最长后缀的最大k值
                Goods_List[i - 1] = j - 1;
        }
    }

    for (Postion i = 0; i &lt; p_len; i++)
    {
        if (Goods_List[i] != p_len)
            Goods_List[i] = p_len - (Goods_List[i] + 1);//下标是从0开始的,而且要对齐后缀
        else//Goods_List[i]==p_len
        {
            Goods_List[i] += p_len - (1 + i);//下标是从0开始的
            if (max_suffix_length != 0 &amp;&amp; p_len - 1 - i &gt;= max_suffix_length)
                Goods_List[i] -= max_suffix_length;
        }
    }
}

bool Inffix_Suffix_Compare(_String sx, _String sy, const int len)
{
    for (int i = 0; i &lt; len; i++)
        if (sx[i] != sy[i])
            return false;
    return true;
}</pre><pre class="hljs"><code>void BuildGoods_Slow(_String pattern, const int p_len, int *const Goods_List)
{
    //以O(n^3)的时间构建好后缀表
    int max_suffix_length = 0;

    fill(Goods_List, Goods_List + p_len, p_len);
    Goods_List[p_len - 1] = 1;//最后一位固定是1

    for (Postion i = p_len - 1; i &gt; 0; i--)
    {
        if (Inffix_Suffix_Compare(pattern, pattern + i, p_len - i))
            max_suffix_length = p_len - i;//记录最长的后缀
        for (Postion j = 1; j &lt; i; j++)
        {
            if (Inffix_Suffix_Compare(pattern + j, pattern + i, p_len - i)
                &amp;&amp; pattern[i - 1] != pattern[j - 1])//一定要是不等于的时候才记录，最长后缀的最大k值
                Goods_List[i - 1] = j - 1;
        }
    }

    for (Postion i = 0; i &lt; p_len; i++)
    {
        if (Goods_List[i] != p_len)
            Goods_List[i] = p_len - (Goods_List[i] + 1);//下标是从0开始的,而且要对齐后缀
        else//Goods_List[i]==p_len
        {
            Goods_List[i] += p_len - (1 + i);//下标是从0开始的
            if (max_suffix_length != 0 &amp;&amp; p_len - 1 - i &gt;= max_suffix_length)
                Goods_List[i] -= max_suffix_length;
        }
    }
}

bool Inffix_Suffix_Compare(_String sx, _String sy, const int len)
{
    for (int i = 0; i &lt; len; i++)
        if (sx[i] != sy[i])
            return false;
    return true;
}</code></pre></div>
<p>第二个是很巧妙的算法，算法时间复杂度O(n^2)</p>
<ol>
<li>我们首先定义一个  suff  数组，这个数组和  pre的定义是一样的，但是说法可能不太一样，suff[i]  表示  以  i  为边界，与  模式串  后缀匹配  的最大长度。</li>
</ol>
<p>有了suff数组，我们直接定义  Good_List  数组，实现方式  与第一种算法的类似：</p>
<ol>
<li>模式串中  有  子串匹配上  好后缀</li>
<li>模式串中没有  子串匹配上  好后缀，但找到一个  最大前缀</li>
<li>模式串没有  子串匹配上好后缀，但找不到  一个最大前缀</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void BuildGoods_Fast(_String pattern, const int p_len, int *const Goods_List)
{
    int *suff = new int[p_len];
    //构建suff表..........................
    suff[p_len - 1] = p_len;
    for (Postion i = p_len - 2; i &gt;= 0; i--)
    {
        Postion k = i;
        while (k &gt;= 0 &amp;&amp; pattern[k] == pattern[p_len - 1 - (i - k)])
            k--;
        suff[i] = i - k;//设定最长后缀的位置
    }</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildGoods_Fast</span><span class="hljs-params">(_String pattern, <span class="hljs-type">const</span> <span class="hljs-type">int</span> p_len, <span class="hljs-type">int</span> *<span class="hljs-type">const</span> Goods_List)</span>
</span>{
    <span class="hljs-type">int</span> *suff = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[p_len];
    <span class="hljs-comment">//构建suff表..........................</span>
    suff[p_len - <span class="hljs-number">1</span>] = p_len;
    <span class="hljs-keyword">for</span> (Postion i = p_len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
        Postion k = i;
        <span class="hljs-keyword">while</span> (k &gt;= <span class="hljs-number">0</span> &amp;&amp; pattern[k] == pattern[p_len - <span class="hljs-number">1</span> - (i - k)])
            k--;
        suff[i] = i - k;<span class="hljs-comment">//设定最长后缀的位置</span>
    }</code></pre></div>
<p>。。。p_len - 1 - (i - k)  自己代入下，  第一次的时候  k=i，就是  最后一个元素，  后来  每次  k--，所以  每次  前移  一位，  所以  这个while  是  从后往前  找  最大  后缀。一边是  从  最后一个元素，  一边是从  i  开始，  都是往前走。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">    //..........................................
    fill(Goods_List, Goods_List + p_len, p_len);
    for (Postion i = p_len - 1, j = 0; i &gt;= 0; i--)
        if (suff[i] == i + 1)
            for (; j &lt; p_len - (i + 1); j++)
                if (Goods_List[j] == p_len)
                    Goods_List[j] = p_len - (j + 1);
    //以上代码是符合Good_List的第三和第二规则，复杂度是O(n^2)
    //不用排最后一个了，因为最后一个肯定是直接移动p_len的
    for (Postion i = 0; i &lt; p_len - 1; i++)
        Goods_List[p_len - 1 - suff[i]] = p_len - (1 + i);
        //Goods_List的值一直更新最小的，移动更小的位置达到更好的匹配效果
    delete suff;
}</pre><pre class="hljs"><code>    <span class="hljs-comment">//..........................................</span>
    <span class="hljs-built_in">fill</span>(Goods_List, Goods_List + p_len, p_len);
    <span class="hljs-keyword">for</span> (Postion i = p_len - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; i--)
        <span class="hljs-keyword">if</span> (suff[i] == i + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">for</span> (; j &lt; p_len - (i + <span class="hljs-number">1</span>); j++)
                <span class="hljs-keyword">if</span> (Goods_List[j] == p_len)
                    Goods_List[j] = p_len - (j + <span class="hljs-number">1</span>);
    <span class="hljs-comment">//以上代码是符合Good_List的第三和第二规则，复杂度是O(n^2)</span>
    <span class="hljs-comment">//不用排最后一个了，因为最后一个肯定是直接移动p_len的</span>
    <span class="hljs-keyword">for</span> (Postion i = <span class="hljs-number">0</span>; i &lt; p_len - <span class="hljs-number">1</span>; i++)
        Goods_List[p_len - <span class="hljs-number">1</span> - suff[i]] = p_len - (<span class="hljs-number">1</span> + i);
        <span class="hljs-comment">//Goods_List的值一直更新最小的，移动更小的位置达到更好的匹配效果</span>
    <span class="hljs-keyword">delete</span> suff;
}</code></pre></div>
<p>首先我们来  研究怎么创建  怎么构建  suff  数组，根据  suff  数组的定义，其实根据定义  我们就知道，我们只用  从后往前  枚举  pattern[i-k+1, i] == pattern[sz-1-k+1, sz-1]，从而  suff[i] == k (也就是  得到了  i  位置的  最长后缀长度)，  这里的  时间复杂度是  O(n^2)，  这就是  代码  5-12  行所做的事情。</p>
<p>接下来  我们要设定  good_list，  我们知道，如果我们要保证不漏掉  任何一个匹配的  可能，那么  首先  目标串  的  移动  要尽可能地少(其实  坏字符表  的  构建  也是一样的)，  我们每次  的操作  都要保证  移动  good_list  的值  一定要  是  所有的  可能  最小的。而  我们再来看  好后缀表  移动的距离，我们发现  移动的距离  是  情况1 &lt;=  情况2 &lt;=  情况3，而情况3  相当于  k=0  的特殊情况，所以  现在  我们先来  设定  情况2  和  情况3。</p>
<p>代码  14  行，也就是  fill  那一段，就是对  情况3  的实现，一旦情况3  发生，我们直接  让  目标串  移动  sz  的距离  重新匹配。  时间复杂度  O(n)。</p>
<p>代码  15-19  行，这是一段  时间复杂度  O(n)  的代码  (虽然有  2个  for，但是  good_list  的每个位置  最多  只会  改变一次)，而  suff[i] == i+1  也就证明  pattern[0, i]==pattern[sz-1-i, sz-1]，也就是情况2的  前缀情况，所以我们直接  让这个  移动  sz-1-j  个位置  对其前缀。</p>
<p>最后代码  20-23，也就是对  情况1  的实现  而  suff[i]  对于不同的  i  有可能是一样的，但是我们想让  good_list  最小，所以  我们就把  i   从小往大枚举，最后的  good_list  就是最小的。这里的时间复杂度是  O(n)。</p>
<p>最后我们来实现BM的主算法，其实BM主算法和KMP的主算法的思想是差不多的，只是BM算法利用了坏字符表和好后缀表进行跳转。当某个字符匹配成功的时候，我们把目标串和模式串都往前移动一个位置继续匹配（因为匹配是从后往前匹配的），如果匹配失败，我们就把目标串失配的那个位置向后移动这个失配字符的在坏字符表和好后缀表中的最大的那个值。（为什么这里又不是最小了呢？因为我们坏字符表和好后缀表的位置都是已经保证了移动正确性为前提的了，现在我们想要算法更加的高效，那么目标串的移动肯定要尽量大一点的了。）</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">bool BmSearch(_String target, _String pattern)
{
    int t_len = strlen(target), p_len = strlen(pattern);
    int *BadS_List = new int[256];
    int *Goods_List = new int[p_len];

    BuildBads(pattern, p_len, BadS_List);
    //BuildGoods_Slow(pattern, p_len, Goods_List);
    BuildGoods_Fast(pattern, p_len, Goods_List);

    Postion i = p_len - 1, j = p_len - 1;

    while (j &lt; p_len)
    {
        while(j &gt; 0 &amp;&amp; target[i] == pattern[j])
        {
            i--;
            j--;
        }
        if (j == 0 &amp;&amp; target[i] == pattern[j])
        {
            delete BadS_List, Goods_List;;//找到一个就可以了
            return true;
        }

        i += Goods_List[j] &gt; BadS_List[target[i]] ? Goods_List[j] : BadS_List[target[i]];

        j = p_len - 1;
    }
    delete BadS_List, Goods_List;
    return false;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BmSearch</span><span class="hljs-params">(_String target, _String pattern)</span>
</span>{
    <span class="hljs-type">int</span> t_len = <span class="hljs-built_in">strlen</span>(target), p_len = <span class="hljs-built_in">strlen</span>(pattern);
    <span class="hljs-type">int</span> *BadS_List = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">256</span>];
    <span class="hljs-type">int</span> *Goods_List = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[p_len];

    <span class="hljs-built_in">BuildBads</span>(pattern, p_len, BadS_List);
    <span class="hljs-comment">//BuildGoods_Slow(pattern, p_len, Goods_List);</span>
    <span class="hljs-built_in">BuildGoods_Fast</span>(pattern, p_len, Goods_List);

    Postion i = p_len - <span class="hljs-number">1</span>, j = p_len - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (j &lt; p_len)
    {
        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; target[i] == pattern[j])
        {
            i--;
            j--;
        }
        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; target[i] == pattern[j])
        {
            <span class="hljs-keyword">delete</span> BadS_List, Goods_List;;<span class="hljs-comment">//找到一个就可以了</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        i += Goods_List[j] &gt; BadS_List[target[i]] ? Goods_List[j] : BadS_List[target[i]];

        j = p_len - <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">delete</span> BadS_List, Goods_List;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</code></pre></div>
<p>===============================</p>
<h1 id="morris-traversal">Morris Traversal</h1>
<p>时间O(n)，空间O(1)</p>
<p>利用树的  叶节点  的  左右子节点  为空  来压缩空间。</p>
<p>如果cur无左孩子，cur向右移动（cur=cur.right）<br>
如果cur有左孩子，找到cur左子树上最右的节点，记为mostright<br>
如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）<br>
如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</p>
<p>可以实现  pre/in/post order  遍历。<br>
后序遍历比较复杂  。。。都很复杂，后序特别复杂。。</p>
<p>。。感觉就是  把  下一个该访问的  节点  放到  前一个节点的  子节点上。<br>
。。后序遍历  最后一个  是  父节点，左右子节点都是非空的，  所以  特比复杂。<br>
。。先序  中序，  先序最后一个是  右叶子节点，  它的子节点是空的。   中序最后一个是  。。还是  右叶子节点。。</p>
<p>===============================</p>
<p>=================================</p>
<h1 id="rabin-karp-rolling-hash-pattern-match">Rabin-Karp / Rolling hash (pattern match)</h1>
<p>2个人的名字。</p>
<p>LT3036<br>
votru的，有人也问了，为什么只比较了hash，没有进一步的校验是否完全相同，但没有人回答。<br>
而且，也有人说，加上 是否完全相同的校验后，被最后一个 test case 失败了(估计TLE了)。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">int rabin_karp(const vector&lt;int&gt; &amp;s, const vector&lt;int&gt; &amp;t) {
    const int p = 31, m = 1e9 + 9, sz = t.size();
    long long p_pow = 1, h_t = 0, h_s = 0;
    for (int i = 0; i &lt; sz; ++i) {
        h_t = (h_t * p + (t[i] + 1)) % m;
        p_pow = (p_pow * p) % m;            // 。。用于移除第一个元素。
    }
    int res = 0;
    for (int i = 0; i &lt; s.size(); ++i) {
        h_s = (h_s * p + (s[i] + 1)) % m;
        if (i &gt;= sz)
            h_s = (m + h_s - p_pow * (s[i - sz] + 1) % m) % m;
        if (i + 1 &gt;= sz &amp;&amp; h_t == h_s)
            ++res;
    }
    return res;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rabin_karp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;s, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;t)</span> </span>{
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> p = <span class="hljs-number">31</span>, m = <span class="hljs-number">1e9</span> + <span class="hljs-number">9</span>, sz = t.<span class="hljs-built_in">size</span>();
    <span class="hljs-type">long</span> <span class="hljs-type">long</span> p_pow = <span class="hljs-number">1</span>, <span class="hljs-type">h_t</span> = <span class="hljs-number">0</span>, h_s = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; ++i) {
        <span class="hljs-type">h_t</span> = (<span class="hljs-type">h_t</span> * p + (t[i] + <span class="hljs-number">1</span>)) % m;
        p_pow = (p_pow * p) % m;            <span class="hljs-comment">// 。。用于移除第一个元素。</span>
    }
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) {
        h_s = (h_s * p + (s[i] + <span class="hljs-number">1</span>)) % m;
        <span class="hljs-keyword">if</span> (i &gt;= sz)
            h_s = (m + h_s - p_pow * (s[i - sz] + <span class="hljs-number">1</span>) % m) % m;
        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= sz &amp;&amp; <span class="hljs-type">h_t</span> == h_s)
            ++res;
    }
    <span class="hljs-keyword">return</span> res;
}</code></pre></div>
<hr>
<p><a data-from-md title='https://blog.csdn.net/m0_72410588/article/details/131218148' href='https://blog.csdn.net/m0_72410588/article/details/131218148'>https://blog.csdn.net/m0_72410588/article/details/131218148</a></p>
<p>O(n+m)</p>
<p>滑动窗口，从主串的起始位置开始，逐个字符地向右。<br>
对于每个子串，计算hash值，并与模式串的hash值对比。<br>
hash值相同，进一步检查是否完全相同。<br>
hash值不同，向右滑动一个字符</p>
<p>===============================</p>
<h1 id="fisher-yates-algorithm-and-knuth-shuffle">Fisher-Yates Algorithm and Knuth Shuffle</h1>
<p>===============================</p>
<h1 id="flood-fill">flood fill</h1>
<p>===============================</p>
<h1 id="sweep-line">sweep line</h1>
<p>===============================</p>
<h1 id="manacher-最长回文-on">Manacher  最长回文  O(n)</h1>
<p>在进行Manacher算法时，字符串都会进行一个字符处理，比如输入的字符为acbbcbds，用“#”字符处理之后的新字符串就是#a#c#b#b#c#b#d#s#。</p>
<p>回文半径和回文直径：因为处理后回文字符串的长度一定是奇数，所以回文半径是包括回文中心在内的回文子串的一半的长度，回文直径则是回文半径的2倍减1。比如对于字符串 &quot;aba&quot;，在字符 'b' 处的回文半径就是2，回文直径就是3。</p>
<p>最右回文边界R：在遍历字符串时，每个字符遍历出的最长回文子串都会有个右边界，而R则是所有已知右边界中最靠右的位置，也就是说R的值是只增不减的。</p>
<p>回文中心C：取得当前R的第一次更新时的回文中心。由此可见R和C时伴生的。</p>
<p>半径数组：这个数组记录了原字符串中每一个字符对应的最长回文半径。</p>
<hr>
<p>悟了一半：<br>
用arr[]保存  以  下标为中心的  最大  回文<br>
就是  如果本次要检查的  下标A  在  之前的最大回文B里，那么  就按照B的中心对称到  B的左半部分，dp下。<br>
如果  下标A  在最大回文B外，  那么  硬算。<br>
如果  下标A在  B内，但是还可以超过B，复用B内的，然后B外的硬算。<br>
。。但是如果最大回文  只是  3个字符，  那么  A不好弄啊。就是  最大回文B，为什么是哪样的</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">//开始从左到右遍历
for (int i = 0; i &lt; len; i++) {
    //第一步直接取得可能的最短的回文半径，当i&gt;R时，最短的回文半径是1，反之，最短的回文半径可能是i对应的i'的回文半径或者i到R的距离
    pArr[i] = R &gt; i ? min(R - i, pArr[2 * C - i]) : 1;
    //取最小值后开始从边界暴力匹配，匹配失败就直接退出
    while (i + pArr[i]&lt;len &amp;&amp; i - pArr[i]&gt;-1) {
        if (chaArr[i + pArr[i]] == chaArr[i - pArr[i]]) {
            pArr[i]++;
        } else {
            break;
        }
    }
    //观察此时R和C是否能够更新
    if (i + pArr[i] &gt; R) {
        R = i + pArr[i];
        C = i;
    }
    //更新最大回文半径的值
    maxn = max(maxn, pArr[i]);
}</pre><pre class="hljs"><code><span class="hljs-comment">//开始从左到右遍历</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
    <span class="hljs-comment">//第一步直接取得可能的最短的回文半径，当i&gt;R时，最短的回文半径是1，反之，最短的回文半径可能是i对应的i&#x27;的回文半径或者i到R的距离</span>
    pArr[i] = R &gt; i ? <span class="hljs-built_in">min</span>(R - i, pArr[<span class="hljs-number">2</span> * C - i]) : <span class="hljs-number">1</span>;
    <span class="hljs-comment">//取最小值后开始从边界暴力匹配，匹配失败就直接退出</span>
    <span class="hljs-keyword">while</span> (i + pArr[i]&lt;len &amp;&amp; i - pArr[i]&gt;<span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">if</span> (chaArr[i + pArr[i]] == chaArr[i - pArr[i]]) {
            pArr[i]++;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-comment">//观察此时R和C是否能够更新</span>
    <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) {
        R = i + pArr[i];
        C = i;
    }
    <span class="hljs-comment">//更新最大回文半径的值</span>
    maxn = <span class="hljs-built_in">max</span>(maxn, pArr[i]);
}</code></pre></div>
<p>。。。复制的</p>
<hr>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">if i &gt;= R: # Case 1
    d[i] = 0
    从d[i]逐步继续扩展，求d[i]
else:
    if d[i'] &lt; R - i: # Case 2
        d[i] = d[i']
    else if d[i'] = R - i: # Case 3
        d[i] = d[i']
        从d[i]逐步继续扩展，求d[i]
    else: # Case 4
        d[i] = R - i</pre><pre class="hljs"><code>if i &gt;= R: # Case 1
    d<span class="hljs-comment">[i]</span> = 0
    从d<span class="hljs-comment">[i]</span>逐步继续扩展，求d<span class="hljs-comment">[i]</span>
else:
    if d<span class="hljs-comment">[i&#x27;]</span> &lt; R - i: # Case 2
        d<span class="hljs-comment">[i]</span> = d<span class="hljs-comment">[i&#x27;]</span>
    else if d<span class="hljs-comment">[i&#x27;]</span> = R - i: # Case 3
        d<span class="hljs-comment">[i]</span> = d<span class="hljs-comment">[i&#x27;]</span>
        从d<span class="hljs-comment">[i]</span>逐步继续扩展，求d<span class="hljs-comment">[i]</span>
    else: # Case 4
        d<span class="hljs-comment">[i]</span> = R - i</code></pre></div>
<hr>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    for i in range(len(s)):
        if i&lt;MaxRight:
            RL[i]=min(RL[2*pos-i], MaxRight-i)
        else:
            RL[i]=1
        #尝试扩展，注意处理边界
        while i-RL[i]&gt;=0 and i+RL[i]&lt;len(s) and s[i-RL[i]]==s[i+RL[i]]:
            RL[i]+=1
        #更新MaxRight,pos
        if RL[i]+i-1&gt;MaxRight:
            MaxRight=RL[i]+i-1
            pos=i
        #更新最长回文串的长度
        MaxLen=max(MaxLen, RL[i])
    return MaxLen-1</pre><pre class="hljs"><code>    <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):
        <span class="hljs-keyword">if</span> i&lt;MaxRight:
            RL<span class="hljs-selector-attr">[i]</span>=<span class="hljs-built_in">min</span>(RL<span class="hljs-selector-attr">[2*pos-i]</span>, MaxRight-i)
        <span class="hljs-keyword">else</span>:
            RL<span class="hljs-selector-attr">[i]</span>=<span class="hljs-number">1</span>
        #尝试扩展，注意处理边界
        while i-RL<span class="hljs-selector-attr">[i]</span>&gt;=<span class="hljs-number">0</span> and i+RL<span class="hljs-selector-attr">[i]</span>&lt;<span class="hljs-built_in">len</span>(s) and s<span class="hljs-selector-attr">[i-RL[i]</span>]==s<span class="hljs-selector-attr">[i+RL[i]</span>]:
            RL<span class="hljs-selector-attr">[i]</span>+=<span class="hljs-number">1</span>
        #更新MaxRight,pos
        <span class="hljs-keyword">if</span> RL<span class="hljs-selector-attr">[i]</span>+i-<span class="hljs-number">1</span>&gt;MaxRight:
            MaxRight=RL<span class="hljs-selector-attr">[i]</span>+i-<span class="hljs-number">1</span>
            pos=<span class="hljs-selector-tag">i</span>
        #更新最长回文串的长度
        MaxLen=<span class="hljs-built_in">max</span>(MaxLen, RL<span class="hljs-selector-attr">[i]</span>)
    return MaxLen-<span class="hljs-number">1</span></code></pre></div>
<hr>
<p><a data-from-md title='https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/' href='https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/'>https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/</a></p>
<hr>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">s[0] = '$'; s[++m] = '#';
for (b = 1; ss[b] != '\0'; ++b) {
    s[++m] = ss[b];
    s[++m] = '#';
}
s[++m] = '?';
for (int i = 1; i &lt; m; ++i) {
    if (maxid &gt; i) p[i] = min(maxid-i, p[2*id-i]);
    else p[i] = 1;
    while (s[i-p[i]] == s[i+p[i]]) p[i]++;
    if (i + p[i] &gt; maxid) {
        maxid = i + p[i];
        id = i;
    }
}</pre><pre class="hljs"><code>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;$&#x27;</span>; s[++m] = <span class="hljs-string">&#x27;#&#x27;</span>;
for (b = <span class="hljs-number">1</span>; ss[b] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++b) {
    s[++m] = ss[b];
    s[++m] = <span class="hljs-string">&#x27;#&#x27;</span>;
}
s[++m] = <span class="hljs-string">&#x27;?&#x27;</span>;
for (int i = <span class="hljs-number">1</span>; i &lt; m; ++i) {
    if (maxid &gt; i) p[i] = min(maxid-i, p[<span class="hljs-number">2</span>*id-i]);
    else p[i] = <span class="hljs-number">1</span>;
    while (s[i-p[i]] == s[i+p[i]]) p[i]++;
    if (i + p[i] &gt; maxid) {
        maxid = i + p[i];
        id = i;
    }
}</code></pre></div>
<p>。。。<br>
最远可达子串的右侧是  maxid。  这个子串的  中心是  id  。  这个id  必然是  遍历过的  i，所以  必然  小于  当前遍历的  i。</p>
<p>如果  maxid  大于  当前遍历的  i。  那么  可以  按照  id  进行  (轴)对称，可以  确定  i  关于id  的对称点  i2，然后  复用  i2的  最大回文长度，  因为  id  是回文，  所以  i  和  i2  附近的  substr  是  倒序相同的。。  i  对于  id  的  对称点  是  id-(i-id) = 2<em>id-i，  所以p[2</em>id-1]  是一个选项。</p>
<p>另外一个选项是  maxid-i，  这个是为了防止  i2  很长，假设  maxid-1  是i2  的最后一个字符，那么此时  p[i2] == p[2<em>id-i] ==  maxid-1-i2 = maxid-1-2</em>id+i</p>
<p>那么  i  的回文的最右侧就是，i + maxid - 1 - 2 * id + i  ，由于  i大于id，  这个长度  是大于  maxid的，  而  大于maxid  的  字符  还没有被  使用过，  所以  无法确保  是  回文的一部分。   所以  需要  限制  最大为  maxid - i</p>
<p>。。。</p>
<p>===================================</p>
<p>// LT1334<br>
//Floyd: 14ms<br>
//Dijkstra: 32ms<br>
//SPFA: 64ms<br>
//Bellman: 251ms</p>
<p>// Prim, Kruskal</p>
<p>===================================</p>
<h1 id="moore-voting-algorithm">Moore Voting Algorithm</h1>
<p>===================================</p>
<p>===================================</p>
<h1 id="欧拉图">欧拉图</h1>
<p>具有欧拉回路的图  被称为欧拉图</p>
<p>具有欧拉路径  但不具有  欧拉回路的图  被称为  半欧拉图</p>
<p>半欧拉图  充要条件：  连通图，且仅有2个  奇度点。</p>
<hr>
<h1 id="欧拉回路">欧拉回路</h1>
<p>通过图(无向或有向图)  中所有边  且  每条边仅通过一次的通路，相应的回路被  称为欧拉回路。</p>
<hr>
<p>如果图G  中一个路径  包括每个边  恰好一次，则该路径被称为  欧拉路径  Euler path<br>
如果一个  回路  是欧拉路径，则称为欧拉回路  Euler circuit<br>
。。回路就是  起点==终点的路径</p>
<hr>
<p>无向图存在欧拉回路的充要条件<br>
一个无向图存在欧拉回路，当且仅当该图  所有  顶点度数  都为偶数，且该图是连通图。</p>
<p>有向图存在欧拉回路的充要条件<br>
所有顶点的  入度等于出度，且是连通图。</p>
<hr>
<p>求欧拉回路的思路</p>
<p>循环的找到出发点。  从某个节点开始，然后查出一个  从这个节点出发  最后回到这个节点的环。如果环中  某个节点  还有边  没有被遍历，则以这个节点为起点，未遍历的边为方向，  找  从这个节点出发  最终回到这个节点的  环。直到所有边都被遍历。</p>
<p>。。首先，不能有  不成环的边，这种边  是无法  构成回路的，最多只能构成  欧拉路径。</p>
<p>。。就是先找一个环，然后  环上  存在  某些点，它们有边没有被遍历，  那么  选一个，  然后  以这个  点为开始，再找环，而且要边的vst(或者st*100000+en)，不然可能和  找到的第一个环  有部分重叠，那么就  不是欧拉路径了。</p>
<p>。。就是找到一个环，中间有节点  还存在没有被遍历的边，那么就  走一个半环  走到那个节点，然后  走那个节点的环，  然后  再走剩下的  半环。<br>
。。就是下面的算法。<br>
。。<br>
。。欧拉回路  所有的边  必然在环中，所以  如果  找不到环，那就可以直接退出了。<br>
。。还要判断下是否  全部边都被遍历了。  可能是一个  非连通图。</p>
<p>===================================</p>
<h1 id="hierholzers-algorithm">Hierholzer's algorithm</h1>
<p>希尔霍尔策算法是数学家卡尔·希尔霍尔策在1873年提出的一种寻找欧拉回路的算法 。比起另一种著名的Fleury算法而言，希尔霍尔策算法更加高效，能够达到图的总边数的线性次复杂度。</p>
<p>下面给出来自Harris的《Combinatorics and Graph Theory》中对该算法的描述 ：现给出一个欧拉图G，求欧拉回路。</p>
<p>选定G中一个环，称其为R1，标记R1的边，并记i为1。<br>
    如果Ri已经包含G中所有边，则停止搜索，显然Ri已经是一个欧拉环路。<br>
    否则，取Ri中一个点vi，满足vi有一条未被标记的边，记作ei。<br>
    从vi和ei出发，寻找一个环Qi，标记Qi上的所有边<br>
    使用Qi，创建一条新的环Ri+1<br>
    i的值加一，并回到步骤二，如此重复。</p>
<hr>
<p>图的环游(tour)是指经过图的每条边至少一次的闭途位。欧拉环游是经过每条边恰好一次的环游。一个图若包含欧拉环游，则称为欧拉图(Euleriangraph)。</p>
<p>弗勒里(B.H.Fleury) 在1883 年给出了在欧拉图中找出一个欧拉环游的多项式时间算法，称为</p>
<h1 id="弗勒里算法">弗勒里算法</h1>
<p>输入：一个连通偶图 G 和 G 中任意一个指定项点 u<br>
输出：从 u 出发的 G 的一个欧拉环游<br>
1、令 W：=u，x：=u，F：=G<br>
2、while  F不为空集<br>
3、选一条   中的边 e，其中 e 不是 F 的一条割边；如果   中的边都是割边，那么任选一条边 e<br>
4、用  uWxey  替换  uWx，用 y 替换 x ，用  F\e  替换 F<br>
5、end while<br>
6、返回 W<br>
。。。都是数学符号。。写不了。</p>
<p>其算法核心就是沿着一条迹往下寻找，先选择非割边，除非这个点的邻边都是割边。这样得到一条新的迹，然后再继续往下寻找，直到把所有边找完。遵循这样一个原则就可以找出图的一个欧拉环游来。</p>
<p>在有向图中也可以类似地定义有向环游、有向欧拉环游、有向欧拉图和有向欧拉迹的概念。</p>
<p>割边：连通图G，e是其中一条边，  G-e  形成的图  不是连通图，则  e  是  G  的一条割边。<br>
割点：</p>
<p>===================================</p>
<h1 id="lis-longest-increment-subsequence">LIS, longest increment subsequence</h1>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    // int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
    //     vector&lt;int&gt; sub;
    //     for (int x : nums) {
    //         if (sub.empty() || sub[sub.size() - 1] &lt; x) {
    //             sub.push_back(x);
    //         } else {
    //             auto it = lower_bound(sub.begin(), sub.end(), x); // Find the index of the smallest number &gt;= x
    //             *it = x; // Replace that number with x
    //         }
    //     }
    //     return sub.size();
    // }</pre><pre class="hljs"><code>    <span class="hljs-regexp">//</span> int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
    <span class="hljs-regexp">//</span>     vector&lt;int&gt; sub;
    <span class="hljs-regexp">//</span>     <span class="hljs-keyword">for</span> (int x : nums) {
    <span class="hljs-regexp">//</span>         <span class="hljs-keyword">if</span> (sub.empty() || sub[sub.size() - <span class="hljs-number">1</span>] &lt; x) {
    <span class="hljs-regexp">//</span>             sub.push_back(x);
    <span class="hljs-regexp">//</span>         } <span class="hljs-keyword">else</span> {
    <span class="hljs-regexp">//</span>             auto it = lower_bound(sub.begin(), sub.end(), x); <span class="hljs-regexp">//</span> Find the index of the smallest number &gt;= x
    <span class="hljs-regexp">//</span>             *it = x; <span class="hljs-regexp">//</span> Replace that number with x
    <span class="hljs-regexp">//</span>         }
    <span class="hljs-regexp">//</span>     }
    <span class="hljs-regexp">//</span>     return sub.size();
    <span class="hljs-regexp">//</span> }</code></pre></div>
<p>===================================</p>
<p>===================================</p>
<ol start="372">
<li>Super Pow</li>
</ol>
<p>Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p>
<p>中国余数定理 (Chinese Remainder Theorem)</p>
<p>费马小定理（。。&amp;&amp;  百度  联想的  其他定理。。。）</p>
<p><a data-from-md title='https://leetcode.com/problems/super-pow/discuss/84475/Fermat-and-Chinese-Remainder' href='https://leetcode.com/problems/super-pow/discuss/84475/Fermat-and-Chinese-Remainder'>https://leetcode.com/problems/super-pow/discuss/84475/Fermat-and-Chinese-Remainder</a></p>
<p>If the modulus weren't 1337 = 7 * 191 but a prime number p, we could use Fermat's little theorem to first reduce the exponent to e = b % (p-1) and then compute the result as ae % p. Oh well, we can do it for 1337's prime factors 7 and 191 and then combine the two results with the Chinese remainder theorem. I'll show my derivation of the magic constants 764 and 574 after the solutions below.</p>
<hr>
<p>1337 only has two divisors 7 and 191 exclusive 1 and itself, so judge if a has a divisor of 7 or 191, and note that 7 and 191 are prime numbers, phi of them is itself - 1, then we can use the Euler's theorem, see it on wiki <a data-from-md title='https://en.wikipedia.org/wiki/Euler&apos;s_theorem' href='https://en.wikipedia.org/wiki/Euler%27s_theorem'>https://en.wikipedia.org/wiki/Euler's_theorem</a>, it's just Fermat's little theorem if the mod n is prime.</p>
<p>see how 1140 is calculated out:<br>
phi(1337) = phi(7) * phi(191) = 6 * 190 = 1140</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="水塘抽样蓄水池抽样算法reservoir-sampling">水塘抽样/蓄水池抽样算法(Reservoir Sampling)</h1>
<p>蓄水池抽样算法(Reservoir Sampling)</p>
<hr>
<p>如果接收的数据量小于m，则依次放入蓄水池。<br>
当接收到第i个数据时，i &gt;= m，在[0,  i]范围内取以随机数d，若d的落在[0,  m-1]范围内，则用接收到的第i个数据替换蓄水池中的第d个数据。<br>
重复步骤2。</p>
<p>当处理完所有的数据时，蓄水池中的每个数据都是以m/N的概率获得的。</p>
<hr>
<p>当i&lt;=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。<br>
当i&gt;m时，在[1,i]内选取随机数d，如果d&lt;=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入过蓄水池的概率=m/i。</p>
<p>当i&lt;=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))<em>(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)...第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后第i个数据不被替换的概率=m/(m+1)</em>(m+1)/(m+2)<em>...</em>(N-1)/N=m/N。</p>
<p>当i&gt;m时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。</p>
<p>结合第1点和第3点可知，当i&lt;=m时，第i个接收到的数据最后留在蓄水池中的概率=1<em>m/N=m/N。结合第2点和第4点可知，当i&gt;m时，第i个接收到的数据留在蓄水池中的概率=m/i</em>i/N=m/N。综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。</p>
<hr>
<p>维护一个大小为M的数组. 记当前接收的是第N个数据(从1开始).</p>
<p>如果N&lt;=M, 直接插入<br>
    如果N&gt;M, 就取一个1~N之间的随机数index. 如果index在1~M之间, 则用新接收的数据替换第index个数据; 否则丢弃.</p>
<hr>
<h2 id="分布式的蓄水池抽样">分布式的蓄水池抽样</h2>
<p>假设有K个机器, 每个机器维护大小为M的数组, 并记录该机器接受的数据总数Ni.</p>
<p>当机器获取新数据时, 进行单机的蓄水池抽样.<br>
    当进行采样时, 重复M次以下操作:<br>
    取随机数d在[0,1)之间, 记N=Sum(Ni | i=1...K)<br>
        若d&lt;N1/N则从第一个机器上等概率抽取一个元素.<br>
        若N1/N&lt;=d&lt;(N1+N2)/N则从第二个机器上等概率抽取一个元素<br>
        依此类推.</p>
<p>===================================</p>
<h1 id="kosaraju算法">Kosaraju算法</h1>
<p>基于对  有向图及其逆有向图2次dfs，时间复杂度也是O(M+N)。<br>
与Trajan相比，Kosaraju可能更直观一些。但是Tarjan只对原图进行一次dfs，不需要建立逆图，更简洁。</p>
<h2 id="在实际的测试中tarjan的效率-比kosaraju-高-30-左右">在实际的测试中，Tarjan的效率  比Kosaraju  高  30%  左右。</h2>
<p>Kosaraju的解释和实现都比较简单，为了找到强连通分量，首先对图G进行dfs，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行dfs，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点的  f  值  从大到小的次序；逆图dfs所得的森林就是  对应的  强连通区域。</p>
<p>对原图G进行深度优先遍历，记录每个节点的离开时间num[i]<br>
    选择具有最晚离开时间的顶点，对反图GT进行遍历，删除能够遍历到的顶点，这些顶点构成一个强连通分量<br>
    如果还有顶点没有删除，继续步骤2，否则算法结束</p>
<p>===================================</p>
<h1 id="tarjan算法">Tarjan算法</h1>
<p><mark>tarjan三件套都是基于dfs的<br>
用两个数组来记录时间戳和他能到达的最小时间戳<br>
这是三个算法的核心</mark></p>
<h2 id="线性时间求解有向图强连通分量">线性时间求解有向图强连通分量</h2>
<p>Robert Tarjan</p>
<p>线性时间求解有向图强连通分量</p>
<p>如果2个顶点可以  相互  到达，则称2个顶点  强连通  (strongly connected)。如果有向图G的每2个顶点都  强连通，称G是一个  强连通图。</p>
<p>有向图的极大强连通子图，称为  强连通分量</p>
<p>Tarjan算法是用于求  有向图  的  强连通分量的。</p>
<p>Robert  Tarjan  还发明了  求  双连通分量  的  Tarjan  算法。</p>
<p>时间复杂度O(N+M)</p>
<p>tarjan算法是基于对图的  深度优先搜索的  算法，每个强连通分量是  搜索树中的  一颗子树。搜索时，把当前搜索树中未处理的  节点  加入一个栈，回溯时  可以判断  栈顶  到栈中的节点  是否为  一个强连通分量。</p>
<p>定义DFN(u)  为节点u  搜索的  次序编号  (时间戳)，Low(u)  是  u  或u的子树能追溯到的  最早的  栈中节点的次序号。<br>
当  DFN(u)==Low(u)时，以u为根的  搜索子树上所有节点是一个  强连通分量。</p>
<ol>
<li>当首次搜索到点u  时，DFN[u] = Low[u] = time;</li>
<li>每当搜索到一个点，把该点压入栈顶</li>
<li>当u  和  v有边相连时：
<ol>
<li>如果v  不在栈中  (树枝旁)，dfs(v)，然后  Low[u] = min{Low[u], Low[v]};</li>
<li>如果v  在栈中  (前向边  /  后向边)，此时  Low[u] = min{Low[u], DNF[v]}
<ol>
<li>当DFN[u] = Low[u]时，将它及它之上的元素弹出栈，这些弹出栈的节点构成一个  强连通分量</li>
<li>继续搜索，直到图被遍历完。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="../_resources/e8b6509328cc9de211cd4514df2da2df.png" alt="preview"></p>
<p>===================================</p>
<h2 id="lca">LCA</h2>
<p>Robert Tarjan<br>
LCA</p>
<p>。。下面这段 没什么意思。 看 下下段 (主要是那张图片 + 描述)。</p>
<p>对于有根树T  的2个节点u，v，最近公共祖先LCA(T,u,v)  表示一个节点x，满足  x是u和v的祖先  且x的深度尽可能大(。。深度应该浅吧)。在这里，一个节点也可以是它自己的祖先。</p>
<p>另一种理解方式是把  T  理解为一个  无向无环图，而LCA(T,u,v)  即  u到v的最短路径上深度最小的点。<br>
。。这个路径不能重复的。</p>
<p>利用并查集  优越的  时空复杂度，我们可以实现LCA问题的  O(n+Q)算法，Q表示查询次数。</p>
<p>Tarjan算法基于dfs，对于新搜索到的  节点，首先创建由  这个节点构成的集合，再对当前节点的每一个子树进行搜索，每搜索完一颗子树，则可以确定子树内的LCA询问都已解决。其他的LCA询问的结果必然在这个子树之外，这时把子树所形成的集合与当前节点的集合合并，并将当前节点设置为这个集合的祖先。</p>
<p>之后继续搜索下一棵子树，直到当前节点的所有子树都搜索完。这时把当前节点也设置为已检查，同时可以处理有关当前节点的LCA查询，如果有一个  当前节点  到  节点v  的询问，且v已经被检查过，则由于进行的是  dfs，当前节点  与  v的  LCA  一定还没有被检查，而这个  LCA  的包含  v  的子树一定已经搜索过了，那么这个  LCA一定是  v  所在集合的  祖先。</p>
<hr>
<p><a data-from-md title='https://www.cnblogs.com/jsawz/p/6723221.html' href='https://www.cnblogs.com/jsawz/p/6723221.html'>https://www.cnblogs.com/jsawz/p/6723221.html</a><br>
tarjan算法离线算法</p>
<p>离线算法，是指首先读入所有的询问（求一次LCA叫做一次询问），然后重新组织查询处理顺序以便得到更高效的处理方法。Tarjan算法是一个常见的用于解决LCA问题的离线算法，它结合了深度优先遍历和并查集，整个算法为线性处理时间。</p>
<p>总思路就是每进入一个节点u的深搜，就把整个树的一部分看作以节点u为根节点的小树，再搜索其他的节点。每搜索完一个点后，如果该点和另一个已搜索完点为需要查询LCA的点，则这两点的LCA为另一个点的现在的祖先。</p>
<p>1.先建立两个链表，一个为树的各条边，另一个是需要查询最近公共祖先的两节点。</p>
<p>2.建好后，从根节点开始进行一遍深搜。</p>
<p>3.先把该节点u的father设为他自己（也就是只看大树的一部分，把那一部分看作是一棵树），搜索与此节点相连的所有点v，如果点v没被搜索过，则进入点v的深搜，深搜完后把点v的father设为点u。</p>
<p>4.深搜完一点u后，开始判断节点u与另一节点v是否满足求LCA的条件，满足则将结果存入数组中。</p>
<p>5.搜索完所有点，自动退出初始的第一个深搜，输出结果。</p>
<p><img src="../_resources/5b8985b674474f71ad74b9f6cb879845.png" alt="b7e178706ae3431e3128f6351815cb66.png"></p>
<p>如上图，根据实现算法可以看出，只有当某一棵子树全部遍历处理完成后，才将该子树的根节点标记为有颜色（初始化是白色），假设程序按上面的树形结构进行遍历，<br>
首先从节点1开始，然后递归处理根为2的子树，当子树2处理完毕后，节点2， 5， 6均为红色；<br>
接着要回溯处理3子树，首先被染色的是节点7（因为节点7作为叶子不用深搜，直接处理），接着节点7就会查看所有询问(7, x)的节点对，假如存在(7, 5)，因为节点5已经被染黑，所以就可以断定(7, 5)的最近公共祖先就是find(5)，即节点1（因为2子树处理完毕后，子树2和节点1返回了合并后的树的根1，此时树根的祖先的值就是1）。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">// 。。father, find 是 uf。

int dfs(int x){//把整棵树的一部分看作以节点x为根节点的小树 
    father[x]=x;//由于节点x被看作是根节点，所以把x的father设为它自己 
    visit[x]=1;//标记为已被搜索过 
    for(int k=head[x];k;k=edge[k].next)//遍历所有与x相连的节点 
        if(!visit[edge[k].to]){//若未被搜索 
            dfs(edge[k].to);//以该节点为根节点搞小树 
            father[edge[k].to]=x;//把x的孩子节点的father重新设为x 
        }
    for(int k=qhead[x];k;k=qedge[k].next)//搜索包含节点x的所有询问 
        if(visit[qedge[k].to]){//如果另一节点已被搜索过 
            qedge[k].lca=find(qedge[k].to);//把另一节点的祖先设为这两个节点的最近公共祖先 

            if(k%2)//由于将每一组查询变为两组，所以2n-1和2n的结果是一样的 		// 。。这个不用管，ans存放的解构不同。
                qedge[k+1].lca=qedge[k].lca;
            else
                qedge[k-1].lca=qedge[k].lca;
        }
}</pre><pre class="hljs"><code><span class="hljs-comment">// 。。father, find 是 uf。</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{<span class="hljs-comment">//把整棵树的一部分看作以节点x为根节点的小树 </span>
    father[x]=x;<span class="hljs-comment">//由于节点x被看作是根节点，所以把x的father设为它自己 </span>
    visit[x]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记为已被搜索过 </span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=head[x];k;k=edge[k].next)<span class="hljs-comment">//遍历所有与x相连的节点 </span>
        <span class="hljs-keyword">if</span>(!visit[edge[k].to]){<span class="hljs-comment">//若未被搜索 </span>
            <span class="hljs-built_in">dfs</span>(edge[k].to);<span class="hljs-comment">//以该节点为根节点搞小树 </span>
            father[edge[k].to]=x;<span class="hljs-comment">//把x的孩子节点的father重新设为x </span>
        }
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=qhead[x];k;k=qedge[k].next)<span class="hljs-comment">//搜索包含节点x的所有询问 </span>
        <span class="hljs-keyword">if</span>(visit[qedge[k].to]){<span class="hljs-comment">//如果另一节点已被搜索过 </span>
            qedge[k].lca=<span class="hljs-built_in">find</span>(qedge[k].to);<span class="hljs-comment">//把另一节点的祖先设为这两个节点的最近公共祖先 </span>

            <span class="hljs-keyword">if</span>(k%<span class="hljs-number">2</span>)<span class="hljs-comment">//由于将每一组查询变为两组，所以2n-1和2n的结果是一样的 		// 。。这个不用管，ans存放的解构不同。</span>
                qedge[k+<span class="hljs-number">1</span>].lca=qedge[k].lca;
            <span class="hljs-keyword">else</span>
                qedge[k<span class="hljs-number">-1</span>].lca=qedge[k].lca;
        }
}</code></pre></div>
<hr>
<h2 id="无向图的割点与桥割边">无向图的割点与桥(割边)</h2>
<p><a data-from-md title='https://zhuanlan.zhihu.com/p/101923309' href='https://zhuanlan.zhihu.com/p/101923309'>https://zhuanlan.zhihu.com/p/101923309</a></p>
<p>Tarjan 算法是图论中非常实用 / 常用的算法之一，能解决强连通分量，双连通分量，割点和桥，求最近公共祖先（LCA）等问题。</p>
<p>主要介绍如何使用 Tarjan 算法求解无向图的割点与桥。</p>
<p>Tarjan 算法是基于深度优先搜索的算法，用于求解图的连通性问题。<br>
Tarjan 算法可以在线性时间内求出无向图的割点与桥，进一步地可以求解无向图的双连通分量；同时，也可以求解有向图的强连通分量、必经点与必经边。</p>
<p>概念：</p>
<ul>
<li>割点: 从图中删除 节点x 以及 所有与 x关联的边 后，图被分为 2个或 2个以上 不相连的子图。那么x 就是 图的割点。</li>
<li>桥/割边: 从图中删除 边e 后，图会分为 2个不相连的子图，那么 e就是 图的 桥/割边</li>
</ul>
<p>Tarjan 需要使用：<br>
时间戳： 标记图中每个节点在进行 dfs时 被访问的 时间顺序，可以理解为 一个序号( 从小到大)，用 dfn[x] 表示<br>
搜索树： 无向图中，从某个节点x 出发，进行dfs，每个节点只访问一次，所有被访问过的节点 与边 构成一棵树，称之为 无向连通图的搜索树<br>
追溯值： 用来表示 从当前节点 x 作为搜索树 的根节点触发，能够访问到的 所有节点中，时间戳最小的值 low[x]。那么，我们要限定下什么是“能够访问到的所有节点”？，其需要满足下面的条件之一即可：</p>
<ul>
<li>以 x 为根的搜索树的所有节点</li>
<li>通过一条非搜索树上的边，能够到达搜索树的所有节点</li>
</ul>
<p>。。追溯值没看明白。。下次。</p>
<p>无向图的桥判定法则<br>
在一张无向图中，判断边 e （其对应的两个节点分别为 u 与 v）是否为桥，需要其满足如下条件即可：dfn[u] &lt; low[v]<br>
它代表的是节点 u 被访问的时间，要优先于（小于）以下这些节点被访问的时间 —— low[v] 。<br>
以节点 v 为根的搜索树中的所有节点<br>
通过一条非搜索树上的边，能够到达搜索树的所有节点（在追溯值内容中有所解释）</p>
<p>是不是上面的两个条件很眼熟？对，其实就是前文提到的追溯值 —— low[v]。</p>
<hr>
<p>===================================</p>
<h1 id="lca-2">LCA</h1>
<hr>
<p><a data-from-md title='https://riteme.site/blog/2017-9-3/lca.html' href='https://riteme.site/blog/2017-9-3/lca.html'>https://riteme.site/blog/2017-9-3/lca.html</a></p>
<h2 id="朴素算法">朴素算法</h2>
<h3 id="调整深度上浮">调整深度+上浮</h3>
<ol>
<li>先将两个结点调为同一深度</li>
<li>将两个结点同时上调，直到这两个结点到达同一位置时，此时即为LCA</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">// 伪代码
def Plain_LCA(u, v):
    if d(u) &lt; d(v):
        swap(u, v)  # 始终保持u所处的深度较深

    while d(u) != d(v):
        u = father(u)  # 将u上调

    # 将u和v同时上调
    while u != v:
        u = father(u)
        v = father(v)

    # 最后会使u == v，即他们到达了LCA
    return u</pre><pre class="hljs"><code>// 伪代码
def Plain_LCA(u, v):
    if d(u) &lt; d(v):
        swap(u, v)  # 始终保持u所处的深度较深

    while d(u) != d(v):
        u = father(u)  # 将u上调

    # 将u和v同时上调
    while u != v:
        u = father(u)
        v = father(v)

    # 最后会使u == v，即他们到达了LCA
    return u</code></pre></div>
<p>。。<br>
计算出 2个节点的深度。<br>
如果深度不同，那么 深的那个上浮一次。<br>
现在深度相同。<br>
如果 2个节点不同，那么 都 上浮一次。 直到 2个节点相同。 这个节点就是 LCA</p>
<p>但是，上浮，就意味着 记录 parent，  可以一个 一维数组。<br>
深度，就意味这要 dfs， 建立树，  顺便 记录 parent。</p>
<p>还行， dfs一次，找到2个 节点 以及它们的深度， 并且 建立 parent 数组。 找到2个节点后 就可以 退出了。 parent数组 虽然不完整，但是够用了。<br>
然后 就是判断 深度。 进行 上浮。<br>
。。</p>
<hr>
<p>。。mine start</p>
<p>我以前用的是。。 有2种。 一种是 直接给树 TreeNode,  一种是给边。</p>
<h3 id="treenode">TreeNode</h3>
<p>.. 那么就是 二叉树了。 当然，可以应用到多叉树。 不过TreeNode 的解构就是 二叉树的。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">TreeNode* dfsa1(TreeNode* ptr, TreeNode* a, TreeNode* b)
{
    if (ptr == nullptr)	
        return ptr;

    if (node == a || node == b)		// 应该可以。
        return ptr;
    
    lft = dfsa1(ptr-&gt;left);		// 多叉树的话，就是这里，保存下 非null 的指针，然后 判断下： 2个，就返回node，1个就返回 那一个， 0个就返回 null。
    rht = dfsa1(ptr-&gt;right);

    if (lft != nullptr &amp;&amp; rht != nullptr)
        return ptr
    
    return lft == nullptr ? rht : lft;
}</pre><pre class="hljs"><code>TreeNode* dfsa1(TreeNode* ptr, TreeNode* a, TreeNode* b)
{
    if (ptr == nullptr)	
        return ptr;

    if (node == a || node == b)		// 应该可以。
        return ptr;
    
    lft = dfsa1(ptr-&gt;left);		// 多叉树的话，就是这里，保存下 非null 的指针，然后 判断下： 2个，就返回node，1个就返回 那一个， 0个就返回 null。
    rht = dfsa1(ptr-&gt;right);

    if (lft != nullptr &amp;&amp; rht != nullptr)
        return ptr
    
    return lft == nullptr ? rht : lft;
}</code></pre></div>
<h3 id="只给了-边">只给了 边</h3>
<p>一般就是多叉树了。<br>
按照TreeNode 的逻辑 应该也可以。<br>
就是返回，得返回 pair&lt;node, count&gt;， 就是 LCA， 和 找到多少个节点(最多2个)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">pair&lt;int, int&gt; dfsa1(vector&lt;vector&lt;int&gt;&gt;&amp; vvi, int node, int parent, int a, int b)
{
    if (node == a || node == b)
        return {node, 1};		// 如果a 在b的子树中，那么会返回 &lt;b, 1&gt;。 count是1。
    pair&lt;int, int&gt; p;
    vector&lt;int&gt; vi;
    for (int nxt : vvi[node])
    {
        if (nxt != parent)
        {
            p = dfsa1(vvi, nxt, node, a, b);
            if (p.second != 0)
            {
                vi.push_back(p.first);
            }
        }
    }

    if (vi.size() == 2)
    {
        return {node, 2};
    }
    else if (vi.size() == 1)
    {
        return {vi[0], 1};
    }
    return {-1, 0};
}</pre><pre class="hljs"><code>pair&lt;int, int&gt; dfsa1(vector&lt;vector&lt;int&gt;&gt;&amp; vvi, int node, int parent, int a, int b)
{
    if (node == a || node == b)
        return {node, 1};		// 如果a 在b的子树中，那么会返回 &lt;b, 1&gt;。 count是1。
    pair&lt;int, int&gt; p;
    vector&lt;int&gt; vi;
    for (int nxt : vvi[node])
    {
        if (nxt != parent)
        {
            p = dfsa1(vvi, nxt, node, a, b);
            if (p.second != 0)
            {
                vi.push_back(p.first);
            }
        }
    }

    if (vi.size() == 2)
    {
        return {node, 2};
    }
    else if (vi.size() == 1)
    {
        return {vi[0], 1};
    }
    return {-1, 0};
}</code></pre></div>
<p>。。mine end</p>
<h2 id="tarjan-见tarjan-lca">Tarjan (见Tarjan-LCA)</h2>
<p>离线算法 (指，必须直到 query，才能开始计算，不能预先设置好。或者说预先设置的话 消耗的内存/CPU 太多了。)</p>
<p>Tarjan-LCA算法能在 O(n+q) 时间内计算出所有询问的LCA，其中q为询问总数。n为边树</p>
<h2 id="倍增法">倍增法</h2>
<p>在线算法</p>
<p>Tarjan-LCA算法速度很快，效果也很好，但有一个致命的问题… 就是内存占用。<br>
首先它需要离线操作，如果空间比较紧且操作较多时，显然不合适。<br>
另外，如果要处理任意结点对的LCA，就需要一个巨大的二维数组来存储，这意味着如果n&gt;10000 此算法将报废。</p>
<p>倍增法能以 Θ(logn)的时间复杂度和 Θ(nlog⁡n)的空间复杂度内完成LCA的计算。</p>
<p>倍增法运用了动态规划的思想，并利用二进制达到了Θ(log⁡n) 的时间复杂度。</p>
<ol>
<li>倍增法首先需要计算一个f数组，其含义为：<br>
f[i,j]: 离节点i相距2^j的父节点<br>
即：<br>
distance(i, f[i,j]) = 2^j</li>
</ol>
<p>f[i, 0] 就是 i的父节点。<br>
有如下状态转移方程:<br>
<code class="inline-code">f[i, j] = f[f[i, j-1], j-1]</code></p>
<p>利用得到的状态转移方程，我们可以在Θ(nlog⁡n) 的时间内推出f数组。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```"># 初始化f[i, 0]
for i in [1, n]:
    f[i, 0] = father(i)

# 计算整个f数组
for j in [1, log(n)]:
    for i in [1, n]:
        f[i, j] = f[f[i, j - 1], j - 1]</pre><pre class="hljs"><code><span class="hljs-comment"># 初始化f[i, 0]</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, n]:
    f[i, <span class="hljs-number">0</span>] = father(i)

<span class="hljs-comment"># 计算整个f数组</span>
<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, log(n)]:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, n]:
        f[i, j] = f[f[i, j - <span class="hljs-number">1</span>], j - <span class="hljs-number">1</span>]</code></pre></div>
<ol start="2">
<li>得到f数组后，剩下的就是计算LCA<br>
事实上，倍增法计算LCA的过程与朴素算法一样，也是要先调制同一深度，再同时上调。<br>
倍增法利用算出的f数组来加速提升的过程，使得节点的上升的距离可以达到2j 2^j 2j，而不是一格一格往上调。</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">def Double_LCA(u, v):
    if d(u) &lt; d(v):
        swap(u, v)  # 始终保持u所处的深度较深

    # 将u上调dist个距离
    dist = d(u) - d(v)
    for i in [0, log(n)]:
        if (1 &lt;&lt; i) &amp; dist  # KEY #1
            u = f[u, i]

    if u == v:
        return u  # 特判此时u, v是否在同一位置，如果是，u和v都站在LCA上

    # 将u和v同时上调
    for i from log(n) to 0:
        if f[u, i] != f[v, i]:  # KEY #2
            u = f[u, i]
            v = f[v, i]

    # 最后会使u和v成为LCA的子节点
    return f[u, 0]</pre><pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">Double_LCA</span>(<span class="hljs-params">u, v</span>):
    <span class="hljs-keyword">if</span> d(u) &lt; d(v):
        swap(u, v)  <span class="hljs-comment"># 始终保持u所处的深度较深</span>

    <span class="hljs-comment"># 将u上调dist个距离</span>
    dist = d(u) - d(v)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, log(n)]:
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;&lt; i) &amp; dist  <span class="hljs-comment"># KEY #1</span>
            u = f[u, i]

    <span class="hljs-keyword">if</span> u == v:
        <span class="hljs-keyword">return</span> u  <span class="hljs-comment"># 特判此时u, v是否在同一位置，如果是，u和v都站在LCA上</span>

    <span class="hljs-comment"># 将u和v同时上调</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> log(n) to <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> f[u, i] != f[v, i]:  <span class="hljs-comment"># KEY #2</span>
            u = f[u, i]
            v = f[v, i]

    <span class="hljs-comment"># 最后会使u和v成为LCA的子节点</span>
    <span class="hljs-keyword">return</span> f[u, <span class="hljs-number">0</span>]</code></pre></div>
<p>代码中有两处比较奇特的地方，被注释打上了KEY。</p>
<hr>
<h2 id="欧拉序列-rmqst">欧拉序(列) + RMQ/ST</h2>
<p>欧拉序列概念: 对一棵树进行 DFS，无论是第一次访问还是回溯，每次到达一个结点时都将编号记录下来，可以得到一个长度为<br>
2𝑛 − 1的序列，这个序列被称作这棵树的欧拉序列。</p>
<p><a data-from-md title='https://www.cnblogs.com/codjjj/p/17237723.html' href='https://www.cnblogs.com/codjjj/p/17237723.html'>https://www.cnblogs.com/codjjj/p/17237723.html</a><br>
。。这个是 欧拉序 + ST表</p>
<p><mark>两个点的LCA是欧拉序之间dep最小的点</mark><br>
。。最浅的点。<br>
。。深度最小，所以 需要一个转换， RMQ/ST 的时候 用 深度计算，但是 query的时候 得返回 这个深度的 node。所以需要是一个 pair。</p>
<p>因为LCA肯定会在欧拉序之间，而LCA的祖先不会，因为如果会，说明LCA的这颗子树已经被遍历完了，那之后不会再有另一个节点</p>
<p>因此我们dfs建立欧拉序，在欧拉序上建ST表，每次查u,v的LCA，等价于查找<br>
<code class="inline-code">[pos[u],pos[v]]</code><br>
在ST表上的最小值</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void initST() {
    for(int i=2;i&lt;=_;i++)Log2[i]=Log2[i/2]+1;
    for(int i=1;i&lt;=20;i++)
        for (int j = 1; j+(1&lt;&lt;i)-1 &lt;= _; j++) {
            val[i][j]=min(val[i-1][j],val[i-1][j+(1&lt;&lt;i-1)]);
        }
}

int query(int l, int r) {
    if(l&gt;r)swap(l,r);
    int len=Log2[r-l+1];
    return min(val[len][l],val[len][r-(1&lt;&lt;len)+1]).second;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initST</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=_;i++)Log2[i]=Log2[i/<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j+(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">-1</span> &lt;= _; j++) {
            val[i][j]=<span class="hljs-built_in">min</span>(val[i<span class="hljs-number">-1</span>][j],val[i<span class="hljs-number">-1</span>][j+(<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>)]);
        }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{
    <span class="hljs-keyword">if</span>(l&gt;r)<span class="hljs-built_in">swap</span>(l,r);
    <span class="hljs-type">int</span> len=Log2[r-l+<span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(val[len][l],val[len][r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>]).second;
}</code></pre></div>
<p>===================================</p>
<h1 id="dijkstra">Dijkstra</h1>
<p>一个顶点到其它各个顶点的最短路径。<br>
解决有权图中最短路径。  不能存在  负权边</p>
<p>从起始点开始，采用  贪心策略，每次  遍历  未访问的节点中  距离起始点最近的  节点。</p>
<p>具体过程：</p>
<ol>
<li>需要一个辅助数组D，它的每个元素表示  起始点  到  其它节点的最短长度。</li>
<li>辅助数组D的初始化：
<ol>
<li>如果从  节点vi  到  起始点  有直接边  相连，则  D[i]  的值就是  边的权值。  没有直接变相连，则  D[i]  值是  无穷大。</li>
</ol>
</li>
<li>辅助数组D中最小值，就是  从起始点出发  到其它某个节点  的最短路径。</li>
<li>找到  某个其它节点后，更新  与  这个节点  直接相连的  节点的  最小长度。</li>
<li>再取  (除了起始点和已找到的节点外的)  最小值</li>
<li>然后  再  根据取到的节点  刷新  辅助数组D  中直接相连的  节点的  最小长度。</li>
</ol>
<p>===================================</p>
<h1 id="prim">Prim</h1>
<ol>
<li>
<p>输入：一个加权连通图，其中顶点集合为V，边集合为E；</p>
</li>
<li>
<p>初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；</p>
</li>
<li>
<p>重复下列操作，直到Vnew = V：</p>
<ol>
<li>在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li>
<li>将v加入集合Vnew中，将&lt;u, v&gt;边加入集合Enew中；</li>
</ol>
</li>
<li>
<p>输出：使用集合Vnew和Enew来描述所得到的最小生成树。</p>
</li>
</ol>
<p>这里<mark>不需要更新</mark><br>
dijkstra xuyao</p>
<p>===================================</p>
<h1 id="kruskal">Kruskal</h1>
<p>时间复杂度为O（eloge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树</p>
<p>假设连通网G=（V，E），令最小生成树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），概述图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点分别在T中不同的连通分量上，则将此边加入到T中；否则，舍去此边而选择下一条代价最小的边。依此类推，直至T中所有顶点构成一个连通分量为止。</p>
<p>===================================</p>
<h1 id="spfa">SPFA</h1>
<p>//LT1631</p>
<p>//Using BFS is actually an improvement of Bellman - Ford, called Shortest Path Faster Algorithm, <a data-from-md title='https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm' href='https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm'>https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm</a></p>
<p>//SPFA removes the unnecessary edge relaxations, thus reducing the time complexity, but worst case still the same as Bellman - Ford.</p>
<p>===================================</p>
<h1 id="floyd">Floyd</h1>
<p><mark>外层是k</mark>。<br>
代表  结点i 到 结点j 的 经过 k 的最短距离。</p>
<p><code class="inline-code">j 必须从1开始，不能从 i+1 开始</code></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">    for(k=1;k&lt;=n;k++)
        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=n;j++) {
                if(d[i][k]+d[k][j]&lt;d[i][j]) {</pre><pre class="hljs"><code>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)
            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++) {
                <span class="hljs-keyword">if</span>(d[i][k]+d[k][j]&lt;d[i][j]) {</code></pre></div>
<p>===================================</p>
<h1 id="bellman-ford">Bellman-Ford</h1>
<p>===================================</p>
<h1 id="suffix-array">Suffix  Array</h1>
<p>对字符串所有后缀进行排序后得到的数组。<br>
用于全文索引，数据压缩算法，生物信息学。</p>
<p>后缀数组，SA[i]存放排名第i大的后缀首字符下标<br>
一维数组，保证  suffix(SA[i])  &lt; suffix(SA[i+1])<br>
也就是将  字符串S  的n个后缀  从小到大排序之后，把排好序的后缀的  开头位置依次放入SA中。<br>
名次数组，rank[i]  存放  suffix(i)的优先级<br>
保存的是  suffix(i)  在所有后缀中  从小到大排列的  名次</p>
<p>。。SA是排序后，保存  排序前  这个substring的起始下标。。。就是  sz1 - substr.size()。<br>
。。rank保存的是  排序前  这个substring，  在排序后的  数组中的  次序。</p>
<p>SA：排第几的是谁。<br>
rank：你排第几。</p>
<p>SA和rank是互逆运算。只要计算出SA，就可以在O(n)中算出  rank。</p>
<p>height数组：保存的是  suffix(i)  和  suffix(i  - 1)  的最长公共前缀的长度。也就是排名相邻的2个后缀的最长公共前缀。</p>
<p>。。这里的排名相邻是指SA相邻？  主要是前面说  suffix(i)，感觉是排序前的  相邻substr的  最长公共前缀。  不不不，相邻的substr的  公共前缀是  非常  稀少的，没有太大意义的。</p>
<p>构建suffix  array，主要就是要构建  SA，rank，height数组。</p>
<p>如何构建SA数组：</p>
<ol>
<li>倍增算法：O(nlogn)</li>
<li>DC3算法：O(n)</li>
<li>skew算法：不常用</li>
</ol>
<p>这里介绍DC3算法：</p>
<ol>
<li>将后缀分成2步伐，然后对第一部分的后缀排序。<br>
字符的编号从0开始<br>
将后缀分成  2部分：<br>
第一部分是后缀k  (k%3 != 0)<br>
第二部分是后缀k  (k%3 == 0)</li>
<li>利用  步骤1  的结果，对第二部分的后缀排序</li>
<li>将  步骤1  和  2  的结果合并，就完成了  对所有后缀的排序。</li>
</ol>
<p>求出了所有后缀的排序，有什么用呢？主要是用于求它们之间的最长公共前缀(LCP，longed  common prefix)</p>
<p>求出SA数组后，根据  rank[sa[i]] = i，  rank数组可以在  O(n)  中求出。</p>
<p>如何求出height数组呢？</p>
<p>令  LCP(i,j)  为  第i小的后缀  和  第j小的后缀  (即  suffix(SA[i])  和  suffix(SA[j])  )  的最长公共前缀的长度，则有如下2个性质：</p>
<ol>
<li>对于任意  i&lt;=k&lt;=j，有  LCP(i,j)  = min( LCP(i,k), LCP(k,j)  )</li>
<li>LCP(i,  j)  = min( i &lt; k &lt;= j )( LCP(k-1, k) )</li>
</ol>
<p>令height[i]  = LCP(i-1, i)，即height[i]代表第i小的后缀  与  第i-1小的后缀的  LCP，则求  LCP(i,  j)  就变成了  求  height[i+1] height[i]  之间的  RMQ，使用RMQ  算法就可以了，复杂度是  预处理  O(nlogn)，查询O(1)。</p>
<p>。。？</p>
<p>。。。代码很难的。</p>
<hr>
<h2 id="倍增算法">倍增算法</h2>
<ol>
<li>
<p>根据字典顺序  对每个后缀的  第一个字符  排序，得到了第一次的排序</p>
</li>
<li>
<p>对每个后缀的  前2个字符  进行排序，得到了  第二次的排序</p>
</li>
<li>
<p>对每个后缀的  前4个字符进行排序（这就是倍增）。  但是我们这次排序的仍然时2个字符。后缀k的前4个字符  看成  由  后缀k的  前2个字符  和  后缀k+2  的前2个字符组成。所以如果要把  后缀m  和  后缀n  进行比较，那么应该首先  比较  后缀m  的前2个字符  和  后缀  n  的前2个字符，如果相同，再比较  后缀m+2  的  前2个字符  和  后缀n+2  的前2个字符。  所以  一直排序的是  二元组，这就是为什么要  使用  基数排序。</p>
</li>
<li>
<p>如果所有的排名都不同的话，就不需要再倍增了</p>
</li>
</ol>
<p>。。感觉像桶排序。先根据第一个char进行排序，然后根据第二个char。<br>
。。不过这里，可以有dp。  桶排序没有。</p>
<p>。。代码是  一个for  中  7个for。。。</p>
<p>===================================</p>
<h1 id="lcp-array">LCP array</h1>
<p>===================================</p>
<h1 id="rmq-算法">RMQ  算法</h1>
<p>range  min/max  query，区间最值查询</p>
<p>解决多个区间最值查询的算法。</p>
<hr>
<p>假设有一个长度N的数组arr，求a-b之间的最大/最小值。</p>
<p>最简单的就是二维数组，预先计算好  每个ab对的  max/min。但是内存非常浪费。</p>
<p>RMQ算法就是巧妙地运用  2的幂数/对数  解决这个问题的。</p>
<p>设  dp[i][j]  是  以  i  为起点，  (1&lt;&lt;j)  长度的  最大值。</p>
<p>这样，需要求  a-b  的最大值时，只需要求  max(dp[a][某个长度], dp[b-(1&lt;&lt;某个长度)+1][某个长度])，其中  某个长度  = log2(b-a+1)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">void query(int a, int b, int &amp;maxV) {
    int r = mlog2(b - a + 1);
    maxV = max( dpMax[a][r], dpMax[b - (1&lt;&lt;r) + 1][r] );
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;maxV)</span> </span>{
    <span class="hljs-type">int</span> r = <span class="hljs-built_in">mlog2</span>(b - a + <span class="hljs-number">1</span>);
    maxV = <span class="hljs-built_in">max</span>( dpMax[a][r], dpMax[b - (<span class="hljs-number">1</span>&lt;&lt;r) + <span class="hljs-number">1</span>][r] );
}</code></pre></div>
<hr>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">using namespace std;

#define MAXN 50005

int h[MAXN];
int dpMin[MAXN][16];
int dpMax[MAXN][16];

int mlog2(int x) {
    double xx = x;
    double v1 = log(xx);
    double v2 = log(2.0);
    return v1/v2;
}

void genDP(int len){
    for(int i=0;i&lt;len;i++){
        dpMax[i][0] = h[i];
        dpMin[i][0] = h[i];
    }
    for(int j=1;(1&lt;&lt;j)&lt;len;j++){
        for( int i=0;i+(1&lt;&lt;j)-1&lt;len;i++ ){
            int r = i+(1&lt;&lt;(j-1));
            dpMax[i][j] = max(dpMax[i][j-1],dpMax[r][j-1]);
            dpMin[i][j] = min(dpMin[i][j-1],dpMin[r][j-1]);
        }
    }
}

void query(int a,int b,int &amp;maxV,int &amp;minV){
    int r = mlog2(b-a+1);
    maxV = max(dpMax[a][r],dpMax[b-(1&lt;&lt;r)+1][r]);
    minV = min(dpMin[a][r],dpMin[b-(1&lt;&lt;r)+1][r]);
}

int main(){
    int N,Q;
    int t;
    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);
    for( int i=0;i&lt;N;i++ ){
        scanf(&quot;%d&quot;,&amp;t);
        h[i] = t;
    }
    genDP(N);
    int a,b;
    int maxV,minV;
    for( int i=0;i&lt;Q;i++ ){
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        if ( a==b ){
            printf(&quot;0\n&quot;);
        }else{
            query(a-1,b-1,maxV,minV);
            printf(&quot;%d\n&quot;,maxV-minV);
        }
    }
    return 0;
}</pre><pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 50005</span>

<span class="hljs-type">int</span> h[MAXN];
<span class="hljs-type">int</span> dpMin[MAXN][<span class="hljs-number">16</span>];
<span class="hljs-type">int</span> dpMax[MAXN][<span class="hljs-number">16</span>];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mlog2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-type">double</span> xx = x;
    <span class="hljs-type">double</span> v1 = <span class="hljs-built_in">log</span>(xx);
    <span class="hljs-type">double</span> v2 = <span class="hljs-built_in">log</span>(<span class="hljs-number">2.0</span>);
    <span class="hljs-keyword">return</span> v1/v2;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">genDP</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++){
        dpMax[i][<span class="hljs-number">0</span>] = h[i];
        dpMin[i][<span class="hljs-number">0</span>] = h[i];
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;len;j++){
        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;len;i++ ){
            <span class="hljs-type">int</span> r = i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>));
            dpMax[i][j] = <span class="hljs-built_in">max</span>(dpMax[i][j<span class="hljs-number">-1</span>],dpMax[r][j<span class="hljs-number">-1</span>]);
            dpMin[i][j] = <span class="hljs-built_in">min</span>(dpMin[i][j<span class="hljs-number">-1</span>],dpMin[r][j<span class="hljs-number">-1</span>]);
        }
    }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;maxV,<span class="hljs-type">int</span> &amp;minV)</span></span>{
    <span class="hljs-type">int</span> r = <span class="hljs-built_in">mlog2</span>(b-a+<span class="hljs-number">1</span>);
    maxV = <span class="hljs-built_in">max</span>(dpMax[a][r],dpMax[b-(<span class="hljs-number">1</span>&lt;&lt;r)+<span class="hljs-number">1</span>][r]);
    minV = <span class="hljs-built_in">min</span>(dpMin[a][r],dpMin[b-(<span class="hljs-number">1</span>&lt;&lt;r)+<span class="hljs-number">1</span>][r]);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">int</span> N,Q;
    <span class="hljs-type">int</span> t;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;N,&amp;Q);
    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++ ){
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);
        h[i] = t;
    }
    <span class="hljs-built_in">genDP</span>(N);
    <span class="hljs-type">int</span> a,b;
    <span class="hljs-type">int</span> maxV,minV;
    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Q;i++ ){
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);
        <span class="hljs-keyword">if</span> ( a==b ){
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-built_in">query</span>(a<span class="hljs-number">-1</span>,b<span class="hljs-number">-1</span>,maxV,minV);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,maxV-minV);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="travelling-salesman-problem">Travelling Salesman Problem</h1>
<p>哈密顿回路(Hamiltonian cycle)  哈密顿图(Hamiltonian Path)  旅行推销员问题(Travelling salesman problem)</p>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="线段树">线段树</h1>
<p><a data-from-md title='https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/' href='https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/'>https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/</a></p>
<p>。。这个是  sum  of given range,  还有一个是  range  min query。  都差不多，就是  merge  的行为的不同</p>
<p>考虑如下问题  来理解  segment tree<br>
有一个数组  arr[0  … n-1]。我们需要做到：</p>
<ol>
<li>计算  [l, r]  区间内的  元素  和</li>
<li>修改某个元素的值</li>
</ol>
<p>方案</p>
<ol>
<li>遍历[l, r]  来累加  sum；这样，操作1是  O(n)，操作2是  O(1)</li>
<li>前缀和数组，保存从下标0  到当前下标的  sum。这样，操作1是  O(1)，操作2是  O(n)。</li>
<li>最有效的方法是  使用  Segment  Tree。2个操作都是  O(logn)</li>
</ol>
<p>Segment  tree  的描述</p>
<ol>
<li>
<p>叶子节点  是  输入的arr  的元素</p>
</li>
<li>
<p>每个  内部节点  表示  叶子节点的  merge。这个  merge  对于不同的问题  是不同的。对于目前的问题，这个  merge  是  该内部节点  下属的  所有  叶子节点  的  sum。</p>
</li>
<li>
<p>树  的  数组形式  来  表示  Segment tree。对于  下标  i的节点，左child  是在  下标  i<em>2+1，右child  是  i</em>2+2，parent  是  (floor( (i-1) / 2 ))</p>
</li>
</ol>
<p><img src="../_resources/039a57039ffc8aec4761b813aa5b4b18.png" alt="node represents  sum of array values"></p>
<p>。。不过这个没有办法转成数组。因为不是  完全二叉树。</p>
<p>从输入的数组  构造  Segment Tree</p>
<p>我们从一个  segment: arr[0, n-1]  开始。每次  我们  divide  当前的  segment  成  2个  (只要  segment  还没有变成  长度1)，然后  对  2个新的  segment  再次使用相同的计算，对于每个这样的  segment，我们在对应的node  上保存  sum。</p>
<p>构造出的  segment tree  的  除了最后一层外，每层  都是满的。  这样，tree  会是  一个  full  二叉树，因为  我们divide segment  成2个。  由于  构造的tree  是一个  含有n  个叶子  的  full  二叉树，所以  会有  n-1  个  内部节点，所以一共有  2*n  - 1  个节点。</p>
<p>。。国内外  对  full  binary tree  (满二叉树)  的定义不同，  国内是  正好一个等腰三角形。  国外是：每个节点  要么是叶子节点，要么  有2个child。</p>
<p>输入的arr  的  segment tree  的  高度是多少</p>
<p>线段树的  高度是  ceil(logN)。  由于  树  是通过arr  来表达的，且  parent  和child node  之间的  关系  是固定的，  所以  申请的  空间是  (2 * 2^(ceil(logN)) - 1).</p>
<p>。。也就是  2^(ceil(logN) + 1) - 1</p>
<p>查询  给定range  的  sum</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">int getSum(node, l, r)
{
   if the range of the node is within l and r
        return value in the node
   else if the range of the node is completely outside l and r
        return 0
   else
         return getSum(node's left  child, l, r) +
                getSum(node's right child, l, r)
}</pre><pre class="hljs"><code><span class="hljs-built_in">int</span> get<span class="hljs-constructor">Sum(<span class="hljs-params">node</span>, <span class="hljs-params">l</span>, <span class="hljs-params">r</span>)</span>
{
   <span class="hljs-keyword">if</span> the range <span class="hljs-keyword">of</span> the node is within l <span class="hljs-keyword">and</span> r
        return value <span class="hljs-keyword">in</span> the node
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> the range <span class="hljs-keyword">of</span> the node is completely outside l <span class="hljs-keyword">and</span> r
        return <span class="hljs-number">0</span>
   <span class="hljs-keyword">else</span>
         return get<span class="hljs-constructor">Sum(<span class="hljs-params">node</span>&#x27;<span class="hljs-params">s</span> <span class="hljs-params">left</span>  <span class="hljs-params">child</span>, <span class="hljs-params">l</span>, <span class="hljs-params">r</span>)</span> +
                get<span class="hljs-constructor">Sum(<span class="hljs-params">node</span>&#x27;<span class="hljs-params">s</span> <span class="hljs-params">right</span> <span class="hljs-params">child</span>, <span class="hljs-params">l</span>, <span class="hljs-params">r</span>)</span>
}</code></pre></div>
<p>上面的实现中，有3个分支</p>
<ol>
<li>如果  当前node  的range  被  [l, r]  完全包围，那么  直接  把  节点的值  加到  ans</li>
<li>如果  range  和  [l, r]  没有重叠，那么  ans + 0</li>
<li>如果部分重叠，  递归  left  和  right child</li>
</ol>
<p>更新值<br>
和  tree的构造，查询  一样，update  也是  递归的。  我们收到一个  需要更新的  index，需要加上  diff  值。<br>
我们从  root  开始，增加  diff  值  到  任何  range  包含  index  的  node。</p>
<p>。。。更下面有个位运算实现的，更短。不过  下标是从  1  开始的。<br>
。。这里是  从0  开始，  所以  i<em>2+1, i</em>2+2<br>
。。从1开始的话，i<em>2, i</em>2+1</p>
<h2 id="segment-tree-impl">segment tree impl</h2>
<p>下面是代码实现</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">#include &lt;bits/stdc++.h&gt;
using namespace std;

int getMid(int s, int e) { return s + (e -s)/2; }

int *constructST(int arr[], int n)
{
    int x = (int)(ceil(log2(n)));
    int max_size = 2*(int)pow(2, x) - 1;
    int *st = new int[max_size];

    constructSTUtil(arr, 0, n-1, st, 0);

    return st;
}

int constructSTUtil(int arr[], int ss, int se, int *st, int si)
{
    if (ss == se)
    {
        st[si] = arr[ss];
        return arr[ss];
    }

    int mid = getMid(ss, se);
    st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) +
            constructSTUtil(arr, mid+1, se, st, si*2+2);
    return st[si];
}

int getSum(int *st, int n, int qs, int qe)
{
    if (qs &lt; 0 || qe &gt; n-1 || qs &gt; qe)
    {
        cout&lt;&lt;&quot;Invalid Input&quot;;
        return -1;
    }
    return getSumUtil(st, 0, n-1, qs, qe, 0);
}

//  st : segment tree
// si : current node's index in array
// ss, se :  当前node代表的  range
// qs, qe :  query range
int getSumUtil(int *st, int ss, int se, int qs, int qe, int si)
{
    if (qs &lt;= ss &amp;&amp; qe &gt;= se)
        return st[si];

    if (se &lt; qs || ss &gt; qe)
        return 0;

    int mid = getMid(ss, se);
    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +
        getSumUtil(st, mid+1, se, qs, qe, 2*si+2);
}

void updateValue(int arr[], int *st, int n, int i, int new_val)
{
    if (i &lt; 0 || i &gt; n-1)
    {
        cout&lt;&lt;&quot;Invalid Input&quot;;
        return;
    }

    int diff = new_val - arr[i];

    arr[i] = new_val;             //  这个是arr，  下面更新的是  st。  ok的。

    updateValueUtil(st, 0, n-1, i, diff, 0);
}

void updateValueUtil(int *st, int ss, int se, int i, int diff, int si)
{
    if (i &lt; ss || i &gt; se)
        return;

    st[si] = st[si] + diff;
    if (se != ss)
    {
        int mid = getMid(ss, se);
        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);
        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);
    }
}

int main()
{
    int arr[] = {1, 3, 5, 7, 9, 11};
    int n = sizeof(arr)/sizeof(arr[0]);

    int *st = constructST(arr, n);

    cout&lt;&lt;&quot;Sum of values in given range = &quot;&lt;&lt;getSum(st, n, 1, 3)&lt;&lt;endl;

    updateValue(arr, st, n, 1, 10);

    cout&lt;&lt;&quot;Updated sum of values in given range = &quot;
            &lt;&lt;getSum(st, n, 1, 3)&lt;&lt;endl;
    return 0;
}</pre><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMid</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> </span>{ <span class="hljs-keyword">return</span> s + (e -s)/<span class="hljs-number">2</span>; }

<span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">constructST</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>
</span>{
    <span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>)(<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(n)));
    <span class="hljs-type">int</span> max_size = <span class="hljs-number">2</span>*(<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, x) - <span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> *st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[max_size];

    <span class="hljs-built_in">constructSTUtil</span>(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, st, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">return</span> st;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">constructSTUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> *st, <span class="hljs-type">int</span> si)</span>
</span>{
    <span class="hljs-keyword">if</span> (ss == se)
    {
        st[si] = arr[ss];
        <span class="hljs-keyword">return</span> arr[ss];
    }

    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">getMid</span>(ss, se);
    st[si] = <span class="hljs-built_in">constructSTUtil</span>(arr, ss, mid, st, si*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>) +
            <span class="hljs-built_in">constructSTUtil</span>(arr, mid+<span class="hljs-number">1</span>, se, st, si*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> st[si];
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> *st, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> qs, <span class="hljs-type">int</span> qe)</span>
</span>{
    <span class="hljs-keyword">if</span> (qs &lt; <span class="hljs-number">0</span> || qe &gt; n<span class="hljs-number">-1</span> || qs &gt; qe)
    {
        cout&lt;&lt;<span class="hljs-string">&quot;Invalid Input&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getSumUtil</span>(st, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, qs, qe, <span class="hljs-number">0</span>);
}

<span class="hljs-comment">//  st : segment tree</span>
<span class="hljs-comment">// si : current node&#x27;s index in array</span>
<span class="hljs-comment">// ss, se :  当前node代表的  range</span>
<span class="hljs-comment">// qs, qe :  query range</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSumUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> *st, <span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> qs, <span class="hljs-type">int</span> qe, <span class="hljs-type">int</span> si)</span>
</span>{
    <span class="hljs-keyword">if</span> (qs &lt;= ss &amp;&amp; qe &gt;= se)
        <span class="hljs-keyword">return</span> st[si];

    <span class="hljs-keyword">if</span> (se &lt; qs || ss &gt; qe)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">getMid</span>(ss, se);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getSumUtil</span>(st, ss, mid, qs, qe, <span class="hljs-number">2</span>*si+<span class="hljs-number">1</span>) +
        <span class="hljs-built_in">getSumUtil</span>(st, mid+<span class="hljs-number">1</span>, se, qs, qe, <span class="hljs-number">2</span>*si+<span class="hljs-number">2</span>);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateValue</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> *st, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> new_val)</span>
</span>{
    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; n<span class="hljs-number">-1</span>)
    {
        cout&lt;&lt;<span class="hljs-string">&quot;Invalid Input&quot;</span>;
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-type">int</span> diff = new_val - arr[i];

    arr[i] = new_val;             <span class="hljs-comment">//  这个是arr，  下面更新的是  st。  ok的。</span>

    <span class="hljs-built_in">updateValueUtil</span>(st, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, i, diff, <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateValueUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> *st, <span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> diff, <span class="hljs-type">int</span> si)</span>
</span>{
    <span class="hljs-keyword">if</span> (i &lt; ss || i &gt; se)
        <span class="hljs-keyword">return</span>;

    st[si] = st[si] + diff;
    <span class="hljs-keyword">if</span> (se != ss)
    {
        <span class="hljs-type">int</span> mid = <span class="hljs-built_in">getMid</span>(ss, se);
        <span class="hljs-built_in">updateValueUtil</span>(st, ss, mid, i, diff, <span class="hljs-number">2</span>*si + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">updateValueUtil</span>(st, mid+<span class="hljs-number">1</span>, se, i, diff, <span class="hljs-number">2</span>*si + <span class="hljs-number">2</span>);
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> arr[] = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>};
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(arr)/<span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);

    <span class="hljs-type">int</span> *st = <span class="hljs-built_in">constructST</span>(arr, n);

    cout&lt;&lt;<span class="hljs-string">&quot;Sum of values in given range = &quot;</span>&lt;&lt;<span class="hljs-built_in">getSum</span>(st, n, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)&lt;&lt;endl;

    <span class="hljs-built_in">updateValue</span>(arr, st, n, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>);

    cout&lt;&lt;<span class="hljs-string">&quot;Updated sum of values in given range = &quot;</span>
            &lt;&lt;<span class="hljs-built_in">getSum</span>(st, n, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)&lt;&lt;endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<hr>
<p><a data-from-md title='https://www.geeksforgeeks.org/segment-tree-efficient-implementation/' href='https://www.geeksforgeeks.org/segment-tree-efficient-implementation/'>https://www.geeksforgeeks.org/segment-tree-efficient-implementation/</a><br>
考虑如下问题  来理解  segment tree，  不使用递归。<br>
。。不使用递归的意思是，construct，update，query segment tree  的时候  不是  递归的。</p>
<p>有一个数组  arr[0  … n-1]。我们需要做到：</p>
<ol>
<li>计算  [l, r]  区间内的  元素  和</li>
<li>修改某个元素的值</li>
</ol>
<p>方案</p>
<ol>
<li>每次遍历[l, r]  区间来计算  sum，  这样的话，上面的第一个操作是  O(n)，  第二个操作是  O(1)。</li>
<li>创建数组来保存  从  i开始的后缀数组的和。  第一个操作是  O(1)，  第二个操作是  O(n)。</li>
<li>有没有一种  都是  O(logn)  的呢？  我们可以使用  segment tree</li>
</ol>
<p>考虑下面的数组和  segment tree</p>
<p>。。注意这里  下标是从  1  开始的。</p>
<p><img src="../_resources/f282e8106f02a278a91349416e2b3e3e.png" alt="1"></p>
<p>可以看到  原始数组  在底部，是一个下标从0开始的  16个元素  组成的arr。<br>
树一共有31个node，叶子节点(保存了原始数组的元素)  从  node16  开始。<br>
所以我们可以方便地  使用  2*N  大小的  数组  来构造  segment tree (N  是  原始数组的长度)。</p>
<p>叶子节点从  数组的下标N  开始，到  2*N - 1  结束。  因此，原数组  下标为  i的元素，在  segment tree  中  下标是  N + i。</p>
<p>现在来计算child(原文是parent)，  我们从下标  N  - 1  开始，向前移动。</p>
<p>对于  下标  i，left child  会在  2<em>i，right child  会在  2</em>i+1。  所以  2<em>i  和  2</em>i+1  的  node  上的值  被组合到  node i  上。</p>
<p>在上图中，我们可以查询  [l, r)  的区间。<br>
我们将使用  位运算  来实现这些  乘法和加法。</p>
<h2 id="segment-tree-impl2">segment tree impl2</h2>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 100000;
int n; // array size
int tree[2 * N];

void build( int arr[])
{
    // 添加原数组
    for (int i=0; i&lt;n; i++)
        tree[n+i] = arr[i];

    // 通过计算child  来merge，注意下标从  1  开始。不然  0  &lt;&lt; 1  还是0  。。
    //  这里原文是  build the tree by calculating parents
    //           但是这里是  已知parent  为  i，计算child  啊。
    for (int i = n - 1; i &gt; 0; --i)
        tree[i] = tree[i&lt;&lt;1] + tree[i&lt;&lt;1 | 1];
}

void updateTreeNode(int p, int value)
{
    //  先写  p  += n  不好么。
    tree[p+n] = value;
    p = p+n;

    //  i^1  是  找到  和  i配对的那个，可能大于，可能小于。
    //  因为  parent  是  i&gt;&gt;1,  所以  child  是  (i&gt;&gt;1)&lt;&lt;1  和  ((i&gt;&gt;1)&lt;&lt;1)+1
    //                这2个值  和  i，i^1  是相同集合
    for (int i=p; i  &gt;  1; i &gt;&gt;= 1)
        tree[i&gt;&gt;1] = tree[i] + tree[i^1];
}

// function to get sum on interval [l, r)
int query(int l, int r)
{
    int res = 0;

    //  l  和  r  变成  segment tree  中的  叶子节点  的下标
    //  如果  &amp;1 == true，说明  &gt;&gt;1  时会被  舍弃，所以需要  +
    //  注意  先用  l，然后  + 1。  先-1，然后用  r
    //  先-1，  然后r  是因为  [l, r)
    //  还有  root  下标是1，  child  是  xxx0, xxx1  是成对出现的。
    //  所以当  l&amp;1  时，说明  左侧多了一个  不成匹配的  单个值  xxx1，所以  先+上，然后  从range中  移除这个  单个值
    //  当  r&amp;1  时，  说明右侧多了一个  不成匹配的  单个值  xxx0，  所以  加上这个0。
    for (l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)
    {
        if (l&amp;1)
        res += tree[l++];
        if (r&amp;1)
        res += tree[--r];
    }

    return res;
}

int main()
{
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    n = sizeof(a)/sizeof(a[0]);

    build(a);

    cout &lt;&lt; query(1, 3)&lt;&lt;endl;

    updateTreeNode(2, 1);

    cout &lt;&lt; query(1, 3)&lt;&lt;endl;

    return 0;
}</pre><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000</span>;
<span class="hljs-type">int</span> n; <span class="hljs-comment">// array size</span>
<span class="hljs-type">int</span> tree[<span class="hljs-number">2</span> * N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">( <span class="hljs-type">int</span> arr[])</span>
</span>{
    <span class="hljs-comment">// 添加原数组</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)
        tree[n+i] = arr[i];

    <span class="hljs-comment">// 通过计算child  来merge，注意下标从  1  开始。不然  0  &lt;&lt; 1  还是0  。。</span>
    <span class="hljs-comment">//  这里原文是  build the tree by calculating parents</span>
    <span class="hljs-comment">//           但是这里是  已知parent  为  i，计算child  啊。</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i)
        tree[i] = tree[i&lt;&lt;<span class="hljs-number">1</span>] + tree[i&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>];
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateTreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> value)</span>
</span>{
    <span class="hljs-comment">//  先写  p  += n  不好么。</span>
    tree[p+n] = value;
    p = p+n;

    <span class="hljs-comment">//  i^1  是  找到  和  i配对的那个，可能大于，可能小于。</span>
    <span class="hljs-comment">//  因为  parent  是  i&gt;&gt;1,  所以  child  是  (i&gt;&gt;1)&lt;&lt;1  和  ((i&gt;&gt;1)&lt;&lt;1)+1</span>
    <span class="hljs-comment">//                这2个值  和  i，i^1  是相同集合</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=p; i  &gt;  <span class="hljs-number">1</span>; i &gt;&gt;= <span class="hljs-number">1</span>)
        tree[i&gt;&gt;<span class="hljs-number">1</span>] = tree[i] + tree[i^<span class="hljs-number">1</span>];
}

<span class="hljs-comment">// function to get sum on interval [l, r)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>
</span>{
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//  l  和  r  变成  segment tree  中的  叶子节点  的下标</span>
    <span class="hljs-comment">//  如果  &amp;1 == true，说明  &gt;&gt;1  时会被  舍弃，所以需要  +</span>
    <span class="hljs-comment">//  注意  先用  l，然后  + 1。  先-1，然后用  r</span>
    <span class="hljs-comment">//  先-1，  然后r  是因为  [l, r)</span>
    <span class="hljs-comment">//  还有  root  下标是1，  child  是  xxx0, xxx1  是成对出现的。</span>
    <span class="hljs-comment">//  所以当  l&amp;1  时，说明  左侧多了一个  不成匹配的  单个值  xxx1，所以  先+上，然后  从range中  移除这个  单个值</span>
    <span class="hljs-comment">//  当  r&amp;1  时，  说明右侧多了一个  不成匹配的  单个值  xxx0，  所以  加上这个0。</span>
    <span class="hljs-keyword">for</span> (l += n, r += n; l &lt; r; l &gt;&gt;= <span class="hljs-number">1</span>, r &gt;&gt;= <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span> (l&amp;<span class="hljs-number">1</span>)
        res += tree[l++];
        <span class="hljs-keyword">if</span> (r&amp;<span class="hljs-number">1</span>)
        res += tree[--r];
    }

    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a[] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>};
    n = <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]);

    <span class="hljs-built_in">build</span>(a);

    cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)&lt;&lt;endl;

    <span class="hljs-built_in">updateTreeNode</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);

    cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)&lt;&lt;endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<hr>
<p><a data-from-md title='https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/' href='https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/'>https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/</a></p>
<p>在第一个  sum of range  的  segment  tree  中，update方法  用来更新  数组中的一个值，这个update  会导致  segment tree  中的  多次更新，因为  被更新的值  在  segment  tree  的node  的range  中。</p>
<p>下面的简单的逻辑</p>
<ol>
<li>从  segment tree  的root  开始。</li>
<li>如果  被更新的值  不在  node  的range  中，则return</li>
<li>如果在  range中，则  更新node，并且  递归  children。</li>
</ol>
<p>下面是  第一个  sum of range  中使用的  update  代码</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void updateValueUtil(int tree[], int ss, int se, int i,  int diff, int si)
{
    if (i &lt; ss || i &gt; se)
        return;

    st[si] = st[si] + diff;
    if (se != ss)
    {
        int mid = getMid(ss, se);
        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);
        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateValueUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> tree[], <span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> i,  <span class="hljs-type">int</span> diff, <span class="hljs-type">int</span> si)</span>
</span>{
    <span class="hljs-keyword">if</span> (i &lt; ss || i &gt; se)
        <span class="hljs-keyword">return</span>;

    st[si] = st[si] + diff;
    <span class="hljs-keyword">if</span> (se != ss)
    {
        <span class="hljs-type">int</span> mid = <span class="hljs-built_in">getMid</span>(ss, se);
        <span class="hljs-built_in">updateValueUtil</span>(st, ss, mid, i, diff, <span class="hljs-number">2</span>*si + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">updateValueUtil</span>(st, mid+<span class="hljs-number">1</span>, se, i, diff, <span class="hljs-number">2</span>*si + <span class="hljs-number">2</span>);
    }
}</code></pre></div>
<p>如果update  是对于  一段下标range  进行的，该怎么处理？<br>
例如，对于  下标  2  到  7  的元素  全部  + 10。<br>
上面的代码  会对  每个下标  调用  update操作。  我们可以避免  多次调用，  通过  编写一个  updateRange()  方法</p>
<p>。。是range内全部加一个固定值。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">// si  是  segment tree  中的  当前节点
// ss，se，是  当前node  存储的  原数组元素  下标的  起止
//  us，ue，update  range  的起止
// diff，update  range中  每个元素的  add  的值。
void updateRangeUtil(int si, int ss, int se, int us,  int ue, int diff)
{
    // out of range
    if (ss&gt;se || ss&gt;ue || se&lt;us)
        return ;

    // Current node is a leaf node
    if (ss==se)
    {
        // Add the difference to current node
        tree[si] += diff;
        return;
    }

    // If not a leaf node, recur for children.
    int mid = (ss+se)/2;
    updateRangeUtil(si*2+1, ss, mid, us, ue, diff);
    updateRangeUtil(si*2+2, mid+1, se, us, ue, diff);

    // Use the result of children calls to update this
    // node
    tree[si] = tree[si*2+1] + tree[si*2+2];
}</pre><pre class="hljs"><code><span class="hljs-comment">// si  是  segment tree  中的  当前节点</span>
<span class="hljs-comment">// ss，se，是  当前node  存储的  原数组元素  下标的  起止</span>
<span class="hljs-comment">//  us，ue，update  range  的起止</span>
<span class="hljs-comment">// diff，update  range中  每个元素的  add  的值。</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateRangeUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> si, <span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> us,  <span class="hljs-type">int</span> ue, <span class="hljs-type">int</span> diff)</span>
</span>{
    <span class="hljs-comment">// out of range</span>
    <span class="hljs-keyword">if</span> (ss&gt;se || ss&gt;ue || se&lt;us)
        <span class="hljs-keyword">return</span> ;

    <span class="hljs-comment">// Current node is a leaf node</span>
    <span class="hljs-keyword">if</span> (ss==se)
    {
        <span class="hljs-comment">// Add the difference to current node</span>
        tree[si] += diff;
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// If not a leaf node, recur for children.</span>
    <span class="hljs-type">int</span> mid = (ss+se)/<span class="hljs-number">2</span>;
    <span class="hljs-built_in">updateRangeUtil</span>(si*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, ss, mid, us, ue, diff);
    <span class="hljs-built_in">updateRangeUtil</span>(si*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>, mid+<span class="hljs-number">1</span>, se, us, ue, diff);

    <span class="hljs-comment">// Use the result of children calls to update this</span>
    <span class="hljs-comment">// node</span>
    tree[si] = tree[si*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] + tree[si*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>];
}</code></pre></div>
<h2 id="lazy-propagation-an-optimization-to-make-range-updates-faster">Lazy  Propagation  –  An optimization to make range updates faster</h2>
<p>当有许多update  range时，我们可以  推迟一些  update  (避免  update的  递归调用)，只有在需要时  才执行  update</p>
<p>segment tree  中的  node  保存了  对index  range  的  query  的结果。<br>
如果  node  的  range  在  update操作的range  的内部，那么  这个  node  的所有  后代都需要被  update。</p>
<p>例如，一个node  保存了  下标3-5的sum，那么  如果有一个  update range  是2-5，那么  这个node  和它所有后代node  都要被更新。</p>
<p>使用  lazy propagation，我们只更新  这个node，推迟  对这个node的后代node  的update，通过  保存  update info  到  单独的  被称为  lazy node  的  节点。</p>
<p>我们创建一个  lazy[]  来表示  lazy node。  长度  和  segment tree  的  数组的长度一样。</p>
<p>初始化为  全0。lazy[i]  == 0  意味着  node i  没有  待执行的  update。  非0  意味者  对这个节点的  任何查询之前  需要把  这个值  加到  节点  i上。</p>
<p>更新us  到  ue  的值</p>
<ol>
<li>如果当前 node  有待执行的  update，那么把  待执行的update  加到  当前node。</li>
<li>如果当前node  的range  完全包含于  update range
<ol>
<li>更新当前node</li>
<li>推迟  对child  的update，通过设置  child  node  的  lazy value。</li>
</ol>
</li>
<li>如果当前node  的range  和  update range  有  重叠
<ol>
<li>递归  left，  right child</li>
<li>使用 left，  right  返回的值，更新  当前  node  的值。</li>
</ol>
</li>
</ol>
<p>query方法  是否有变化？<br>
由于  我们修改了  update  方法  来延迟，如果对  还没有update  的  node  进行query  会出现问题。</p>
<p>所以我们需要  修改  query  方法。现在的  getSumUtil  方法  先检查  是否有  待执行的  update，如果有，那么update  node，在  update  执行完后，  就和  之前的getSumUtil  一样。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define MAX 1000

int tree[MAX] = {0}; // To store segment tree
int lazy[MAX] = {0}; // To store pending updates

// si：当前node  在  segment tree  的array表达  中的index
// ss，se，当前node  存储的  元素下标的  start  和  end
// us，ue，update  range  的  start  和  end
// diff，我们需要add  到  us  到  ue  的  值。
void updateRangeUtil(int si, int ss, int se, int us,  int ue, int diff)
{
//  如果当前node  的  lazy value  非0，那么说明  存在  待执行的  update。
//  所以我们要确保  在  新update  前，待执行的  update  被执行完。  因为  本节点的值  会被  parent  用到。
//  (看这个方法的  最后一行，用到了child  的  值，所以  本节点的parent  会用到  本节点的值)
if (lazy[si] != 0)
{
//  当前节点上  执行  待执行的  update。
tree[si] += (se-ss+1)*lazy[si];

//  如果有child，需要把  lazy  的值  下放到  child上。
if (ss != se)
{
lazy[si*2 + 1] += lazy[si];
lazy[si*2 + 2] += lazy[si];
}

lazy[si] = 0;
}

// out of range  //  这行怎么不是  第一行。。
if (ss&gt;se || ss&gt;ue || se&lt;us)
return ;

//  。觉得不太对啊。
//  首先  out of range  应该是第一行。
//  第二，应该先判断  是否被完全覆盖，然后  检查  lazy[si]吧。

//  假设  lazy[si]  不为0，如果  si  依然被  update range  完全覆盖，  并不需要  执行  pending的update  啊。  只需要把  本次的  diff  在  加到  lazy[si]  上就可以了啊。

//  ？这里多做了一层(就是  diff  保存到  本node  就可以了，  但是这里保存到了  child  上。)。  不知道有什么含义。
//

//  这里是为了  query  的时候，因为  照这里的写法，  query  的时候  只需要  判断  lazy[si]  是否为0，  为0  ，就可以直接取  tree[si]，然后返回。

//  如果diff  保存到  本节点，  那么在  query  的时候  就需要  执行这里的  部分操作：把  diff  的值  *  range size，加到  tree[si]  上，然后  把  diff  保存到  child  上，然后返回。

//  不够lazy啊。  可能只有  update，没有query。。
//

//  不，不能延迟到  query时，  因为这里  最下面  使用了  tree[left-child]  + tree[right-child]  来更新自己  。  所以  只要进入了这个  方法，就必须确保  tree[si]  是最新的，  不然  退出这个方法，回到  上层，  tree[child]  不是最新的，会导致  tree[si]  错误。

//  当前node  被  update range  完全覆盖。
if (ss&gt;=us &amp;&amp; se&lt;=ue)
{
// Add the difference to current node
tree[si] += (se-ss+1)*diff;

// same logic for checking leaf node or not
if (ss != se)
{
lazy[si*2 + 1] += diff;
lazy[si*2 + 2] += diff;
}
return;
}

//  剩下的清空：  被部分覆盖。
int mid = (ss+se)/2;
updateRangeUtil(si*2+1, ss, mid, us, ue, diff);
updateRangeUtil(si*2+2, mid+1, se, us, ue, diff);

//  使用child  的值  来更新自己
tree[si] = tree[si*2+1] + tree[si*2+2];
}

// us，ue，update  range  的  start，end
void updateRange(int n, int us, int ue, int diff)
{
updateRangeUtil(0, 0, n-1, us, ue, diff);
}

// si，当前node  在  segment tree  中的index，最初传0进来，因为root的index  是0
//  ss，se，当前node  代表的  index  的  start  和  end
// qs，qe，query  range  的  start  和  end
int getSumUtil(int ss, int se, int qs, int qe, int si)
{
//  如果  当前node  有  pending  的update，需要确保在  query  前，执行完  pending  的  update
if (lazy[si] != 0)
{
tree[si] += (se-ss+1)*lazy[si];
if (ss != se)
{
lazy[si*2+1] += lazy[si];
lazy[si*2+2] += lazy[si];
}
lazy[si] = 0;
}

// Out of range
if (ss&gt;se || ss&gt;qe || se&lt;qs)
return 0;

// 当前node  的range  被query  range  覆盖
if (ss&gt;=qs &amp;&amp; se&lt;=qe)
return tree[si];

int mid = (ss + se)/2;
return getSumUtil(ss, mid, qs, qe, 2*si+1) +
getSumUtil(mid+1, se, qs, qe, 2*si+2);
}

int getSum(int n, int qs, int qe)
{
if (qs &lt; 0 || qe &gt; n-1 || qs &gt; qe)
{
printf(&quot;Invalid Input&quot;);
return -1;
}

return getSumUtil(0, n-1, qs, qe, 0);
}

//  为[ss, se]  subarr  构造  segment tree，节点是  si。
void constructSTUtil(int arr[], int ss, int se, int si)
{
// out of range as ss can never be greater than se
if (ss &gt; se)
return ;

if (ss == se)
{
tree[si] = arr[ss];
return;
}

int mid = (ss + se)/2;
constructSTUtil(arr, ss, mid, si*2+1);
constructSTUtil(arr, mid+1, se, si*2+2);

tree[si] = tree[si*2 + 1] + tree[si*2 + 2];
}

void constructST(int arr[], int n)
{
constructSTUtil(arr, 0, n-1, 0);
}

int main()
{
int arr[] = {1, 3, 5, 7, 9, 11};
int n = sizeof(arr)/sizeof(arr[0]);

constructST(arr, n);

printf(&quot;Sum of values in given range = %d\n&quot;,
getSum(n, 1, 3));

updateRange(n, 1, 5, 10);

printf(&quot;Updated sum of values in given range = %d\n&quot;,
getSum( n, 1, 3));

return 0;
}</pre><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000</span>

<span class="hljs-type">int</span> tree[MAX] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// To store segment tree</span>
<span class="hljs-type">int</span> lazy[MAX] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// To store pending updates</span>

<span class="hljs-comment">// si：当前node  在  segment tree  的array表达  中的index</span>
<span class="hljs-comment">// ss，se，当前node  存储的  元素下标的  start  和  end</span>
<span class="hljs-comment">// us，ue，update  range  的  start  和  end</span>
<span class="hljs-comment">// diff，我们需要add  到  us  到  ue  的  值。</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateRangeUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> si, <span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> us,  <span class="hljs-type">int</span> ue, <span class="hljs-type">int</span> diff)</span>
</span>{
<span class="hljs-comment">//  如果当前node  的  lazy value  非0，那么说明  存在  待执行的  update。</span>
<span class="hljs-comment">//  所以我们要确保  在  新update  前，待执行的  update  被执行完。  因为  本节点的值  会被  parent  用到。</span>
<span class="hljs-comment">//  (看这个方法的  最后一行，用到了child  的  值，所以  本节点的parent  会用到  本节点的值)</span>
<span class="hljs-keyword">if</span> (lazy[si] != <span class="hljs-number">0</span>)
{
<span class="hljs-comment">//  当前节点上  执行  待执行的  update。</span>
tree[si] += (se-ss+<span class="hljs-number">1</span>)*lazy[si];

<span class="hljs-comment">//  如果有child，需要把  lazy  的值  下放到  child上。</span>
<span class="hljs-keyword">if</span> (ss != se)
{
lazy[si*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += lazy[si];
lazy[si*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>] += lazy[si];
}

lazy[si] = <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// out of range  //  这行怎么不是  第一行。。</span>
<span class="hljs-keyword">if</span> (ss&gt;se || ss&gt;ue || se&lt;us)
<span class="hljs-keyword">return</span> ;

<span class="hljs-comment">//  。觉得不太对啊。</span>
<span class="hljs-comment">//  首先  out of range  应该是第一行。</span>
<span class="hljs-comment">//  第二，应该先判断  是否被完全覆盖，然后  检查  lazy[si]吧。</span>

<span class="hljs-comment">//  假设  lazy[si]  不为0，如果  si  依然被  update range  完全覆盖，  并不需要  执行  pending的update  啊。  只需要把  本次的  diff  在  加到  lazy[si]  上就可以了啊。</span>

<span class="hljs-comment">//  ？这里多做了一层(就是  diff  保存到  本node  就可以了，  但是这里保存到了  child  上。)。  不知道有什么含义。</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">//  这里是为了  query  的时候，因为  照这里的写法，  query  的时候  只需要  判断  lazy[si]  是否为0，  为0  ，就可以直接取  tree[si]，然后返回。</span>

<span class="hljs-comment">//  如果diff  保存到  本节点，  那么在  query  的时候  就需要  执行这里的  部分操作：把  diff  的值  *  range size，加到  tree[si]  上，然后  把  diff  保存到  child  上，然后返回。</span>

<span class="hljs-comment">//  不够lazy啊。  可能只有  update，没有query。。</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">//  不，不能延迟到  query时，  因为这里  最下面  使用了  tree[left-child]  + tree[right-child]  来更新自己  。  所以  只要进入了这个  方法，就必须确保  tree[si]  是最新的，  不然  退出这个方法，回到  上层，  tree[child]  不是最新的，会导致  tree[si]  错误。</span>

<span class="hljs-comment">//  当前node  被  update range  完全覆盖。</span>
<span class="hljs-keyword">if</span> (ss&gt;=us &amp;&amp; se&lt;=ue)
{
<span class="hljs-comment">// Add the difference to current node</span>
tree[si] += (se-ss+<span class="hljs-number">1</span>)*diff;

<span class="hljs-comment">// same logic for checking leaf node or not</span>
<span class="hljs-keyword">if</span> (ss != se)
{
lazy[si*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += diff;
lazy[si*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>] += diff;
}
<span class="hljs-keyword">return</span>;
}

<span class="hljs-comment">//  剩下的清空：  被部分覆盖。</span>
<span class="hljs-type">int</span> mid = (ss+se)/<span class="hljs-number">2</span>;
<span class="hljs-built_in">updateRangeUtil</span>(si*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, ss, mid, us, ue, diff);
<span class="hljs-built_in">updateRangeUtil</span>(si*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>, mid+<span class="hljs-number">1</span>, se, us, ue, diff);

<span class="hljs-comment">//  使用child  的值  来更新自己</span>
tree[si] = tree[si*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] + tree[si*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>];
}

<span class="hljs-comment">// us，ue，update  range  的  start，end</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateRange</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> us, <span class="hljs-type">int</span> ue, <span class="hljs-type">int</span> diff)</span>
</span>{
<span class="hljs-built_in">updateRangeUtil</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, us, ue, diff);
}

<span class="hljs-comment">// si，当前node  在  segment tree  中的index，最初传0进来，因为root的index  是0</span>
<span class="hljs-comment">//  ss，se，当前node  代表的  index  的  start  和  end</span>
<span class="hljs-comment">// qs，qe，query  range  的  start  和  end</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSumUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> qs, <span class="hljs-type">int</span> qe, <span class="hljs-type">int</span> si)</span>
</span>{
<span class="hljs-comment">//  如果  当前node  有  pending  的update，需要确保在  query  前，执行完  pending  的  update</span>
<span class="hljs-keyword">if</span> (lazy[si] != <span class="hljs-number">0</span>)
{
tree[si] += (se-ss+<span class="hljs-number">1</span>)*lazy[si];
<span class="hljs-keyword">if</span> (ss != se)
{
lazy[si*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += lazy[si];
lazy[si*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>] += lazy[si];
}
lazy[si] = <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// Out of range</span>
<span class="hljs-keyword">if</span> (ss&gt;se || ss&gt;qe || se&lt;qs)
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

<span class="hljs-comment">// 当前node  的range  被query  range  覆盖</span>
<span class="hljs-keyword">if</span> (ss&gt;=qs &amp;&amp; se&lt;=qe)
<span class="hljs-keyword">return</span> tree[si];

<span class="hljs-type">int</span> mid = (ss + se)/<span class="hljs-number">2</span>;
<span class="hljs-keyword">return</span> <span class="hljs-built_in">getSumUtil</span>(ss, mid, qs, qe, <span class="hljs-number">2</span>*si+<span class="hljs-number">1</span>) +
<span class="hljs-built_in">getSumUtil</span>(mid+<span class="hljs-number">1</span>, se, qs, qe, <span class="hljs-number">2</span>*si+<span class="hljs-number">2</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> qs, <span class="hljs-type">int</span> qe)</span>
</span>{
<span class="hljs-keyword">if</span> (qs &lt; <span class="hljs-number">0</span> || qe &gt; n<span class="hljs-number">-1</span> || qs &gt; qe)
{
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid Input&quot;</span>);
<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-keyword">return</span> <span class="hljs-built_in">getSumUtil</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, qs, qe, <span class="hljs-number">0</span>);
}

<span class="hljs-comment">//  为[ss, se]  subarr  构造  segment tree，节点是  si。</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">constructSTUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> ss, <span class="hljs-type">int</span> se, <span class="hljs-type">int</span> si)</span>
</span>{
<span class="hljs-comment">// out of range as ss can never be greater than se</span>
<span class="hljs-keyword">if</span> (ss &gt; se)
<span class="hljs-keyword">return</span> ;

<span class="hljs-keyword">if</span> (ss == se)
{
tree[si] = arr[ss];
<span class="hljs-keyword">return</span>;
}

<span class="hljs-type">int</span> mid = (ss + se)/<span class="hljs-number">2</span>;
<span class="hljs-built_in">constructSTUtil</span>(arr, ss, mid, si*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);
<span class="hljs-built_in">constructSTUtil</span>(arr, mid+<span class="hljs-number">1</span>, se, si*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);

tree[si] = tree[si*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] + tree[si*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>];
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">constructST</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>
</span>{
<span class="hljs-built_in">constructSTUtil</span>(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-type">int</span> arr[] = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>};
<span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(arr)/<span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);

<span class="hljs-built_in">constructST</span>(arr, n);

<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sum of values in given range = %d\n&quot;</span>,
<span class="hljs-built_in">getSum</span>(n, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>));

<span class="hljs-built_in">updateRange</span>(n, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);

<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Updated sum of values in given range = %d\n&quot;</span>,
<span class="hljs-built_in">getSum</span>( n, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>));

<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<hr>
<p><a data-from-md title='https://www.geeksforgeeks.org/persistent-segment-tree-set-1-introduction' href='https://www.geeksforgeeks.org/persistent-segment-tree-set-1-introduction'>https://www.geeksforgeeks.org/persistent-segment-tree-set-1-introduction</a></p>
<h2 id="persistent-segment-tree">Persistent Segment Tree</h2>
<p>把segment  tree  进行持久化，这样可以查看  各个  update  前的  情况。</p>
<p>struct node<br>
{<br>
    int val;</p>
<p>node* left, *right;</p>
<p>node() {}<br>
    node(node* l, node* r, int v)<br>
    {<br>
        left = l;<br>
        right = r;<br>
        val = v;<br>
    }<br>
};</p>
<p>// input array<br>
int arr[MAXN];</p>
<p>// root pointers for all versions<br>
node* version[MAXN];</p>
<p>每次更新原数组的一个元素，segment  tree  会修改  logN  个节点，所以  每次update  都  新建  logN  个节点，保存为  version。</p>
<p>。。代码没有复制。</p>
<p>===================================<br>
主席树</p>
<p>。。就是上面的  Persistent Segment Tree</p>
<p>===================================<br>
树状数组</p>
<p><a data-from-md title='https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/' href='https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/'>https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/</a></p>
<h1 id="binary-indexed-tree-or-fenwick-tree">Binary Indexed Tree or Fenwick Tree</h1>
<p>考虑下面的问题  来理解  binary  indexed  tree。<br>
我们有  一个数组  arr[0 .. n-1]，  我们希望：</p>
<ol>
<li>计算  前  i个元素的  sum</li>
<li>修改某个元素的值</li>
</ol>
<p>方案</p>
<ol>
<li>不做任何预处理，query的时候  遍历前  i个</li>
<li>prefix  sum，update的时候需要遍历  i后的元素</li>
</ol>
<p>我们能做到  query  和  update  都是  O(logn)  吗？<br>
一种有效的方法是  segment tree。  它的  query  和  update  都是  O(logn)。</p>
<p>另一种方法是  Binary Indexed Tree，query  和  update  也是  O(logn)。相比  segment tree，BIT  需要更少的空间，更容易实现。</p>
<p>BIT使用数组来表达。假设数组是  BITree[]，每个  BIT  的节点  保存了  原数组的  一些元素的  sum。  BIT数组的  长度等于  原数组。</p>
<p>构造<br>
我们初始化  BITree  数组中的  每个元素为0。  然后  对每个下标  调用  update  方法。</p>
<p>操作<br>
getSum(x)：  返回  子数组  [0 .. x]  的  sum。</p>
<p>//  使用  通过  原数组arr[0..n-1]  构造的  BITree[0..n]  来  计算  原数组[0..x]  的sum</p>
<ol>
<li>
<p>初始化  sum  为0，当前index  为  x + 1</p>
</li>
<li>
<p>当  当前index  &gt; 0  时，做：</p>
<ol>
<li>增加BITree[index]  到  sum</li>
<li>移动到  BITree[index]  的  parent，parent可以通过  移除  当前index  的二进制的  最后一个  1  来  获得。如，index  = index  -  (index &amp; (-index))</li>
</ol>
</li>
<li>
<p>返回  sum</p>
</li>
</ol>
<p><img src="../_resources/06507cb2e42293e05a349c991c9ecdad.png" alt="BITSum"></p>
<p>BITree[0]  是  dummy  node。</p>
<p>BITree[y]  是  BITree[x]  的parent，  当且仅当  y  可以通过  移除  x的二进制的  最后一个  1  而获得，即  y  = x  -  (x &amp; (-x))。</p>
<p>BITree[y]  的  child node BITree[x]  保存了  [y,  x)  的sum</p>
<p>update(x, val)  ：  更新BIT，通过执行  arr[index] += val<br>
//  注意，update(x, val)  不会修改  arr[]，只修改  BITree[]。</p>
<ol>
<li>初始化当前index  为  x + 1</li>
<li>当  当前index  &lt;= n  时，执行：
<ol>
<li>
<p>增加val  到  BITree[index]</p>
</li>
<li>
<p>移动到  BITree[index]  的  下一个元素，下一个元素可以通过   增加  当前index  的  最后一个  bit 1  来  实现，如，  index = index  +  (index &amp; (-index))</p>
</li>
</ol>
</li>
</ol>
<p><img src="../_resources/c775c760d6d777d1c5c3ebc2707a4c6a.png" alt="BITUpdate1"></p>
<p>。。。<br>
10 = 8 + 2<br>
00001010</p>
<p>-10<br>
11110101<br>
11110110</p>
<p>&amp; = 0000 0010<br>
。。。</p>
<p>。。  下标的顺序是  树的后续遍历。</p>
<p>How does Binary Indexed Tree work?</p>
<p>原理是基于  一个事实：所有正数  都可以  表达为  2的次方的  和。<br>
例如，19  可以表达为  16 + 2 + 1。<br>
BITree  中的  每个  node  保存了  n个元素的  和  (n  是  2的次方)</p>
<p>例如，在第一张图中(getSum  的图)，前12个元素的  sum  可以通过  最后4个元素(9-12) +  上  第8个元素(从1-8)  来获得。</p>
<p>数字n  的二进制  的  bit  数量  是  O(logn)。因此，我们  遍历最多  O(logn)  个node，  在  getSum  和  update  操作中。  构造BITree  的复杂度是  O(nlogn)，因为它  对每个  元素  调用一次  update()。</p>
<h2 id="bit-impl-index-start-from-1">BIT impl (index start from 1)</h2>
<p>下面是BIT的实现</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">#include &lt;iostream&gt;
using namespace std;

// n：input array 的 元素个数
// BITree[0..n]，BIT的数组形式
// arr[0..n-1]，input array
int getSum(int BITree[], int index)
{
    int sum = 0;

// BITree 中的下标 比 arr 中的下标 多1
    index = index + 1;

    while (index&gt;0)
    {
        sum += BITree[index];
        index -= index &amp; (-index);
    }
    return sum;
}

void updateBIT(int BITree[], int n, int index, int val)
{
    // BITree 比 arr 的下标 多 1
    index = index + 1;

    while (index &lt;= n)
    {
        BITree[index] += val;
        index += index &amp; (-index);
    }
}

int *constructBITree(int arr[], int n)
{
    int *BITree = new int[n+1];
    for (int i=1; i&lt;=n; i++)
        BITree[i] = 0;

    // Store the actual values in BITree[] using update()
    for (int i=0; i&lt;n; i++)
        updateBIT(BITree, n, i, arr[i]);

    return BITree;
}


// Driver program to test above functions
int main()
{
    int freq[] = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};
    int n = sizeof(freq)/sizeof(freq[0]);
    int *BITree = constructBITree(freq, n);
    cout &lt;&lt; &quot;Sum of elements in arr[0..5] is &quot;&lt;&lt; getSum(BITree, 5);

    freq[3] += 6;
    updateBIT(BITree, n, 3, 6);  // 上面是 [3] = 6, 这里也是 3，6

    cout &lt;&lt; &quot;\nSum of elements in arr[0..5] after update is &quot;&lt;&lt; getSum(BITree, 5);

    return 0;
}</pre><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// n：input array 的 元素个数</span>
<span class="hljs-comment">// BITree[0..n]，BIT的数组形式</span>
<span class="hljs-comment">// arr[0..n-1]，input array</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> BITree[], <span class="hljs-type">int</span> index)</span>
</span>{
    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;

<span class="hljs-comment">// BITree 中的下标 比 arr 中的下标 多1</span>
    index = index + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (index&gt;<span class="hljs-number">0</span>)
    {
        sum += BITree[index];
        index -= index &amp; (-index);
    }
    <span class="hljs-keyword">return</span> sum;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateBIT</span><span class="hljs-params">(<span class="hljs-type">int</span> BITree[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span>
</span>{
    <span class="hljs-comment">// BITree 比 arr 的下标 多 1</span>
    index = index + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (index &lt;= n)
    {
        BITree[index] += val;
        index += index &amp; (-index);
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">constructBITree</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>
</span>{
    <span class="hljs-type">int</span> *BITree = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)
        BITree[i] = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Store the actual values in BITree[] using update()</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)
        <span class="hljs-built_in">updateBIT</span>(BITree, n, i, arr[i]);

    <span class="hljs-keyword">return</span> BITree;
}


<span class="hljs-comment">// Driver program to test above functions</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> freq[] = {<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>};
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(freq)/<span class="hljs-built_in">sizeof</span>(freq[<span class="hljs-number">0</span>]);
    <span class="hljs-type">int</span> *BITree = <span class="hljs-built_in">constructBITree</span>(freq, n);
    cout &lt;&lt; <span class="hljs-string">&quot;Sum of elements in arr[0..5] is &quot;</span>&lt;&lt; <span class="hljs-built_in">getSum</span>(BITree, <span class="hljs-number">5</span>);

    freq[<span class="hljs-number">3</span>] += <span class="hljs-number">6</span>;
    <span class="hljs-built_in">updateBIT</span>(BITree, n, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>);  <span class="hljs-comment">// 上面是 [3] = 6, 这里也是 3，6</span>

    cout &lt;&lt; <span class="hljs-string">&quot;\nSum of elements in arr[0..5] after update is &quot;</span>&lt;&lt; <span class="hljs-built_in">getSum</span>(BITree, <span class="hljs-number">5</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>计算range  sum<br>
<code class="inline-code">rangeSum(l, r) = getSum(r)  –  getSum(l-1)</code></p>
<hr>
<p><a data-from-md title='https://cp-algorithms.com/data_structures/fenwick.html' href='https://cp-algorithms.com/data_structures/fenwick.html'>https://cp-algorithms.com/data_structures/fenwick.html</a></p>
<p>。。这个  BIT，是  从0开始的。</p>
<p>设  f  是一些  group  操作  (具有元和逆元的集合上的  二元操作)，A  是长度  N  的数组。</p>
<p>Fenwick tree  是一种数据结构，可以做到：</p>
<ol>
<li>在 O(logN)  时间内  计算  [l,  r]  区间内的  f函数  的值。</li>
<li>O(logN)  时间内  更新  A  中的一个元素的值</li>
<li>需要  O(N)  空间</li>
<li>方便地  使用和编码，特别是在  多维数组的帮助下。</li>
</ol>
<p>Fenwick  Tree  最常见的  应用是  计算  range  的sum。</p>
<p>Fenwick  Tree  也被称为  Binary  Indexed Tree，  简写  BIT</p>
<p>第一次出现于  1994年的  &quot;A new data structure for cumulative frequency tables&quot;  论文，  Peter  M. Fenwick</p>
<p>为了简单起见，我们假设  f  只是一个  sum  方法。</p>
<p>给定数组  A[0 … N-1]，  BIT  是一个数组  T[0 … N-1]，其中的每个元素等于  A数组的  [g(i), i]  区间的  sum。</p>
<p>Note：这里的BIT  从下标0  开始。许多人使用  下标1开始的  BIT。因此在  implementation  章节，你会看到  一个  下标1开始的  实现。  2个版本  的  时间  空间  复杂度都是一样的。</p>
<p>对于上面提到的2个操作的一些伪代码：  获得  A  中[0, r]  的元素的和，更新  Ai：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">def sum(int r):
    res = 0
    while (r &gt;= 0):
        res += t[r]
        r = g(r) - 1
    return res

def increase(int i, int delta):
    for all j with g(j) &lt;= i &lt;= j:
        t[j] += delta</pre><pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> r</span>):
    res = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (r &gt;= <span class="hljs-number">0</span>):
        res += t[r]
        r = g(r) - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> res

<span class="hljs-keyword">def</span> <span class="hljs-title function_">increase</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> delta</span>):
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">all</span> j <span class="hljs-keyword">with</span> g(j) &lt;= i &lt;= j:
        t[j] += delta</code></pre></div>
<p>sum  的行为如下：</p>
<ol>
<li>增加  [g(r), r]  的  sum  到  result</li>
<li>然后，跳到  range  [g(g(r) - 1), g(r) - 1]。  然后增加  这个range的  sum  到result。</li>
<li>一直跳，直到  从  [0, g(g(…g(r) - 1)..-1)-1]  跳到  [g(-1), -1]，  stop。</li>
</ol>
<p>increase的行为如下：</p>
<ol>
<li>满足 g(j) &lt;= i &lt;= j  的  [g(j), j]  增加  delta，即  t[j] += delta。  因此  我们更新  T  中  所有和  Ai  相关的  range  的值。</li>
</ol>
<p>显然，sum  和  increase  的  复杂度都依赖于  g  函数。  有许多种  g函数，只要  0  &lt;= g(i) &lt;= i，for  all i。  例如  g(i) =  i  是可以的，这个会导致  T = A。  我们也可以使用  g(i) = 0,  这个  会导致  T  变成  prefix  sum array。</p>
<p>Fenwick  算法的核心部分  就是，使用了一个  特别定义的  function g，来使得  2个操作  都是  O(logN)</p>
<p>定义g(i)<br>
g(i)  的计算  使用了下面的  简单操作：替换  i  的尾部(后缀)  1  为  0，直到  i  变成  0。</p>
<p>换句话说，如果  i  的二进制  的最低位  是0，那么  g(i) = i。  如果  最低位  是  1，那么  把  后缀  1  全部  翻转  为  0。</p>
<p>例如：<br>
g(11) = g(0b1011) = 0b1000 =  8<br>
g(12) = g(0b1100) = 0b1100 = 12<br>
g(13) = g(0b1101) = 0b1100 = 12<br>
g(14) = g(0b1110) = 0b1110 = 14<br>
g(15) = g(0b1111) = 0b0000 = 0</p>
<p>一个简单的实现是  使用  位操作：  g(i) = i &amp; (i + 1)<br>
。。  + 1  会使得  后缀1  全部变成  0，  且  最后出现的  0  会变成1，  然后  &amp;   就可以把  后缀  1  全部消掉了。</p>
<p>现在，我们只需要找到一个  方法  来遍历  所有  满足  g(j) &lt;=  i  &lt;= j  的  j。</p>
<p>容易看到：我们可以  找到所有的  j，通过：以  i  为开始，然后  翻转  最后一个  值为0  的bit。  我们称这个  操作是  h(j)。  例如，对于  i=10：</p>
<p>10 = 0b0001010<br>
h(10) = 11 = 0b0001011<br>
h(11) = 15 = 0b0001111<br>
h(15) = 31 = 0b0011111<br>
h(31) = 63 = 0b0111111</p>
<p>也存在一个  简答的方法  来执行  h：  h(j) = j | (j + 1)</p>
<p>下面的图片展示了  一个  BIT。<br>
<img src="../_resources/d66613efe784c43e02f0438b29c9366e.png" alt="Binary Indexed Tree"></p>
<p>Implementation</p>
<p>Finding sum in one-dimensional array</p>
<h2 id="bit-impl-2">BIT impl 2</h2>
<p>这里提供了2个构造器，一个是新建一个arr，一个是使用原数组</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">struct FenwickTree {
    vector&lt;int&gt; bit;  // binary indexed tree
    int n;

    FenwickTree(int n) {
        this-&gt;n = n;
        bit.assign(n, 0);
    }

    FenwickTree(vector&lt;int&gt; a) : FenwickTree(a.size()) {
        for (size_t i = 0; i &lt; a.size(); i++)
            add(i, a[i]);
    }

    int sum(int r) {
        int ret = 0;
        for (; r &gt;= 0; r = (r &amp; (r + 1)) - 1)
            ret += bit[r];
        return ret;
    }

    int sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
    void add(int idx, int delta) {
        for (; idx &lt; n; idx = idx | (idx + 1))
            bit[idx] += delta;
    }
};</pre><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FenwickTree</span> {
    vector&lt;<span class="hljs-type">int</span>&gt; bit;  <span class="hljs-comment">// binary indexed tree</span>
    <span class="hljs-type">int</span> n;

    <span class="hljs-built_in">FenwickTree</span>(<span class="hljs-type">int</span> n) {
        <span class="hljs-keyword">this</span>-&gt;n = n;
        bit.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);
    }

    <span class="hljs-built_in">FenwickTree</span>(vector&lt;<span class="hljs-type">int</span>&gt; a) : <span class="hljs-built_in">FenwickTree</span>(a.<span class="hljs-built_in">size</span>()) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)
            <span class="hljs-built_in">add</span>(i, a[i]);
    }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span> </span>{
        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (; r &gt;= <span class="hljs-number">0</span>; r = (r &amp; (r + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>)
            ret += bit[r];
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> delta)</span> </span>{
        <span class="hljs-keyword">for</span> (; idx &lt; n; idx = idx | (idx + <span class="hljs-number">1</span>))
            bit[idx] += delta;
    }
};</code></pre></div>
<p>Finding minimum of  [0, r]  in one-dimensional  array<br>
显然，没有  简单的方法来  找到  [l, r]  区间的  min。<br>
BIT  只能回答  [0, r]  区间的查询。另外，每当值  被更新时，新的值必须小于当前值。<br>
这2个限制是因为  min  运算  和  整数集  不能形成  group，因为没有逆元素。</p>
<h2 id="bit-impl-3">BIT impl 3</h2>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">struct FenwickTreeMin {
    vector&lt;int&gt; bit;
    int n;
    const int INF = (int)1e9;

    FenwickTreeMin(int n) {
        this-&gt;n = n;
        bit.assign(n, INF);
    }

    FenwickTreeMin(vector&lt;int&gt; a) : FenwickTreeMin(a.size()) {
        for (size_t i = 0; i &lt; a.size(); i++)
            update(i, a[i]);
    }

    int getmin(int r) {
        int ret = INF;
        for (; r &gt;= 0; r = (r &amp; (r + 1)) - 1)
            ret = min(ret, bit[r]);
        return ret;
    }

    void update(int idx, int val) {
        for (; idx &lt; n; idx = idx | (idx + 1))
            bit[idx] = min(bit[idx], val);
    }
};</pre><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FenwickTreeMin</span> {
    vector&lt;<span class="hljs-type">int</span>&gt; bit;
    <span class="hljs-type">int</span> n;
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>;

    <span class="hljs-built_in">FenwickTreeMin</span>(<span class="hljs-type">int</span> n) {
        <span class="hljs-keyword">this</span>-&gt;n = n;
        bit.<span class="hljs-built_in">assign</span>(n, INF);
    }

    <span class="hljs-built_in">FenwickTreeMin</span>(vector&lt;<span class="hljs-type">int</span>&gt; a) : <span class="hljs-built_in">FenwickTreeMin</span>(a.<span class="hljs-built_in">size</span>()) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)
            <span class="hljs-built_in">update</span>(i, a[i]);
    }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span> </span>{
        <span class="hljs-type">int</span> ret = INF;
        <span class="hljs-keyword">for</span> (; r &gt;= <span class="hljs-number">0</span>; r = (r &amp; (r + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>)
            ret = <span class="hljs-built_in">min</span>(ret, bit[r]);
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>{
        <span class="hljs-keyword">for</span> (; idx &lt; n; idx = idx | (idx + <span class="hljs-number">1</span>))
            bit[idx] = <span class="hljs-built_in">min</span>(bit[idx], val);
    }
};</code></pre></div>
<p>Note：这是可能的：使用  Fenwick tree  来  处理  任意的  min query  和  任意的  update。论文《Efficient Range Minimum Queries using Binary Indexed Trees》  (<a data-from-md title='http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf' href='http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf'>http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf</a>)  描述了这种实现。  但是，需要维护一个  second binary indexed tree，因为  一个  tree  无法保存数组中所有元素的值。</p>
<p>Finding sum in two-dimensional array<br>
很容易就可以  实现  Fenwick Tree for  多维数组。</p>
<h2 id="bit-impl-2d-array">BIT impl 2D array</h2>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">struct FenwickTree2D {
    vector&lt;vector&lt;int&gt;&gt; bit;
    int n, m;

    // init(...) { ... }

    int sum(int x, int y) {
        int ret = 0;
        for (int i = x; i &gt;= 0; i = (i &amp; (i + 1)) - 1)
            for (int j = y; j &gt;= 0; j = (j &amp; (j + 1)) - 1)
                ret += bit[i][j];
        return ret;
    }

    void add(int x, int y, int delta) {
        for (int i = x; i &lt; n; i = i | (i + 1))
            for (int j = y; j &lt; m; j = j | (j + 1))
                bit[i][j] += delta;
    }
};</pre><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FenwickTree2D</span> {
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; bit;
    <span class="hljs-type">int</span> n, m;

    <span class="hljs-comment">// init(...) { ... }</span>

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &gt;= <span class="hljs-number">0</span>; i = (i &amp; (i + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>)
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y; j &gt;= <span class="hljs-number">0</span>; j = (j &amp; (j + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>)
                ret += bit[i][j];
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> delta)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; n; i = i | (i + <span class="hljs-number">1</span>))
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y; j &lt; m; j = j | (j + <span class="hljs-number">1</span>))
                bit[i][j] += delta;
    }
};</code></pre></div>
<p>下标从1开始的  实现<br>
我们修改了  T[]  和  g()  的定义。  我们希望  T[i]  保存  sum  of [g(i)+1, i]。  这会使得  代码有点不同。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">def sum(int r):
    res = 0
    while (r &gt; 0):
        res += t[r]
        r = g(r)
    return res

def increase(int i, int delta):
    for all j with g(j) &lt; i &lt;= j:
        t[j] += delta</pre><pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> r</span>):
    res = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span>):
        res += t[r]
        r = g(r)
    <span class="hljs-keyword">return</span> res

<span class="hljs-keyword">def</span> <span class="hljs-title function_">increase</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> delta</span>):
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">all</span> j <span class="hljs-keyword">with</span> g(j) &lt; i &lt;= j:
        t[j] += delta</code></pre></div>
<p>g(i)  的计算是：i  的二进制的  最低位(最后一个)  1  被  翻转为  0。<br>
g(7) = g(0b111) = 0b110 = 6<br>
g(6) = g(0b110) = 0b100 = 4<br>
g(4) = g(0b100) = 0b000 = 0</p>
<p>最低位的  1  可以通过  i&amp;(-i)  来获得，所以  操作可以展开为：g(i) =  i-(i&amp;(-i))</p>
<p>不难看出，你需要  以  i, h(i), h(h(i)) …  的顺序  来修改  T[j]  的值，  当你  想更新  A[j]  时，  h(i)  的定义：  h(i) = i+(i&amp;(-i))</p>
<h2 id="bit-impl-index-start-from-1-2">BIT impl (index start from 1)</h2>
<p>你可以看到，这个实现的主要好处是：二元操作可以相互补充。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">struct FenwickTreeOneBasedIndexing {
    vector&lt;int&gt; bit;  // binary indexed tree
    int n;
    FenwickTreeOneBasedIndexing(int n) {
        this-&gt;n = n + 1;
        bit.assign(n + 1, 0);
    }
    FenwickTreeOneBasedIndexing(vector&lt;int&gt; a)
        : FenwickTreeOneBasedIndexing(a.size()) {
        for (size_t i = 0; i &lt; a.size(); i++)
            add(i, a[i]);
    }
    int sum(int idx) {
        int ret = 0;
        for (++idx; idx &gt; 0; idx -= idx &amp; -idx)
            ret += bit[idx];
        return ret;
    }
    int sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
    void add(int idx, int delta) {
        for (++idx; idx &lt; n; idx += idx &amp; -idx)
            bit[idx] += delta;
    }
};</pre><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FenwickTreeOneBasedIndexing</span> {
    vector&lt;<span class="hljs-type">int</span>&gt; bit;  <span class="hljs-comment">// binary indexed tree</span>
    <span class="hljs-type">int</span> n;
    <span class="hljs-built_in">FenwickTreeOneBasedIndexing</span>(<span class="hljs-type">int</span> n) {
        <span class="hljs-keyword">this</span>-&gt;n = n + <span class="hljs-number">1</span>;
        bit.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    }
    <span class="hljs-built_in">FenwickTreeOneBasedIndexing</span>(vector&lt;<span class="hljs-type">int</span>&gt; a)
        : <span class="hljs-built_in">FenwickTreeOneBasedIndexing</span>(a.<span class="hljs-built_in">size</span>()) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)
            <span class="hljs-built_in">add</span>(i, a[i]);
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>{
        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (++idx; idx &gt; <span class="hljs-number">0</span>; idx -= idx &amp; -idx)
            ret += bit[idx];
        <span class="hljs-keyword">return</span> ret;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> delta)</span> </span>{
        <span class="hljs-keyword">for</span> (++idx; idx &lt; n; idx += idx &amp; -idx)
            bit[idx] += delta;
    }
};</code></pre></div>
<p>Range  operations<br>
BIT  可以支持下面的range  操作：</p>
<ol>
<li>
<p>point  update  和  range query</p>
</li>
<li>
<p>range update  和  point query</p>
</li>
<li>
<p>range update  和  range query</p>
</li>
<li>
<p>Point Update and Range Query<br>
普通的  BIT  就可以。</p>
</li>
<li>
<p>Range Update and Point Query<br>
使用简单的技巧，我们可以执行相反的操作：  range increase  和  单个值的查询。</p>
</li>
</ol>
<p>将  BIT  初始化为全0。假设我们想要增加[l, r]  每个元素的值  by x。我们在  BIT  上执行  2次  point  update，一次是  add(l, x),  一次是  add(r+1, -x)</p>
<p>如果我们想要获得  A[i]  的值，我们只需要  使用  普通的  range  sum  方法  就可以获得  prefix  sum。</p>
<p>为了证明正确性，让我们聚焦于  上面的  increase  操作，如果  i&lt;l，那么  2次  update  操作  不会对  query  造成影响，我们得到  sum 0。  如果  i在[l, r]  区间内，那么我们得到  答案x  ，因为  第一次的  update  操作，  如果  i&gt;r，那么  第二次的  update  会  撤销  第一次的  update  的结果。</p>
<p>下面的实现是  下标从1开始的。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">void add(int idx, int val) {
    for (++idx; idx &lt; n; idx += idx &amp; -idx)
        bit[idx] += val;
}

void range_add(int l, int r, int val) {
    add(l, val);
    add(r + 1, -val);
}

int point_query(int idx) {
    int ret = 0;
    for (++idx; idx &gt; 0; idx -= idx &amp; -idx)
        ret += bit[idx];
    return ret;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>{
    <span class="hljs-keyword">for</span> (++idx; idx &lt; n; idx += idx &amp; -idx)
        bit[idx] += val;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>{
    <span class="hljs-built_in">add</span>(l, val);
    <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -val);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">point_query</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>{
    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (++idx; idx &gt; <span class="hljs-number">0</span>; idx -= idx &amp; -idx)
        ret += bit[idx];
    <span class="hljs-keyword">return</span> ret;
}</code></pre></div>
<p>Note：  这个也可以  增加单个值  A[i]，  通过  range_add(i,  i,  val)</p>
<ol>
<li>Range Updates and Range Queries<br>
为了支持  range update  和  range query，我们需要  2个BIT，一个B1[],  一个B2[]，用0  初始化。</li>
</ol>
<p>假设  我们想要增加[l, r]  区间的每个值  by x。类似上面的方法，  我们执行2次  point update  在  B1  上：  add(B1, l, x)  和  add(B1, r+1, -x)  。  我们也更新B2，具体后面说。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">def range_add(l, r, x):
    add(B1, l, x)
    add(B1, r+1, -x)
    add(B2, l, x*(l-1))
    add(B2, r+1, -x*r))</pre><pre class="hljs"><code>def range_add(l<span class="hljs-punctuation">,</span> r<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>):
    <span class="hljs-keyword">add</span>(B<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> l<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)
    <span class="hljs-keyword">add</span>(B<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> r<span class="hljs-number">+1</span><span class="hljs-punctuation">,</span> -<span class="hljs-keyword">x</span>)
    <span class="hljs-keyword">add</span>(B<span class="hljs-number">2</span><span class="hljs-punctuation">,</span> l<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>*(l<span class="hljs-number">-1</span>))
    <span class="hljs-keyword">add</span>(B<span class="hljs-number">2</span><span class="hljs-punctuation">,</span> r<span class="hljs-number">+1</span><span class="hljs-punctuation">,</span> -<span class="hljs-keyword">x</span>*r))</code></pre></div>
<p>在  range update  (l, r, x)  后，  range  sum  query  应该返回下面的值</p>
<p>sum[0, i] =</p>
<ol>
<li>0, i&lt;l</li>
<li>x*(i-(l-1)), l&lt;=i&lt;=r</li>
<li>x*(r-l+1), i&gt;r</li>
</ol>
<p>我们可以把  range  sum  写成  2项  的差，我们使用  B1  代表第一项，B2代表第二项。对于这2项的查询  的差  就是  [0, i]  的  prefix  sum</p>
<p>sum[0, i] = sum(B1, i)*i - sum(B2, i) =</p>
<ol>
<li>0*i - 0, i&lt;l</li>
<li>x<em>i-x</em>(l-1), l&lt;=i&lt;=r</li>
<li>0<em>i-(x</em>(l-1)-x*r), i&gt;r</li>
</ol>
<p>最后一个表达式就是所需的项，所以，我们可以使用B2  来移除  额外的项，当我们执行乘法  B1[i] * i时</p>
<p>我们可以执行任意的  range  sum，通过计算  l-1  和  r  的前缀和，然后  获得  差</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">def add(b, idx, x):
    while idx &lt;= N:
        b[idx] += x
        idx += idx &amp; -idx

def range_add(l,r,x):
    add(B1, l, x)
    add(B1, r+1, -x)
    add(B2, l, x*(l-1))
    add(B2, r+1, -x*r)

def sum(b, idx):
    total = 0
    while idx &gt; 0:
        total += b[idx]
        idx -= idx &amp; -idx
    return total

def prefix_sum(idx):
    return sum(B1, idx)*idx -  sum(B2, idx)

def range_sum(l, r):
    return prefix_sum(r) - prefix_sum(l-1)</pre><pre class="hljs"><code><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">b, idx, x</span>):
    <span class="hljs-keyword">while</span> idx &lt;= N:
        b[idx] += x
        idx += idx &amp; -idx

<span class="hljs-keyword">def</span> <span class="hljs-title function_">range_add</span>(<span class="hljs-params">l,r,x</span>):
    add(B1, l, x)
    add(B1, r+<span class="hljs-number">1</span>, -x)
    add(B2, l, x*(l-<span class="hljs-number">1</span>))
    add(B2, r+<span class="hljs-number">1</span>, -x*r)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">b, idx</span>):
    total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> idx &gt; <span class="hljs-number">0</span>:
        total += b[idx]
        idx -= idx &amp; -idx
    <span class="hljs-keyword">return</span> total

<span class="hljs-keyword">def</span> <span class="hljs-title function_">prefix_sum</span>(<span class="hljs-params">idx</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(B1, idx)*idx -  <span class="hljs-built_in">sum</span>(B2, idx)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">range_sum</span>(<span class="hljs-params">l, r</span>):
    <span class="hljs-keyword">return</span> prefix_sum(r) - prefix_sum(l-<span class="hljs-number">1</span>)</code></pre></div>
<p>===================================</p>
<h1 id="splay">Splay</h1>
<p>===================================</p>
<h1 id="分块">分块</h1>
<p>===================================</p>
<h1 id="莫队">莫队</h1>
<p>===================================</p>
<h1 id="珂朵莉树">珂朵莉树</h1>
<p>===================================</p>
<h1 id="哈夫曼树">哈夫曼树</h1>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="数学">数学</h1>
<h2 id="裴蜀定理">裴蜀定理</h2>
<p>又称  贝祖定理，Bézout's lemma</p>
<p>若a,  b  是整数，且  <code class="inline-code">d  = gcd(a, b)</code>，<br>
那么对于  任意整数x, y，ax  + by  一定是  d的倍数，<br>
特定地，一定存在x,y,  使得  <code class="inline-code">ax  +  by  = d</code>  成立。</p>
<p>一个重要推论：a, b互质的  充要条件  是  存在整数  x,y，使得ax  + by = 1<br>
。。2，3互质  ：2*(-1)  + 3*1 = 1</p>
<hr>
<p>n个整数间  的裴蜀定理</p>
<p>设a1,a2,a3…an  为n个整数，  d  是它们的最大公约数，那么存在整数x1,x2..xn  使得a1<em>x1 + a2</em>x2 … + an*xn  = d  成立。</p>
<p>特别地，如果  a1,a2..an  存在  2个数是互质的  (不必两两互质)，  则存在  整数  x1,x2…xn  使得  a1<em>x2 + a2</em>x2 +..+an*xn  = 1  成立。</p>
<hr>
<p>裴蜀可以推广到任意的  主理想环  上。  设环A  是  主理想环，a和b  是  环中元素，d是它们的一个  最大公约元，那么存在  环中元素  x  和y  使得：  ax  + by = d。  这是因为  主理想环  中，a和b  的最大公约元  被定义为  理想  aA  + bB  的生成元。</p>
<p>。。主理想环  -  理想  -  主理想  -  环论  -  非结合代数  -  域论  -  泛函分析<br>
。。环  -  四元数  -  乘法不符合交换律  -  超复数  -  自旋(量子力学)  -  幺正厄米复矩阵(幺正矩阵，厄米矩阵，复矩阵)<br>
。。。。。</p>
<p>===================================</p>
<h2 id="威尔逊定理数论四大定理之一">威尔逊定理(数论四大定理之一)</h2>
<p>判断自然数  是否是  素数  的  充要条件：  当且仅当  p  为素数时：  (p - 1)!  ≡  -1(mod p)<br>
。。。mod(负，正)=正  mod(正，负)=负。</p>
<p>充分性<br>
1<br>
4<br>
<code class="inline-code">&gt; 4  的完全平方数</code><br>
p=k^2<br>
2k-p = 2k - k^2<br>
= 2k - k^2 - 1 + 1<br>
= -(k-1)^2 + 1 &lt; 0<br>
所以  k  &lt; p, 2k &lt; p  成立<br>
(p-1)! = 1<em>2</em>..k* .. <em>2k * (p-1)<br>
= k</em>2k*n<br>
= 2nk^2<br>
= 2np<br>
所以  (p-1)! = 0(mod p)</p>
<p><code class="inline-code">&gt; 4  的非完全平方数</code><br>
p  必然等于  2个不等数  a,b的乘积<br>
(p-1)! = 1<em>2</em>…<em>a..<em>b…</em>(p-1)<br>
= a</em>b*n<br>
= np<br>
所以  (p-1)! = 0(mod p)</p>
<p>必要性<br>
证明：如果p是质数，则p可以整除  (p-1)!+1<br>
。。。</p>
<p>===================================<br>
数论四大定理<br>
威尔逊定理<br>
欧拉定理<br>
孙子定理<br>
费马小定理</p>
<p>===================================</p>
<h2 id="费马小定理">费马小定理</h2>
<p>如果p是一个质数，整数a  不是p的倍数，则有  a^(p-1) ≡ 1(mod p)</p>
<p>是欧拉定理的  一个特殊情况</p>
<p>===================================</p>
<h2 id="欧拉定理">欧拉定理</h2>
<p>设a,m  是  正整数，且  gcd(a, m) = 1,  则有<br>
a^(φ(m)) ≡ 1(mod m)</p>
<p>φ(m)  成为  对模m  缩系的元素个数</p>
<p>。。缩系，应该就是：  小于m  且  和  m  互质的数  的集合。  (。。1也是的)  。。  不是  小于  m  的素数  的集合。   比如  5和4  互质。   或者说  是  gcd = 1  就是互质。</p>
<p>当  m  是素数时，变为  费马小定理</p>
<p>应用<br>
用来简化  幂的模运算。</p>
<p>比如  计算  7^222  的个位数，  实际上求的是  7^222  被10  除的  余数。7和10互质(gcd=1)，且φ(10) = 4。  由欧拉定理知  7^4 = 1(mod 10).  所以  7^222 = (7^4)^55 * 7^22 = 1^55 * 7^2 = 49 = 9 (mod 10)</p>
<p>===================================</p>
<h2 id="孙子定理中国余数定理">孙子定理，中国余数定理</h2>
<p>一元线性同余方程组<br>
x  ≡ a1 (mod m1)<br>
x ≡ a2 (mod m2)<br>
x ≡ a3 (mod m3)<br>
…<br>
x ≡ an (mod mn)</p>
<p>中国剩余定理说明：  假设  整数  m1,m2…mn  两两互质，则对  任意整数  a1,a2,…an,  上面的方程祖  有解，并且  通解  可以通过如下方式获得：</p>
<p>设  M =  m1 * m2 … * mn，  并设  Mi  = M/mi  ，即  除mi意外  n-1个数的  乘积。</p>
<p>设  ti = Mi ^ -1，  即  Mi  模  mi  的数论倒数  (ti  为  Mi  模  mi  意义下的  逆元)  Miti ≡ 1  (mod mi)。</p>
<p>方程组的通解：  x = a1t1M1 + a2t2M2 +… + antnMn + kM。  k是整数。<br>
在模  M  的意义下，  只有一个  通解  x  = (a1t1M1 + … + antnMn)  mod M</p>
<p>。。  余数a1 *  (M  / mi) * (  Mi ^ -1 )</p>
<p>x  = 2  (mod 3)<br>
x = 3 (mod 5)<br>
x = 2  (mod 7)</p>
<p>M = 105<br>
M1 = 35<br>
M2 = 21<br>
M3 = 15</p>
<p>a1 = 2<br>
a2 = 3<br>
a3 = 2</p>
<hr>
<p>逆元<br>
。。。<br>
扩展欧几里得算法</p>
<p>===================================</p>
<h2 id="模逆">模逆</h2>
<p><a data-from-md title='https://www.cnblogs.com/Cattle-Horse/p/17096887.html' href='https://www.cnblogs.com/Cattle-Horse/p/17096887.html'>https://www.cnblogs.com/Cattle-Horse/p/17096887.html</a><br>
逆元<br>
逆元:在一个集合中,对于某种运算,如果任意两个元素的运算结果等于单位元,则称这两个元素互为逆元</p>
<p>为了避免大整数计算，常常要求输出答案对一个数（通常为质数）取模<br>
对于除法， 由于取整，在大部分情况下 <code class="inline-code">floor(a/b) != floor(b/d) mod n</code><br>
需要找到其他满足 模性质的 运算代替 除法运算，就可以解决这个问题。<br>
因此，引入 <code class="inline-code">乘法逆元</code></p>
<p>定义</p>
<p>单位元：<br>
在一个集合中，对于某种运算，如果对于 任何集合的元素 a，与元素e 运算，得到的还是 a，则称 e 为这个运算下的 单位元</p>
<ul>
<li>加法中， <code class="inline-code">a+e=e+a=a, e=0</code></li>
<li>乘法中， <code class="inline-code">a*e=e*a=a, e=1</code></li>
</ul>
<p>逆元：<br>
在一个集合中，对于某种运算，如果任意 2个元素的 运算结果等于 单位元，则称 这2个元素 互为逆元。</p>
<ul>
<li>加法，任意实数a 的逆元是 -a</li>
<li>乘法，任意非0实数a 的逆元是 a^-1</li>
</ul>
<blockquote>
<p>模意义下的单位元</p>
</blockquote>
<p>前置知识：</p>
<ol>
<li>取余运算可以转化为 加法及乘法。即 <code class="inline-code">a(mod m) = k*m + a</code></li>
<li>如果运算 * (这个不是乘法) 的 单位元为 e，则 对于任意实数 a 满足 a*e=a</li>
</ol>
<p>模意义下，在加法运算中，任意实数的单位元为 0</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">令模m意义下的 单位元为 e(mod m)，对于任意实数a：
a(mod m) + e(mod m) = k1*m + a + k2*m + e
           a(mod m) = (k1 + k2)*m + a + e
           k1*m + a = (k1 + k2)*m + a + e
               k1*m = (k1 + k2)*m + e
所以：
k1 = k1+k2
e = 0</pre><pre class="hljs"><code>令模m意义下的 单位元为 e(mod m)，对于任意实数a：
a(mod m) + e(mod m) = k1*m + a + k2*m + e
           a(mod m) = (k1 + k2)*m + a + e
           k1*m + a = (k1 + k2)*m + a + e
               k1*m = (k1 + k2)*m + e
所以：
k1 = k1+k2
e = 0</code></pre></div>
<p>。。不知道。 主要是 第一行 到 第二行， 为什么把 e(mod m) 删除了。这个时候，并不知道 e 是0 啊。<br>
。。不，知道的， e 是单位元， 单位元 是和 任何元素a 进行运算后 还是 a 的，所以可以直接删除。<br>
。。但是不知道 单位元 在 模意义下， 还是 和任何元素a 运算后还是 a 吗。。<br>
。。估计是这样的： <code class="inline-code">a(mod m) + e(mod m) = (a+e)(mod m) = a(mod m)</code></p>
<p>模意义下，在乘法运算中，任意非0实数的单位元为 1</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">令模m 意义下的 单位元为 e(mod m)， 对于任意非0 实数 a
a(mod m) * e(mod m) = (k1*m + a) * (k2*m + e)
           a(mod m) = (k1 + k2)*m + a + e
           k1*m + a = (k1k2m + k1*e + k2*a) * m + a*e
所以：
k1 = k1*k2*m + k1*e + k2*e
e = 1</pre><pre class="hljs"><code>令模m 意义下的 单位元为 e(mod m)， 对于任意非0 实数 a
a(mod m) * e(mod m) = (k1*m + a) * (k2*m + e)
           a(mod m) = (k1 + k2)*m + a + e
           k1*m + a = (k1k2m + k1*e + k2*a) * m + a*e
所以：
k1 = k1*k2*m + k1*e + k2*e
e = 1</code></pre></div>
<p>。。应该也是 <code class="inline-code">a(mod m) * e(mod m) = (a*e)(mod m) = a(mod m)</code></p>
<blockquote>
<p>模意义下的逆元</p>
</blockquote>
<p>在模m意义下<br>
加法运算中，对于任意实数a，逆元为 (-a)(mod m)<br>
乘法中，对于任意非0实数a，逆元为 a^-1(mod m)</p>
<p>乘法逆元满足等式 a * a^-1 = 1(mod m)<br>
当且仅当，<mark>乘法逆元只有在 gcd(a, m) = 1 即互质的情况下 存在</mark><br>
证明</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">令 x 是正整数 a 在 模b意义下的 乘法逆元，则 ax = 1(mod m)
同余号转等号： ax = by' + 1，
由于 y' 是一个随 x变化的值，令 y=-y'，则 ax + by = 1
令 g = gcd(a, b), 则： g * (a/g * x + b/g * y) = 1
两个整数相乘 等于1， 则这2个整数一定都是 1 或 都是-1.
由于 g 是一个正整数，所以 gcd(a,b)=1</pre><pre class="hljs"><code>令 x 是正整数 a 在 模b意义下的 乘法逆元，则 ax = 1(mod m)
同余号转等号： ax = by&#x27; + 1，
由于 y&#x27; 是一个随 x变化的值，令 y=-y&#x27;，则 ax + by = 1
令 g = gcd(a, b), 则： g * (a/g * x + b/g * y) = 1
两个整数相乘 等于1， 则这2个整数一定都是 1 或 都是-1.
由于 g 是一个正整数，所以 gcd(a,b)=1</code></pre></div>
<p>。。<br>
<code class="inline-code">g * (a/g * x + b/g * y) = 1</code> 等价于 <code class="inline-code">g * [(ax + by) / g] = 1</code><br>
2个整数 就是指  g , (ax+by)/g<br>
。。</p>
<h3 id="扩展欧几里得求乘法逆元">扩展欧几里得求乘法逆元</h3>
<p>求解逆元 a^-1 就是 求解 线性同余方程 ax = 1(mod m) 的一个整数解<br>
或者说，求解 二元一次不定方程 ax + by = 1 的一个整数解， 其中b=m。</p>
<p>时间复杂度 O(nlogn)</p>
<p>递归：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">static int x = 0, y = 0;
static int exgcd(int a, int b) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int gcd = exgcd(b, a % b), t = x;
    x = y;
    y = t - a / b * y;
    return gcd;
}
static int inv(int a, int b) {
    int gcd = exgcd(a, b);
    if (gcd == 1) return (x % b + b) % b;
    System.out.println(String.format(&quot;gcd(%d, %d)!=1，无逆元&quot;, a, b));
    return -1;
}</pre><pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;
<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) {
        x = <span class="hljs-number">1</span>;
        y = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> a;
    }
    <span class="hljs-type">int</span> <span class="hljs-variable">gcd</span> <span class="hljs-operator">=</span> exgcd(b, a % b), t = x;
    x = y;
    y = t - a / b * y;
    <span class="hljs-keyword">return</span> gcd;
}
<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">gcd</span> <span class="hljs-operator">=</span> exgcd(a, b);
    <span class="hljs-keyword">if</span> (gcd == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (x % b + b) % b;
    System.out.println(String.format(<span class="hljs-string">&quot;gcd(%d, %d)!=1，无逆元&quot;</span>, a, b));
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}</code></pre></div>
<p>迭代</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">static int x = 0, y = 0;
static int exgcd(int a, int b) {
    x = 1;
    y = 0;
    int nx = 0, ny = 1, q, t;
    while (b != 0) {
        q = a / b;
        x -= q * nx;
        t = x; x = nx; nx = t;
        y -= q * ny;
        t = y; y = ny; ny = t;
        a -= q * b;
        t = b; b = a; a = t;
    }
    // 结束后
    // a 是 gcd(a,b)
    // 如果 gcd(a,b)!=1 则 无整数解
    // 否则 x,y 是 ax+by=gcd(a,b) 的一组整数解
    return a;
}
static int inv(int a, int b) {
    int gcd = exgcd(a, b);
    if (gcd == 1) return (x % b + b) % b;
    System.out.println(String.format(&quot;gcd(%d, %d)!=1，无逆元&quot;, a, b));
    return -1;
}</pre><pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;
<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    x = <span class="hljs-number">1</span>;
    y = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ny = <span class="hljs-number">1</span>, q, t;
    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {
        q = a / b;
        x -= q * nx;
        t = x; x = nx; nx = t;
        y -= q * ny;
        t = y; y = ny; ny = t;
        a -= q * b;
        t = b; b = a; a = t;
    }
    <span class="hljs-comment">// 结束后</span>
    <span class="hljs-comment">// a 是 gcd(a,b)</span>
    <span class="hljs-comment">// 如果 gcd(a,b)!=1 则 无整数解</span>
    <span class="hljs-comment">// 否则 x,y 是 ax+by=gcd(a,b) 的一组整数解</span>
    <span class="hljs-keyword">return</span> a;
}
<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">gcd</span> <span class="hljs-operator">=</span> exgcd(a, b);
    <span class="hljs-keyword">if</span> (gcd == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (x % b + b) % b;
    System.out.println(String.format(<span class="hljs-string">&quot;gcd(%d, %d)!=1，无逆元&quot;</span>, a, b));
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}</code></pre></div>
<h3 id="欧拉定理求乘法逆元">欧拉定理求乘法逆元</h3>
<p>欧拉定义：如果gcd(a,b)=1，则 a^(f(b)) = 1 (mod b)<br>
所以乘法逆元式子变为： ax = a^(f(b)) (mod b)<br>
a 是非0 实数，所以两侧 处于 a ： x = a^(f(b) - 1) (mod b)<br>
欧拉函数的 计算公式是 f(n) = n * ∏(1- 1/pi)  i从1到s<br>
。。。数学公式不好写。<br>
通过分解质因子(O(sqrt(b))) 求出 欧拉函数值，<br>
通过快速幂 (O(log(f(b)))) 即可求得 逆元 a^-1<br>
时间复杂度 O(sqrt(b) + log(f(b)))</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">static int getPhi(int n) {
    int ans = n;
    for (int i = 2; i * i &lt;= n; ++i) {
        if (n % i == 0) {
            ans = ans / i * (i - 1);
            do n /= i; while (n % i == 0);
        }
    }
    if (n &gt; 1) ans = ans / n * (n - 1);
    return ans;
}
static long powMod(long a, int b, final long mod) {
    long ret = 1;
    while (b != 0) {
        if ((b &amp; 1) == 1) ret = ret * a % mod;
        b &gt;&gt;= 1;
        a = a * a % mod;
    }
    return ret;
}
static long inv(int a, int b) {
    return powMod(a, getPhi(b) - 1, b);
}</pre><pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPhi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i * i &lt;= n; ++i) {
        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) {
            ans = ans / i * (i - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">do</span> n /= i; <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>);
        }
    }
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) ans = ans / n * (n - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">powMod</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">int</span> b, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> mod)</span> {
    <span class="hljs-type">long</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) ret = ret * a % mod;
        b &gt;&gt;= <span class="hljs-number">1</span>;
        a = a * a % mod;
    }
    <span class="hljs-keyword">return</span> ret;
}
<span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> powMod(a, getPhi(b) - <span class="hljs-number">1</span>, b);
}</code></pre></div>
<h3 id="费马小定理求乘法逆元">费马小定理求乘法逆元</h3>
<p>只有在 模为质数 时才能用</p>
<p>费马小定理： 如果p为质数，且 gcd(a,p)=1，则有 a^(p-1) = 1 (mod p)</p>
<p>在模质数 p 意义下， 求非0整数 a 的乘法逆元</p>
<p>当 gcd(a,p) != 1时， 无乘法逆元<br>
当gcd(a,p) = 1时，<br>
由费马小定理的 a^(p-1) = 1 (mod p)<br>
则乘法逆元式子变为： ax = a^(p-1) (mod p)<br>
a!=0，所以两侧除以a，x = a^(p-2) (mod p)</p>
<p>使用快速幂求解<br>
时间复杂度O(logp)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">static long powMod(long a, int b, final long mod) {
    long ret = 1;
    while (b != 0) {
        if ((b &amp; 1) == 1) ret = ret * a % mod;
        b &gt;&gt;= 1;
        a = a * a % mod;
    }
    return ret;
}
static long inv(int a, int b) {
    // 要求b是质数，且 gcd(a,b)=1
    return powMod(a, b - 2, b);
}</pre><pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">powMod</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">int</span> b, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> mod)</span> {
    <span class="hljs-type">long</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) ret = ret * a % mod;
        b &gt;&gt;= <span class="hljs-number">1</span>;
        a = a * a % mod;
    }
    <span class="hljs-keyword">return</span> ret;
}
<span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-comment">// 要求b是质数，且 gcd(a,b)=1</span>
    <span class="hljs-keyword">return</span> powMod(a, b - <span class="hljs-number">2</span>, b);
}</code></pre></div>
<h3 id="递推求乘法逆元">递推求乘法逆元</h3>
<p>只有 模为质数时 才能用<br>
因为，在递推过程中，如果 模数p 不是质数，则可能会出现 gcd(i,p) != 1 的情况，导致 逆元无意义</p>
<p>在模p(p&gt;1) 正整数下，1 的逆元为其本身<br>
对于求 i 的乘法逆元 i^-1， 令 k = floor(p/i), r=p%i, 即 k<em>i + r = p<br>
则 k</em>i + r = 0(mod p)<br>
两侧乘以 i^-1 和 r^-1，得： k<em>r^-1 + i^-1 = 0 (mod p)<br>
。。 0 * 任何数 = 0<br>
移项，得 i^-1 = -k</em>r^-1 (mod p)<br>
即，i^-1 = -floor(p/i) * (p%i)^-1 (mod p)<br>
由于 p%i &lt; i, 即在 求解 i 的逆元 i^-1 时，p%i 的逆元 (p%i)^-1 已经获得。<br>
由于 -floor(p/i) 导致计算的 逆元会为 负数，在模p意义下 -floor(p/i) = p - floor(p/i)</p>
<p>因此，当i=1时，i^-1 = 1<br>
当 <code class="inline-code">1&lt;i&lt;p</code> 时, i^-1 = (p - floor(p/i)) * (p%i)^-1 (mod p)<br>
。。这个 对比上面的 简单多了。。好吧，还有个 费马小定理，不过 快速幂。。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">// 求 [1,n] 的逆元
// 要求 n&lt;p，且 p 是质数
static int[] invs(int n, final int p) {
    int[] inv = new int[n + 1];
    inv[1] = 1;
    for (int i = 2; i &lt;= n; ++i) {
        inv[i] = (int) ((long) (p - p / i) * inv[p % i] % p);
    }
    return inv;
}</pre><pre class="hljs"><code><span class="hljs-comment">// 求 [1,n] 的逆元</span>
<span class="hljs-comment">// 要求 n&lt;p，且 p 是质数</span>
<span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] invs(<span class="hljs-type">int</span> n, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> p) {
    <span class="hljs-type">int</span>[] inv = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];
    inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) {
        inv[i] = (<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) (p - p / i) * inv[p % i] % p);
    }
    <span class="hljs-keyword">return</span> inv;
}</code></pre></div>
<h3 id="阶乘与逆元">阶乘与逆元</h3>
<p>阶乘(也叫 前缀积) 常用于 求 组合数和排列数</p>
<p>阶乘的逆元 就是 逆元的阶乘 (即 逆元是完全积性的)</p>
<p>在模p意义下，若 f(i) 代表 i!, f^-1(i) 代表 i! 的乘法逆元，则<br>
f^-1(i) = (i+1) * f^-1(i+1)<br>
i^-1 = f(i-1) * f^-1(i)</p>
<p>其中 f^-1(n) 需要手动求出， f(0) = 1<br>
时间复杂度 O(n + logp)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">import java.io.*;
import java.util.Scanner;

public class Main {
    static int powMod(long a, int b, final int mod) {
        long ret = 1;
        while (b != 0) {
            if ((b &amp; 1) == 1) ret = ret * a % mod;
            b &gt;&gt;= 1;
            a = a * a % mod;
        }
        return (int) ret;
    }

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), p = 1000000007;
        int[] fact = new int[n + 1];
        int[] factInv = new int[n + 1];
        fact[0] = factInv[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            fact[i] = (int) ((long) i * fact[i - 1] % p);
        }
        factInv[n] = powMod(fact[n], p - 2, p);
        for (int i = n; i &gt; 0; --i) {
            factInv[i - 1] = (int) ((long) factInv[i] * i % p);
        }
        for (int i = 0; i &lt;= n; ++i) {
            System.out.println(String.format(&quot;%d, %d&quot;, fact[i], factInv[i]));
        }
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">powMod</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">int</span> b, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> mod)</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) ret = ret * a % mod;
            b &gt;&gt;= <span class="hljs-number">1</span>;
            a = a * a % mod;
        }
        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ret;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt(), p = <span class="hljs-number">1000000007</span>;
        <span class="hljs-type">int</span>[] fact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];
        <span class="hljs-type">int</span>[] factInv = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];
        fact[<span class="hljs-number">0</span>] = factInv[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) {
            fact[i] = (<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) i * fact[i - <span class="hljs-number">1</span>] % p);
        }
        factInv[n] = powMod(fact[n], p - <span class="hljs-number">2</span>, p);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">0</span>; --i) {
            factInv[i - <span class="hljs-number">1</span>] = (<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) factInv[i] * i % p);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; ++i) {
            System.out.println(String.format(<span class="hljs-string">&quot;%d, %d&quot;</span>, fact[i], factInv[i]));
        }
    }
}</code></pre></div>
<p>===================================</p>
<p><a data-from-md title='https://cloud.tencent.com/developer/article/2240738' href='https://cloud.tencent.com/developer/article/2240738'>https://cloud.tencent.com/developer/article/2240738</a></p>
<p>基于 裴蜀等式 <code class="inline-code">ax + by = gcd(a, b)</code><br>
我们求，a 在模b下的 逆c</p>
<p>如果逆存在，则a和b的 gcd 一定是1<br>
所以 裴蜀等式 变成了 <code class="inline-code">ax + by = 1</code><br>
两侧模b后： ax ≡ 1 mod b<br>
x 就是我们要求的 a在模b下的逆</p>
<p>下面以 求7在模26下的逆 作为例子</p>
<ol>
<li>写出 26和7的 辗转相除法的所有推导过程</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">26 = 3*7 + 5
7 = 1*5 + 2
5 = 2*2 + 1</pre><pre class="hljs"><code>26 = 3*7 + 5
7 = 1*5 + 2
5 = 2*2 + 1</code></pre></div>
<p>。。？这不是辗转相除法吧。 第二行的 7 有什么意义？</p>
<ol>
<li>从最后一个式子出发，移项后得到 <code class="inline-code">1 = 5 - 2*2</code>		// 4</li>
<li>从第二个式子，移项后得出 <code class="inline-code">2 = 7 - 1*5</code>		// 5</li>
<li>5代入4 后，得到 <code class="inline-code">1 = 5 - 2*(7-1*5)</code> 即 <code class="inline-code">1 = -2*7 + 3*5</code></li>
<li>类似的，将 <code class="inline-code">5 = 26-3*7</code> 代入，得到 <code class="inline-code">1 = -2*7 + 3*(26-3*7)</code></li>
<li>整理后得到 <code class="inline-code">1 = 3*26 - 11*7</code> 即 <code class="inline-code">3*26 - 11*7 = 1</code> (即裴蜀等式)</li>
<li>-11 mod 26 == 15， 所以 15就是7在模26时的 逆元。</li>
<li>即 7*15 % 26 == 1</li>
</ol>
<p>。。有代码，python的，<br>
。。而且，文字的 LaTeX 没有起效，很难阅读</p>
<p>===================================</p>
<p>同余的基本性质<br>
<a data-from-md title='https://www.luogu.com.cn/blog/Snowrry/tong-yu-di-ji-ben-xing-zhi' href='https://www.luogu.com.cn/blog/Snowrry/tong-yu-di-ji-ben-xing-zhi'>https://www.luogu.com.cn/blog/Snowrry/tong-yu-di-ji-ben-xing-zhi</a></p>
<p>这里默认 a,b,c,d 是整数， m,k,d 是正整数</p>
<ul>
<li>如果 a1 ≡ b1 (mod m), a2 ≡ b2 (mod m) 则 a1 ± a2 ≡ b1 ± b2 (mod m)</li>
<li>如果 a1 ≡ b1 (mod m), a2 ≡ b2 (mod m) 则 a1 * b2 ≡ b1 * b2 (mod m)</li>
<li>如果 a+b ≡ c (mod m), 则 a ≡ c-b (mod m)</li>
<li>如果 a ≡ b (mod m), 则 ak ≡ bk (mod mk)</li>
<li>如果 d|a, d|b, d|m, a ≡ b (mod m), 则 a/d ≡ b/d (mod d/m)</li>
<li>如果 d|m, a ≡ b (mod m), 则 a ≡ b (mod d)</li>
<li>如果 a ≡ b (mod m), 则 (a, m) ≡ (b, m)</li>
<li>如果 d|m 且 d|a或b，则 d|a 且 d|b</li>
</ul>
<p>===================================<br>
不定方程<br>
<a data-from-md title='https://www.luogu.com.cn/blog/Snowrry/basic-math-note' href='https://www.luogu.com.cn/blog/Snowrry/basic-math-note'>https://www.luogu.com.cn/blog/Snowrry/basic-math-note</a></p>
<p>。。(a,b) 代表 gcd(a,b)</p>
<p>定理1<br>
若 a,b,m,n是整数，c|a, c|b<br>
则 c|(ma+nb)<br>
证明：令 a=ce, b=cf,代入，再提取公因式即可。</p>
<p>定理2<br>
若 a,b,c 是整数<br>
则 (a+cb, b) = (a, b)<br>
证明：由定理1 证明两者 公因子相同即可</p>
<p>定理3<br>
2个不全为0 的整数 a,b 的 最大公因子是 a,b 线性组合的最小正整数<br>
证明：令 d 是a,b 的线性组合中的最小正整数， d=ma+nb, 其中m,n为正整数，我们将证明 d|a, d|b<br>
。。证明 我跳过，6行。。</p>
<p>定理4<br>
若 a,b 是正整数，则所有 a,b 的线性组合构成的 集合与 所有 (a,b)的倍数构成的 集合相同。<br>
证明： 由定理1 得出 a,b 的线性组合都是 (a,b) 倍数<br>
由定理3得 (a,b) 属于线性组合，其倍数显然也是线性组合。<br>
得证。</p>
<p>定理5<br>
若 a,b,c是整数， m是正整数， d=(c,m)<br>
且有 ac = bc (mod m)<br>
则 a = b (mod m/d)<br>
证明：<br>
令 ac = km + bc ，移项后 (a-b)c = km<br>
同除以d，得 (a-b)(c/d) = k(m/d)<br>
因为 (c/d) 和 (m/d) 互质	   -------- 说明(a,b) == gcd(a,b)<br>
所以有 (m/d) | (a-b)<br>
得到结论 a = b (mod m/d)</p>
<p>定理5推论<br>
若 a,b,c 是整数， m是正整数， (c,m) = 1<br>
且有 ac = bc (mod m)<br>
则有 a = b (mod m)</p>
<p>定理6：<br>
若 r1, r2,.., rm 是一个模m的 完全剩余系，且有正整数 a，满足(a,m) = 1<br>
则对任何整数 b 有： <code class="inline-code">a*r1+b, a*r2+b,.., a*rm+b</code> 也是一个模m的 完全剩余系<br>
证明，若有 <code class="inline-code">a*ri + b</code> 与 <code class="inline-code">a*rj + b</code> 同余，则有 <code class="inline-code">a*ri</code> 与 <code class="inline-code">a*rj</code> 同余<br>
由定理5推论可知：此时有 ri 和 rj 同余，矛盾!<br>
故定理成立</p>
<p>朴素欧几里得定理<br>
若 a,b 是整数<br>
则 (a,b) = gcd(b, a%b)<br>
证明：令 a=bq+r, 则 r=a-bq,<br>
由定理2得， <code class="inline-code">gcd(a,b) = gcd(a-bq,b) = gcd(r,b) = gcd(a%b,b) = gcd(b,a%b)</code><br>
。。6</p>
<p>扩展欧几里得算法<br>
在朴素欧几里得 的基础上 求一组 未知解 (x,y) 的解。<br>
公式推导：<br>
对于 ax + by = (a, b)<br>
设 a&gt;b,</p>
<ol>
<li>b=0,则 x=1, y=0</li>
<li>a&gt;b&gt;0<br>
设 <code class="inline-code">a*x1 + b*y1 = gcd(a,b), b*x2 + (a mod b)*y2</code><br>
由 朴素欧几里得 得： gcd(a,b) = gcd(b, a mod b)<br>
所以 <code class="inline-code">a*x1 + b*y1 = b*x2 + (a mod b) * y2</code><br>
即 <code class="inline-code">a*x1 + b*y1 = b*x2 + (a - floor(a/b) * b) * y2</code><br>
化简得：<code class="inline-code">a*x1 + b*y1 = b*x2 + a*y2 - floor(a/b)*b*y2</code><br>
由裴蜀等式得 x1 = y2, y1 = x2 - floor(a/b)*y2</li>
</ol>
<p>裴蜀定理<br>
若 a,b 是整数<br>
则存在 <code class="inline-code">a*x + b*y = (a,b)</code>, x,y 是整数<br>
证明：由定理3易证</p>
<p>推论：整数a,b互质，当且仅当 存在整数m,n 使得 ma + nb = 1 成立<br>
证明：若 ma + nb = 1，则定理3 得 (a,b)=1， 易证</p>
<p>二元一次不定方程<br>
对于一些方程 形如： <code class="inline-code">ax + by = c</code><br>
如果 x=x0, y=y0 是方程的一个特解，<br>
那么所有的解可以表示为 <code class="inline-code">x=x0+(b/d)n, y=y0-(a/d)n</code> n是整数</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">//二元一次不定方程
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

int G,a,b,c,d,x,y;

void exgcd(int a,int b,int&amp; d,int&amp; x,int&amp; y) {
    if(!b) {
        d=a,x=1,y=0;
        return ;
    }
    exgcd(b,a%b,d,x,y);
    int t=x;
    x=y,y=t-a/b*y;
    return ;
}

signed main() {
    scanf(&quot;%lld&quot;,&amp;G);
    while(G--) {
        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);
        exgcd(a,b,d,x,y);
        if(c%d!=0) {
            printf(&quot;-1\n&quot;);
            continue;
        }
        x*=c/d,y*=c/d;
        int mx=b/d,my=a/d,minx=-1,maxx=-1,miny=-1,maxy=-1,t;
        if(x&gt;0) {
            minx=x-(x/mx)*mx;
            int ty=y+(x/mx)*my;
            if(!minx) minx+=mx,ty-=my;
            if(ty&gt;0) maxx=minx+ty/my*mx-mx*(ty%my==0?1:0),t=ty/my+1-(ty%my==0?1:0);
        }
        else {
            minx=x+(-x)/mx*mx+mx;
            int ty=y-((-x)/mx+1)*my;
            if(ty&gt;0) maxx=minx+ty/my*mx-mx*(ty%my==0?1:0),t=ty/my+1-(ty%my==0?1:0);
        }
        if(y&gt;0) {
            miny=y-(y/my)*my;
            int tx=x+(y/my)*mx;
            if(!miny) miny+=my,tx-=mx;
            if(tx&gt;0) maxy=miny+tx/mx*my-my*(tx%mx==0?1:0);
        }
        else {
            miny=y+(-y)/my*my+my;
            int tx=x-((-y)/my+1)*mx;
            if(tx&gt;0) maxy=miny+tx/mx*my-my*(tx%mx==0?1:0);
        }
        if(maxx!=-1) printf(&quot;%lld %lld %lld %lld %lld\n&quot;,t,minx,miny,maxx,maxy);
        else printf(&quot;%lld %lld\n&quot;,minx,miny);
    }
    return 0;
}</pre><pre class="hljs"><code><span class="hljs-comment">//二元一次不定方程</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">int</span> G,a,b,c,d,x,y;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; d,<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span>&amp; y)</span> </span>{
    <span class="hljs-keyword">if</span>(!b) {
        d=a,x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> ;
    }
    <span class="hljs-built_in">exgcd</span>(b,a%b,d,x,y);
    <span class="hljs-type">int</span> t=x;
    x=y,y=t-a/b*y;
    <span class="hljs-keyword">return</span> ;
}

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;G);
    <span class="hljs-keyword">while</span>(G--) {
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;c);
        <span class="hljs-built_in">exgcd</span>(a,b,d,x,y);
        <span class="hljs-keyword">if</span>(c%d!=<span class="hljs-number">0</span>) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);
            <span class="hljs-keyword">continue</span>;
        }
        x*=c/d,y*=c/d;
        <span class="hljs-type">int</span> mx=b/d,my=a/d,minx=<span class="hljs-number">-1</span>,maxx=<span class="hljs-number">-1</span>,miny=<span class="hljs-number">-1</span>,maxy=<span class="hljs-number">-1</span>,t;
        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>) {
            minx=x-(x/mx)*mx;
            <span class="hljs-type">int</span> ty=y+(x/mx)*my;
            <span class="hljs-keyword">if</span>(!minx) minx+=mx,ty-=my;
            <span class="hljs-keyword">if</span>(ty&gt;<span class="hljs-number">0</span>) maxx=minx+ty/my*mx-mx*(ty%my==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>),t=ty/my+<span class="hljs-number">1</span>-(ty%my==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">else</span> {
            minx=x+(-x)/mx*mx+mx;
            <span class="hljs-type">int</span> ty=y-((-x)/mx+<span class="hljs-number">1</span>)*my;
            <span class="hljs-keyword">if</span>(ty&gt;<span class="hljs-number">0</span>) maxx=minx+ty/my*mx-mx*(ty%my==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>),t=ty/my+<span class="hljs-number">1</span>-(ty%my==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">if</span>(y&gt;<span class="hljs-number">0</span>) {
            miny=y-(y/my)*my;
            <span class="hljs-type">int</span> tx=x+(y/my)*mx;
            <span class="hljs-keyword">if</span>(!miny) miny+=my,tx-=mx;
            <span class="hljs-keyword">if</span>(tx&gt;<span class="hljs-number">0</span>) maxy=miny+tx/mx*my-my*(tx%mx==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">else</span> {
            miny=y+(-y)/my*my+my;
            <span class="hljs-type">int</span> tx=x-((-y)/my+<span class="hljs-number">1</span>)*mx;
            <span class="hljs-keyword">if</span>(tx&gt;<span class="hljs-number">0</span>) maxy=miny+tx/mx*my-my*(tx%mx==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">if</span>(maxx!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld %lld %lld\n&quot;</span>,t,minx,miny,maxx,maxy);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,minx,miny);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>多元一次不定方程<br>
对于方程形如 <code class="inline-code">a1*x1 + a2*x2 + .. + an*xn = c</code><br>
由前文所述，我们知道 <code class="inline-code">a1*x1 + a2*x2 = k(a1, a2)</code> k是整数<br>
所以原式就可以换成： <code class="inline-code">(a1,a2)*x + a3*x3 + .. + an*xn = c</code><br>
重复以上操作，就可以得到： <code class="inline-code">(a1,a2,..an-1)x + an*xn = c</code><br>
再一层层解回去即可</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">//多元一次不定方程
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

const int maxn=5+5;

long long n,c,a[maxn],ans[maxn];

void exgcd(int a,int b,int&amp; d,int&amp; x,int&amp; y) {
    if(!b) {
        d=a,x=1,y=0;
        return ;
    }
    exgcd(b,a%b,d,x,y);
    int temp=x;
    x=y,y=temp-a/b*y;
    return ;
}

void f(long long t,int now,int&amp; nc) {
    if(now&lt;n) f(__gcd(t,a[now]),now+1,nc);
    int x,y,d;
    exgcd(t,a[now],d,x,y);
    if(nc%d!=0) {
        printf(&quot;-1&quot;);
        exit(0);
    }
    x*=nc/d,y*=nc/d;
    ans[now]=y;
    if(now==2) ans[now-1]=x;
    nc=t*x;
    return ;
}

signed main() {
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;c);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%lld&quot;,&amp;a[i]);
    f(a[1],2,c);
    for(int i=1;i&lt;=n;i++)
        printf(&quot;%lld &quot;,ans[i]);
    return 0;
}</pre><pre class="hljs"><code><span class="hljs-comment">//多元一次不定方程</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">5</span>+<span class="hljs-number">5</span>;

<span class="hljs-type">long</span> <span class="hljs-type">long</span> n,c,a[maxn],ans[maxn];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; d,<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span>&amp; y)</span> </span>{
    <span class="hljs-keyword">if</span>(!b) {
        d=a,x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> ;
    }
    <span class="hljs-built_in">exgcd</span>(b,a%b,d,x,y);
    <span class="hljs-type">int</span> temp=x;
    x=y,y=temp-a/b*y;
    <span class="hljs-keyword">return</span> ;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> t,<span class="hljs-type">int</span> now,<span class="hljs-type">int</span>&amp; nc)</span> </span>{
    <span class="hljs-keyword">if</span>(now&lt;n) <span class="hljs-built_in">f</span>(__gcd(t,a[now]),now+<span class="hljs-number">1</span>,nc);
    <span class="hljs-type">int</span> x,y,d;
    <span class="hljs-built_in">exgcd</span>(t,a[now],d,x,y);
    <span class="hljs-keyword">if</span>(nc%d!=<span class="hljs-number">0</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }
    x*=nc/d,y*=nc/d;
    ans[now]=y;
    <span class="hljs-keyword">if</span>(now==<span class="hljs-number">2</span>) ans[now<span class="hljs-number">-1</span>]=x;
    nc=t*x;
    <span class="hljs-keyword">return</span> ;
}

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;c);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);
    <span class="hljs-built_in">f</span>(a[<span class="hljs-number">1</span>],<span class="hljs-number">2</span>,c);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>===================================</p>
<p>同余方程</p>
<p><a data-from-md title='https://www.luogu.com.cn/blog/Snowrry/basic-math-note-2' href='https://www.luogu.com.cn/blog/Snowrry/basic-math-note-2'>https://www.luogu.com.cn/blog/Snowrry/basic-math-note-2</a></p>
<p>是否有解的判断<br>
对于一个方程，形如 <code class="inline-code">ax ≡ b (mod m)</code><br>
其中 a,b 是整数，m是正整数<br>
并令 d=(a,m)<br>
如果 d∤b，则方程 ax = b (mod m) 无解。<br>
如果 d|b，则方程 ax = b (mod m) 恰有 d 个模m 不同余的解。</p>
<p>。。证明。。跳，太长了。</p>
<p>推论<br>
若 a,b 是整数，m是正整数，(a,m) = 1<br>
则对于同余方程 ax = b (mod m)<br>
恰有1个模 m 不同余的解。</p>
<p>===================================</p>
<h2 id="模的逆">模的逆</h2>
<p><a data-from-md title='https://www.cnblogs.com/wonder-land/p/17416718.html' href='https://www.cnblogs.com/wonder-land/p/17416718.html'>https://www.cnblogs.com/wonder-land/p/17416718.html</a></p>
<p>很多题目要求对答案取模<br>
当运算中只有 加法，乘法，自然没有问题</p>
<p>但是有<mark>除法就完蛋</mark>了。</p>
<p>所以我们考虑将 除法转换为 乘法。</p>
<p>即对于 a/b，我们要找到一个 数 x，使得 ax 在模m 意义下，x 等同于 1/b，我们把 x 写作 b^-1</p>
<p>定义<br>
给定整数a，且满足(a,m) = 1，称 ax = 1 (mod m) 的一个解 为 a模m的逆。</p>
<p>扩展欧几里得求逆</p>
<p>费马小定理求逆</p>
<p>线性递推求逆<br>
。。这些都在 前面有，所以就没有抄了。</p>
<h3 id="应用my"><mark>应用</mark>my</h3>
<p>就是现在是求 a1/b1 * a2/b2 * a3/b3 ... 的 模 1e9+7 的 值。<br>
由于有 除法 所以导致 无法 a1 * a2%MOD * a3%MOD ...<br>
要把 a/b 转换为 a*b^-1 。变成 连乘后，就可以 边乘 边MOD。<br>
b^-1 ，就是 b在模1e9+7情况下 的 逆元。</p>
<p>===================================</p>
<p>===================================</p>
<h2 id="快速傅里叶变换fft">快速傅里叶变换FFT</h2>
<p><a data-from-md title='https://www.luogu.com.cn/blog/Snowrry/FFT-note' href='https://www.luogu.com.cn/blog/Snowrry/FFT-note'>https://www.luogu.com.cn/blog/Snowrry/FFT-note</a></p>
<p>学数论时，会遇到 多项式 乘法。<br>
快速傅里叶变换 可以在 O(nlogn + c) 的时间复杂度内 解决此问题。 c大不大另说。</p>
<p>一个多项式大概的样子： F[0] + F[1]x + F[2]x^2 + F[3]x^3 + ... + F[n-1]x^(n-1)</p>
<p>我们用 F 表示这个多项式。</p>
<p>。。能力之外了。。</p>
<p>===================================</p>
<h2 id="鞋带公式-求多边形面积">鞋带公式 - 求多边形面积</h2>
<p><img src="../_resources/badf91d4e2c0452ef227f53199190e0b.png" alt=""></p>
<p>选择一个顶点，然后按照  逆时针  顺序读取坐标，最后回到起点。<br>
按照类似  系鞋带的顺序  将坐标  串联起来。</p>
<p><img src="../_resources/b1ee27fdde33aa4d88d8ce2d9c443f64.png" alt=""></p>
<p>都是相乘，  sum(绿色) - sum(红色) = 110，  多边形的面积就是  110/2=55</p>
<p>这个是把  多边形  切分成  多个  三角形，  然后  向量计算  三角形面积。  都是  都需要/2，所以  最后  /2</p>
<hr>
<p>S三角形=0.5∗((x1∗y2+x2∗y3+x3∗y1)−(y1∗x2+y2∗x3+y3∗x1))</p>
<p>现在  多边形上  取一条边，  加上原点(0,0)  就组成  三角形，  套入上面的公式，  有原点(0,0) (假设x1,y1  是原点)，  所以就等于  1/2 * (x2<em>y3 - x3</em>y2)</p>
<p>就是上面的  绿线相乘  -  红线相乘。然后/2</p>
<p>然后按照顺序遍历所有的边。计算每个三角形</p>
<hr>
<p>由A--&gt;B--&gt;C--&gt;A 按逆时针方向转。(行列式书写要求） 设三角形的面积为S ，则S=（1/2)*(下面行列式）</p>
<p>|x1 y1 1|<br>
|x2 y2 1|<br>
|x3 y3 1|</p>
<p>S=(1/2)<em>(x1y2</em>1+x2y3<em>1+x3y1</em>1-x1y3<em>1-x2y1</em>1-x3y2*1)</p>
<p>即用三角形的三个顶点坐标求其面积的公式为: S=(1/2)*(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)。</p>
<p>===================================</p>
<p>===================================</p>
<h2 id="欧几里得算法-辗转相除法">欧几里得算法 - 辗转相除法</h2>
<p>求2个数的最大公约数</p>
<hr>
<p>扩展欧几里得算法</p>
<p>旨在解决一个问题：  求  ax + by = gcd(a, b)，  其中a, b为常数  的整数解</p>
<p>收集  辗转相除法  中产生的  式子，倒回去，可以得到  ax + by = gcd(a, b)  的整数解。</p>
<p>扩展欧几里得算法  可以用于  计算  模逆元</p>
<p>int exgcd(int a,int b,int &amp;x,int &amp;y){<br>
    //x为a的解，y为b的解<br>
    if(b==0){//到达尽头<br>
        x=1,y=0;<br>
        //y可赋任意整数值<br>
        return a;//返回最大公因数<br>
    }<br>
    int d=exgcd(b,a%b,x,y);<br>
    //此时的x,y为下一层的解<br>
    int temp=y;<br>
    y=x-a/b*y;//把y变成当前层解<br>
    x=temp;//把x变成当前层解<br>
    return d;<br>
}</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="差分数组">差分数组</h1>
<p>频繁对数组的  区间[i,j]  中每个元素做加减法。<br>
比如，对区间[a,b]中每个元素  +3，  然后  对[a+1,b-1]中每个元素  -2</p>
<p>差分数组是  一个和原数组等长的数组，其第i个元素表示  原数组[i]和[i-1]的差值，即原数组[i]  -  原数组[i-1]</p>
<p>由原数组  得到差分数组<br>
i == 0 :  diff[0] = nums[0];<br>
i != 0 : diff[i] = nums[i] - nums[i - 1];</p>
<p>由差分数组  得到原数组<br>
i ==0：nums[0] = diff[0];<br>
i !=0：nums[i] = nums[i - 1] + diff[i];</p>
<p>给区间[i  ,j]增加val<br>
diff[i] += val;<br>
if (j + 1 &lt; diff.size())<br>
diff[j + 1] -= val;</p>
<hr>
<p>给你一个数组(或全0的数组)，然后多个区间，进行加减，最后求  数组和。</p>
<p>给你多个区间[x, y]，分别告诉你小于x获得多少，[x, y]  获得多少，大于x获得多少，然后  求  在哪里能获得最大值，最大值多少</p>
<p>多个区间[x,y,z,a,b,c], &lt;x多少，[x, y]多少，[y,z]多少，[z,a]多少，[a,b]多少，[b,c]多少，大于c多少。</p>
<p>===================================</p>
<h1 id="快速幂">快速幂</h1>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">// a^b % mod
static long powMod(long a, int b, final long mod) {
    long ret = 1;
    while (b != 0) {
        if ((b &amp; 1) == 1) ret = ret * a % mod;
        b &gt;&gt;= 1;
        a = a * a % mod;
    }
    return ret;
}</pre><pre class="hljs"><code><span class="hljs-comment">// a^b % mod</span>
<span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">powMod</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">int</span> b, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> mod)</span> {
    <span class="hljs-type">long</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) ret = ret * a % mod;
        b &gt;&gt;= <span class="hljs-number">1</span>;
        a = a * a % mod;
    }
    <span class="hljs-keyword">return</span> ret;
}</code></pre></div>
<p>===================================</p>
<p><a data-from-md title='https://www.geeksforgeeks.org/range-minimum-query-for-static-array/' href='https://www.geeksforgeeks.org/range-minimum-query-for-static-array/'>https://www.geeksforgeeks.org/range-minimum-query-for-static-array/</a></p>
<h1 id="range-minimum-query-square-root-decomposition-and-sparse-table">Range Minimum Query (Square Root Decomposition and Sparse Table)</h1>
<p>。平方根分解  与  稀疏表</p>
<p>我们有一个数组  arr[0…n-1]，  我们需要高效地  找到  L R  区间内的  min value。比如下面的情况<br>
Input：  arr[] = {7,2,3,0,5,10,3,12,18}<br>
query[] = [0,4],[4,7],[7,8]</p>
<p>Output: min of [0,4] is 0<br>
min of [4,7] is 3<br>
min of [7,8] is 12</p>
<p>一种方法是  遍历  L  到  R  来找到  min，  不需要额外的  时间空间，每次查询  O(n)，<br>
另一种是  segment tree，需要  额外的  O(n)的时间和空间  来构建  segment tree，  每次查询  O(logN)</p>
<p>Can we do better if we know that the array is static?</p>
<p>Method  1  (Simple  Solution)</p>
<p>创建一个  2维数组，[i][j]  保存的就是  range[i,j]的  min  。  query  时间复杂度是O(1)。但预处理时  需要  O(n^2)  时间和空间</p>
<p>Method  2  (Square Root Decomposition)<br>
我们可以使用  平方根分解  来降低  上面方法需要的  空间。</p>
<p>预处理</p>
<ol>
<li>
<p>将[0, n-1]  划分为  sqrt(n)  个。。Divide the range [0, n-1] into different blocks of  √n each.  。。不知道  是  sqrt(n)  个block，还是  每个block  sqrt(n)个元素。。  还有  是  上取整，还是下取整。。。  看第二步，应该是  每个  block sqrt(n)  个元素。  但是不一定  正好是  平方数啊。  sqrt个  和  每个sqrt  都差不多，区别就是  最后一个block  中元素  是否能超过  sqrt(n)</p>
</li>
<li>
<p>计算每个  sqrt(n)  大小的  block  的  min，并且保存下  结果。</p>
</li>
</ol>
<p>预处理的  时间复杂度是  O(sqrt(n) ^ 2) = O(n)，  空间复杂度O(sqrt(n))</p>
<p><img src="../_resources/b4042f1d760f6d8adbafca70ed7be830.png" alt="rmq3"></p>
<p>query:</p>
<ol>
<li>要查询  L  到R  的  min，我们  获得  被  L R  范围  完全覆盖的  多个block  的  min。对于左侧  和右侧的  边界的block，可能被部分覆盖，我们  遍历它们  来搜索  min。</li>
</ol>
<p>时间复杂度  O(sqrt(N))</p>
<p>更多信息看：  <a data-from-md title='https://www.geeksforgeeks.org/sqrt-square-root-decomposition-technique-set-1-introduction/' href='https://www.geeksforgeeks.org/sqrt-square-root-decomposition-technique-set-1-introduction/'>https://www.geeksforgeeks.org/sqrt-square-root-decomposition-technique-set-1-introduction/</a></p>
<p>下面的代码来上上面的链接</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void update(int idx, int val)
{
    int blockNumber = idx / blk_sz;
    block[blockNumber] += val - arr[idx];
    arr[idx] = val;
}

int query(int l, int r)
{
    int sum = 0;
    while (l&lt;r and l%blk_sz!=0 and l!=0)
    {
        sum += arr[l];
        l++;
    }
    while (l+blk_sz-1 &lt;= r)
    {
        sum += block[l/blk_sz];
        l += blk_sz;
    }
    while (l&lt;=r)
    {
        sum += arr[l];
        l++;
    }
    return sum;
}

// Fills values in input[]
void preprocess(int input[], int n)
{
    int blk_idx = -1;
    blk_sz = sqrt(n);
    for (int i=0; i&lt;n; i++)
    {
        arr[i] = input[i];
        if (i%blk_sz == 0)
        {
            blk_idx++;
        }
        block[blk_idx] += arr[i];
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span>
</span>{
    <span class="hljs-type">int</span> blockNumber = idx / blk_sz;
    block[blockNumber] += val - arr[idx];
    arr[idx] = val;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>
</span>{
    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (l&lt;r <span class="hljs-keyword">and</span> l%blk_sz!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> l!=<span class="hljs-number">0</span>)
    {
        sum += arr[l];
        l++;
    }
    <span class="hljs-keyword">while</span> (l+blk_sz<span class="hljs-number">-1</span> &lt;= r)
    {
        sum += block[l/blk_sz];
        l += blk_sz;
    }
    <span class="hljs-keyword">while</span> (l&lt;=r)
    {
        sum += arr[l];
        l++;
    }
    <span class="hljs-keyword">return</span> sum;
}

<span class="hljs-comment">// Fills values in input[]</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preprocess</span><span class="hljs-params">(<span class="hljs-type">int</span> input[], <span class="hljs-type">int</span> n)</span>
</span>{
    <span class="hljs-type">int</span> blk_idx = <span class="hljs-number">-1</span>;
    blk_sz = <span class="hljs-built_in">sqrt</span>(n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)
    {
        arr[i] = input[i];
        <span class="hljs-keyword">if</span> (i%blk_sz == <span class="hljs-number">0</span>)
        {
            blk_idx++;
        }
        block[blk_idx] += arr[i];
    }
}</code></pre></div>
<p>。看起来是  每个block  最多  sqrt(n)  个，  不过  最后一个block，如果没有满，则不会被用到。  query的时候  由于  l  + blk_size  大于  r，所以进不了  最后一个  不满的block</p>
<p>Method  3 (Sparse Table Algorithm)</p>
<p>上面的方法  只使用了  O(sqrt(n))  的空间，  但是  每次query  使用  O(sqrt(n))  的时间。<br>
sparse  table  支持  query O(1)，  额外空间  O(nlogn)</p>
<p>基本思想是  预处理  每个  2^j  长度的  subarr，计算它的  min，  j  的范围是  [0, logn]。</p>
<p>和method  1一样，  我们需要一个  lookup  数组，lookup[i][j]  表示的是  从i开始，长度为  2^j  的subarr  的min。例如，  lookup[0][3]  保存了  [0,7]  range  的min  (从下标0开始，长度是  2^3)</p>
<p>预处理：<br>
lookup表中元素  如何生成？方法很简单，bottom-up的方式，使用  上次计算的值  来  fill table。</p>
<p>例如，为了  找到  range[0,7]  的min，  我们会使用到  2个range  来计算min：  range  [0,3], range[4,7]。</p>
<p>基于上面的例子，下面是  伪代码</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// If arr[lookup[0][2]] &lt;=  arr[lookup[4][2]],
// then lookup[0][3] = lookup[0][2]
If arr[lookup[i][j-1]] &lt;= arr[lookup[i+2^(j-1)][j-1]]
   lookup[i][j] = lookup[i][j-1]

// If arr[lookup[0][2]] &gt;  arr[lookup[4][2]],
// then lookup[0][3] = lookup[4][2]
Else
   lookup[i][j] = lookup[i+2j-1][j-1]</pre><pre class="hljs"><code>// If arr<span class="hljs-comment">[lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[2]</span>]</span> &lt;=  arr<span class="hljs-comment">[lookup<span class="hljs-comment">[4]</span><span class="hljs-comment">[2]</span>]</span>,
// then lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span> = lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[2]</span>
If arr<span class="hljs-comment">[lookup<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>]</span> &lt;= arr<span class="hljs-comment">[lookup<span class="hljs-comment">[i+2^(j-1)]</span><span class="hljs-comment">[j-1]</span>]</span>
   lookup<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = lookup<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>

// If arr<span class="hljs-comment">[lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[2]</span>]</span> &gt;  arr<span class="hljs-comment">[lookup<span class="hljs-comment">[4]</span><span class="hljs-comment">[2]</span>]</span>,
// then lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span> = lookup<span class="hljs-comment">[4]</span><span class="hljs-comment">[2]</span>
Else
   lookup<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = lookup<span class="hljs-comment">[i+2j-1]</span><span class="hljs-comment">[j-1]</span></code></pre></div>
<p>。。计算[i][j]，用到了  [i][j-1]  和  [i+2^(j-1)][j-1]</p>
<p><img src="../_resources/8c185adb6bb26d8b4edb9eef91bdaf2a.png" alt="rmqsparsetable"></p>
<p>query:</p>
<p>对于每个[L, R]，我们需要  使用  2的次方  长度的  range。  每次使用  最接近的  2的次方。我们需要做  最多一次的  比较  (比较  2个  2的次方长度的  range的  min  的  大小)。</p>
<p>一个range  开始于L，终于  L  +  最大的2的次方。<br>
另一个range  终于R，开始于  R  -  相同的最大的2的次方  + 1。</p>
<p>例如，如果给定的range  是  [2,10]，那么我们比较  [2,9], [3,10]  的  min。<br>
。。range  [2, 9]  就是  lookup[2, 3],  range[3,10]  就是lookup[3,3]</p>
<p>上面例子的  伪代码</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// For (2,10), j = floor(Log2(10-2+1)) = 3
j = floor(Log(R-L+1))

// If arr[lookup[0][3]] &lt;=  arr[lookup[3][3]],
// then RMQ(2,10) = lookup[0][3]
If arr[lookup[L][j]] &lt;= arr[lookup[R-(int)pow(2,j)+1][j]]
   RMQ(L, R) = lookup[L][j]

// If arr[lookup[0][3]] &gt;  arr[lookup[3][3]],
// then RMQ(2,10) = lookup[3][3]
Else
   RMQ(L, R) = lookup[R-(int)pow(2,j)+1][j]</pre><pre class="hljs"><code>// For (2,10), j = floor(Log2(10-2+1)) = 3
j = floor(Log(R-L+1))

// If arr<span class="hljs-comment">[lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span>]</span> &lt;=  arr<span class="hljs-comment">[lookup<span class="hljs-comment">[3]</span><span class="hljs-comment">[3]</span>]</span>,
// then RMQ(2,10) = lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span>
If arr<span class="hljs-comment">[lookup<span class="hljs-comment">[L]</span><span class="hljs-comment">[j]</span>]</span> &lt;= arr<span class="hljs-comment">[lookup<span class="hljs-comment">[R-(int)pow(2,j)+1]</span><span class="hljs-comment">[j]</span>]</span>
   RMQ(L, R) = lookup<span class="hljs-comment">[L]</span><span class="hljs-comment">[j]</span>

// If arr<span class="hljs-comment">[lookup<span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span>]</span> &gt;  arr<span class="hljs-comment">[lookup<span class="hljs-comment">[3]</span><span class="hljs-comment">[3]</span>]</span>,
// then RMQ(2,10) = lookup<span class="hljs-comment">[3]</span><span class="hljs-comment">[3]</span>
Else
   RMQ(L, R) = lookup<span class="hljs-comment">[R-(int)pow(2,j)+1]</span><span class="hljs-comment">[j]</span></code></pre></div>
<p>我们只做了一次  比较，所以  时间复杂度是  O(1)。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">// C++代码，完成 range min
// query O(1)
// 额外空间 和 预处理时间 都是 O(n log n)
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define MAX 500

// [i][j] 保存了 i为第一个元素，2^j 为长度的 subarr 的min
// 应该是 [n][logn]，这里固定下来，来使得代码简单一些。
int lookup[MAX][MAX];

// Structure to represent a query range
struct Query {
    int L, R;
};

// bottom-up 地 fill 数组
void preprocess(int arr[], int n)
{
// 长度1 的subarr 的 min
    for (int i = 0; i &lt; n; i++)
        lookup[i][0] = i;

// 间隔 从小到大 开始计算 min
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++)
    {
        // 以每个下标为开始， 计算 2^j 长度的 subarr 的 min
        for (int i = 0; (i + (1 &lt;&lt; j) - 1) &lt; n; i++)
        {

            if (arr[lookup[i][j - 1]] &lt; arr[lookup[i + (1 &lt;&lt; (j - 1))][j - 1]])

                lookup[i][j] = lookup[i][j - 1];
            else
                lookup[i][j] = lookup[i + (1 &lt;&lt; (j - 1))][j - 1];
        }
    }
}

// Returns minimum of arr[L..R]
int query(int arr[], int L, int R)
{
    int j = (int)log2(R - L + 1);

    if (arr[lookup[L][j]] &lt;= arr[lookup[R - (1 &lt;&lt; j) + 1][j]])
        return arr[lookup[L][j]];
    else
        return arr[lookup[R - (1 &lt;&lt; j) + 1][j]];
}

// Prints minimum of given
// m query ranges in arr[0..n-1]
void RMQ(int arr[], int n, Query q[], int m)
{
    // Fills table lookup[n][Log n]
    preprocess(arr, n);

    // One by one compute sum of all queries
    for (int i = 0; i &lt; m; i++)
    {
        int L = q[i].L, R = q[i].R;

        // Print sum of current query range
        cout &lt;&lt; &quot;Minimum of [&quot; &lt;&lt; L &lt;&lt; &quot;, &quot;
             &lt;&lt; R &lt;&lt; &quot;] is &quot;
             &lt;&lt; query(arr, L, R) &lt;&lt; endl;
    }
}

// Driver code
int main()
{
    int a[] = { 7, 2, 3, 0, 5, 10, 3, 12, 18 };
    int n = sizeof(a) / sizeof(a[0]);
    Query q[] = { { 0, 4 }, { 4, 7 }, { 7, 8 } };
    int m = sizeof(q) / sizeof(q[0]);
    RMQ(a, n, q, m);
    return 0;
}</pre><pre class="hljs"><code><span class="hljs-comment">// C++代码，完成 range min</span>
<span class="hljs-comment">// query O(1)</span>
<span class="hljs-comment">// 额外空间 和 预处理时间 都是 O(n log n)</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 500</span>

<span class="hljs-comment">// [i][j] 保存了 i为第一个元素，2^j 为长度的 subarr 的min</span>
<span class="hljs-comment">// 应该是 [n][logn]，这里固定下来，来使得代码简单一些。</span>
<span class="hljs-type">int</span> lookup[MAX][MAX];

<span class="hljs-comment">// Structure to represent a query range</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span> {
    <span class="hljs-type">int</span> L, R;
};

<span class="hljs-comment">// bottom-up 地 fill 数组</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preprocess</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>
</span>{
<span class="hljs-comment">// 长度1 的subarr 的 min</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        lookup[i][<span class="hljs-number">0</span>] = i;

<span class="hljs-comment">// 间隔 从小到大 开始计算 min</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= n; j++)
    {
        <span class="hljs-comment">// 以每个下标为开始， 计算 2^j 长度的 subarr 的 min</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; (i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span>) &lt; n; i++)
        {

            <span class="hljs-keyword">if</span> (arr[lookup[i][j - <span class="hljs-number">1</span>]] &lt; arr[lookup[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]])

                lookup[i][j] = lookup[i][j - <span class="hljs-number">1</span>];
            <span class="hljs-keyword">else</span>
                lookup[i][j] = lookup[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>];
        }
    }
}

<span class="hljs-comment">// Returns minimum of arr[L..R]</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span>
</span>{
    <span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)<span class="hljs-built_in">log2</span>(R - L + <span class="hljs-number">1</span>);

    <span class="hljs-keyword">if</span> (arr[lookup[L][j]] &lt;= arr[lookup[R - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]])
        <span class="hljs-keyword">return</span> arr[lookup[L][j]];
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> arr[lookup[R - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]];
}

<span class="hljs-comment">// Prints minimum of given</span>
<span class="hljs-comment">// m query ranges in arr[0..n-1]</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RMQ</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, Query q[], <span class="hljs-type">int</span> m)</span>
</span>{
    <span class="hljs-comment">// Fills table lookup[n][Log n]</span>
    <span class="hljs-built_in">preprocess</span>(arr, n);

    <span class="hljs-comment">// One by one compute sum of all queries</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)
    {
        <span class="hljs-type">int</span> L = q[i].L, R = q[i].R;

        <span class="hljs-comment">// Print sum of current query range</span>
        cout &lt;&lt; <span class="hljs-string">&quot;Minimum of [&quot;</span> &lt;&lt; L &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>
             &lt;&lt; R &lt;&lt; <span class="hljs-string">&quot;] is &quot;</span>
             &lt;&lt; <span class="hljs-built_in">query</span>(arr, L, R) &lt;&lt; endl;
    }
}

<span class="hljs-comment">// Driver code</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a[] = { <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span> };
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(a) / <span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]);
    Query q[] = { { <span class="hljs-number">0</span>, <span class="hljs-number">4</span> }, { <span class="hljs-number">4</span>, <span class="hljs-number">7</span> }, { <span class="hljs-number">7</span>, <span class="hljs-number">8</span> } };
    <span class="hljs-type">int</span> m = <span class="hljs-built_in">sizeof</span>(q) / <span class="hljs-built_in">sizeof</span>(q[<span class="hljs-number">0</span>]);
    <span class="hljs-built_in">RMQ</span>(a, n, q, m);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>===================================</p>
<p>===================================</p>
<h1 id="lsm-tree-nosql数据库存储结构">LSM tree - nosql数据库存储结构</h1>
<p><a data-from-md title='https://zhuanlan.zhihu.com/p/181498475' href='https://zhuanlan.zhihu.com/p/181498475'>https://zhuanlan.zhihu.com/p/181498475</a></p>
<p>LSM树(log structured merge tree)  会给  初识者  一个错误的印象。</p>
<p>实际上，LSM  并不像  B+树，红黑树  那样  是一颗  严格的  树状数据结构，它其实是一种  存储结构，目前  HBase，LevelDB，RocksDB  这些  NoSQL  存储  都是  采用LSM树</p>
<p>LSM树的  核心特点是  利用  顺序写  来提高  写性能，但因为  分层(  此处分层是指  分为  内存  和  文件  2部分)  的设计  会稍微降低  读性能，但是  通过  牺牲  小部分  读性能  换来  高性能写，使得  LSM树  称为  非常  流程的  存储结构</p>
<p>LSM树核心思想</p>
<p><img src="../_resources/69f879c9b8cb3aa4b27abe4ab3c0b2c6.png" alt="计算机生成了可选文字: Memory memtable write immutable memtable read blockcache sstable flush sstable Disk sstable"></p>
<p>如上所示，有3个重要组成部分</p>
<ol>
<li>MemTable</li>
</ol>
<p>是内存中的  数据结构，用于保存最近更新的数据，会按照  Key  有序地  组织这些数据，LSM树  对于  具体如何  有序地  组织数据  并没有明确的  数据结构定义。例如  Hbase  使用跳表来保证内存中  Key  的有序</p>
<p>因为数据暂时保存在内存中，内存并不是可靠的存储，所以  通常  会通过WAL(write-ahead logging，  预写式日志)  的方式  来保证数据的可靠性</p>
<ol>
<li>Immutable  MemTable</li>
</ol>
<p>当MemTable  达到一定大小后，会转化为  Immutable MemTable，这个是  将  MemTable  转化为  SSTable  的  一种中间状态。写操作由  新的  MemTable  处理，在转存过程中  不阻塞  数据更新操作</p>
<ol>
<li>SSTable(Sorted String Table)</li>
</ol>
<p>有序  键值对  集合，是  LSM树  在  磁盘中的  数据结构，为了加快  SSTable  的读取，可以通过  建立  Key  的索引  以及  布隆过滤器  来加快  Key  的查找。</p>
<p>LSM树会将  所有数据插入，修改，删除  等  操作记录   保存在内存中，当此类操作  达到一定的数据量后，再批量地  顺序写入到  磁盘中。  这和B+树不同，B+树  数据的更新  会直接在  原数据  处  修改对于的值，但是  LSM树  的更新是  日志式的，  一次数据的更新  是通过  append  一条更新日志  来完成的。  这样设计的  目的是  为了顺序写，不断地将  Immutable MemTable  刷新到磁盘即可，而不用去  修改  以往的  SSTable  中  Key  的值，保证了  顺序写。</p>
<p>因此  在不同的  SSTable中，可能存在  相同key  的记录，当然  最新的  那条  记录  才是准确的。  这样的设计  虽然  大大提高了  写性能，但是  带来了一些问题</p>
<ol>
<li>
<p>冗余存储，对于  某个Key，除了最新的那条以外，其他的记录  都是冗余的，但是仍然占据了  存储空间。因此需要  进行  Compact操作  (合并多个  SSTable)  来清除冗余数据。</p>
</li>
<li>
<p>读取时  需要从  最新的  倒着查。最坏情况要查询完  所有的  SSTable，这里可以通过  前面提到的  index，bloom filter  来优化查找速度</p>
</li>
</ol>
<p>LSM的Compact策略<br>
从上面可以看出，Compact  操作  是十分关键的操作，苟泽  SSTable  数量会  不断膨胀。这里主要介绍  2  种  基本策略。</p>
<p>先介绍3个比较重要的  概念，实际上  不同的策略  就是  围绕  这3个  概念  之间  做出  权衡  和  取舍。</p>
<ol>
<li>
<p>读放大：读取数据时  实际读取的数据量  大于  真正的数据量。例如  在LSM树中  需要先在  MemTable  查看  当前  key  是否存在，不存在  则继续从  SSTable  中寻找</p>
</li>
<li>
<p>写放大：写入数据时  实际写入的数据量  大于真正的  数据量。  例如，在  LSM树  中  写入时  可能触发  Compact  操作，导致  实际写入的  数据量  远大于  该  Key  的数据量</p>
</li>
<li>
<p>空间放大：数据实际占用的  磁盘空间  比数据真正的大小更多。  就是上面提到的  冗余存储。</p>
</li>
</ol>
<p>size-tiered  策略<br>
保证每层  SSTable  的大小相近，同时限制每层SSTable  的数量。</p>
<p>每层限制  SSTable  为  N，当每层  SSTable  达到N后，触发  Compact  操作  合并这些  SSTable，将  合并后的  结果写入到  下一层  成为一个  更大的  SSTable。</p>
<p>由此可以看出，当层数达到一定数量时，最底层(。。是从上往下合并的  )  的  单个  SSTable  的大小会变得  非常大。</p>
<p>并且  该策略  导致  空间放大比较严重。  即使在  同一层的SSTable，每个  key  的记录是可能存在  多份的，只有当该层的  SSTable  执行  compact  时  才会消除  这些  key的  冗余记录。</p>
<p>。。只要不是  最顶层，不可能  空间放大。  。  不，  可能是  第一层  3个  合并了，放到  第二层中，然后  第一层又  有了  3个，  并且  第一层中  和  第二层中  有相同的  key，  然后  第一层进行合并，放到  第二层，  那么  第二层  就有重复了。</p>
<p>。。  所以  同层  会重复。   不同层也有重复。</p>
<p>leveled策略<br>
也是分层的思想，每一层限制  总文件  的大小。</p>
<p>但是和  size-tiered  不同的是，leveled  会将  每层  切分成  多个  大小相近的  SSTable。这些  SSTable  在这一层  是  全局有序的，意味着，一个key  在每层  至多只有一条记录，不存在冗余记录。</p>
<p>当第一层L1  的  总大小  超过  大小限制时，  会从  L1中  选择至少一个文件，然后把  它  跟  L2  有交集的部分(非常关键)  进行  合并，  生成的文件  会放在  L2</p>
<p>如果L1  的  第二个SSTable  的  key  范围  覆盖了  L2中  前3个  SSTable，那么就需要在  L1的第二个  和  L2的  前3个  SSTable  中  执行  compact  操作</p>
<p>如果L2  在  compact后  超过了  限制，那么就重复之前的操作：  选至少一个文件，然后合并到  下一层。</p>
<p>多个不相干的合并是可以并发进行的。</p>
<p><img src="../_resources/1c35af92a765b2098f0582959c3c0eb0.png" alt="1"></p>
<p>leveled策略相较于  size-tired  策略来说，每层内  key  是不会重复的，即使最坏的情况，除开最底层外，其余层  都是  重复key，按照相邻层  大小比例  为  10  来算，冗余占比也很小，因此空间放大问题得到缓解。但是  写放大问题  更加突出。举一个  最坏的场景，如果  某层的  某个SSTable  的  key  范围跨度非常大，覆盖了  下一层的  所有  key  的范围，那么  进行  compact时  将涉及  下一层的  全部数据。</p>
<p>===================================</p>
<h1 id="用卡特兰数来求出栈序列个数">用卡特兰数来求出栈序列个数</h1>
<p>===================================</p>
<p>===================================</p>
<h1 id="指派问题匈牙利算法">指派问题，匈牙利算法</h1>
<p>需要完成n个任务，正好有n个人，每个人的专长不同，所以完成任务的代价不同。<br>
应该为人  指派什么问题，使得完成  n  项任务的  总代价最小。</p>
<p>这类问题，根据  人员和代价(收益)  建立矩阵，称为  效率矩阵  或系数矩阵，其中元素  cij &gt; 0  表示  第i个人  完成第j个任务的  效率(或时间，成本等)</p>
<p>代价矩阵有一个性质，如果从指派问题的  系数矩阵的  某行(列)  各元素  分别减去  或者  加上常数  k，  其最优任务  分解问题不变。</p>
<p>匈牙利算法  实际上有2个算法，分别解决  指派问题  和  二分图最大匹配求解问题。此处  指的是  解决指派问题的  匈牙利算法。</p>
<p>第一步<br>
矩阵经过变换，在各行各列中都出现  0  元素。<br>
使指派问题的  系数矩阵变换，在  各行各列中  都出现  0  元素<br>
从  系数矩阵的  每行元素减去  该行的最小元素<br>
从所得系数矩阵的  每列元素  减去  该列的最小元素。<br>
如果某行(列)  已有  0  元素，那就不必再  减了。<br>
每行每列  最小元素  非负</p>
<p>第二步<br>
进行试指派，以寻求最优解。为此，按以下步骤进行</p>
<p>经第一步变换后，系数矩阵中  每行每列  都已有了  0  元素，  但需要找出  n  个独立的  0  元素。如果能找到，就以这些  独立  0  元素  对应  解矩阵  (xij)  中的元素  为1，  其余为0，就得到最优解。</p>
<p>步骤为</p>
<ol>
<li>
<p>从只有一个0元素的  行  开始，给这个  0  元素加圈，记做@，这表示  对这行  所代表的人，只有  一种  任务可以指派。然后  划去@  所在  列  的其他  0元素，记做Φ。这表示  这列所代表的  任务已经指派完，不需要考虑其他人</p>
</li>
<li>
<p>只有  一个0元素的  列  的  0元素加圈，记做@，然后  划去  @所在的行的  0元素，记做  Φ。</p>
</li>
<li>
<p>反复进行1,2，直到所有  0元素都被  圈出  和  划掉。</p>
</li>
<li>
<p>如果  仍有  没有  画圈的  0元素，且  同行(列)  的  0元素至少有2个。这可以用不同的方案  去试探。  从剩余0元素  最少的  行(列)  开始，比较这行  各  0  元素所在列中0元素的数目，选择0元素少的  那列的  0元素  加圈。  然后划掉同行同列的  其他0元素。  反复进行，直到所有0元素  都已圈出  和  划掉为止。</p>
</li>
<li>
<p>如果  @元素  的数目m  等于  矩阵的阶数n，那么  指派问题的  最优解已经得到，如果  m &lt; n，  则进入下一步。</p>
</li>
</ol>
<p>第三步<br>
(m &lt; n  时的处理方法)：  作最少的直线  覆盖  所有0元素，  以确定  该系数矩阵中  能找到  最多的  独立元素数。<br>
为此按以下步骤进行：</p>
<ol>
<li>
<p>对没有@  的行  打  √  号；</p>
</li>
<li>
<p>对已打√  的行中  所有  包含@元素  的  列  打  √。</p>
</li>
<li>
<p>再对  打√的  列  中  含有@元素的  行  打√。</p>
</li>
<li>
<p>重复2,3，直到得不出新的  √。</p>
</li>
<li>
<p>对没有  √  的行  画一条横线，  对有  √的  列画一条  纵线，这样  就得到了  覆盖所有  0元素的  最少直线数  l  。  如果  l &lt; n，说明必须  变换当前  系数矩阵，才能找到  n  个独立的  0元素，因此需要转第四步；如果  l=n，而m&lt;n，则应该回到  第二步的4，另行试探。</p>
</li>
</ol>
<p>第四步<br>
对矩阵进行变换的目的是增加0元素。</p>
<p>为此，在没有被直线覆盖的部分  找出最小元素，然后在  打√  行  各元素都减去这个  最小元素，而在打√  列  的各元素  都加上这个  最小元素，以保证原来的  0  元素不变。</p>
<p>这样得到  新的  系数矩阵  (它的最优解  和  原问题相同)。  如果得到  n  个独立的  0元素，则已经得到最优解，否则  回到  第三步重复进行。</p>
<p>===================================</p>
<h1 id="匈牙利算法-二分图最大匹配">匈牙利算法  -  二分图最大匹配</h1>
<p>用于求解  无权二分图的  最大匹配</p>
<p>二分图，有2个点集，集合内部没有边相连，集合之间有边相连，如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义：不含有  [含奇数条边的环]  的图。</p>
<p>匹配，在图论中，匹配  是一个边的集合，其中  任意两条边  没有公共顶点。</p>
<p>匹配点，匹配边，非匹配点，非匹配边</p>
<p>最大匹配，一个图  的所有匹配中，所含匹配边数最多的匹配，称为这个图的  最大匹配。</p>
<p>完美匹配，如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。  显然，完美匹配一定是最大匹配(  完美匹配的  每个点都已经匹配，添加一条新  的匹配边  一定会与现有的匹配边冲突)</p>
<p>交替路，从一个  未匹配点出发，依次经过非匹配边，匹配边，非匹配边  。。  形成的  路径。</p>
<p>增广路，从一个  未匹配点出发，走交替路，如果途经另一个未匹配点  (出发点不算)，则这条交替路称为  增广路</p>
<p>增广路有一个重要特点：非匹配边  比  匹配边多一条。因此，研究增广路的意义是  改进匹配。只要把增广路中的  匹配边  和  非匹配边  的身份交换即可。由于  中间的匹配节点不存在  其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目  比原来  多了一条。</p>
<p>我们可以通过不断地  找增广路  来增加匹配中的  匹配边  和  匹配点。找不到增广路时，达到最大匹配(这是增广路定理)。  匈牙利算法正是这么做的。</p>
<h2 id="匈牙利树">匈牙利树</h2>
<p>一般由  BFS  构造。  从一个未匹配点出发运行bfs (唯一的限制是，必须走交替路)，直到不能再扩展为止。</p>
<p>匈牙利算法要点如下</p>
<ol>
<li>
<p>从左边第一个顶点开始，挑选未匹配点进行搜索，寻找增广路</p>
<ol>
<li>如果经过一个  未匹配点，说明寻找成功。更新路径信息，匹配边数+1，停止搜索</li>
<li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一颗匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li>
</ol>
</li>
<li>
<p>由于找到增广路之后需要  沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS版本通过  函数调用  隐式地使用栈，而BFS使用  prev  数组</p>
</li>
</ol>
<p>对于稀疏图，BFS  明显快于DFS。  稠密图，不相上下。</p>
<p>最大匹配数，最大匹配的匹配边的数目<br>
最小点覆盖数，选取最少的点，使任意一条边至少有一个端点被选择<br>
最大独立数，选取最多的点，使任意所选2点均不相连<br>
最小路径覆盖数，对于一个  DAG (有向无环图)，选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为0 (即单个点)</p>
<p>定理1：最大匹配数  =  最小点覆盖数  (这是  Konig  定理)<br>
定理2：最大匹配数  =  最大独立数<br>
定理3：最小路径覆盖数  =  顶点数  -  最大匹配数</p>
<h2 id="konig-定理">Konig  定理</h2>
<p>由匈牙利数学家柯尼希（D.Konig）于1913年首先陈述的定理。<br>
定理的内容：在0-1矩阵中，1的最大独立集合最小覆盖包含的元素个数相同，等价地，二分图中的最大匹配数等于这个图中的最小点覆盖数。</p>
<hr>
<p>匈牙利算法的核心在于：在  A  集合中选择一个点，然后  将与其相连的  B中的点  依次对照，如果  B中的点尚未匹配，那就将这2个点进行匹配，然后遍历  A  中下一个点，继续访问与其相连的  B  中的点，如果  B  中的点  已经被匹配了，那么就尝试  递归地  将与B中这个点  相匹配的  A  中的点  换一个  匹配对象。</p>
<p>这其实就是在  寻找  增广路。</p>
<hr>
<h2 id="二分图最大匹配">二分图最大匹配</h2>
<p><a data-from-md title='https://www.cnblogs.com/jsawz/p/6855307.html' href='https://www.cnblogs.com/jsawz/p/6855307.html'>https://www.cnblogs.com/jsawz/p/6855307.html</a></p>
<p>二分图：可以被分为两个子集且保证每个子集中的元素不直接相连的图。<br>
交替路：从一个未匹配点出发，依次经过未匹配边，匹配边，未匹配边......形成的路径叫做交替路。<br>
增广路：从一个未匹配点出发，经过交替路，如果途径一个未匹配点，就把走过的路径叫做增广路。<br>
最大匹配：在一个图的所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。<br>
完美匹配：一个图的所有顶点都是匹配点，那么这个图就是最大匹配。</p>
<p>从增广路的定义上我们可以发现，每一条增广路所包含的未匹配点总比匹配点多一个。如果把增广路的所有匹配点变为未匹配点，未匹配点变为匹配点，每进行这样一次操作，未匹配点都会变少一个。我们可以每次在这个图上寻找增广路，然后进行这样的操作，直到在这个图上找不到增广路为止。而进行完这些操作后，所形成的图就是一个最大匹配的图。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">int dfs(int x){
    for(int i=head[x];i;i=next[i])
        if(!vis[to[i]]){
            vis[to[i]]=1;
            if(!used[to[i]]||dfs(used[to[i]])){
                used[to[i]]=x;
                return 1;
            }
        }
    return 0;
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=next[i])
        <span class="hljs-keyword">if</span>(!vis[to[i]]){
            vis[to[i]]=<span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(!used[to[i]]||<span class="hljs-built_in">dfs</span>(used[to[i]])){
                used[to[i]]=x;
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            }
        }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>===================================</p>
<h1 id="判断二分图">判断二分图</h1>
<p><a data-from-md title='https://www.cnblogs.com/jsawz/p/6847185.html' href='https://www.cnblogs.com/jsawz/p/6847185.html'>https://www.cnblogs.com/jsawz/p/6847185.html</a></p>
<p>二分图定义:<br>
一个无向图，使得顶点集V可以分割为两个互不相交的子集A,B，使得所有边两端分别属于两个子集A,B。</p>
<p>要判断二分图，要分两种情况，一种是联通图，一种是非连通图，两者都不难。</p>
<p>遍历所有点，如果节点u 未染色，把它染上一种颜色，之后遍历所有与它相连的节点v，如果节点v已被染色并且颜色和节点u一样，那么就失败了。如果这个节点v没有被染色，先把它染成与节点u不同颜色的颜色，然后遍历所有与节点v相连的节点</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void dfs(int x,int color){
    col[x]=color;
    for(int i=head[x];i;i=next[i]){
        if(col[to[i]]==col[x]){
            printf(&quot;NO&quot;);
            flag=1;
            exit(0);
        }
        if(!col[to[i]])
            dfs(to[i],-color);
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> color)</span></span>{
    col[x]=color;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=next[i]){
        <span class="hljs-keyword">if</span>(col[to[i]]==col[x]){
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO&quot;</span>);
            flag=<span class="hljs-number">1</span>;
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">if</span>(!col[to[i]])
            <span class="hljs-built_in">dfs</span>(to[i],-color);
    }
}</code></pre></div>
<p>===================================<br>
CF 1633 E<br>
<a data-from-md title='https://www.wenjiangs.com/doc/zapnony9' href='https://www.wenjiangs.com/doc/zapnony9'>https://www.wenjiangs.com/doc/zapnony9</a></p>
<p>Spanning Tree  生成树<br>
是图G  的子集，使用最少的边  覆盖了所有顶点。因此，生成树没有  环，即  移出任意一条边后  会变成  非连通图。</p>
<p>最小生成树<br>
Kruskal<br>
Prim</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="ternary-search">ternary search</h1>
<p>三分查找用来确定函数在凹/凸区间上的极值点</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="大数组合combination">大数组合Combination</h1>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    // big number, nCr
    // p MUST be prime and less than 2^63
    uint64_t inverseModp(uint64_t a, uint64_t p) {

        uint64_t ex = p - 2, result = 1;
        while (ex &gt; 0) {                 //  这个就是  快速幂  来求  逆元
            if (ex % 2 == 1) {
                result = (result * a) % p;
            }
            a = (a * a) % p;
            ex /= 2;
        }
        return result;
    }

    // p MUST be prime
    uint32_t nCrModp(uint32_t n, uint32_t r, uint32_t p)
    {
        if (r &gt; n - r) r = n - r;
        if (r == 0) return 1;
        if (n / p - (n - r) / p &gt; r / p) return 0;

        uint64_t result = 1; //intermediary results may overflow 32 bits

        for (uint32_t i = n, x = 1; i &gt; r; --i, ++x) {
            if (i % p != 0) {
                result *= i % p;
                result %= p;
            }
            if (x % p != 0) {         //  费马小定理：  x  不是  p  的倍数
                result *= inverseModp(x % p, p);
                result %= p;
            }
        }
        return result;
    }</pre><pre class="hljs"><code>    // big number, nCr
    // p MUST be prime and less than 2^63
    uint64_t inverseModp(uint64_t a, uint64_t p) {

        uint64_t ex = p - 2, result = 1;
        while (ex &gt; 0) {                 //  这个就是  快速幂  来求  逆元
            if (ex % 2 == 1) {
                result = (result * a) % p;
            }
            a = (a * a) % p;
            ex /= 2;
        }
        return result;
    }

    // p MUST be prime
    uint32_t nCrModp(uint32_t n, uint32_t r, uint32_t p)
    {
        if (r &gt; n - r) r = n - r;
        if (r == 0) return 1;
        if (n / p - (n - r) / p &gt; r / p) return 0;

        uint64_t result = 1; //intermediary results may overflow 32 bits

        for (uint32_t i = n, x = 1; i &gt; r; --i, ++x) {
            if (i % p != 0) {
                result *= i % p;
                result %= p;
            }
            if (x % p != 0) {         //  费马小定理：  x  不是  p  的倍数
                result *= inverseModp(x % p, p);
                result %= p;
            }
        }
        return result;
    }</code></pre></div>
<p>===================================</p>
<p>===================================</p>
<p>(a/b) mod m = (a mod(m * b)) / b<br>
证:<br>
设  a/b mod m = x<br>
则：<br>
a/b = km + x<br>
a = kbm + bx<br>
a mod bm = bx<br>
a mod bm / b = x</p>
<p>。。对大数的  组合排列，没有用，因为  bm  是一个大数，无法计算的。</p>
<hr>
<p>通过逆元求解</p>
<p>费马小定理：如果  p  是质数，且  a  不是  p  的倍数，则  a^(p-1) ≡1  (mod p)<br>
。。如果  a  是  p  的倍数，  则  a^(x) mod p = 0  (x &gt; 0)<br>
逆元：如果存在x，使得  ax ≡ 1 (mod p)，  那么  x  就是  a  的逆元。</p>
<p>a^(p-1) = a * a^(p-2) = 1(mod p)，  所以  a^(p-2)  就是  a  的逆元。</p>
<p>下面的1  使用了  b^(c-1) mod c = 1<br>
(a/b) mod c<br>
&lt;=&gt;  a<em>1</em>b^(-1) mod c<br>
&lt;=&gt;  a*(b^(c-1))<em>b^(-1) mod c<br>
&lt;=&gt; a</em>b^(c-2) mod c</p>
<p>一般  c  很大，所以要用快速幂</p>
<p>===================================</p>
<h1 id="lucas卢卡斯定理">Lucas卢卡斯定理</h1>
<p>C(n,m)%p=C(n/p,m/p)*C(n%p,m%p)%p</p>
<p>条件：n,m&lt;=10^18,p为素数，p&lt;=10^5<br>
ll C(ll n,ll m){<br>
   ll ans=1;<br>
   for(ll i=1;i&lt;=m;i++){<br>
        ans=ans*(n-m+i)/i;          //  这里可以  mod  吧<br>
   }<br>
   return ans;<br>
}<br>
int Lucas(ll n,ll m){<br>
   if(n==0)return 1;<br>
   return C(n%p,m%p)*lucas(n/p,m/p)%p;<br>
}<br>
。。n%p  以后，再递归调用  Lucas  也没用，因为不会变小了，  所以需要  硬算。</p>
<p>===================================</p>
<p>c(m,n)=c(m-1,n-1)+c(m-1,n)</p>
<p>===================================</p>
<p>===================================</p>
<h1 id="st表-sparse-table之前有">ST表, (sparse table，之前有)</h1>
<p>用于解决  可重复贡献问题</p>
<p>可重复贡献问题：  对于运算  op，运算的性质满足  x op x = x，则对应的  区间查询就是  一个  可重复贡献问题，例如，最大值满足  max(x,x)=x,  最大公因数满足  gcd(x,x)=x，因此  RMQ  和  GCD  就是一个  可重复贡献的问题。</p>
<p>但是  区间和  就不满足  这个性质，因为  在  求解  区间和的过程中  采用的  预处理区间  会发生  重叠，导致  重叠部分被重复计算，因此  对于  op  操作  还需要  满足  结合律  才能使用  ST  表  进行求解。</p>
<p>题目：给定  n  个数，有  m  个查询，对于每个查询，你需要回答  [l, r]  区间内的  最大值。<br>
暴力算法是  O(n^2)。</p>
<p>ST表  基于  倍增思想，可以做到  O(nlogn)  预处理，O(1)  回答。  但是  不支持修改。  所以  ST  表  是一种  离线的  数据结构</p>
<p>基于倍增思想，我们考虑如何求出  区间最值。可以发现，如果按照  一般的  倍增流程，每次跳  2^i  步的话，询问时的  复杂度  仍然  是  O(logn)，  并没有比  线段树  更优，而且  预处理  比  线段树  慢。</p>
<p>我们发现，区间最值  是一个  可重复贡献  的问题。  即使  用来求解的  预处理  区间  有  重叠部分，  只要这些  区间的  并  是  所求的区间，  最终计算出来的  结果就是  正确的。</p>
<p>以最大值为例，设  arr[i][j]  表示整个数列  A  中  下标在  [i，i+2^j-1]  区间中的  最大值。  递推的  边界是  arr[i][0] = A[i]，即数列A  在区间[i，i]  中的最大值。</p>
<p>预处理<br>
在递推时，我们把  子区间  的长度  成倍增加，于是  就可以得到下面的  递推表达式<br>
arr[i][j] = max( arr[i][j-1], arr[i+2^(j-1)][j-1] )</p>
<p>得到代码：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">inline void prework(){
    for(int i=1;i&lt;=n;i++)
        f[i][0]=a[i];
        int  t  =  log(n)/log(2)  +  1;
        for(int j=1;j  &lt;  t;j++){             //  必须  先枚举  倍增次数。
            for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++){
            f[i][j]=max(f[i][j-1],f[  i+(  1  &lt;&lt;  (j-1))  ][j-1]);
        }
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        f[i][<span class="hljs-number">0</span>]=a[i];
        <span class="hljs-type">int</span>  t  =  <span class="hljs-built_in">log</span>(n)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)  +  <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j  &lt;  t;j++){             <span class="hljs-comment">//  必须  先枚举  倍增次数。</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++){
            f[i][j]=<span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[  i+(  <span class="hljs-number">1</span>  &lt;&lt;  (j<span class="hljs-number">-1</span>))  ][j<span class="hljs-number">-1</span>]);
        }
    }
}</code></pre></div>
<p>查询<br>
在查询任意区间[l,r]  的最大值时，先计算出  一个  k，满足<br>
2^k &lt;= r-l+1 &lt; 2^(k+1)<br>
也就是  2的k次幂  小于  区间长度的前提下的  最大的  k。</p>
<p>左侧：<br>
k &lt;= log(r-l+1)/log2<br>
右侧：<br>
k &gt; log(r-l+1)/log2 - 1</p>
<p>所以  k  的上界就是  log(r-l+1)/log2<br>
因此，[l, r]  之间的最大值就是：<br>
max(f[l][k], f[r-(1&lt;&lt;k)+1][k])</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">inline int query(int l,int r){
    int k=log(r-l+1)/log(2);
    return max(f[l][k],f[r-(1&lt;&lt;k)+1][k])
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>{
    <span class="hljs-type">int</span> k=<span class="hljs-built_in">log</span>(r-l+<span class="hljs-number">1</span>)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[l][k],f[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k])
}</code></pre></div>
<hr>
<p>std::__lg（它是  O(1)  的）<br>
__lg在gcc上的实现是调的__builtin_clz，编译出来直接是单独的汇编指令<br>
这函数生成一条汇编bsr指令，有原生的支持</p>
<p>===================================</p>
<p>DSU</p>
<h1 id="uf">UF</h1>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">struct DSU {
    std::vector&lt;int&gt; f, siz;
    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }
    int leader(int x) {
        while (x != f[x]) x = f[x] = f[f[x]];
        return x;
    }
    bool same(int x, int y) { return leader(x) == leader(y); }
    bool merge(int x, int y) {
        x = leader(x);
        y = leader(y);
        if (x == y) return false;
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    int size(int x) { return siz[leader(x)]; }
};</pre><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> {
    std::vector&lt;<span class="hljs-type">int</span>&gt; f, siz;
    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">f</span>(n), <span class="hljs-built_in">siz</span>(n, <span class="hljs-number">1</span>) { std::<span class="hljs-built_in">iota</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leader</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-keyword">while</span> (x != f[x]) x = f[x] = f[f[x]];
        <span class="hljs-keyword">return</span> x;
    }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">leader</span>(x) == <span class="hljs-built_in">leader</span>(y); }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        x = <span class="hljs-built_in">leader</span>(x);
        y = <span class="hljs-built_in">leader</span>(y);
        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        siz[x] += siz[y];
        f[y] = x;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">leader</span>(x)]; }
};</code></pre></div>
<p>周赛345，6432。 siz是边的个数，sz是点的个数。</p>
<p>siz需要在遍历边的时候，加到边的某个点上。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">struct DSU {
    std::vector&lt;int&gt; f, siz, sz;
    DSU(int n) : f(n), siz(n, 0), sz(n, 1) { std::iota(f.begin(), f.end(), 0); }
    int leader(int x) {
        while (x != f[x]) x = f[x] = f[f[x]];
        return x;
    }
    bool same(int x, int y) { return leader(x) == leader(y); }
    bool merge(int x, int y) {
        x = leader(x);
        y = leader(y);
        if (x == y) return false;
        siz[x] += siz[y];
        sz[x] += sz[y];
        f[y] = x;
        return true;
    }
    int size(int x) { return siz[leader(x)]; }
};</pre><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> {
    std::vector&lt;<span class="hljs-type">int</span>&gt; f, siz, sz;
    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">f</span>(n), <span class="hljs-built_in">siz</span>(n, <span class="hljs-number">0</span>), <span class="hljs-built_in">sz</span>(n, <span class="hljs-number">1</span>) { std::<span class="hljs-built_in">iota</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leader</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-keyword">while</span> (x != f[x]) x = f[x] = f[f[x]];
        <span class="hljs-keyword">return</span> x;
    }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">leader</span>(x) == <span class="hljs-built_in">leader</span>(y); }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        x = <span class="hljs-built_in">leader</span>(x);
        y = <span class="hljs-built_in">leader</span>(y);
        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        siz[x] += siz[y];
        sz[x] += sz[y];
        f[y] = x;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">leader</span>(x)]; }
};</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">
DSU uf(n);
for (vector&lt;int&gt;&amp; vi : edges)
{
    ++uf.siz[vi[0]];		// 这个应该能和下面合并到一起的。
}
for (vector&lt;int&gt;&amp; vi : edges)
{
    //++uf.siz[vi[0]];
    uf.merge(vi[0], vi[1]);
}
int ans = 0;
int a, b;
for (int i = 0; i &lt; n; ++i)
{
    if (uf.leader(i) == i)
    {
        a = uf.siz[i];      // edge
        b = uf.sz[i];       // node
        if (a == (b - 1) * b / 2)
            ++ans;
    }
}
return ans;</pre><pre class="hljs"><code>
<span class="hljs-function">DSU <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;
<span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; vi : edges)
{
    ++uf.siz[vi[<span class="hljs-number">0</span>]];		<span class="hljs-comment">// 这个应该能和下面合并到一起的。</span>
}
<span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; vi : edges)
{
    <span class="hljs-comment">//++uf.siz[vi[0]];</span>
    uf.<span class="hljs-built_in">merge</span>(vi[<span class="hljs-number">0</span>], vi[<span class="hljs-number">1</span>]);
}
<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
<span class="hljs-type">int</span> a, b;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
{
    <span class="hljs-keyword">if</span> (uf.<span class="hljs-built_in">leader</span>(i) == i)
    {
        a = uf.siz[i];      <span class="hljs-comment">// edge</span>
        b = uf.sz[i];       <span class="hljs-comment">// node</span>
        <span class="hljs-keyword">if</span> (a == (b - <span class="hljs-number">1</span>) * b / <span class="hljs-number">2</span>)
            ++ans;
    }
}
<span class="hljs-keyword">return</span> ans;</code></pre></div>
<p>===================================</p>
<h1 id="轮廓线dp">轮廓线DP</h1>
<p>n<em>m  的棋盘，放置  1</em>2  的  骨牌。  求能摆满棋盘的方案。</p>
<p>我们只需要统计  边界  上  格子的状态  就可以进行转移了。</p>
<ol>
<li>这个格子  向上放，需要保证  它上面的格子是空的</li>
<li>这个格子  向左放，需要保证它左边的格子为空，且  上面的格子已经填满</li>
<li>不放，需要保证  它上面的格子被填满。</li>
</ol>
<p>总结：  (这里使用了  滚动数据)<br>
dp[tmp][k ^ p[j]] += dp[tmp ^ 1][k], k &amp; p[j]</p>
<p>dp[tmp][k || p[j - 1]] += dp[tmp ^ 1][k], (j &gt; 1) &amp;&amp; !(k &amp; p[j - 1]) &amp;&amp; (k &amp; p[j])</p>
<p>dp[tmp][k || p[j]] += dp[tmp ^ 1][k], (i &gt; 1) &amp;&amp; (k &amp; p[j])</p>
<p>。。k,p,j  分别代表了什么？<br>
。。根据  ||  说明  第二维  是  bool。   但是  tmp  应该是  滚动数组的，  所以  后面那维  应该是  棋盘的  长或宽。<br>
可能是  |  ，而不是  ||  ？<br>
下面以  行数  远远大于  列数  作为前提  (  这样的话  滚动数组的  第二维  应该是  列数)<br>
感觉  k  是代表  当前格子的  列值。<br>
公式中的  逗号  后面应该是  条件，满足条件的时候  才执行前面的  +=  。<br>
根据  公式  上面的  文字描述，  感觉应该是  一一对应的。<br>
但是  p，j  是什么，  p  应该代表  本行。。  估计  p = grid[i]  ？  grid  是  n*m  的棋盘。<br>
。。文章有一张图，当时没有在意。。看  k  的下标。。是  &quot;蠕动数组&quot;。。但是  tmp  是什么？  感觉图文  不匹配。</p>
<p><img src="../_resources/54eb12a5e339a23360f844ea9c1761fb.png" alt="1"></p>
<p>。。。还真是  蠕动的数组。。下面的  讲得比较清</p>
<hr>
<p>轮廓线DP</p>
<p>适用范文：  较窄的棋盘。  按  整行  或整列  无法进行  状态转移。  而是把  轮廓线  作为  状态的一部分。</p>
<p>我们定义  0  为  非覆盖，1为覆盖。<br>
对于每一个小格，轮廓线  包含：  该小格  和  该小格前面且确定该小格后状态还不确定的小格。<br>
。。就是  该小格  +  该小格这行前面的格子  +  该小格上方的后面的格子。    一行格子。不包括  k2</p>
<p><img src="../_resources/91f8d6e675c2085420ac1585f70430c0.png" alt=""></p>
<p>因此，总共有  2^m  个状态  (就是这个格子  被覆盖  或  没被覆盖)。  所以  对于每个小格，我们需要分配  2^m  个状态，因此：</p>
<ol>
<li>
<p>定义  dp[cur][S] :   当前所讨论  小格  轮廓线  内  状态  为  S  时  (例子中  S = k1k2O (2进制)，  当前小格  和  当前小格前面的所有小格  (绿色圈内区域)  的总共铺放  方法数)</p>
</li>
<li>
<p>目标状态：  dp[last][2^m - 1]</p>
</li>
<li>
<p>状态转移：</p>
<ol>
<li>
<p>选择：对每个小格，由于我们只讨论  其  对前面区域的影响，所以可以选择：不放，左放，上放：</p>
<ol>
<li>
<p>不放：O = 0；  前一状态的k2  为1  。(。。就是当前位置是0(代表没有覆盖)，当前位置的上方(本例中为k2)必须已经  覆盖(即1))</p>
</li>
<li>
<p>左放：当前小格不能在第一列；  k0 = O = 1；  前一状态k0=0，k2=1。</p>
</li>
<li>
<p>上放：当前小格不能在第一行；  O=1；  前一状态的  k2 = 0。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="../_resources/a15cb34523bed34c4992d2bec7af4dbb.png" alt="1"></p>
<ol>
<li>滚动数组：当前小格是在  前一小格的基础上讨论，所以采用  滚动数组：
<ol>
<li>dp[x][S]：  表示  前一个小格的  状态</li>
<li>dp[1-x][S]：  表示后一个  小格的状态。  x  属于  {0, 1}</li>
</ol>
</li>
<li>根据  转移的选择  及  条件，有  状态转移方程式：
<ol>
<li>A = dp[1 - cur][(s &gt;&gt; 1) | (1 &lt;&lt; (m-1))]</li>
<li>B = dp[1 - cur][( (s &gt;&gt; 1) | (1 &lt;&lt; (m-1))) &amp; ((1&lt;&lt;m) - 2)]</li>
<li>C = dp[1 - cur][ s &gt;&gt; 1 ]</li>
</ol>
</li>
</ol>
<p>dp[cur][S] =  当前  S  满足不铺：  A<br>
当前  S  满足左铺：  B<br>
当前  S  满足上铺：  C<br>
当前  S  满足左铺+上铺：  B+C</p>
<p>这里  A  对应  不放，B  对应左放，  C  对应上放。</p>
<p>初始状态：dp[0][2^m - 1] = 1，  其余为  0。(这里可以想象：  由于  第0行，不能上方，  所以  -1  行  就  必须全部  被覆盖，  这样  第  0  行  就会  因为  -1  行  被覆盖了，所以  无法  上放)。</p>
<p>初始状态  对应的  是  第  -1  行的  最后一个  小格。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">while (cin &gt;&gt; m &gt;&gt; n)
{
    if (m + n == 0)
        return 0;
    if (n &lt; m)
        swap(n, m);

    memset(dp, 0, sizeof(dp));
    cur = 0;
    dp[cur][ (1&lt;&lt;m) - 1 ] = 1;
    for (int i = 0; i &lt; n; ++i)
    {
        for (int j = 0; j &lt; m; ++j)
        {
            cur ^= 1;
            memset(dp[cur], 0, sizeof(dp[cur]));
            for (int s = 0; s &lt; (1 &lt;&lt; m); ++s)
            {
                //  不放

。。s  是增加本格子后的状态，所以如果增加本格子后，  最后一位(即本格子)  是0，即  没有覆盖，则取  上一个状态的  s&gt;&gt;1 | (1&lt;&lt;(m-1))

。。  s&gt;&gt;1  代表，通过  本状态  获得  上次的状态，  因为  本状态  只是  在  上次的  状态上  去掉头，然后  append  本格子(这里是0)，所以  要  获得  上一个  状态，  就需要  把  本状态  后移一位，  这样  获得了   去掉头的上次状态，

 然后由于  本格子不放，  那么就意味着  本格子上方的格子  必须被覆盖，所以  上次的状态  的  头  就是  被覆盖的。  所以  | (1&lt;&lt;(m-1))。

。。因为  本格子不放，所以  本格子不会  上放，  所以  上方  的格子  必须已经被覆盖了，  不然  没有办法  再覆盖  上方的格子了  (因为  本格子不会放了)。

                if (!(s &amp; 1))
                    dp[cur][s] += dp[1 - cur][ (s&gt;&gt;1) | (1 &lt;&lt; (m - 1))];
                else
                {
                    //  左放
。。不能是第0列。

。。  不过这个  条件  没有看懂  s&gt;&gt;1 &amp; 1，  这个应该是  要求  上一个状态的  最后一位  是1，  即  被覆盖，  如果上一个状态的  最后一位  是1，  本格子  没有办法  左放啊。

。。左放，  也要求  本格子上方  的格子  已经被覆盖，  所以  s&gt;&gt;1 | 1&lt;&lt;(m-1)
。。但是  感觉是  !(s&gt;&gt;1 &amp; 1)  才对啊，  这样的话：  由于这里是  else，所以  保证  本格子  被覆盖。

。。不不不，  s  是  本格子处理后的  状态，  所以  确实  是要求  本格子  前面的  格子  (在处理(左放)完后)  被覆盖，  所以确实  是  s&gt;&gt;1 &amp; 1。

。。  但是  dp  的  下标就不对啊。  应该是  要求  上一个状态：  头被覆盖  &amp;&amp;  尾巴为0  啊  &amp;&amp;  本次的头也被覆盖。。  而现在  s&gt;&gt;1 | (1&lt;&lt;m-1)  的  尾巴  必然是  1，  因为  if  里的判断。

。。  尾巴为0  就意味着  尾巴的  上方的  格子  必然  是  1。  (根据  不放  里的逻辑)。
。。所以应该是要求  上次  尾巴0 &amp;&amp;  本格子上方  已覆盖。

。。不，  s  是  滚动的，  没有办法  限制  上次的  尾巴。  而且  s  是  处理后的，  所以  处理后  上次的尾巴(这次的倒数第二)  必然是  1。  不，本次是1  不代表  之前的状态是1。

。。我感觉应该是  dp[1-cur][ (s&gt;&gt;2)&lt;&lt;1 | (3 &lt; (m-2)) ]   就是上个状态  的末尾  是0   且   开头2位是1  。  上个状态末尾0  代表  本次格子的  处理前  左侧是0，这样就可以  进行  左放  处理，  并且  上个状态开头2个1  ，代表  本次格子  和  本次格子左侧，这2个格子的  上方  都是  被覆盖了。

。。应该是  我认为的  这个。   可以看下面的  那段代码，  可以看到  左放的时候，  是要求  之前的状态  尾巴  是0，  之后的状态  尾巴是  11。    所以  这里  我应该  搜索  上个状态  的尾巴  为0  的。  所以  要  (s&gt;&gt;2)&lt;&lt;1  ，这样  上个状态  尾巴是  0，  然后  再加上  头是  11  。

。。找半天，找不到一个  标准/通用的。。各种写法  都有。太难了。

                    if (j &amp;&amp; (s &gt;&gt; 1 &amp; 1))
                        dp[cur][s] += dp[1 - cur][ (s &gt;&gt; 1) | (1 &lt;&lt; (m - 1)) ];

                    //  上放

。。只要不是  第0行，  都可以尝试  上放。  上放  就要求  上次状态的  头是0，  所以  这里  就是  s &gt;&gt; 1 &amp; (1&lt;&lt;(m-1) - 1) == s &gt;&gt; 1

                    if (i)
                    dp[cur][s] += dp[1 - cur][s &gt;&gt; 1];
                }
            }
        }
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">while</span> (cin &gt;&gt; m &gt;&gt; n)
{
    <span class="hljs-keyword">if</span> (m + n == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (n &lt; m)
        <span class="hljs-built_in">swap</span>(n, m);

    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));
    cur = <span class="hljs-number">0</span>;
    dp[cur][ (<span class="hljs-number">1</span>&lt;&lt;m) - <span class="hljs-number">1</span> ] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)
        {
            cur ^= <span class="hljs-number">1</span>;
            <span class="hljs-built_in">memset</span>(dp[cur], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp[cur]));
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; m); ++s)
            {
                <span class="hljs-comment">//  不放</span>

。。s  是增加本格子后的状态，所以如果增加本格子后，  最后一位(即本格子)  是<span class="hljs-number">0</span>，即  没有覆盖，则取  上一个状态的  s&gt;&gt;<span class="hljs-number">1</span> | (<span class="hljs-number">1</span>&lt;&lt;(m<span class="hljs-number">-1</span>))

。。  s&gt;&gt;<span class="hljs-number">1</span>  代表，通过  本状态  获得  上次的状态，  因为  本状态  只是  在  上次的  状态上  去掉头，然后  append  本格子(这里是<span class="hljs-number">0</span>)，所以  要  获得  上一个  状态，  就需要  把  本状态  后移一位，  这样  获得了   去掉头的上次状态，

 然后由于  本格子不放，  那么就意味着  本格子上方的格子  必须被覆盖，所以  上次的状态  的  头  就是  被覆盖的。  所以  | (<span class="hljs-number">1</span>&lt;&lt;(m<span class="hljs-number">-1</span>))。

。。因为  本格子不放，所以  本格子不会  上放，  所以  上方  的格子  必须已经被覆盖了，  不然  没有办法  再覆盖  上方的格子了  (因为  本格子不会放了)。

                <span class="hljs-keyword">if</span> (!(s &amp; <span class="hljs-number">1</span>))
                    dp[cur][s] += dp[<span class="hljs-number">1</span> - cur][ (s&gt;&gt;<span class="hljs-number">1</span>) | (<span class="hljs-number">1</span> &lt;&lt; (m - <span class="hljs-number">1</span>))];
                <span class="hljs-keyword">else</span>
                {
                    <span class="hljs-comment">//  左放</span>
。。不能是第<span class="hljs-number">0</span>列。

。。  不过这个  条件  没有看懂  s&gt;&gt;<span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>，  这个应该是  要求  上一个状态的  最后一位  是<span class="hljs-number">1</span>，  即  被覆盖，  如果上一个状态的  最后一位  是<span class="hljs-number">1</span>，  本格子  没有办法  左放啊。

。。左放，  也要求  本格子上方  的格子  已经被覆盖，  所以  s&gt;&gt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>&lt;&lt;(m<span class="hljs-number">-1</span>)
。。但是  感觉是  !(s&gt;&gt;<span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>)  才对啊，  这样的话：  由于这里是  <span class="hljs-keyword">else</span>，所以  保证  本格子  被覆盖。

。。不不不，  s  是  本格子处理后的  状态，  所以  确实  是要求  本格子  前面的  格子  (在处理(左放)完后)  被覆盖，  所以确实  是  s&gt;&gt;<span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>。

。。  但是  dp  的  下标就不对啊。  应该是  要求  上一个状态：  头被覆盖  &amp;&amp;  尾巴为<span class="hljs-number">0</span>  啊  &amp;&amp;  本次的头也被覆盖。。  而现在  s&gt;&gt;<span class="hljs-number">1</span> | (<span class="hljs-number">1</span>&lt;&lt;m<span class="hljs-number">-1</span>)  的  尾巴  必然是  <span class="hljs-number">1</span>，  因为  <span class="hljs-keyword">if</span>  里的判断。

。。  尾巴为<span class="hljs-number">0</span>  就意味着  尾巴的  上方的  格子  必然  是  <span class="hljs-number">1</span>。  (根据  不放  里的逻辑)。
。。所以应该是要求  上次  尾巴<span class="hljs-number">0</span> &amp;&amp;  本格子上方  已覆盖。

。。不，  s  是  滚动的，  没有办法  限制  上次的  尾巴。  而且  s  是  处理后的，  所以  处理后  上次的尾巴(这次的倒数第二)  必然是  <span class="hljs-number">1</span>。  不，本次是<span class="hljs-number">1</span>  不代表  之前的状态是<span class="hljs-number">1</span>。

。。我感觉应该是  dp[<span class="hljs-number">1</span>-cur][ (s&gt;&gt;<span class="hljs-number">2</span>)&lt;&lt;<span class="hljs-number">1</span> | (<span class="hljs-number">3</span> &lt; (m<span class="hljs-number">-2</span>)) ]   就是上个状态  的末尾  是<span class="hljs-number">0</span>   且   开头<span class="hljs-number">2</span>位是<span class="hljs-number">1</span>  。  上个状态末尾<span class="hljs-number">0</span>  代表  本次格子的  处理前  左侧是<span class="hljs-number">0</span>，这样就可以  进行  左放  处理，  并且  上个状态开头<span class="hljs-number">2</span>个<span class="hljs-number">1</span>  ，代表  本次格子  和  本次格子左侧，这<span class="hljs-number">2</span>个格子的  上方  都是  被覆盖了。

。。应该是  我认为的  这个。   可以看下面的  那段代码，  可以看到  左放的时候，  是要求  之前的状态  尾巴  是<span class="hljs-number">0</span>，  之后的状态  尾巴是  <span class="hljs-number">11</span>。    所以  这里  我应该  搜索  上个状态  的尾巴  为<span class="hljs-number">0</span>  的。  所以  要  (s&gt;&gt;<span class="hljs-number">2</span>)&lt;&lt;<span class="hljs-number">1</span>  ，这样  上个状态  尾巴是  <span class="hljs-number">0</span>，  然后  再加上  头是  <span class="hljs-number">11</span>  。

。。找半天，找不到一个  标准/通用的。。各种写法  都有。太难了。

                    <span class="hljs-keyword">if</span> (j &amp;&amp; (s &gt;&gt; <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>))
                        dp[cur][s] += dp[<span class="hljs-number">1</span> - cur][ (s &gt;&gt; <span class="hljs-number">1</span>) | (<span class="hljs-number">1</span> &lt;&lt; (m - <span class="hljs-number">1</span>)) ];

                    <span class="hljs-comment">//  上放</span>

。。只要不是  第<span class="hljs-number">0</span>行，  都可以尝试  上放。  上放  就要求  上次状态的  头是<span class="hljs-number">0</span>，  所以  这里  就是  s &gt;&gt; <span class="hljs-number">1</span> &amp; (<span class="hljs-number">1</span>&lt;&lt;(m<span class="hljs-number">-1</span>) - <span class="hljs-number">1</span>) == s &gt;&gt; <span class="hljs-number">1</span>

                    <span class="hljs-keyword">if</span> (i)
                    dp[cur][s] += dp[<span class="hljs-number">1</span> - cur][s &gt;&gt; <span class="hljs-number">1</span>];
                }
            }
        }
    }
}</code></pre></div>
<hr>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">void update(int a,int b){
    dp[cur][b] += dp[cur^1][a];  //更新状态方案数
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>{
    dp[cur][b] += dp[cur^<span class="hljs-number">1</span>][a];  <span class="hljs-comment">//更新状态方案数</span>
}</code></pre></div>
<p>。。update()  第一个参数  是  原状态，第二个参数是新状态。</p>
<p>```<br>
for(int k = 0;k &lt; (1&lt;&lt;m);k++){//枚举当前状态<br>
        //当前和上都放  上有空位就不能往左，也不能不放<br>
        if(i &amp;&amp; !(k&amp;(1&lt;&lt;(m-1))))//不是第一行，且正上方为空<br>
        {<br>
            update(k,((k&lt;&lt;1)^1)&amp;mask);//新状态尾部置1<br>
        }else<br>
        {<br>
            //当前和左放<br>
            if(j &amp;&amp; (!(k&amp;1)))//不是第一列并且左边为空<br>
                update(k,((k&lt;&lt;1)^3)&amp;mask);//新状态尾两个11<br>
            //不放<br>
            update(k,(k&lt;&lt;1)&amp;mask);<br>
                                //掩码是只取低m位作为状态<br>
        }<br>
    }</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">
------------------------
</pre><pre class="hljs"><code>
<span class="hljs-comment">------------------------</span>
</code></pre></div>
<p>54                 for(int k = 0; k &lt; (1&lt;&lt;m); k++) {<br>
55                     update(k, k&lt;&lt;1);<br>
56                     if(i &amp;&amp; !(k&amp;(1&lt;&lt;(m-1)))) update(k, (k&lt;&lt;1)^(1&lt;&lt;m)^1);<br>
57                     if(j &amp;&amp; !(k&amp;1)) update(k, (k&lt;&lt;1)^3);<br>
58                 }</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"></pre><pre class="hljs"><code></code></pre></div>
<p>38 void update(int a, int b) {<br>
39     if(b &amp; (1&lt;&lt;m)) dp[cur][b^(1&lt;&lt;m)] += dp[1-cur][a];<br>
40 }</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">
---------------------------

``` C++
void update(int a,int b)
{
    if(b&amp;(1&lt;&lt;m))
    {
        d[cur][b^(1&lt;&lt;m)]+=d[1-cur][a];
    }
}

for(int k=0;k&lt;(1&lt;&lt;m);k++)
{
    update(k,k&lt;&lt;1); //不放
    if(i&amp;&amp;!(k&amp;(1&lt;&lt;m-1)))
        update(k,(k&lt;&lt;1)^(1&lt;&lt;m)^1); //竖着放
    if(j&amp;&amp;!(k&amp;1))
        update(k,(k&lt;&lt;1)^3);//横着放
}</pre><pre class="hljs"><code>
---------------------------

``` C++
void update<span class="hljs-comment">(int a,int b)</span>
{
    <span class="hljs-keyword">if</span><span class="hljs-comment">(b&amp;(1&lt;&lt;m)</span>)
    {
        d[cur][b^<span class="hljs-comment">(1&lt;&lt;m)</span>]+=d[<span class="hljs-number">1</span>-cur][a];
    }
}

for<span class="hljs-comment">(int k=0;k&lt;(1&lt;&lt;m)</span>;k++)
{
    update<span class="hljs-comment">(k,k&lt;&lt;1)</span>; <span class="hljs-comment">//不放</span>
    <span class="hljs-keyword">if</span><span class="hljs-comment">(i&amp;&amp;!(k&amp;(1&lt;&lt;m-1)</span>))
        update<span class="hljs-comment">(k,(k&lt;&lt;1)</span>^<span class="hljs-comment">(1&lt;&lt;m)</span>^<span class="hljs-number">1</span>); <span class="hljs-comment">//竖着放</span>
    <span class="hljs-keyword">if</span><span class="hljs-comment">(j&amp;&amp;!(k&amp;1)</span>)
        update<span class="hljs-comment">(k,(k&lt;&lt;1)</span>^<span class="hljs-number">3</span>);<span class="hljs-comment">//横着放</span>
}</code></pre></div>
<p>。。很多都是  根据现在的状态  来  生成  下一个状态。<br>
。。最开始那个  是根据现在的状态  来推算  上一个状态。</p>
<p>===================================</p>
<h1 id="状态压缩dp">状态压缩DP</h1>
<p>传统DP  都是基于  整数的，比如  背包问题：  定义状态  dp[i][j]，  背包容量  为  j  时  前  i  件物品的  最大收益。  这里  i  取整数。</p>
<p>对于  状态压缩dp，  动态规划  是基于  集合的，  但是  我们使用  二进制  来将  这个集合  压缩成  一个  整数，这个  过程就是  状态压缩。</p>
<p>状态压缩  DP  常常用到  位运算  来  模拟  对集合的  操作<br>
&amp;<br>
|<br>
~<br>
^</p>
<p>旅行商问题</p>
<p>给定  n  个顶点  组成的  带权  有向图  的  距离矩阵  d(i,j) (INF  代表没有边)。要求从  顶点  0  出发，经过每个  顶点  恰好一次  后  再回到  顶点0。  问  所经过  的  边  的总权重  的  最小值  是  多少？</p>
<p>限制：<br>
2 &lt;= n &lt;= 15<br>
0 &lt;= d(i,j) &lt;= 1000</p>
<p>定义  dp[S][v] :  当已拜访节点  集合为  S，且  当前位置为  v  时，回到  位置0  还需要  经过  的最短路径。</p>
<p>目标态  dp[0][0] :  拜访所有城市再回到  0  所经过  的最短路径。</p>
<p>状态转移：dp[S][v] = min{dp[ S  交集并  {u} ][ u ] + d(v,u) | u  不属于  S}<br>
。。我怎么觉得  不太对呢。<br>
。。感觉是  d(u, v)  吧？  就是  dp[ S包含u ][u] + d(u, v)  ，  且  v  不属于  S  ？</p>
<p>。。这样的话  就是  所有  以  u  为  终点  的  路径  再次  向  v  走，  这些走法中  最min  的。   这里  需要  遍历  u  的。</p>
<p>。。不是，看下面的，说的是  S  递减。。  而且上面说了，  是  还需要  经过的  最短距离。</p>
<p>更新策略: 由状态转移方程式可知, 所有的 dp[S][v] 都由 d p [ S'  ] [ u ] ( S' &gt;  S )  转移而来，故我们按照  S'递减更新。</p>
<p>初始化：  dp[2^n - 1][0] = 0：  已经全部拜访，并且  当前位置为  0，  因此  还需要  经过路径  长度  为0。</p>
<p>核心代码：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void solve(int n)
{
    /*
    n: 需要拜访的城市数量
    road[i][j]: 城市i到城市j的距离，若没有路，则为INF。
    dp[i][j]: 当前到达城市节点集合为i, 且当前位于城市j，剩余的路程长度。
    */

    // 初始化dp数组
    for(int i=0; i&lt;1&lt;&lt;n; i++)
        for(int j=0; j&lt;n; j++)
            dp[i][j] = inf;

    dp[(1&lt;&lt;n)-1][0] = 0;
    for(int i=(1&lt;&lt;n)-2; i&gt;=0; i--)
    {
        for(int v=0; v&lt;n; v++)
        {
            for(int u=0; u&lt;n; u++)
            {
                // 使用移位运算和按位与判断元素是否存在于集合
                if(!(i &gt;&gt; u &amp; 1))
                {
                        // 使用按位或运算模拟集合求并
                        // 由于没有路初始化为inf，因此没有判断v和u间是否存在路。
                    dp[i][v] = min(dp[i][v], dp[i | (1 &lt;&lt; u)][u] + road[v][u]);
                }
            }
        }
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
    <span class="hljs-comment">/*
    n: 需要拜访的城市数量
    road[i][j]: 城市i到城市j的距离，若没有路，则为INF。
    dp[i][j]: 当前到达城市节点集合为i, 且当前位于城市j，剩余的路程长度。
    */</span>

    <span class="hljs-comment">// 初始化dp数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1</span>&lt;&lt;n; i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)
            dp[i][j] = inf;

    dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; i--)
    {
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>; v&lt;n; v++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>; u&lt;n; u++)
            {
                <span class="hljs-comment">// 使用移位运算和按位与判断元素是否存在于集合</span>
                <span class="hljs-keyword">if</span>(!(i &gt;&gt; u &amp; <span class="hljs-number">1</span>))
                {
                        <span class="hljs-comment">// 使用按位或运算模拟集合求并</span>
                        <span class="hljs-comment">// 由于没有路初始化为inf，因此没有判断v和u间是否存在路。</span>
                    dp[i][v] = <span class="hljs-built_in">min</span>(dp[i][v], dp[i | (<span class="hljs-number">1</span> &lt;&lt; u)][u] + road[v][u]);
                }
            }
        }
    }
}</code></pre></div>
<p>Travelling by Stagecoach</p>
<p>旅行家计划  乘坐  马车  旅行。  他所在的  国家有  m  个城市，在城市间  有  若干道路相连。  从某个城市  沿  某条道路  到  相邻的城市  需要  坐马车。  坐马车  需要  车票，每  用一张  车票  只可以  通过  一条  道路。  每张车票上  都记录了  马的  匹数，从  一个  城市  移动到  另一个城市  的  所需时间  等于  城市之间  道路的长度  除以  马的数量。</p>
<p>这位旅行家  一共有  n  张  车票，第  i张  车票  上的  马的匹数  是  ti。  一张车票  只能  使用一次，并且  换乘时间  可以忽略。  求  从  城市  a   到  城市  b  所需的  最短时间。  无法到达则输出  Impossible。</p>
<p>限制<br>
1 &lt;= n &lt;= 8<br>
2 &lt;= m &lt;= 30<br>
1 &lt;= a,b &lt;= m (a != b)<br>
1 &lt;= ti &lt;= 10<br>
1 &lt;=  道路长度  &lt;= 100</p>
<p>定义  dp[T][v]：  当前  所剩票  的集合  T，且  位于  城市  v，要到达  b  还需要的  最小花费。</p>
<p>目标态  dp[2^ - 1][a] :   从  a  出发，且有题目给定的票数，  到达  b  的最小花费。</p>
<p>状态转移：dp[T][v] = min{ dp[T - t][u] + road[v][u] / t }, t  属于  T，  u属于v的邻居节点集合。</p>
<p>更新策略：  由状态转移方程式  可知，  T  是用  T' (T' &lt; T)  更新的，  因此  按  T'  递增更新。</p>
<p>初始化：<br>
dp[*][b] = 0,  已到达b  ，还需要花费  0<br>
dp[0][x] = inf, x != b时；  即如果不是终点，且没有票，则无法到达，设置为  inf。</p>
<p>核心代码</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">void solve(int n)
{
    /*
    1代表还有该票
    0代表没有该票
    dp[i][j]: 剩下车票状态i，现在在城市j到达b还需要的花费
    */
    for(int i=0; i&lt;=m; i++){
        dp[0][i] = INF;
    }

    for(int i=0; i&lt; (1&lt;&lt;n); i++)
        dp[i][b] = 0;

    for(int s=1; s&lt;1&lt;&lt;n; s++)
    {
        for(int v=1; v&lt;=m; v++)
        {
            for(int u=1; u&lt;=m; u++)
            {
                if(grad[v][u] != INF)
                {
                    for(int t=0; t&lt;n; t++)
                    {
                        if(s &gt;&gt; t &amp; 1)

                            dp[s][v] = min(dp[s][v], dp[s &amp; ~(1 &lt;&lt; t)][u] + grad[v][u] / T[t]);

                    }
                }
            }
        }
    }
}</pre><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
    <span class="hljs-comment">/*
    1代表还有该票
    0代表没有该票
    dp[i][j]: 剩下车票状态i，现在在城市j到达b还需要的花费
    */</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=m; i++){
        dp[<span class="hljs-number">0</span>][i] = INF;
    }

    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; (<span class="hljs-number">1</span>&lt;&lt;n); i++)
        dp[i][b] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>; s&lt;<span class="hljs-number">1</span>&lt;&lt;n; s++)
    {
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>; v&lt;=m; v++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">1</span>; u&lt;=m; u++)
            {
                <span class="hljs-keyword">if</span>(grad[v][u] != INF)
                {
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; t&lt;n; t++)
                    {
                        <span class="hljs-keyword">if</span>(s &gt;&gt; t &amp; <span class="hljs-number">1</span>)

                            dp[s][v] = <span class="hljs-built_in">min</span>(dp[s][v], dp[s &amp; ~(<span class="hljs-number">1</span> &lt;&lt; t)][u] + grad[v][u] / T[t]);

                    }
                }
            }
        }
    }
}</code></pre></div>
<p>1*2  骨牌  铺砖问题</p>
<p>对铺好的转  进行编码：<br>
横放：  2个格子都是1<br>
竖放：  上面是0，  下面是  1</p>
<p>可以证明  编码  和  铺装方案  是一一对应的。</p>
<p>。。等于就是：  0  代表  它和下面的1  是  一块  竖放的  砖。  其他的  1都是代表  横放的砖。</p>
<p>递推：<br>
根据编码，我们知道：<br>
铺砖  的上一排  和  下一排  一定有  对应关系，必须按  一定规则  才算合法；<br>
最后一排砖  肯定全  1。</p>
<p>假设我们已经知道：<br>
倒数第二排  所有  编码对应的  铺砖方法总数<br>
最后一排  对应  编码的  所有  倒数第二排  合法编码。<br>
那么我们就能得到总数，即为  所有倒数第二排  合法编码  总数之和。<br>
而要求  倒数第二排的数量，我们又需要  倒数第三排的数量  以及  对应  合法关系，因此  逐层递推。</p>
<p>求解对应关系：<br>
如何  简便求解  对应的合法关系？  考虑两排格子。对第二排的当前格子，我们有  三种  铺放方式：  右铺，不铺，上铺。</p>
<p>这样  对下一排的  编码方式  进行  深度优先搜索，  我们就可以求出  所有的上下两排  对应  合法  编码。具体的，先将  两排  (top, down)  都初始化为  0。</p>
<ol>
<li>右铺：则  top = (top &lt;&lt; 2) | 3, down = (down &lt;&lt; 2) | 3</li>
<li>上铺：则  top = (top &lt;&lt; 1), down = (down &lt;&lt; 1) | 1</li>
<li>不铺：则  top = (top &lt;&lt; 1) | 1, down = (down &lt;&lt; 1)</li>
</ol>
<p>可以证明，如果不是  正好  铺完长度  m  的铺法，则是不合法的，反之则合法。(最后一格不能选择  右铺)</p>
<p>方便起见，我们人为设置  第0排  全1，并将其  数量置为  1，  因为  这样设置  第0排  符合  第一排  的  不能上铺的设定。<br>
。。第-1排。</p>
<p>DP  步骤<br>
定义  dp[i][E] :  第  i行  编码为  E  时，  前  i行  所有  铺砖  方法的总数<br>
目标态  : dp[n][2^m - 1]，  最后一行  全  1  的铺法总数</p>
<p>状态转移：  dp[i][Edown] = sum { dp[i-1][Etop] , Etop  属于  N，N是所有  和Edown  合法匹配的  上一行  }</p>
<p>更新策略：按  i从小到大更新<br>
初态：  dp[0][2^m - 1] = 1,  其余  dp[0][*] = 0</p>
<p>代码：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">int ok_for_top_down[MAX][2];
//ok_for_top_down[i][0]表示第i个合法上下排的上
//ok_for_top_down[i][0]表示第i个合法上下排的下排

ll dp[12][MAX];
int n, m;
ll cnt;
void dfs_get_all_ok(int c, int top, int down)
{
    // 不合法
    if(c &gt; m)
        return;

    // 合法
    if(c == m)
    {
        ok_for_top_down[cnt][0] = top;
        ok_for_top_down[cnt][1] = down;
        cnt++;
    }

    // 右铺
    dfs_get_all_ok(c+2, (top &lt;&lt; 2) | 3, (down &lt;&lt; 2) | 3);
    // 上铺
    dfs_get_all_ok(c+1, (top &lt;&lt; 1), (down &lt;&lt; 1)|1);
    // 不铺
    dfs_get_all_ok(c+1, (top &lt;&lt; 1) | 1, (down &lt;&lt; 1));
}
int main()
{
    while(cin &gt;&gt; n &gt;&gt; m)
    {
        if(n + m == 0)
            break;
        if(n &lt; m)
            swap(n, m);
        cnt = 0;
        dfs_get_all_ok(0, 0, 0);

        memset(dp, 0, sizeof(dp));
        dp[0][(1&lt;&lt;m)-1] = 1;

        for(int i=1; i&lt;=n; i++)
        {
            for(int k=0; k&lt;cnt; k++)
            {
                int top = ok_for_top_down[k][0];
                int down = ok_for_top_down[k][1];
                dp[i][down] += dp[i-1][top];
            }
        }
        cout &lt;&lt; dp[n][(1&lt;&lt;m)-1] &lt;&lt; endl;
    }
    return 0;
}</pre><pre class="hljs"><code><span class="hljs-type">int</span> ok_for_top_down[MAX][<span class="hljs-number">2</span>];
<span class="hljs-comment">//ok_for_top_down[i][0]表示第i个合法上下排的上</span>
<span class="hljs-comment">//ok_for_top_down[i][0]表示第i个合法上下排的下排</span>

ll dp[<span class="hljs-number">12</span>][MAX];
<span class="hljs-type">int</span> n, m;
ll cnt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_get_all_ok</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> down)</span>
</span>{
    <span class="hljs-comment">// 不合法</span>
    <span class="hljs-keyword">if</span>(c &gt; m)
        <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 合法</span>
    <span class="hljs-keyword">if</span>(c == m)
    {
        ok_for_top_down[cnt][<span class="hljs-number">0</span>] = top;
        ok_for_top_down[cnt][<span class="hljs-number">1</span>] = down;
        cnt++;
    }

    <span class="hljs-comment">// 右铺</span>
    <span class="hljs-built_in">dfs_get_all_ok</span>(c+<span class="hljs-number">2</span>, (top &lt;&lt; <span class="hljs-number">2</span>) | <span class="hljs-number">3</span>, (down &lt;&lt; <span class="hljs-number">2</span>) | <span class="hljs-number">3</span>);
    <span class="hljs-comment">// 上铺</span>
    <span class="hljs-built_in">dfs_get_all_ok</span>(c+<span class="hljs-number">1</span>, (top &lt;&lt; <span class="hljs-number">1</span>), (down &lt;&lt; <span class="hljs-number">1</span>)|<span class="hljs-number">1</span>);
    <span class="hljs-comment">// 不铺</span>
    <span class="hljs-built_in">dfs_get_all_ok</span>(c+<span class="hljs-number">1</span>, (top &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>, (down &lt;&lt; <span class="hljs-number">1</span>));
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)
    {
        <span class="hljs-keyword">if</span>(n + m == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span>(n &lt; m)
            <span class="hljs-built_in">swap</span>(n, m);
        cnt = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">dfs_get_all_ok</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));
        dp[<span class="hljs-number">0</span>][(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;cnt; k++)
            {
                <span class="hljs-type">int</span> top = ok_for_top_down[k][<span class="hljs-number">0</span>];
                <span class="hljs-type">int</span> down = ok_for_top_down[k][<span class="hljs-number">1</span>];
                dp[i][down] += dp[i<span class="hljs-number">-1</span>][top];
            }
        }
        cout &lt;&lt; dp[n][(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>] &lt;&lt; endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>===================================</p>
<h1 id="莱文斯坦距离">莱文斯坦距离</h1>
<p>莱文斯坦距离，又称Levenshtein距离，是编辑距离的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。允许的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p>
<p>LeetCode  有这道题。</p>
<p><img src="../_resources/c6e105300ece7ab2051feb30f27b38cf.png" alt="1"></p>
<p>使用动态规划进行编程</p>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<p>===================================</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
<h1 id="后缀自动机sam">后缀自动机SAM</h1>
<h1 id="基环树-环套树">基环树、环套树</h1>
<h1 id="哈密顿回路hamiltonian-cycle">哈密顿回路（Hamiltonian cycle）</h1>
<h1 id="de-brujin">De Brujin</h1>
<p>a de Bruijn sequence of order n on a size-k alphabet A is a cyclic sequence in which every possible length-n string on A occurs exactly once as a substring</p>
<p>LT753</p>
<h1 id="牛顿迭代法">牛顿迭代法</h1>
<h1 id="01背包">01背包</h1>
<p>背包容量为0时，0<br>
背包容量从1-&gt;目标容量，对每个物品尝试放入。尝试 物品的价值 + (当前背包容量-该物品的重量后)剩余容量的最大价值</p>
<p>上面是<br>
遍历所有容量0-&gt;目标容量<br>
遍历每个物品</p>
<p>也可以：<br>
遍历每个物品：<br>
遍历容量0-&gt;目标容量，对该物品尝试放入。</p>
<h1 id="z-function">z-function</h1>
<p>LT3031</p>
<p>z[i] tells us how many characters, starting from the position i,  match with the first characters of  the string .</p>
<p>。。str[i..i+z[i]] is the str's max prefix<br>
。。z[i] is substr's length, i is substr's first char</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C++" data-joplin-source-open="```C++&#10;" data-joplin-source-close="&#10;```">vector&lt;int&gt; z_function(const string &amp;s) {
    int n = s.size(), l = 0, r = 0;
    vector&lt;int&gt; z(n);
    for(int i = 1; i &lt; n; i++) {
        if(i &lt; r)
            z[i] = min(r - i, z[i - l]);
        while(i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]])
            z[i]++;
        if(i + z[i] &gt; r) {
            l = i;
            r = i + z[i];
        }
    }
    return z;
}</pre><pre class="hljs"><code><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z_function</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> </span>{
    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">if</span>(i &lt; r)
            z[i] = <span class="hljs-built_in">min</span>(r - i, z[i - l]);
        <span class="hljs-keyword">while</span>(i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]])
            z[i]++;
        <span class="hljs-keyword">if</span>(i + z[i] &gt; r) {
            l = i;
            r = i + z[i];
        }
    }
    <span class="hljs-keyword">return</span> z;
}</code></pre></div>
</div></div>
					</body>
				</html>
			