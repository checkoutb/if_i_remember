
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1" />
						<link rel="stylesheet" href="pluginAssets/katex/katex.css"><link rel="stylesheet" href="pluginAssets/highlight.js/atom-one-light.css">
						<title>TCP</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">TCP</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}
		::-webkit-scrollbar {
			width: 7px;
			height: 7px;
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(100, 100, 100, 0.3); 
			border-radius: 5px;
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(100, 100, 100, 0.7); 
		}

		

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: 1.35em;

			/*
				Adds support for RTL text in the note body. It automatically detects the direction using the content.
				Issue: https://github.com/laurent22/joplin/issues/3991
			*/
			unicode-bidi: plaintext;
		}

		h1, h2, h3, h4, h5, h6, ul, table {
			margin-bottom: 0.65em;
		}

		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
			font-weight: bold;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}

		.resource-icon {
			display: inline-block;
			position: relative;
			top: 0.3em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to precvent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: 0.7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		.not-loaded-resource img {
			width: 1.15em;
			height: 1.15em;
			background: white;
			padding: 2px !important;
			border-radius: 2px;
			box-shadow: 0 1px 3px #000000aa;
		}

		a.not-loaded-resource img {
			margin-right: .2em;
		}

		a.not-loaded-resource {
			display: flex;
			flex-direction: row;
			align-items: center;
		}

		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		mark {
			background: #F7D26E;
			color: black;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 35rem;
			width: 100%;
			max-width: 1000px;
			margin: 0;
			border: 0;
			display: block;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* To make code blocks horizontally scrollable */
		/* https://github.com/laurent22/joplin/issues/5740 */
		pre.hljs {
			overflow-x: auto;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}</style><div id="rendered-md"><p>TCP<br>
2022年11月29日<br>
13:33</p>
<p>transmission control protocol</p>
<nav class="table-of-contents"><ul><li><a href="#3次握手4次挥手">3次握手，4次挥手</a><ul><li><a href="#tcp的连接建立">TCP的连接建立</a></li></ul></li><li><a href="#四次挥手">四次挥手</a></li><li><a href="#code-a-tcpip-stack">Code a TCP/IP stack</a><ul><li><a href="#ethernet以太网-arp">Ethernet(以太网) &amp; ARP</a><ul><li><a href="#tuntap-devices">TUN/TAP devices</a></li><li><a href="#ethernet-frame-format">ethernet frame format</a></li><li><a href="#ethernet-frame-parsing">Ethernet Frame Parsing</a></li><li><a href="#address-resolution-protocol-arp">Address Resolution Protocol ARP</a></li><li><a href="#address-resolution-algorithm">Address Resolution Algorithm</a></li></ul></li><li><a href="#ipv4-icmpv4">IPv4 &amp;&amp; ICMPv4</a><ul><li><a href="#internet-protocol-version-4">Internet Protocol version 4</a><ul><li><a href="#header-format">header format</a></li><li><a href="#internet-checksum">internet checksum</a></li></ul></li><li><a href="#internet-control-message-protocol-version-4">internet control message protocol version 4</a><ul><li><a href="#header-format-1">header format</a></li><li><a href="#message-and-their-processing">message and their processing</a></li></ul></li><li><a href="#testing-the-implementation">testing the implementation</a></li><li><a href="#conclusion">Conclusion</a></li></ul></li><li><a href="#tcp-basics-handshake">TCP Basics &amp; Handshake</a><ul><li><a href="#reliablity-mechanisms">Reliablity mechanisms</a></li><li><a href="#tcp-basics">TCP basics</a><ul><li><a href="#tcp-header-format">TCP header format</a></li></ul></li><li><a href="#tcp-handshake">TCP handshake</a></li><li><a href="#tcp-options">TCP options</a></li><li><a href="#test-tcp-handshake">test TCP handshake</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#tcp-data-flow-socket-api">TCP data flow &amp; socket api</a><ul><li><a href="#transmission-control-block">transmission control block</a></li></ul></li></ul></li></ul></nav><p>========================</p>
<p><a data-from-md title='https://zhuanlan.zhihu.com/p/430799766' href='https://zhuanlan.zhihu.com/p/430799766'>https://zhuanlan.zhihu.com/p/430799766</a><br>
<a data-from-md title='https://juejin.cn/post/7028003193502040072' href='https://juejin.cn/post/7028003193502040072'>https://juejin.cn/post/7028003193502040072</a></p>
<h1 id="3次握手4次挥手">3次握手，4次挥手</h1>
<p>TCP传输分为3个阶段</p>
<ol>
<li>建立连接</li>
<li>数据传输</li>
<li>释放连接</li>
</ol>
<p>TCP头部格式</p>
<p><img src="../_resources/2a5c9c5b598ff7317eb8e8481f0fdf91.png" alt="1"></p>
<p>源端口，16bit，源端口号，用来识别  发送  该TCP报文段的  应用进程。</p>
<p>目的端口，16bit，目的端口号，用来识别  接受  该TCP报文段的  应用进程。</p>
<p>序号，32bit，取值范围[0,2^32-1]，序号增加到最后一个后，下一个序号又回到0。指出  本TCP报文段  数据载荷  的第一个字节的  序号。</p>
<p>确认号，32bit，uint，最大+1变成0。  指出  期望  收到对方下一个TCP  报文段的  数据载荷的  第一个字节的  序号，同时  也是对  之前收到的  所有数据的确认。如果确认号是  n，那么说明  &lt;= n-1  的数据都已经被正确接收，希望获得  序号为  n  的数据。</p>
<p>确认标志位ACK，取值为1  时，  确认号  字段才有效。TCP规定，在连接建立后，所有传送的  TCP报文段  都应该将  ACK  设置为  1</p>
<p>数据偏移，占4bit，并以4字节为单位。用来指出  TCP  报文段的  数据载荷部分的  起始处  距离  TCP  报文段的  起始处有多远。  这个字段实际上  是指出  TCP报文段的  首部长度。</p>
<p>窗口，16bit，以字节为单位。指出发送  本报文段的  一方的  接收窗。</p>
<p>同步标志位SYN，在TCP连接  建立时  用来同步序号。</p>
<p>终止标志位FIN：用来释放TCP连接。</p>
<p>复位标志位RST：用来复位TCP连接。</p>
<p>推送标志位PSH：接收方的  TCP  收到  该标志位为1  的报文  会  尽快上交应用程序，而不必等到接受缓存  都填满后  再向上交付。</p>
<p>校验和：16bit，检查范围  包括  TCP  报文段的  首部  和  数据载荷  2部分。在计算校验和时，要在  TCP  报文段的  前面加上  12字节的  伪首部。</p>
<p>紧急指针：16bit，以字节为单位，用来指明  紧急数据的长度。</p>
<p>填充，由于  选项的  长度可变，因此使用  填充来  确保报文段首部  能被4整除  (因为  数据偏移  字段，  也就是  首部长度字段，是以  4字节  为单位的)</p>
<h2 id="tcp的连接建立">TCP的连接建立</h2>
<p>建立连接的过程叫做握手，需要在  客户端  和  服务器  之间  交换  3个TCP  报文段，称为  三报文握手。<br>
采用三报文握手，主要是为了防止  已  失效的  连接  请求  报文段  突然  又传送到了，而产生错误。</p>
<p>TCP的连接建立  需要解决以下  3个问题</p>
<ol>
<li>使  TCP  双方都能  确知  对方的  存在</li>
<li>使  TCP  双方  能够  协商  一些  参数  (  最大窗口值是否使用窗口扩大选项和时间戳选项，以及  服务质量等)</li>
<li>使  TCP  双方  都能  对  运输实体资源  (例如  缓存大小  连接表中的项目  等)  进行分配。</li>
</ol>
<p>主动发起TCP连接建立  的称为  客户端<br>
被动等待  TCP连接建立  的称为  服务器</p>
<ol>
<li>
<p>最开始，2端  的  TCP  进程都处于  关闭状态。</p>
</li>
<li>
<p>服务器TCP进程  创建  传输控制块，用来  存储  TCP连接中的  一些重要信息，例如，TCP连接表，指向发送  和  接受  缓存的  指针，指向  重传队列的  指针，当前的  发送  和  接受序号  等。之后  就  准备  接受  TCP客户端进程  的  连接请求，此时  TCP服务器进程  进入  监听状态，等待  TCP客户端进程的  连接请求。</p>
</li>
<li>
<p>TCP客户单  也需要  首先  创建  传输控制块，然后  再打算建立。TCP服务器进程  是  被动等待  来自TCP客户端进程的  连接请求，所以被称为  被动打开连接。</p>
</li>
<li>
<p>TCP连接时  向TCP服务器  进程  发送  TCP连接请求  报文段，并进入  同步已发送状态。</p>
<ol>
<li>TCP连接请求报文首部中的  同步位SYN  被设置为  1，表明这是一个  TCP  连接请求报文段。</li>
<li>序号字段seq  被设置为  一个  初始值  x  作为TCP客户端进程  所选择的  初始序号。</li>
</ol>
</li>
<li>
<p>由于TCP连接建立  是由  TCP  客户端进程主动发起的，因此成为  主动打开连接。  注意TCP规定  SYN被设置为1  的报文段  不能携带数据  但要  消耗一个  序号。</p>
</li>
<li>
<p>TCP服务器进程  收到  TCP  连接请求报文段后，如果  同意建立连接，则向  客户端进程  发送  TCP  连接  请求  确认报文段，并进入到  同步已接收状态。</p>
<ol>
<li>该报文段  首部中的  同步位  SYN  和  确认位ACK  都设置为1，  表明这是一个  TCP连接请求。</li>
<li>序号字段SEQ被设置了一个  初始值  y，作为  TCP服务器进程  所选择的  初始序号。</li>
<li>确认号  字段ACK  的值  被设置为  x+1，  这是对TCP  客户进程  所选择的  初始序号SEQ  的确认。<br>
注意，这个报文段  也不能携带数据，因为  SYN是1，但同样要消耗一个  序号。</li>
</ol>
</li>
<li>
<p>TCP客户进程  收到  TCP  连接请求  确认报文段后，还要向  TCP服务器  进程  发送一个  普通的TCP确认报文段  并进入  连接已建立状态。</p>
<ol>
<li>
<p>该报文段首部中的  确认位ACK  为1，表明是一个  普通的TCP确认报文段</p>
</li>
<li>
<p>序号字段SEQ  被设置为  x+1，  这是因为  TCP客户端  发送的第一个TCP  报文的序号是  x，并且  不携带数据，所以  第二个报文段的  序号是  x + 1</p>
</li>
<li>
<p>确认号字段ACK  被设置为  y + 1，  这是对  TCP服务器进程  所选择的  初始序号的  确认。</p>
</li>
</ol>
</li>
<li>
<p>TCP服务器收到  该确认报文段后  也进入  连接已建立状态，现在  TCP双方都进入了  连接已建立  状态，它们可以基于  已建立好  的TCP  连接进行  可靠的数据传输了。</p>
</li>
</ol>
<p><img src="../_resources/466539228be329ea76432fd94caa0a65.png" alt="1"></p>
<p>注意，TCP规定，普通的TCP  确认报文段  可以携带数据。但如果不携带数据  则不消耗  序号，在这种情况下，下一个数据报文段的序号仍然是  x + 1。<br>
。。。？不消耗序号的话，下一个  不应该  还是  x  ？</p>
<p>两次握手的问题<br>
客户端发送  建立TCP连接请求，<br>
但是超时，客户端重试，这次  服务器收到，并返回  连接建立  报文给  客户端，<br>
数据传输，<br>
挥手释放连接。</p>
<p>客户端发送的第一个请求  送达服务器，服务器  返回  连接建立报文  给客户端，  但是客户端已经关闭了，所以不会有响应，  服务器就一直维持着  这个连接，等待  客户端的数据。</p>
<p>在不可靠的信道中想要模拟出可靠的，双向的传输最少也得是三次通信，两次只能建立可靠的单向传输。</p>
<hr>
<p><a data-from-md title='https://juejin.cn/post/7132499826771656734' href='https://juejin.cn/post/7132499826771656734'>https://juejin.cn/post/7132499826771656734</a></p>
<h1 id="四次挥手">四次挥手</h1>
<ol>
<li>客户端主动停止连接，向服务器发送  FIN=1  的报文</li>
<li>服务器收到后，返回一个  确认报文</li>
<li>服务器  确定自己也没有数据  要发送给  客户端时，服务器会向  客户端  发送  FIN=1  的报文，并等待确认</li>
<li>客户端在收到  服务器的  FIN=1  的报文是，会  立即返回  一个  确认报文，并进入  2MSL  等待阶段。</li>
</ol>
<p>在2MSL  时间范围内，如果客户端收到服务器端  超时重传的  FIN=1  的报文，则说明  客户端发出的确认，服务端  没有收到，所以此时客户端  会重新发送  确认并  重置计时器，在2MSL只有，没有收到服务端的  超时重传  FIN=1  的报文，则客户端正常关闭。服务器在收到  确认后也是正常关闭的。</p>
<p>2MSL MSL是Maximum Segment Lifetime英文的缩写,中文可以译为“报文最大生存时间”</p>
<hr>
<p><a data-from-md title='https://juejin.cn/post/7075945250115551239' href='https://juejin.cn/post/7075945250115551239'>https://juejin.cn/post/7075945250115551239</a></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP/IP模型</td>
<td>OSI模型</td>
<td>作用</td>
</tr>
<tr>
<td>应用层http</td>
<td>应用层</td>
<td>为应用程序提供服务</td>
</tr>
<tr>
<td>应用层http</td>
<td>表示层</td>
<td>数据格式转化，数据加密</td>
</tr>
<tr>
<td>应用层http</td>
<td>会话层</td>
<td>建立，管理，维护会话</td>
</tr>
<tr>
<td>传输层TCP</td>
<td>传输层</td>
<td>建立，管理，维护  端对端的连接</td>
</tr>
<tr>
<td>网络层IP</td>
<td>网络层</td>
<td>IP选址  及  路由选择</td>
</tr>
<tr>
<td>链路层(物理网卡)</td>
<td>链路层</td>
<td>提供介质访问  和  链路管理</td>
</tr>
<tr>
<td>链路层(物理网卡)</td>
<td>物理层</td>
<td>物理传输</td>
</tr>
</tbody>
</table>
<p>TCP/IP  协议族</p>
<p>TCP/IP  是  Internet  最基本的协议，Internet  国际互联网络的基础，由网络层的  IP  协议  和  传输层的  TCP  协议组成。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP/IP概念层模型</td>
<td>功能</td>
<td>TCP/IP协议族</td>
</tr>
<tr>
<td>应用层</td>
<td>文件传输，电子邮件，文件服务，虚拟终端</td>
<td>TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet</td>
</tr>
<tr>
<td>应用层</td>
<td>数据格式化，代码转换，数据加密</td>
<td>没有协议</td>
</tr>
<tr>
<td>应用层</td>
<td>解除  或  建立  与别的接点  的联系</td>
<td>没有协议</td>
</tr>
<tr>
<td>传输层</td>
<td>提供端对端的接口</td>
<td>TCP UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>为数据包选择路由</td>
<td>IP,ICMP,RIP,OSPF,BGP,IGMP</td>
</tr>
<tr>
<td>链路层</td>
<td>传输地址的帧以及错误检测功能</td>
<td>SLIP,CSLIP,PPP,ARP,RARP,MTU</td>
</tr>
<tr>
<td>链路层</td>
<td>以二进制数据形式在物理媒体上传输数据</td>
<td>ISO2110,IEEE802,IEEE802.2</td>
</tr>
</tbody>
</table>
<p>一次完整的http请求的过程<br>
DNS域名解析（本地浏览器缓存，操作系统缓存或者DNS服务器）<br>
三次握手建立TCP连接<br>
客户端发起HTTP请求<br>
服务器响应HTTP请求<br>
客户端解析html代码，并请求HTML代码中的资源<br>
客户端渲染展示内容<br>
关闭TCP连接<br>
1.0 连接不可以复用    2.0  IO多路复用，一次TCP连接可以进行多次http请求</p>
<p>为什么需要四次挥手?<br>
TCP是全双工（即客户端和服务端可以相互发送和接收请求）所以需要双方都确认关闭连接</p>
<p>为什么需要TIME_WAIT状态?<br>
客户端的最后一次应答报文可能在网络传输中会丢失，所以客户端还得进行一次重传，确保可靠的终止TCP/IP  保证迟来的TCP报文有足够的时间，被识别并丢弃</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>========================</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
<h1 id="code-a-tcpip-stack">Code a TCP/IP stack</h1>
<h2 id="ethernet以太网-arp">Ethernet(以太网) &amp; ARP</h2>
<p><a data-from-md title='http://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/' href='http://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/'>http://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/</a></p>
<p>TCP 已经超过40年了(1981)，累积了很多的规范。<br>
但，最核心的规范看起来很简单：最重要的部分是 TCP header parse， state machine，congestion control(拥塞控制)，retransmission timeout computation(超时重发)</p>
<p>大部分2层，3层(Ethernet, IP层)的协议，和 TCP 比较起来是 非常简单的。</p>
<p>在本系列的blog中，我们会在 linux 上实现 最小的 用户空间的 TCP/IP 栈。</p>
<h3 id="tuntap-devices">TUN/TAP devices</h3>
<p>。。 TUN/TAP是操作系统内核中的虚拟网络设备,可以完成用户空间与内核空间的数据的交互<br>
。。 linux支持的虚拟网络设备中,tun/tap设备相对特殊,其为用户空间程序提供了网络数据包的发送和接收能力</p>
<p>。。在计算机网络中，TUN 与 TAP 是操作系统内核中的虚拟网络设备。不同于普通靠硬件网路板卡实现的设备，这些虚拟的网络设备全部由软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。 TAP 等同于一个以太网设备，它操作第二层数据包如以太网数据帧。TUN 模拟了网络层设备，操作第三层数据包比如 IP 数据封包。<br>
。。操作系统通过 TUN/TAP 设备向绑定该设备的<mark>用户空间的</mark>程序发送数据，反之，用户空间的程序也可以像操作硬件网络设备那样，通过 TUN/TAP 设备发送数据。在后种情况下，TUN/TAP 设备向操作系统的网络栈投递（或“注入”）数据包，从而模拟从外部接受数据的过程。<br>
。。<a data-from-md title='https://zhuanlan.zhihu.com/p/388742230' href='https://zhuanlan.zhihu.com/p/388742230'>https://zhuanlan.zhihu.com/p/388742230</a></p>
<p>为了从 linux kernel 拦截 底层的网络流量，我们会使用 Linux TAP device。<br>
networking userspace application 使用 TUN/TAP device 来操作 L3/L2 的traffic(流量)<br>
常见的例子是 <mark>tunneling</mark>，一个packet 被封装在 另一个packet 中。</p>
<p>TUN/TAP device 的优势是，在用户态程序中 容易配置，并且已经得到了广泛的 应用，如 OpenVPN</p>
<p>从L2 开始构建 networking stack，需要一个 TAP device。代码如下：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">/*
 * Taken from Kernel Documentation/networking/tuntap.txt
 */
int tun_alloc(char *dev)
{
    struct ifreq ifr;
    int fd, err;

    if( (fd = open(&quot;/dev/net/tap&quot;, O_RDWR)) &lt; 0 ) {
        print_error(&quot;Cannot open TUN/TAP dev&quot;);
        exit(1);
    }

    CLEAR(ifr);

    /* Flags: IFF_TUN   - TUN device (no Ethernet headers)
     *        IFF_TAP   - TAP device
     *
     *        IFF_NO_PI - Do not provide packet information
     */
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
    if( *dev ) {
        strncpy(ifr.ifr_name, dev, IFNAMSIZ);
    }

    if( (err = ioctl(fd, TUNSETIFF, (void *) &amp;ifr)) &lt; 0 ){
        print_error(&quot;ERR: Could not ioctl tun: %s\n&quot;, strerror(errno));
        close(fd);
        return err;
    }

    strcpy(dev, ifr.ifr_name);
    return fd;
}</pre><pre class="hljs"><code><span class="hljs-comment">/*
 * Taken from Kernel Documentation/networking/tuntap.txt
 */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">tun_alloc</span><span class="hljs-params">(<span class="hljs-type">char</span> *dev)</span>
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>
    <span class="hljs-type">int</span> fd, err;

    <span class="hljs-keyword">if</span>( (fd = open(<span class="hljs-string">&quot;/dev/net/tap&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span> ) {
        print_error(<span class="hljs-string">&quot;Cannot open TUN/TAP dev&quot;</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    CLEAR(ifr);

    <span class="hljs-comment">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)
     *        IFF_TAP   - TAP device
     *
     *        IFF_NO_PI - Do not provide packet information
     */</span>
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
    <span class="hljs-keyword">if</span>( *dev ) {
        <span class="hljs-built_in">strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);
    }

    <span class="hljs-keyword">if</span>( (err = ioctl(fd, TUNSETIFF, (<span class="hljs-type">void</span> *) &amp;ifr)) &lt; <span class="hljs-number">0</span> ){
        print_error(<span class="hljs-string">&quot;ERR: Could not ioctl tun: %s\n&quot;</span>, strerror(errno));
        close(fd);
        <span class="hljs-keyword">return</span> err;
    }

    <span class="hljs-built_in">strcpy</span>(dev, ifr.ifr_name);
    <span class="hljs-keyword">return</span> fd;
}</code></pre></div>
<p>返回的 文件描述符 fd 可以用来 对 虚拟设备 的 ethernet buffer 进行读写。</p>
<p>在这里，IFF_NO_PI 是 关键，不然 我们需要在 ethernet frame 中预处理不必要的数据包信息</p>
<p>你可以查看 tun-device driver 的源码 ( <a data-from-md title='https://github.com/torvalds/linux/blob/v4.4/drivers/net/tun.c#L1306' href='https://github.com/torvalds/linux/blob/v4.4/drivers/net/tun.c#L1306'>https://github.com/torvalds/linux/blob/v4.4/drivers/net/tun.c#L1306</a> )，并自己验证</p>
<h3 id="ethernet-frame-format">ethernet frame format</h3>
<p>各种不同的 以太网网络技术 (ethernet networking technologies) 是 LANs (local area networks，局域网) 中 连接 计算机的 backbone (骨干，基础，支柱)</p>
<p>ethernet的 第一个版本 非常慢：大约10Mb/s，使用了 半双工通信，意味着 你 要么发送，要么接受 数据，不能同时 发送，接受。<br>
这就是 为什么 必须使用 MAC(media access control) 协议 来组织数据流。<br>
现在，如果在 半双工模式下 运行 ethernet 接口，需要使用 CSMA/CD 作为 MAC method。</p>
<p>使用双绞线的 100BASE-T 以太网标准 实现了 全双工 和 更高的吞吐量。<br>
并且，由于以太网交换机 的普及，导致 CSMA/CD 在很大程度上 被淘汰了。</p>
<p>IEEE 802.3 工作组 维护着 各种以太网标准。</p>
<p>我们来看下 以太网帧头， 被如下的 C struct 描述</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">#include &lt;linux/if_ether.h&gt;

struct eth_hdr
{
    unsigned char dmac[6];
    unsigned char smac[6];
    uint16_t ethertype;
    unsigned char payload[];
} __attribute__((packed));</pre><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_ether.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_hdr</span>
{</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> dmac[<span class="hljs-number">6</span>];
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> smac[<span class="hljs-number">6</span>];
    <span class="hljs-type">uint16_t</span> ethertype;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> payload[];
} __attribute__((packed));</code></pre></div>
<p><mark>dmac, smac</mark> 是一目了然的，它们包含了 通信双方的 MAC地址。( destination, source)</p>
<p><mark>ethertype</mark> 是一个 2字节字段，根据值不同，它可能表示 payload 的 长度 或 类型。具体来说，如果值 &gt;= 1536, 就包含了 payload的 类型 (如 IPv4， ARP)。如果 值 小于 1536，那么它包含了 payload的 长度。<br>
。。。？</p>
<p>类型字段后，以太网帧 可能有 几个不同的 <mark>tags</mark>。 这些 tag 用来 描述 帧的 Virtual LAN (VLAN) 或 Quality of Service (QoS) 类型。<br>
本次实现中，没有使用到 ethernet frame tag，所以 上面的代码中 没有它们。</p>
<p><mark>payload</mark>，包含了一个指针 (。。数组==指针)，指向了 以太网帧的 负载。<br>
在我们的例子中，它会包含 一个 ARP 或 IPv4 包。<br>
如果 payload 长度 小于 最低要求 48byte (不包含 tags)，需要在尾部 填充字节。<br>
。。想起来，TCP/IP详解 中提到过，模糊了。 就是在 包的大小 的时候，IP头中的长度 不包含 attribute ？ 。 IPv6 是60 byte ？</p>
<p>代码中，使用了 if_ether.h 头文件，提供了 ethertypes 与 它们的 16进制值 之间的 映射。</p>
<p>以太网帧格式 也包含了 <mark>Frame Check Sequence 字段</mark>，使用 CRC (cyclic redundancy check) 来校验 帧的完整性。 在本次实现中，忽略了。</p>
<h3 id="ethernet-frame-parsing">Ethernet Frame Parsing</h3>
<p>在之前的代码中的 packed 属性 是一个 实现方面的 细节，用来指示 GNU C 编译器 不要优化 struct 内存布局 for 带字节填充的 数据对齐。</p>
<p>。。<code class="inline-code">__attribute__((packed))</code>，告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐,是GCC特有的语法</p>
<p>我们对于 data buffer 的转换 只是 type cast，所以需要这个属性。 (。。乱翻的。 The use of this attribute stems purely out of the way we are “parsing” the protocol buffer, which is just a type cast over the data buffer with the proper protocol struct:)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">struct eth_hdr *hdr = (struct eth_hdr *) buf;</pre><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_hdr</span> *<span class="hljs-title">hdr</span> =</span> (<span class="hljs-keyword">struct</span> eth_hdr *) buf;</code></pre></div>
<p>一种 可移植的方式是 手动序列化 协议数据，通过这种方式， 编译器可以 添加 填充字节，来 满足不同 处理器的 数据对齐的要求。</p>
<p>解析和处理 incoming 以太网帧的 场景非常简单：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">if (tun_read(buf, BUFLEN) &lt; 0) {
    print_error(&quot;ERR: Read from tun_fd: %s\n&quot;, strerror(errno));
}

struct eth_hdr *hdr = init_eth_hdr(buf);

handle_frame(&amp;netdev, hdr);</pre><pre class="hljs"><code><span class="hljs-keyword">if</span> (tun_read(buf, BUFLEN) &lt; <span class="hljs-number">0</span>) {
    print_error(<span class="hljs-string">&quot;ERR: Read from tun_fd: %s\n&quot;</span>, strerror(errno));
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_hdr</span> *<span class="hljs-title">hdr</span> =</span> init_eth_hdr(buf);

handle_frame(&amp;netdev, hdr);</code></pre></div>
<p>handle_frame 只是 查看 以太网头的 ethertype，根据这个值 决定下一步行为</p>
<h3 id="address-resolution-protocol-arp">Address Resolution Protocol ARP</h3>
<p>ARP 用来 动态 映射 48-bit 的 以太网地址 (MAC地址) 到 协议地址 (如. IPv4 地址)。<br>
这里的关键是，with ARP，多个不同的 L3 协议可以使用，不只是 IPv4，还有其他的，如 CHAOS，它声明了 16bit 的协议地址。</p>
<p>。。就是 IP地址，是IP协议的， 以太网层/物理链路层，不知道 IP地址是什么，它只知道 MAC，因为MAC是出厂就设置的，每个设备唯一。 所以 通过ARP，将 MAC地址 和 IP 地址进行了 关联， 以后 IP 地址解析为 MAC地址后，才能真正的传输。<br>
。。IP是可变的， MAC不可变。</p>
<p>通常的情况是，你知道 LAN 中一些设备的 IP地址，但是 要建立 真正的 通信，你还需要知道 硬件地址(MAC)。<br>
因此，ARP 被用来 广播和查询 网络，要求 IP地址的拥有者 报告它的 硬件地址。</p>
<p>ARP包格式：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">struct arp_hdr
{
    uint16_t hwtype;
    uint16_t protype;
    unsigned char hwsize;
    unsigned char prosize;
    uint16_t opcode;
    unsigned char data[];
} __attribute__((packed));</pre><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arp_hdr</span>
{</span>
    <span class="hljs-type">uint16_t</span> hwtype;
    <span class="hljs-type">uint16_t</span> protype;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> hwsize;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> prosize;
    <span class="hljs-type">uint16_t</span> opcode;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[];
} __attribute__((packed));</code></pre></div>
<p>hwtype, 2个8位字节，决定了使用的 link层type。 我们的案例中是 以太网层，值是 0x0001.<br>
protype，2个8位字节，指明了 协议type。 我们的案例中是 IPv4，值是 0x0090<br>
hwsize，prosize，都是 1字节的，分别 包含了 硬件和协议 字段的 size。 我们的案例中是，6 byte的 MAC地址，4 byte的 IP地址<br>
opcode，2个8位字节，声明了 ARP消息的 type。 它可以是：</p>
<ul>
<li>1: arp request</li>
<li>2: arp reply</li>
<li>3: rarp request</li>
<li>4: rarp reply</li>
</ul>
<p>data，包含了 ARP消息的 实际负载，我们的例子中，它会包含 IPv4 特定消息:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">struct arp_ipv4
{
    unsigned char smac[6];
    uint32_t sip;
    unsigned char dmac[6];
    uint32_t dip;
} __attribute__((packed));</pre><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arp_ipv4</span>
{</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> smac[<span class="hljs-number">6</span>];
    <span class="hljs-type">uint32_t</span> sip;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> dmac[<span class="hljs-number">6</span>];
    <span class="hljs-type">uint32_t</span> dip;
} __attribute__((packed));</code></pre></div>
<p>smac, dmac 是 sender，receiver的 6byte的 MAC地址<br>
sip,dip 是sender，receiver的 IP地址</p>
<h3 id="address-resolution-algorithm">Address Resolution Algorithm</h3>
<p><a data-from-md title='https://tools.ietf.org/html/rfc826' href='https://tools.ietf.org/html/rfc826'>https://tools.ietf.org/html/rfc826</a><br>
上面的文档简单描述了 address resolution 的算法</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">?Do I have the hardware type in ar$hrd?
Yes: (almost definitely)
  [optionally check the hardware length ar$hln]
  ?Do I speak the protocol in ar$pro?
  Yes:
    [optionally check the protocol length ar$pln]
    Merge_flag := false
    If the pair &lt;protocol type, sender protocol address&gt; is
        already in my translation table, update the sender
        hardware address field of the entry with the new
        information in the packet and set Merge_flag to true.
    ?Am I the target protocol address?
    Yes:
      If Merge_flag is false, add the triplet &lt;protocol type,
          sender protocol address, sender hardware address&gt; to
          the translation table.
      ?Is the opcode ares_op$REQUEST?  (NOW look at the opcode!!)
      Yes:
        Swap hardware and protocol fields, putting the local
            hardware and protocol addresses in the sender fields.
        Set the ar$op field to ares_op$REPLY
        Send the packet to the (new) target hardware address on
            the same hardware on which the request was received.</pre><pre class="hljs"><code>?Do I have the hardware type in ar$hrd?
Yes: (almost definitely)
  [optionally check the hardware length ar$hln]
  ?Do I speak the protocol in ar$pro?
  Yes:
    [optionally check the protocol length ar$pln]
    Merge_flag := false
    If the pair &lt;protocol type, sender protocol address&gt; is
        already in my translation table, update the sender
        hardware address field of the entry with the new
        information in the packet and set Merge_flag to true.
    ?Am I the target protocol address?
    Yes:
      If Merge_flag is false, add the triplet &lt;protocol type,
          sender protocol address, sender hardware address&gt; to
          the translation table.
      ?Is the opcode ares_op$REQUEST?  (NOW look at the opcode!!)
      Yes:
        Swap hardware and protocol fields, putting the local
            hardware and protocol addresses in the sender fields.
        Set the ar$op field to ares_op$REPLY
        Send the packet to the (new) target hardware address on
            the same hardware on which the request was received.</code></pre></div>
<p>translation table 用来 保存 ARP的结果，作为cache，避免冗余的 ARP 请求。</p>
<p>这个算法的实现在下面。<br>
<a data-from-md title='https://github.com/saminiir/level-ip/blob/e9ceb08f01a5499b85f03e2d615309c655b97e8f/src/arp.c#L53' href='https://github.com/saminiir/level-ip/blob/e9ceb08f01a5499b85f03e2d615309c655b97e8f/src/arp.c#L53'>https://github.com/saminiir/level-ip/blob/e9ceb08f01a5499b85f03e2d615309c655b97e8f/src/arp.c#L53</a></p>
<p>最后，对 自己的ARP 实现 进行测试，观察是否 正确的 对 arp 请求进行 reply</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="shell" data-joplin-source-open="```shell&#10;" data-joplin-source-close="&#10;```">[saminiir@localhost lvl-ip]$ arping -I tap0 10.0.0.4
ARPING 10.0.0.4 from 192.168.1.32 tap0
Unicast reply from 10.0.0.4 [00:0C:29:6D:50:25]  3.170ms
Unicast reply from 10.0.0.4 [00:0C:29:6D:50:25]  13.309ms

[saminiir@localhost lvl-ip]$ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
10.0.0.4                 ether   00:0c:29:6d:50:25   C                     tap0</pre><pre class="hljs"><code>[saminiir@localhost lvl-ip]$ arping -I tap0 10.0.0.4
ARPING 10.0.0.4 from 192.168.1.32 tap0
Unicast reply from 10.0.0.4 [00:0C:29:6D:50:25]  3.170ms
Unicast reply from 10.0.0.4 [00:0C:29:6D:50:25]  13.309ms

[saminiir@localhost lvl-ip]$ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
10.0.0.4                 ether   00:0c:29:6d:50:25   C                     tap0</code></pre></div>
<p>kernel 的 网络栈 识别出来 我们的自定义的网络栈 的 arp reply，并且 存储了 arp cache</p>
<p>。。。？写得代码 放哪里？ 怎么启动？。。</p>
<h2 id="ipv4-icmpv4">IPv4 &amp;&amp; ICMPv4</h2>
<p><a data-from-md title='http://www.saminiir.com/lets-code-tcp-ip-stack-2-ipv4-icmpv4/' href='http://www.saminiir.com/lets-code-tcp-ip-stack-2-ipv4-icmpv4/'>http://www.saminiir.com/lets-code-tcp-ip-stack-2-ipv4-icmpv4/</a></p>
<p>这章，将在 我们的用户空间的 TCP/IP 栈中 实现 最简单的 IP层，并通过 ICMP echo request(即 ping) 来测试它。</p>
<p>我们会看到 IPv4 和 ICMPv4 的格式，我们会描述 如何检查它们的完整性。<br>
一些功能，如 IP fragmentation(碎片，片段)，留给读者作为练习</p>
<p>我们选择 IPv4，而不是IPv6， 因为 v4 目前还是 Internet 默认的 网络协议</p>
<p>内容：</p>
<ul>
<li>Internet Protocol version 4
<ul>
<li>header format</li>
<li>Internet checksum</li>
</ul>
</li>
<li>Internet Control Message Protocol version4
<ul>
<li>header format</li>
<li>message and their procesing</li>
</ul>
</li>
<li>testing the implementation</li>
</ul>
<h3 id="internet-protocol-version-4">Internet Protocol version 4</h3>
<p>在 实现Ethernet帧后，我们来实现 L3 层，它处理 向目的地的 数据传输。<br>
即，IP 是为了向 传输层协议(transport protocol，比如 TCP，UDP) 提供一个 基础 而发明的。<br>
它是 无连接的，在 网络栈中，所有的 数据报(datagram) 都是 独立处理的，和其他数据报没有关系。这也意味着 IP 数据报 可能 乱序到达。</p>
<p>此外，IP 不保证 传递成功，这是 设计者有意为之的，因为 IP也需要为 不保证传递成功的 协议提供一个基础，比如UDP。</p>
<p>如果通信需要保证 可靠性，可以在IP的 基础上 使用 TCP。 更高层的 协议 负责 检测丢失的数据，确保所有的数据 都被传递。</p>
<h4 id="header-format">header format</h4>
<p>IPv4 头 通常有 20个字节。 头还包含了一些 后续的 option，本次实现 我们忽略了这些 option。这意味着 字段非常简单：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">struct iphdr {
    uint8_t version : 4;
    uint8_t ihl : 4;
    uint8_t tos;
    uint16_t len;
    uint16_t id;
    uint16_t flags : 3;
    uint16_t frag_offset : 13;
    uint8_t ttl;
    uint8_t proto;
    uint16_t csum;
    uint32_t saddr;
    uint32_t daddr;
} __attribute__((packed));</pre><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> {</span>
    <span class="hljs-type">uint8_t</span> version : <span class="hljs-number">4</span>;
    <span class="hljs-type">uint8_t</span> ihl : <span class="hljs-number">4</span>;
    <span class="hljs-type">uint8_t</span> tos;
    <span class="hljs-type">uint16_t</span> len;
    <span class="hljs-type">uint16_t</span> id;
    <span class="hljs-type">uint16_t</span> flags : <span class="hljs-number">3</span>;
    <span class="hljs-type">uint16_t</span> frag_offset : <span class="hljs-number">13</span>;
    <span class="hljs-type">uint8_t</span> ttl;
    <span class="hljs-type">uint8_t</span> proto;
    <span class="hljs-type">uint16_t</span> csum;
    <span class="hljs-type">uint32_t</span> saddr;
    <span class="hljs-type">uint32_t</span> daddr;
} __attribute__((packed));</code></pre></div>
<ul>
<li>version<br>
4bit, 表明 internet header的 格式，我们的例子中会是 4，代表 IPv4.</li>
<li>ihl<br>
4bit，internet header length，表明 IP header 中 word (一个word 32bit) 的数量。因为4bit，所以最大15，所以 IP header 最大 32 * 15 / 8 = 60 byte</li>
<li>tos<br>
type of service，第一版IP规范 中就有，后续的规范中 被分解为 更小的 字段。 简单起见，我们使用 第一版中的定义。 这个字段表达 IP数据报的 服务质量</li>
<li>len<br>
total length，代表 整个IP 数据报 的长度，由于是16 bit的，所以 最大长度是 65535 byte。大的 IP数据报 会被 fragmentation，切分成 更小的 数据报 以满足 MTU (maximum transmission unit)。</li>
<li>id<br>
用于 对 数据报建立索引，最终用于 将 fragmented的 IP数据报 重组。 值是一个 简单的计数器，发送一部分就会增加。接收端 就知道 如何 排序 收到的 fragment。</li>
<li>flags<br>
定义了 数据报的 控制标志。 比如，发送者 可以规定 是否允许 数据报 被 fragment， 它是不是最后一个 fragment。</li>
<li>frag_offset<br>
fragment offset, 表明 数据报中 fragment的位置。 通常，第一个数据报 是0</li>
<li>ttl<br>
time to live，是一个 普通属性，用于 倒计时 数据报的 生存时间。最初的发送者 通常设置64，每个 接收者 会降低 1。当 变成0时，数据报会被 丢弃，可能会返回一个 ICMP消息 来报告错误。</li>
<li>proto<br>
为数据报提供了一种能力：在payload 中携带其他协议。通常使 16(UDP) 或 6(TCP)，将数据的实际类型 告知 接收者。</li>
<li>csum<br>
check sum, 用来校验 IP头的 完整性。它的算法相对简单，我们稍后会解释这个算法。</li>
<li>saddr，daddr<br>
数据报的 source，destination的 address。 32bit的，大约43亿个地址，将会被用完。 (。。目前已用完)。 地址的范围会被扩展。 IPv6的地址是 128bit</li>
</ul>
<h4 id="internet-checksum">internet checksum</h4>
<p>internet checksum 用来 检查 IP数据报的完整性 (。。看下面的，应该是 IP 头)</p>
<p>checksum是 header中 所有16位word的 补码和 的 16位1的补码。 为了计算方便， checksum字段被认为0</p>
<p>The checksum field is the 16 bit one’s complement of the one’s complement sum of all 16 bit words in the header. For purposes of computing the checksum, the value of the checksum field is zero.<br>
。。。翻不出，baidu翻译的</p>
<p>算法 代码如下：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">uint16_t checksum(void *addr, int count)
{
    /* Compute Internet Checksum for &quot;count&quot; bytes
     *         beginning at location &quot;addr&quot;.
     * Taken from https://tools.ietf.org/html/rfc1071
     */

    register uint32_t sum = 0;
    uint16_t * ptr = addr;

    while( count &gt; 1 )  {
        /*  This is the inner loop */
        sum += * ptr++;
        count -= 2;
    }

    /*  Add left-over byte, if any */
    if( count &gt; 0 )
        sum += * (uint8_t *) ptr;

    /*  Fold 32-bit sum to 16 bits */
    while (sum&gt;&gt;16)
        sum = (sum &amp; 0xffff) + (sum &gt;&gt; 16);

    return ~sum;
}</pre><pre class="hljs"><code><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">checksum</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">int</span> count)</span>
{
    <span class="hljs-comment">/* Compute Internet Checksum for &quot;count&quot; bytes
     *         beginning at location &quot;addr&quot;.
     * Taken from https://tools.ietf.org/html/rfc1071
     */</span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">uint32_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-type">uint16_t</span> * ptr = addr;

    <span class="hljs-keyword">while</span>( count &gt; <span class="hljs-number">1</span> )  {
        <span class="hljs-comment">/*  This is the inner loop */</span>
        sum += * ptr++;
        count -= <span class="hljs-number">2</span>;
    }

    <span class="hljs-comment">/*  Add left-over byte, if any */</span>
    <span class="hljs-keyword">if</span>( count &gt; <span class="hljs-number">0</span> )
        sum += * (<span class="hljs-type">uint8_t</span> *) ptr;

    <span class="hljs-comment">/*  Fold 32-bit sum to 16 bits */</span>
    <span class="hljs-keyword">while</span> (sum&gt;&gt;<span class="hljs-number">16</span>)
        sum = (sum &amp; <span class="hljs-number">0xffff</span>) + (sum &gt;&gt; <span class="hljs-number">16</span>);

    <span class="hljs-keyword">return</span> ~sum;
}</code></pre></div>
<p>比如，IP头：<code class="inline-code">45 00 00 54 41 e0 40 00 40 01 00 00 0a 00 00 04 0a 00 00 05</code></p>
<ol>
<li>把字段加到一起 得到二的补码和 <code class="inline-code">01 1b 3e</code></li>
<li>为了转换为1 的补码，需要将进位增加到第一个16bit，<code class="inline-code">1b 3e</code> + <code class="inline-code">01</code> = <code class="inline-code">1b 3f</code></li>
<li>最后，获得 1的补码：<code class="inline-code">e4c0</code></li>
</ol>
<p>IP头变为：<code class="inline-code">45 00 00 54 41 e0 40 00 40 01    e4 c0    0a 00 00 04 0a 00 00 05</code></p>
<p>。。two’s complement sum， one’s complement 是什么？<br>
。。看代码+例子，第一步是 word 相加，word是16bit，所以 是 45 00 这种，确实和 是 01 1b 3e<br>
。。1b 3f -&gt; e4c0 是 取反。 不是补码。<br>
。。感觉 2' complement 是指 2个2个 相加？</p>
<p>检验规则：对 转换后的 IP头进行 checksum，如果结果是0，那么是ok的。<br>
。。是的， 1b3f + e4c0 = ffff, 取反就是0</p>
<h3 id="internet-control-message-protocol-version-4">internet control message protocol version 4</h3>
<p>Internet Protocol 缺乏 保证 可靠性的 机制，在出错的时候 通知另一端 是有必要的。<br>
ICMP 用于网络中的诊断措施。<br>
一个例子是：当 gateway 不可达到时， 识别到这个问题的 网络栈 会发送 ICMP &quot;Gateway Unreachable&quot; 到 origin。</p>
<h4 id="header-format-2">header format</h4>
<p>ICMP 头存放在 对应的 <mark>IP包的payload中</mark>，结构如下</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">struct icmp_v4 {
    uint8_t type;
    uint8_t code;
    uint16_t csum;
    uint8_t data[];
} __attribute__((packed));</pre><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmp_v4</span> {</span>
    <span class="hljs-type">uint8_t</span> type;
    <span class="hljs-type">uint8_t</span> code;
    <span class="hljs-type">uint16_t</span> csum;
    <span class="hljs-type">uint8_t</span> data[];
} __attribute__((packed));</code></pre></div>
<ul>
<li>type<br>
表示了 消息的用途，一共有42种不同的值，只有8种是常用的，我们的实现中，只用到了0(echo reply)，3(destination unreachable)，8(echo request)。</li>
<li>code<br>
进一步描述了 消息的含义。例如，当类型是3时，code保存 原因。一个通常的错误是 包无法被路由到 网络，这种情况下，origin会收到 一个ICMP，它的type是3，code是0(Net Unreachable)</li>
<li>csum<br>
和IPv4中的类似，可以使用同一个算法来计算。 不过，ICMPv4中，checksum是 端到端的，意味着 计算 checksum的时候，payload 也包含在内。</li>
</ul>
<h4 id="message-and-their-processing">message and their processing</h4>
<p>实际的ICMP payload 包含：query/informational message 和 error message。<br>
首先，我们查看 Echo request/reply 消息，在互联网中通常 指 ping</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">struct icmp_v4_echo {
    uint16_t id;
    uint16_t seq;
    uint8_t data[];
} __attribute__((packed));</pre><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmp_v4_echo</span> {</span>
    <span class="hljs-type">uint16_t</span> id;
    <span class="hljs-type">uint16_t</span> seq;
    <span class="hljs-type">uint8_t</span> data[];
} __attribute__((packed));</code></pre></div>
<ul>
<li>id<br>
由发送端设置，已确定 echo reply 要发送到哪个进程。比如，进程id 会被设置到这个字段</li>
<li>seq<br>
是echo的 sequence number，是一个从 0开始的 值，每产生一个新的 echo request，就+1。 用于 检测 echo消息是否消失 或 传输中是否被重排序</li>
<li>data<br>
可选的，通常包含一些信息，如：echo的时间戳，能用来 估计 主机间的 rtt (round-trip time)</li>
</ul>
<p>常见的 ICMPv4 错误消息： Destination Unreachable，有如下的格式</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="C" data-joplin-source-open="```C&#10;" data-joplin-source-close="&#10;```">struct icmp_v4_dst_unreachable {
    uint8_t unused;
    uint8_t len;
    uint16_t var;
    uint8_t data[];
} __attribute__((packed));</pre><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmp_v4_dst_unreachable</span> {</span>
    <span class="hljs-type">uint8_t</span> unused;
    <span class="hljs-type">uint8_t</span> len;
    <span class="hljs-type">uint16_t</span> var;
    <span class="hljs-type">uint8_t</span> data[];
} __attribute__((packed));</code></pre></div>
<p>第一个字节没有使用。</p>
<ul>
<li>len<br>
表示初始数据报的长度，IPv4是 4个字节一个单位。</li>
<li>var<br>
依赖于 ICMP code</li>
<li>data<br>
保存 导致 目的地不可达的 尽可能多的 原始 IP分组</li>
</ul>
<h3 id="testing-the-implementation">testing the implementation</h3>
<p>在shell中，可以验证 我们的 用户态的 网络栈 对于 ICMP echo request的 响应：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="shell" data-joplin-source-open="```shell&#10;" data-joplin-source-close="&#10;```">[saminiir@localhost ~]$ ping -c3 10.0.0.4
PING 10.0.0.4 (10.0.0.4) 56(84) bytes of data.
64 bytes from 10.0.0.4: icmp_seq=1 ttl=64 time=0.191 ms
64 bytes from 10.0.0.4: icmp_seq=2 ttl=64 time=0.200 ms
64 bytes from 10.0.0.4: icmp_seq=3 ttl=64 time=0.150 ms

--- 10.0.0.4 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1999ms
rtt min/avg/max/mdev = 0.150/0.180/0.200/0.024 ms</pre><pre class="hljs"><code>[saminiir@localhost ~]$ ping -c3 10.0.0.4
PING 10.0.0.4 (10.0.0.4) 56(84) bytes of data.
64 bytes from 10.0.0.4: icmp_seq=1 ttl=64 time=0.191 ms
64 bytes from 10.0.0.4: icmp_seq=2 ttl=64 time=0.200 ms
64 bytes from 10.0.0.4: icmp_seq=3 ttl=64 time=0.150 ms

--- 10.0.0.4 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1999ms
rtt min/avg/max/mdev = 0.150/0.180/0.200/0.024 ms</code></pre></div>
<h3 id="conclusion">Conclusion</h3>
<p>最小可用的 能处理 以太网帧，ARP，IP的 网络栈 很容易就能创建。<br>
但是，原始的规范 已经被扩展了很多次。在本文中，我们跳过了 IP的部分功能，如 option，fragmentation，header DCN，DS字段。</p>
<p>。。DCN网络，专为数据传输而设计的网络，它支持网络七层协议栈中的第一层（物理层）、第二层（数据链路层）和第三层（网络层）。DCN的主要功能是为传送平面、控制平面和管理平面之间以及它们之间的管理信息和控制信息的通信提供传送途径</p>
<p>。。DS，IPv4头部的第3和第4字段分别是DS(DiffServ)字段(区分服务)和ECN字段，用于支持Internet上不同类型的服务。以前这两个字段称为ToS字段。</p>
<h2 id="tcp-basics-handshake">TCP Basics &amp; Handshake</h2>
<p>transmission control protocol</p>
<p>目前，我们的 用户态 TCP/IP 栈已经实现了 以太网 和 IPv4 的最小功能， 现在是时候开始 TCP了</p>
<p>TCP，在 OSI网络模型的 第四层工作，负责 修复 包传递过程中的 错误连接 和 故障。<br>
TCP是互联网中 重要的 一环，提供了 可靠的连接。</p>
<p>TCP的 第一版规范在 1974年颁发。后续做了很多的修改。</p>
<p>内容</p>
<ul>
<li>reliablity machanisms</li>
<li>TCP basics</li>
<li>TCP header format</li>
<li>TCP handshake</li>
<li>TCP options</li>
</ul>
<h3 id="reliablity-mechanisms">Reliablity mechanisms</h3>
<p>数据的可靠性问题，看起来很简单，实际上很复杂。<br>
主要是以下的问题</p>
<ul>
<li>sender 应该等待 receiver的ack 多久</li>
<li>receiver 不能及时处理数据，应该怎么办</li>
<li>网络不能及时传输数据，应该怎么办</li>
</ul>
<p>。。流量控制，拥塞控制</p>
<p>在所有的场景中， packet-switched 网络的 潜在错误都存在： receiver的 ack 在网络中丢失了，sender的处境就很棘手。</p>
<p>为了解决这些问题，需要使用一些机制。<br>
最常用的就是 <mark>滑动窗口</mark>，它维护了 account of the transmitted data。</p>
<p>使用 滑动窗口 也可以减轻 <mark>流量控制 flow control</mark> 的 问题。<br>
当 receiver 不能及时处理数据时，流量控制是必须的。这种情况下， 滑动窗口的 size 通过协商后 会降低，来减少 sender的 输出。</p>
<p><mark>拥塞控制 congestion control</mark>，帮助 sender 和 receiver 之间的 网络栈避免 拥塞。<br>
有2种方法</p>
<ol>
<li>显式控制：协议中有一个 字段 (..ECN) 来将 拥挤状态 告知 sender。</li>
<li>隐式：sender 尝试猜测 网络拥塞会在什么时候发生， 并降低 输出。</li>
</ol>
<p>总的来说，拥塞控制 是复杂的，反复发生的 网络问题。</p>
<h3 id="tcp-basics">TCP basics</h3>
<p>TCP的底层机制 比其他的协议(如 UDP，IP) 更复杂。<br>
TCP是一个 connection-oriented protocol 面向连接的协议，这意味着 TCP连接的 第一步就是 在 2侧 (各)建立一个 单播通道。<br>
双方都在努力维护着这个 连接： 建立连接(握手)，告知另一方 数据的状态 和可能的问题。</p>
<p>TCP另一个重要的属性是， 它是 <mark>streaming 协议</mark>。 不同于 UDP， TCP不保证 数据发送 和接收时，数据的chunk 是一致的。<br>
TCP 实现 不得不 buffer data (。。对数据进行缓冲)，当 packet 丢失，重排序或 损坏时，TCP 不得不 等待 并在组织buffer中的data。<br>
只有当数据 被认为是 完整的时候，TCP才会把 数据交给 应用的socket。</p>
<p>由于 TCP将data 作为 stream 处理， 来自stream的 chunk 会被转换为 IP能携带的 packet。 这被称为 <mark>packetization</mark>，TCP header 包含了 当前index(。。应该是数据吧) 在 stream 中的 sequence number。这个属性提供了方便 来：stream 可以切分为 多个 可变大小的段( variable-seized segment)，TCP知道如何 re-packetize 它们。</p>
<p>类似于IP，TCP也检查 消息的完整性。 通过和 IP中相同的 checksum算法 来完成，但增加了细节。<br>
checksum 是 end-to-end的，意味着 checksum 的范围包含 头和data。另外，还包括 由IP header 创建的 伪header。</p>
<p>。。？TCP怎么计算到 IP的头？ 所以用了 伪头？ 但还是很难想象 有什么意义。。<br>
。。IP 的 checksum 只包含头， TCP的 包含 头和body？。 yes，卷1，P420，原文: &quot;校验和字段覆盖了TCP的头部和数据以及头部中的一些字段&quot; 。。所以这里没有问题。估计书上的 &quot;头部中的一些字段&quot; 等同于这里的 IP伪头<br>
。。确实， IP的校验和 只校验 IP头，P127。<br>
。。但是无法理解，TCP怎么假设 IP的伪头。。卷1似乎没有特别说明，估计要卷2中 看实现。。。卷2一共900页。。。没有TCP checksum的计算逻辑，只看到了头的struct，估计要自己看 源码的。TCP那章开头有说 .h文件的名称。</p>
<p>如果 TCP 收到 损坏的 segment，TCP会丢弃它们，不会告知 sender。 这种错误 由 sender的 定时器 来纠正，在定时器结束时，没有收到 receiver的 ack，那么会重发那个 segment。</p>
<p>TCP是一个 full-duplex (全双工) 系统，2个方向可以同时传输。 这意味着 通信双方 需要 在内存中 维护 2个方向的 数据的 sequence。更深入地说，TCP会在 它发送的 segment中 包含 对 对方流量的 ACK 信息。</p>
<p>本质上，TCP的主要 原理 是 数据流的 sequencing。 保持同步 并不不简单。 (。。估计就是说 确认信息 是否已被送达，这种 同步)</p>
<h4 id="tcp-header-format">TCP header format</h4>
<p>TCP header 看起来很简单，但是它包含了很多 关于 通信状态的 信息</p>
<p>TCP header 是 20个字节 (20 octets)</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">        0                            15                              31
       -----------------------------------------------------------------
       |          source port          |       destination port        |
       -----------------------------------------------------------------
       |                        sequence number                        |
       -----------------------------------------------------------------
       |                     acknowledgment number                     |
       -----------------------------------------------------------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------</pre><pre class="hljs"><code>        0                            15                              31
       -----------------------------------------------------------------
       |          source port          |       destination port        |
       -----------------------------------------------------------------
       |                        sequence number                        |
       -----------------------------------------------------------------
       |                     acknowledgment number                     |
       -----------------------------------------------------------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------</code></pre></div>
<ul>
<li>
<p>source port 和 destination port<br>
用于建立 host的 多个连接。<br>
伯克利socket 是 app 绑定到 TCP网络的 接口。<br>
通过端口，网络栈 知道将数据 交给哪个进程。<br>
16个bit，所以端口范围是 0 到 65535</p>
</li>
<li>
<p>sequence number<br>
stream中的 每个byte 都是有编号的，squence number 代表了 TCP segment的 window index。<br>
握手时，它包含了 ISN (initial sequence number)</p>
</li>
<li>
<p>ack number<br>
ack number 包含了 sender (。。这个sender是 ack的sender) 希望收到的 下一个byte 的 window index。<br>
握手后，ACK 必须一直 填充。</p>
</li>
<li>
<p>header length<br>
header的长度，单位是 32bit的 word。</p>
</li>
<li>
<p>rsvd<br>
4bit，没有使用。</p>
</li>
<li>
<p>C<br>
congestion window reduced，用来告知 sender 降低发送速率</p>
</li>
<li>
<p>E<br>
ECN Echo，通知sender 收到 拥塞通知</p>
</li>
<li>
<p>U<br>
urgent pointer， 表明 segment 中包含 需要优先处理的数据</p>
</li>
<li>
<p>A<br>
ack，用于传达 TCP握手的 状态，它在 连接的剩余部分 保持打开</p>
</li>
<li>
<p>P<br>
PSH，用来表示 receiver 应该 尽可能快地 推送 数据 到 app</p>
</li>
<li>
<p>R<br>
RST，重置 TCP连接</p>
</li>
<li>
<p>S<br>
SYN，在初始的握手时，用于 同步 sequence number</p>
</li>
<li>
<p>F<br>
FIN，表示 sender已经完成发送</p>
</li>
<li>
<p>Window size<br>
用于 告知 window size。即，这是 receiver 将 会收到的 数据的 byte 数。<br>
16bit，所以 最大的window size 是 65535 byte</p>
</li>
<li>
<p>TCP checksum<br>
校验 TCP segment的 完整性。和IP的算法一样，但是 输入包含了 TCP数据 和 IP数据报的一个 伪头。</p>
</li>
<li>
<p>Urgent Pointer<br>
当 U 标记被设置的时候，有效。指针代表了 stream 中的 加急数据的 位置。</p>
</li>
</ul>
<p>头之后，可以添加一些 option。 比如 MSS ( maximum segment size，用于 sender告知另一方 segment的最大size)。</p>
<p>在可选的 option之后，就是 实际的数据。 数据 不是必须的，比如握手时。</p>
<h3 id="tcp-handshake">TCP handshake</h3>
<p>TCP 连接，通常会经历3个阶段：</p>
<ul>
<li>连接建立(握手)</li>
<li>传输数据</li>
<li>连接关闭</li>
</ul>
<p>下面是 常规的 TCP握手</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="text" data-joplin-source-open="```text&#10;" data-joplin-source-close="&#10;```">          TCP A                                                TCP B
    	  
    1.  CLOSED                                               LISTEN
    	
    2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED
    	  
    3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED
    			
    4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED
    			  
    5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED</pre><pre class="hljs"><code>          TCP A                                                TCP B
    	  
    1.  CLOSED                                               LISTEN
    	
    2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED
    	  
    3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED
    			
    4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED
    			  
    5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED</code></pre></div>
<ol>
<li>主机A的 socket是关闭状态，意味着 它不会接受连接。 主机B的socket 被绑定到 指定端口 监听 新连接</li>
<li>主机A尝试 初始化一个 到 主机B的连接。 主机A发送了一个 TCP段，其中，设置了SYN标记，sequence号被设置了 100</li>
<li>主机B 回应了一个 TCP段，设置了 SYN和 ACK，ACK的值是 收到的sequence(100) + 1，sequence(300)是主机B 生成的。</li>
<li>主机A 发送ACK 代表着 3-way handshake (3次握手) 完成。ACK的值代表了 下次期望收到的 sequence 值。</li>
<li>数据开始传输，因为 双方都 ACK 了对方的 segement。</li>
</ol>
<p>还有一些问题：</p>
<ol>
<li>最初的sequence number 应该选择什么？</li>
<li>如果双方 同时 请求建立 到对方的请求，会发生什么？</li>
<li>如果 segment 延迟 或 丢失，会发生什么？</li>
</ol>
<p>ISN(initial sequence number) 是在第一次接触时，双方 各自 独立选择的，是用于 识别不同connection 的 重要因素，ISN必须尽可能唯一且难以猜测。<br>
TCP sequence number attack 是 攻击者 复制了 TCP连接，并冒充受信任的主机 发送数据</p>
<p>第一版规范 建议 ISN 通过 一个 每4微秒自增一次 的 计数器 来设置。 但是，攻击者可以猜测到这个值。<br>
实际上，现代网络栈 以更复杂的方式 生成 ISN</p>
<p>双方同时收到 对方的 连接请求(SYN) 的情况 被称为 Simultaneous Open (同时打开)。 这通过 TCP握手中的 额外消息交换 来解决： 双方都 发送 ACK ( 不知道对方也这样做)，双方都 SYN-ACK 请求。然后 开始传输数据。<br>
。。不太理解。 主要是 双方都SYN-ACK请求，是指 前面的 SYN，然后ACK 还是说 一个新的步骤？ 如果是一个新的 SYN-ACK，有什么意义？<br>
Both sides send an ACK (without knowing that the other side has done it as well), and both sides SYN-ACK the requests.</p>
<p>TCP的实现中 包含一个 计时器，知道什么时候 放弃建立 连接。 尝试重新建立连接，通常采用 指数退避，retry次数满或 时间阈值到达 以后，认为 连接不存在。</p>
<h3 id="tcp-options">TCP options</h3>
<p>TCP头的最后一部分是 留给 可能的 TCP option。<br>
初版规范提供了3个 option，后续版本进行了添加。<br>
我们来看下最常用的option</p>
<ul>
<li>
<p>MSS<br>
maximum segement size，告知 TCP实现 它会收到的 最大 TCP segment size。通常 IPv4是 1460byte</p>
</li>
<li>
<p>SACK<br>
selective ack，优化了 当许多packet丢失，导致了很多 窗口出现了很多 洞的时候。<br>
为了防止吞吐量降低，TCP实现 会在 SACK 中告知 sender，它没有收到哪些packet。sender就发送 丢失的 packet，而不是 从上次ack的地方全部重发。</p>
</li>
<li>
<p>window scale<br>
用于突破 window size 的 16bit限制。 当双方 在 握手时 都带有这个 option，那么 window size 就要乘以 这个值。 传输大量数据时，更大的 window size 是非常重要的。</p>
</li>
<li>
<p>Timestamps<br>
这个选项 允许 sender 放置 时间戳 到 TCP segment，可以用来计算 RTT。这个信息可以用来计算 重发超时 的超时时间。</p>
</li>
</ul>
<h3 id="test-tcp-handshake">test TCP handshake</h3>
<p>现在，我们有了 普通的 TCP handshake 的mock，它监听了每个端口， 让我们来测试它：</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="shell" data-joplin-source-open="```shell&#10;" data-joplin-source-close="&#10;```">[saminiir@localhost ~]$ nmap -Pn 10.0.0.4 -p 1337

Starting Nmap 7.00 ( https://nmap.org ) at 2016-05-08 19:02 EEST
Nmap scan report for 10.0.0.4
Host is up (0.00041s latency).
PORT     STATE SERVICE
1337/tcp open  waste

Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds</pre><pre class="hljs"><code>[saminiir@localhost ~]$ nmap -Pn 10.0.0.4 -p 1337

Starting Nmap 7.00 ( https://nmap.org ) at 2016-05-08 19:02 EEST
Nmap scan report for 10.0.0.4
Host is up (0.00041s latency).
PORT     STATE SERVICE
1337/tcp open  waste

Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds</code></pre></div>
<p>由于 nmap 没有 SYN-scan (它只是等待 SYN-ACK 来决定目标端口是否打开)， 所以很容易 通过 返回一个 SYN-ACK TCP段 来欺骗它，让它以为 我们有一个app在 端口上监听。</p>
<p>。。？没有代码啊。怎么测试？</p>
<h3 id="总结">总结</h3>
<p>最小可行的TCP握手，只需要 选择 sequence number，设置 SYN-ACK标志，计算TCP segment的 checksum 就可以。</p>
<p>接下来，我们会看 TCP最重要的责任：可靠性。stream 的窗口的 管理，对于 TCP 传输数据 至关重要，它的逻辑可能变得复杂</p>
<p>将app 绑定到 TCP实现， 是通过 socket 完成的。我们会 查看 伯克利的 socket api，来看 我们是否可以 为我们的app mock 它，使得它们(。。socket) 使用 我们自定义的 TCP 实现</p>
<h2 id="tcp-data-flow-socket-api">TCP data flow &amp; socket api</h2>
<p><a data-from-md title='http://www.saminiir.com/lets-code-tcp-ip-stack-4-tcp-data-flow-socket-api/' href='http://www.saminiir.com/lets-code-tcp-ip-stack-4-tcp-data-flow-socket-api/'>http://www.saminiir.com/lets-code-tcp-ip-stack-4-tcp-data-flow-socket-api/</a></p>
<p>上一篇，我们了解了 TCP header，及 如何建立连接</p>
<p>现在，我们看 TCP 数据传输，及 如何管理。</p>
<p>另外，我们会 从 网络栈 提供一个 接口，应用可以使用这个 接口来进行 网络通信。<br>
我们会使用 这个 socket api，来向 网站发送 简单的 http 请求。</p>
<p>内容</p>
<ul>
<li>transmission control block</li>
<li>TCP data communication</li>
<li>TCP connection termination</li>
<li>Socket api</li>
<li>test</li>
<li>conclusion</li>
<li>source</li>
</ul>
<h3 id="transmission-control-block">transmission control block</h3>
</div></div>
					</body>
				</html>
			