小处实诚非小事
神在细节之中
物皆有其位，而后物尽归其位
守小节者不亏大节
人孰无过，神亦容之
稍后等于永不later equals never

命名！
对代码现状诚实地广而告之。不自欺
代码重构！。。这里不是重写。重构是不同的形参。

阅读标准的代码。

编程：将需求明确到机器可以执行的细节程度。

代码越来越烂，最终无法管理。

高内聚，低耦合。

小块代码。。就像那个cms的excel的导入？似乎都是差不多的。
测试！
简单代码：能通过所有测试。没有重复代码！，体现全部设计理念，尽量少的实体(类，方法)。
消除重复，提高表达力

33
命名
所有自定义的东西都要有意义。
foreach的变量也要有意义
判断时用的数值也要有意义，(是枚举？还是上面定义一个int值，然后赋值？，静态/(全局)变量。)
方法名是动词(get,set,find,update,is...)+名词(动词的操作对象)。

把判断提取出来写成一个函数。

特殊含义的单词要确定的使用，list只能用在List类型的变量命名中。
任意2个命名的差距要大，要一眼就看出差别，别头，尾相同，就中间有差别。

命名要有意义。
不用单个的I，l，O，以及他们的组合。

形参也要有意义。

少用无意义的单词，Product，ProductInfo，ProductData，ProductObject，似乎是一个东西。

动词不出现在变量名中。
用到的单词要简单，别让人读不出。别用字母，读的时候有点。。

用枚举/全局变量，取代数值，前者能起个有意义的名字。

不需要前缀，后缀来标志方法or变量，大部分人会直接无视前后缀。
。。Impl。。

小循环可以用ijk，千万别l，大的循环别用ijk单字母的循环变量

重载构造器时，使用描述了参数的静态工厂方法，可以将构造器设为private，强制工厂方法。
命名的时候别耍宝，你懂的，别人不一定懂/一定不懂。

别用近义词，get，receive，fetch。或者自己要明确每个动词的不同
Manager，Controller有什么区别？

单词有多义，只使用其中一种意义，add有数学的+，list中插入的加。

命名时把语境加上，或者说，这个变量用来组成什么。当然组成什么一般都会写在类名中。。用在接收类变量的局部变量命名。
别添加不必要的语境。
取名难在，良好的描述技巧，共有的文化背景


函数
长函数很少。，，基本都是方法抽离，重命名，重构掉。

1短小
2只做1件事
3每个函数一个抽象层级。函数中的语句在同一个抽象层级上。高层次和低层次混合会让人困惑。。基本的方法(低层抽象)和集合方法(方法里有多个方法，高层抽象)分开。。把方法分解到最小粒度，然后数个合成一个方法，而不是方法内同时含有最小粒度的方法和大粒度的方法。

52

自顶向下，方法是越往下，越抽象，就是下面的方法用到了上面的方法。

4switch，要藏在低层次抽象中，并且永不重复，，层次越低，方法越简单，越容易被复用。
书上的例子，switch直接放到了抽象工厂中，就是把switch中的任一case都写成一个类。

5使用描述性名称，特别小函数的名字要取好。复用的地方多
命名要一致，一个模块中，一脉相承的动词/短语/名词不要换

6函数参数，越少越好，0最好。3个已经很差了。
有形参，没返回值的方法一定要小心，他肯定修改了东西。
如果方法一进去就是if来分开，分成2个方法，名字也要改。不是if中的写成一个方法。是if外的方法就分成2个。
使用二元函数要付出代价，最好换成一元方法。
如果函数需要2，3or跟多参数，那么就要将某些参数封装成一个类。
可变参数。
方法名，一元函数是动词(+名词)，名词是形参类型/名字。二元是动词xxx动词XXX，前后xxx可以用形参类型/名字直接写进去。

7无副作用，函数应该只完成一件事，多出来的就是副作用。
参数一般都是方法的输入，但是有些传值形参也作为输出，这样非常不好，java完全可以qqq.xxx()来调用(有this指针)，而不是xxx(qqq)。


60

8一个方法一件事
9使用异常替代返回错误码，错误处理和主代码分开，不会太多的if嵌套。
9.1抽离try/catch，让他成为一个独立的函数。try应该是这个函数的第一个单词，且catch/finally后不应有其他内容
9.2错误处理也是一件事。
9.3error.java，自己定义包含所有/一组错误的枚举类，不应该有，因为很多地方都会用到(import)，所以导致error修改时，其他类也要重新编译，部署，有时就选择继续用旧的错误码，而不扩展。。使用异常，就可以直接从旧的异常类派生出来，无需重新编译和部署。也是开闭原则的一个范例。
。。这个无需重新编译和部署，是指其他类吧，话说怎么用到自定义的异常，也是要导入进去的吧。

10别重复自己。。很多原则和实践规则都是为了控制和消除重复而创建的。要避免冗余。

11结构化编程，Dijkstra认为每个函数，每个函数中的代码块，都应该有一个入口，一个出口。。就是说每个函数中应该只有一个return，循环中不能有break或者continue，，对于小函数意义不太大，大函数中会有明显的好处。

写代码要先写出来，然后不停的打磨。

函数是动词，类是名词


注释

别给糟糕的代码加注释，重新写吧。

放置良好的注释，乱七八糟的注释，陈旧，错误的注释。

注释是为了弥补代码的表达失败。

注释存在的越久，与代码的含义越远。

69
if后的判断变成一个方法，并且方法名描述这些判断的作用。

注释可以写个人的想法，是否建议使用该方法，注意事项，警告，告知该方法的重要性。
看公共api的注释。
如果写注释就要写好，并且注释是完整的，不需要再查看其它代码/注释才能明白
不要写多余的注释，注释只出现在必要的地方。

能用函数或变量就别用注释，就是把注释的描述性单词变成变量/方法名。就像if后的判断可以写成一个方法。

代码直接删除，而不是注释。注释掉的代码或多或少会引起人的好奇，浪费时间。

短函数不需要太多描述，取一个好名字比注释更有用。

90


格式
可读性，为以后的维护，扩展准备。

空白行用来分隔。

方法中的变量声明尽量靠近使用的地方，当然，如果短函数，可以在最开始的地方。

函数的调用者在被调用函数的上面




把长串调用，变成类的函数，如a.b().c().d()，直接变成a类中的一个函数。

分层抽象。数据库操作就是数据库操作，不添加业务逻辑。

方法只有纯getter/setter的类是数据结构，数据结构暴露数据(但是这里暴露的是get/set，并没有把数据设为public，有没有属性直接public，没有get/set的？)。
对象暴露行为，隐藏数据。



错误处理

使用异常，而不是返回错误代码。

可控异常，不可控异常。
。。可控异常就是方法内throw一个异常，方法声明那里就要+throws，如果多层嵌套，那么每层都要throws，。对封装也是一种破坏(高层要知道低层抛了什么异常。)，。修改也要全部修改。
一般来说可控异常的收益低于付出。



117

将第三方api打包

别返回null，如果list，返回空的list，这样就不需要判断是不是null了
java的Collections.emptyList()

别传进去null值。


边界
将map包装成一个类，这样get函数就覆盖了map的get函数。
并不建议总是包装map，不建议将map在系统中传递。
。。。烦。。

对第三方api学习性测试。

使用尚不存在的代码，就是写个接口，实现可能来不及/不会

适配器模式将接口转为第三方提供的接口


129
单元测试

敏捷和tdd鼓舞了许多程序员编写自动化单元测试。

tdd要求在编写代码前先编写单元测试
1.在编写不能通过的单元测试前，不可编写代码。
2.只可编写刚好无法通过的单元测试，不能编译也算不通过
3.只可编写刚好足以通过当前失败测试的生产代码。

测试代码也要规范。
因为代码会更新，或许测试代码也会重用。

测试：构造-操作-检验

把多个状态缩成一个string(大小写也是一种信息)，然后检验。
这个缩，写一个方法，这样，多个状态就能用一个方法来缩成一个string，这在生产代码中是不可能写出来的。

每个测试有且只有一个断言
，这样会有大量的重复测试代码，可以用模板方法模式，(似乎是：将相同部分变成一个类，然后不同部分写在他的子类中，)，来消除代码重复。也可以将相同部分放到@Before，

单个断言是好的准则，但是一个以上也没有问题。

每个测试一个概念。
尽量减少断言的数量，来减少测试测的概念。

整洁的测试：
FIRST
fast运行够快
independent某个测试不应为下个测试设定条件，应该可以单独运行每个测试。不然，头错了，就全错了。
repeatable
self-validating有输出，而不是看日志之类的来确定测试是否通过。
timely测试代码在编写代码前。不然会发现代码难以测试，


141
类

顺序：公共静态常量，私有静态变量，私有实体变量。
公共函数在变量列表后，
某个函数调用的私有工具函数跟在这个函数后。

封装：如果测试需要用到某个方法，那么这个方法就是protected/public，测试说了算。当然，首先是尽量的私有，然后根据测试确定访问控制符。

类要短小！

类的名字应当描述其权责，命名是判断类长度的第一个手段，如果无法精确命名，那么这个类太长了。
如果类名中含有含义模糊的单词，如：manager，super，processor，那么这个类有不恰当的权责聚集。

我们也应该能用25个单词描述一个类，且不用if，and，or，but等词汇。

单一权责srp
类或模块应且只有一条加以修改的理由，
类只应有一个权责------只有一条修改的理由。

有大量短小类的系统并不比有少量庞大类的系统拥有更多的移动部件，其数量大致相等，
每个达到一定规模的系统都会包含大量的逻辑和复杂性，管理这种复杂性的首要目标就是加以组织，以便开发者知道哪里能找到东西。并在某个特定时间只需要理解直接有关的复杂性。

内聚。类的每个私有变量都被类的每个方法使用----最高的内聚。

保持内聚就会得到许多短小的类。

将较大的函数切割为小函数，会导致更多的类。
一个有许多变量的大函数，把其中的某一部分拆解成单独的函数，这部分函数使用了大函数中的4个变量，是否有必要将这4个变量传递给新函数呢？No，直接将这4个变量变成类的私有变量就ok。不需要传递变量就拆解代码，这样很容易将函数拆分成小块。
这也意味这丧失了内聚性，因为堆积了越来越多的只为少量函数共享而存在的实体变量，这时，可以拆分出小的类了！！！


多数系统，修改将一直持续，
在整洁的系统中，我们对类加以组织，以降低修改的风险。

152/136
将sql的增删查改语句直接一个语句一个类。cooooooooooool
百利无一弊，支持单一权责srp，支持开闭原则ocp


需求会改变，所以代码也会变，具体实现类包含实现细节，抽象类只呈现概念，这样当细节改变时，借助接口/抽象类来隔离这些细节带来的影响。

154
对于细节的依赖给测试带来挑战，。。。不懂，似乎就是对第三方提供实时数据api做一个包装。


158
系统

构造和使用是非常不一样的过程。(房子的建造和使用)
软件系统应将启始过程和启始过程后的运行时逻辑分开，在启始过程中构建应用对象，也会存在互相缠结的依赖关系。

大多数程序都没有将构造和使用分离，特别是延迟加载，
就是测试难，违反单一权责。
不知道该类在所有情形中是否都有正确的对象。

如果要打造良好格式且强固的系统，就不该让这类小技巧破坏模块组织。
。。不过现在，已经不反对这种延迟加载了吧

将构造和使用分开的方法之一是将全部构造过程搬到main中，

有时应用程序也要负责确定何时创建对象，这种情况下，使用抽象工厂模式。让应用自行控制何时创建，但构造的细节隔离于应用代码之外。

一种强大的机制可以分离构造和使用----依赖注入，控制反转是依赖管理中的一种应用手段。控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中，从而遵循单一权责。

扩容，
一开始就做对系统纯属神话。我们应该只取实现今天的用户故事，然后重构，明天在扩展系统，实现新的用户故事，这就是迭代和增量敏捷的精髓。测试驱动开发，重构以及他们打造出的整洁代码，在代码层面保证了这个过程的实现。

java代理，反射

纯java aop框架

aspectJ

架构应该是简单演化到精细，而不是先做大设计，先做大设计有时会阻碍改进，因为心理上会抵制丢弃既成之事。


领域特定语言dsl，dsl是一种单独的小型脚本语言或以标准语言写成的api，领域专家可以用它编写组织严谨的代码。
优秀的dsl填平了领域概念和实现领域概念的代码之间的壕沟。


系统应该是整洁的，
侵害性架构会湮灭领域逻辑，冲击敏捷能力，
所有的抽象层级上，意图都应该清晰可变，
无论设计系统或单独的模块，别忘了使用大概可以工作的最简单方案


173
迭进

简单设计的四条规则，遵循以下规则，设计就能变简单
运行所有测试
不可重复
表达了程序员的意图
尽可能减少类和方法的数量
。。优先级由高到低

抽取不同方法的共性后，一般可以将共性继续抽象成一个新的类。

表达力：好的名字，大函数切成小函数，不时的查看代码，看是否要修改


179
并发编程

整洁的并发----非常难。
编写表面上看起来不错，深入进去却支离破碎的多线程代码也简单，但是一旦受到压力，这种代码就扛不住了

并发是一种解耦策略。她帮我们把做什么(目的)和何时(时机)分开，单线程中目的和时机紧密耦合，很多时候只要查看堆栈追踪即可断定应用程序的状态，

解耦目的和时机能明显地改进应用程序的吞吐量和结构，从结构看，应用程序像是许多台协同工作的计算机，而不是一个大循环。

结构并非采用并发的唯一动机，有些系统对响应时间和吞吐量有要求，

一些误区：
并发总能改进性能
编写并发无需修改设计，并发和单线程的设计极不相同，目的与时机的解耦往往会对系统结构产生巨大影响。
在采用web/ejb容器时，理解并发并不重要。要了解容器在做什么，以便解决并发更新，死锁等问题。

中肯说法：
并发会在性能和编写额外代码上增加一些开销
正确的并发是复杂的，即使是简单的问题
并发缺陷并非总能重现，所以常被看作偶然事件而忽略，未被当作真的缺陷来看待
并发常常需要对设计策略的根本性修改。


并发防御原则，技巧
单一权责srp，分离并发相关代码和其他代码。
限制数据作用域。防止两个线程相互影响。利用synchronized，数据封装，严格限制对可能被共享的数据的访问。
使用数据复本，对复本只读对待，或者从多线程收集所有复本结果，在单线程中合并。
线程应尽可能的独立。在自己的世界中，不和其他线程共享数据。尝试将数据分解到可以被独立线程(可能不同cpu)操作的独立子集。

使用java5：
使用类库提供的线程安全群集，java,util.concurrent,实际上，在近乎所有情况下，ConcurrentHashMap比HashMap表现的好。
使用executor框架执行无关任务
尽可能使用非锁定解决方案
有几个类并不是线程安全的。

了解执行模型：
互斥
线程饥饿，准备好了，但是进不去cpu时间片,(看cpu时间片算法)
死锁
活锁
生产者-消费者模型，一个/多个生产者线程创建，并置于缓存/队列中，一个/多个消费者线程从中获取。
读者-作者模型，当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是一个问题,增加吞吐量，会导致线程饥饿和过时信息的累计，更新会影响吞吐量，协调读者，使其不去读作者在更新的信息(反之亦然)是辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，会导致吞吐量问题。
宴席哲学家，一圈人在圆桌旁，每个人左手边一把叉子，桌子中间是面，，每个人要拿叉子吃面，但是除非手上有两把叉子，不然没办法进食。如果左边/右边的人已经拿到一把叉子，那么中间的人只能等待。每个人吃完后，放回2把叉子，直到再饿。

警惕同步方法之间的依赖，Java有synchronized概念，可以用来保护单个方法，但是，如果同一个共享类中有多个同步方法，系统就可能有问题。。。避免使用一个共享对象的多个方法。
有时必须使用一个共享对象的多个方法，那么3种写对代码的方法：
基于客户端的锁定，客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。
基于服务端的锁定，在服务端内穿件锁定服务端的方法，调用所有方法，然后解锁，让客户端代码调用新方法
适配服务端，创建执行锁定的中间层，这是一种基于服务端的锁定的例子，但不修改原始服务端代码。

保持同步区域微小。
synchronized制造了锁，同一个锁维护的所有代码区域在任一时刻保证只有一个线程执行，锁是昂贵的，因为他们带来了延迟和额外开销，所以要尽可能少的设计临界区。(，，，别为了数量少，而选择扩大临界区(来兼并其他临界区)。。)

很难编写正确的关闭代码。
平静关闭很难，常见问题和死锁有关，线程一个等待永不会到来的信号
要尽早的考虑关闭问题，令其工作正常，这会花费比你预期更多的时间，检视既有算法，因为这可能会比想象中难得多。

测试线程代码
编写有潜力暴露问题的测试，在不同编程配置，系统配置和负载下频繁运行，跟踪所有发生的错误。
一些建议：
将伪失败看作线程问题，不要将错误归咎于偶发事件
先使非线程代码可工作
编写可插拔的线程代码，编写可在数个配置环境下运行的线程代码，
编写可调整的线程代码，要允许线程数量可调整，允许系统在运行时根据吞吐量和使用率调节线程。
运行多余处理器数量的线程，系统在切换任务时可能会发生一些事，为了促使任务交换，运行多余处理器核心数量的线程。
不同平台上运行
调整代码并强迫错误发生，增加对Object的wait，sleep，yield，priority方法的调用改变代码执行顺序，增加侦测到缺陷的可能性。2中装置代码的方法，硬编码(手动插入wait,sleep,yield,priority)和自动化(aspect-oriented_framework,cglib,asm之类的工具，pdf190)。


逐步改进
192
...这里好像是为了分析/验证args是否是所期望的。而写的一个类。
。。但是全代码。。

有多个isxxx可以合并/内联成一个，但是加个形参来传入xxx

。。。有空看吧。。251.。60页全代码。。


Jnuit
ComparisonCompactor模块，鉴别2个字符串。
用<..[x]...>来暴露差别在x这里。

离开要比来时整洁。
。。。这节也是对ComparisonCompactor代码的修改的说明。。。


SerialDate重构。
。。。

285
味道与启发

注释：
不恰当的信息，废弃的注释，冗余的注释(注释要说明不能从代码里看到的东西)。糟糕的注释(表达能力)，注释掉的代码。


函数：
过多的参数(越少越好，0最好，3个以上回炉)，输出参数(不要用形参用来返回信息)，标识参数(boolean大声宣告函数做了不止一件事，令人迷惑)，死函数(不会被调用的方法，大胆删除，从源代码控制系统能找到。)

一般性问题：
一个源文件中存在多种语言，应尽量减少源文件中额外语言的数量和范围。
明显的行为未被实现，遵循最小惊异原则，函数或类应该实现程序员期待的行为(说的好像是：名字别乱取)
不正确的边界行为，不要依赖直觉，追索每种边界条件，并编写测试。
忽视安全，
重复，dry，don't repeat yourself. 重复的代码以为着遗漏了抽象，最明显是重复就是不断看到明显一样的代码，隐蔽点的是不同模块中不断出现的检测同一组条件的switch/if链，可以用多态替换(？好像可以，但是不如抽取出来另写方法？)。更隐蔽的是采用类似算法，但是具体代码不同，可以使用模板方法模式或策略模式来修正。重点已经在那里，尽可能找到并消除重复。
在错误的抽象层级上的代码，
基类依赖于派生类，
信息过多，commissiondetail!
死代码
垂直分隔，变量和方法应该在靠近被使用的地方定义，本地变量应该正好在其首次被使用的位置上面声明，垂直距离要短。
291
前后不一致，从一而终，最小惊异原则，(不同渠道，同一个字段，保存的不一样。。。)
混淆视听，没有用到的方法(包括构造方法)，变量，没有信息的注释。要保持整洁。
人为耦合，值两个没有直接目的之间的模块耦合(？？)。根源是将变量，常量，函数不恰当的放在临时方便的位置。
特性依赖，类的方法应该只对其所属的类中的变量和函数感兴趣(低耦合)。
选择算子参数，没什么比形参中有一个boolean(选择算子)参数更可憎的事，选择算子参数将多个函数绑到一起，只是一种避免将大函数切分为多个小函数的偷懒做法。。。当然，选择算子不一定是boolean，可能是枚举，整数，or任何一种用于选择函数行为的参数。使用多个函数，通常优于单个函数+选择算子。。执行批处理的那个，那个不算是选择算子，他是直接就用那个string了，根据不同string执行不同xml配置。是spring自己的。实际上这个流程不算是选择算子。
晦涩的意图，代码要有表达力，不要为了短小紧凑，而使得代码的表达力非常低。
位置错误的权责，
不恰当的静态方法，.....静态的不能多态？的确啊，静态方法调用的时候要用类名，这就意味着不可能多态。。不是，实例也能调用静态方法。，静态没有多态的意思应该是，编译时确定调用哪个方法，所以那些spring注入的数据库读的，就没有用了。甚至通过if判断选哪个的。
使用解释性变量，让程序可读的有力方法之一就是将计算过程打散成在用有意思的单词命名的变量中放置的中间值。。。意思就是，计算过程中每一步的结果都保存在有含义的中间变量中，然后再进行下一步，而不是一个长计算。
函数名应该表达其行为，
理解算法，，，在完成一个函数前，要理解工作原理，，，获得这种知识和理解的最好途径是重构函数，得到整洁而具有表达力，清晰呈现如何工作的代码。
把逻辑依赖改为物理依赖，当某个模块依赖于另一个模块时，依赖就应该是物理上的，而不是逻辑上的，依赖者模块不应对被依赖者有假定，它应当明确询问后者全部信息。。。？？？
用多态替代if/else,switch/case,多数人使用switch是用为它直接了当又有力，而不是因为最适合，，在switch前，优先考虑多态。单个switch，多余给定的选择类型，不应有多于一个的switch语句，在switch用的多个case，必须创建多态对象，取代系统中其他类似switch语句，，，意思是：多个switch合并成一个，并且变成一个单独的方法？而且多态的话，是指switch所在的方法可以处理多种类。
297
遵循标准约定，
用命名常量代替魔术数，(魔术数字（magic number）是程式设计中所谓的直接写在程式码里的具体数值（如“10”“123”等以数字直接写出的值）。)
准确，
结构甚于约定，命名约定很好，但次于强制性的结构，。。。
封装条件，将布尔逻辑封装成一个方法。用方法名描述功能。
避免否定性的条件，否定式比肯定式难明白一些。
函数只做一件事，。。不过这样，会分割成很多函数把，话说相同功能，函数多，会降低速度吗？，会，所以不要太小型化，这样的话，布尔条件封装成方法并没有意义。
不要掩蔽时序耦合，如果一个方法里按序调用多个方法，最好让前一个方法的返回是后一个方法的形参，这样能体现时序。后来的人不会弄错顺序。
封装边界条件，不要将+1-1随处放置，而是变成一个新的变量。
函数应该只在一个抽象层级上，方法中的语句应该在同一抽象层级上，该层级应该是函数名所示操作的下一层，。。是方法中的语句是同一个层次的。这个难。
在较高的层级放置可配置数据，如果有个已知并应该在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中，把它作为较高层级函数调用较低层级函数时的一个参数，，位于较高层级的配置性常量易于修改，他们向下贯穿应用程序，应用程序的较低层并不拥有这些常量的值。
避免传递浏览，通常，不想让某个模块了解太多其协作者的信息，如，a与b合作，b与c协作，我们不想让a了解c的信息(例如：不能写：a.getB().getC().xxxx())。这就是墨忒耳律，如果用了a.getB.getC,那么要在bc之间插一个q，你得找到所有的getB.getC.然后修改成getB.getQ.getC，系统缺乏柔韧性，太多的模块了解了太多有关架构的信息。

java：
通过使用通配符避免过长的导入清单。用通配符应该是编译的时候慢吧？不过现在无所谓的，可以折叠import。还有不同包的同名类。
不要继承常量，错误的：接口里写了静态变量，然后子类去使用，一般人，不会认为这个常量来自接口的。。应该静态导入。import static xxx.xxx.*/静态;
常量vs枚举，枚举可以拥有方法和字段，比public static final int 更具有表达力

名称：
采用描述性名称，
名称应与抽象层级相符，就是父类有父类的动作，不要用子类的动作，如：动物有进食这个动作，但你不能用吃中饭来替代进食这个方法名。
尽可能使用标准命名法。
无歧义的名称
为较大作用范围选较长名称，越长越准确。
说明副作用

测试
测试不足
使用覆盖率工具
别略过小测试
被忽略的测试就是对不确定事务的疑问
测试边界条件
全面测试相近的缺陷
测试失败的模式有启发性
测试覆盖率的模式有启发性
测试应该快速

313



































































































